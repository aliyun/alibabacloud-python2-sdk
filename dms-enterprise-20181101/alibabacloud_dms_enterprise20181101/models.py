# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class AsyncTaskVO(TeaModel):
    def __init__(self, dataset_id=None, id=None, remark=None, task_name=None, task_status=None, task_type=None,
                 user_id=None):
        self.dataset_id = dataset_id  # type: str
        self.id = id  # type: long
        self.remark = remark  # type: str
        self.task_name = task_name  # type: str
        self.task_status = task_status  # type: int
        self.task_type = task_type  # type: int
        self.user_id = user_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AsyncTaskVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.id is not None:
            result['Id'] = self.id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DatasetItemVO(TeaModel):
    def __init__(self, async_task_list=None, dataset_status=None, dataset_type=None, digest=None, file_system=None,
                 id=None, key_name=None, more_info=None, path=None, projects_linked=None, recent_task_status=None,
                 remark=None, schema=None, table_name=None, url=None):
        self.async_task_list = async_task_list  # type: list[AsyncTaskVO]
        self.dataset_status = dataset_status  # type: int
        self.dataset_type = dataset_type  # type: int
        self.digest = digest  # type: str
        self.file_system = file_system  # type: str
        self.id = id  # type: str
        self.key_name = key_name  # type: str
        self.more_info = more_info  # type: str
        self.path = path  # type: str
        self.projects_linked = projects_linked  # type: list[ProjectDetailsLiteVO]
        self.recent_task_status = recent_task_status  # type: int
        self.remark = remark  # type: str
        self.schema = schema  # type: str
        self.table_name = table_name  # type: str
        self.url = url  # type: str

    def validate(self):
        if self.async_task_list:
            for k in self.async_task_list:
                if k:
                    k.validate()
        if self.projects_linked:
            for k in self.projects_linked:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DatasetItemVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AsyncTaskList'] = []
        if self.async_task_list is not None:
            for k in self.async_task_list:
                result['AsyncTaskList'].append(k.to_map() if k else None)
        if self.dataset_status is not None:
            result['DatasetStatus'] = self.dataset_status
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.file_system is not None:
            result['FileSystem'] = self.file_system
        if self.id is not None:
            result['Id'] = self.id
        if self.key_name is not None:
            result['KeyName'] = self.key_name
        if self.more_info is not None:
            result['MoreInfo'] = self.more_info
        if self.path is not None:
            result['Path'] = self.path
        result['ProjectsLinked'] = []
        if self.projects_linked is not None:
            for k in self.projects_linked:
                result['ProjectsLinked'].append(k.to_map() if k else None)
        if self.recent_task_status is not None:
            result['RecentTaskStatus'] = self.recent_task_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.async_task_list = []
        if m.get('AsyncTaskList') is not None:
            for k in m.get('AsyncTaskList'):
                temp_model = AsyncTaskVO()
                self.async_task_list.append(temp_model.from_map(k))
        if m.get('DatasetStatus') is not None:
            self.dataset_status = m.get('DatasetStatus')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('FileSystem') is not None:
            self.file_system = m.get('FileSystem')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeyName') is not None:
            self.key_name = m.get('KeyName')
        if m.get('MoreInfo') is not None:
            self.more_info = m.get('MoreInfo')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        self.projects_linked = []
        if m.get('ProjectsLinked') is not None:
            for k in m.get('ProjectsLinked'):
                temp_model = ProjectDetailsLiteVO()
                self.projects_linked.append(temp_model.from_map(k))
        if m.get('RecentTaskStatus') is not None:
            self.recent_task_status = m.get('RecentTaskStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTableDataKeyVO(TeaModel):
    def __init__(self, col_name=None, db_name=None, mek_id=None, schema_name=None, tbl_name=None, user_name=None):
        self.col_name = col_name  # type: str
        self.db_name = db_name  # type: str
        self.mek_id = mek_id  # type: long
        self.schema_name = schema_name  # type: str
        self.tbl_name = tbl_name  # type: str
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTableDataKeyVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col_name is not None:
            result['ColName'] = self.col_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.tbl_name is not None:
            result['TblName'] = self.tbl_name
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColName') is not None:
            self.col_name = m.get('ColName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TblName') is not None:
            self.tbl_name = m.get('TblName')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ImportMasterKeyVO(TeaModel):
    def __init__(self, encrypt_mek_data_base_64=None, mek_id=None, project_id=None):
        self.encrypt_mek_data_base_64 = encrypt_mek_data_base_64  # type: str
        self.mek_id = mek_id  # type: long
        self.project_id = project_id  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportMasterKeyVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_mek_data_base_64 is not None:
            result['EncryptMekDataBase64'] = self.encrypt_mek_data_base_64
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EncryptMekDataBase64') is not None:
            self.encrypt_mek_data_base_64 = m.get('EncryptMekDataBase64')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ProjectDetailsLiteVO(TeaModel):
    def __init__(self, id=None, project_name=None):
        self.id = id  # type: long
        self.project_name = project_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ProjectDetailsLiteVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class StsApplyVO(TeaModel):
    def __init__(self, aliyun_id=None, duration=None):
        self.aliyun_id = aliyun_id  # type: str
        self.duration = duration  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StsApplyVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_id is not None:
            result['AliyunId'] = self.aliyun_id
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliyunId') is not None:
            self.aliyun_id = m.get('AliyunId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class StsTokenVO(TeaModel):
    def __init__(self, access_key_id=None, access_key_secret=None, expiration=None, security_token=None):
        self.access_key_id = access_key_id  # type: str
        self.access_key_secret = access_key_secret  # type: str
        self.expiration = expiration  # type: str
        self.security_token = security_token  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StsTokenVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['AccessKeySecret'] = self.access_key_secret
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('AccessKeySecret') is not None:
            self.access_key_secret = m.get('AccessKeySecret')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class TeeEvidenceVO(TeaModel):
    def __init__(self, cipher_suite=None, enclave_data=None, encrypt_public_key_pem=None,
                 encrypt_public_key_type=None, modified_date=None, public_key=None, public_key_ra_base_64=None, public_key_ra_type=None,
                 quote_report=None, sign_public_key_pem=None, sign_public_key_type=None, trusted_mr_enclave=None):
        self.cipher_suite = cipher_suite  # type: str
        self.enclave_data = enclave_data  # type: str
        self.encrypt_public_key_pem = encrypt_public_key_pem  # type: str
        self.encrypt_public_key_type = encrypt_public_key_type  # type: str
        self.modified_date = modified_date  # type: str
        self.public_key = public_key  # type: str
        self.public_key_ra_base_64 = public_key_ra_base_64  # type: str
        self.public_key_ra_type = public_key_ra_type  # type: str
        self.quote_report = quote_report  # type: str
        self.sign_public_key_pem = sign_public_key_pem  # type: str
        self.sign_public_key_type = sign_public_key_type  # type: str
        self.trusted_mr_enclave = trusted_mr_enclave  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(TeeEvidenceVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_suite is not None:
            result['CipherSuite'] = self.cipher_suite
        if self.enclave_data is not None:
            result['EnclaveData'] = self.enclave_data
        if self.encrypt_public_key_pem is not None:
            result['EncryptPublicKeyPem'] = self.encrypt_public_key_pem
        if self.encrypt_public_key_type is not None:
            result['EncryptPublicKeyType'] = self.encrypt_public_key_type
        if self.modified_date is not None:
            result['ModifiedDate'] = self.modified_date
        if self.public_key is not None:
            result['PublicKey'] = self.public_key
        if self.public_key_ra_base_64 is not None:
            result['PublicKeyRaBase64'] = self.public_key_ra_base_64
        if self.public_key_ra_type is not None:
            result['PublicKeyRaType'] = self.public_key_ra_type
        if self.quote_report is not None:
            result['QuoteReport'] = self.quote_report
        if self.sign_public_key_pem is not None:
            result['SignPublicKeyPem'] = self.sign_public_key_pem
        if self.sign_public_key_type is not None:
            result['SignPublicKeyType'] = self.sign_public_key_type
        if self.trusted_mr_enclave is not None:
            result['TrustedMrEnclave'] = self.trusted_mr_enclave
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CipherSuite') is not None:
            self.cipher_suite = m.get('CipherSuite')
        if m.get('EnclaveData') is not None:
            self.enclave_data = m.get('EnclaveData')
        if m.get('EncryptPublicKeyPem') is not None:
            self.encrypt_public_key_pem = m.get('EncryptPublicKeyPem')
        if m.get('EncryptPublicKeyType') is not None:
            self.encrypt_public_key_type = m.get('EncryptPublicKeyType')
        if m.get('ModifiedDate') is not None:
            self.modified_date = m.get('ModifiedDate')
        if m.get('PublicKey') is not None:
            self.public_key = m.get('PublicKey')
        if m.get('PublicKeyRaBase64') is not None:
            self.public_key_ra_base_64 = m.get('PublicKeyRaBase64')
        if m.get('PublicKeyRaType') is not None:
            self.public_key_ra_type = m.get('PublicKeyRaType')
        if m.get('QuoteReport') is not None:
            self.quote_report = m.get('QuoteReport')
        if m.get('SignPublicKeyPem') is not None:
            self.sign_public_key_pem = m.get('SignPublicKeyPem')
        if m.get('SignPublicKeyType') is not None:
            self.sign_public_key_type = m.get('SignPublicKeyType')
        if m.get('TrustedMrEnclave') is not None:
            self.trusted_mr_enclave = m.get('TrustedMrEnclave')
        return self


class UsersDetailsVO(TeaModel):
    def __init__(self, approval_signature_base_64=None, approval_sql_template=None, approval_status=None,
                 creator=None, data_ready=None, id=None, mekid=None, path_prefix=None, result_party=None, uid=None,
                 user_confirmed=None, user_name=None, user_public_key_pem=None):
        self.approval_signature_base_64 = approval_signature_base_64  # type: str
        self.approval_sql_template = approval_sql_template  # type: str
        self.approval_status = approval_status  # type: str
        self.creator = creator  # type: int
        self.data_ready = data_ready  # type: int
        self.id = id  # type: long
        self.mekid = mekid  # type: long
        self.path_prefix = path_prefix  # type: str
        self.result_party = result_party  # type: int
        self.uid = uid  # type: str
        self.user_confirmed = user_confirmed  # type: int
        self.user_name = user_name  # type: str
        self.user_public_key_pem = user_public_key_pem  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UsersDetailsVO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_signature_base_64 is not None:
            result['ApprovalSignatureBase64'] = self.approval_signature_base_64
        if self.approval_sql_template is not None:
            result['ApprovalSqlTemplate'] = self.approval_sql_template
        if self.approval_status is not None:
            result['ApprovalStatus'] = self.approval_status
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_ready is not None:
            result['DataReady'] = self.data_ready
        if self.id is not None:
            result['Id'] = self.id
        if self.mekid is not None:
            result['Mekid'] = self.mekid
        if self.path_prefix is not None:
            result['PathPrefix'] = self.path_prefix
        if self.result_party is not None:
            result['ResultParty'] = self.result_party
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_confirmed is not None:
            result['UserConfirmed'] = self.user_confirmed
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_public_key_pem is not None:
            result['UserPublicKeyPem'] = self.user_public_key_pem
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApprovalSignatureBase64') is not None:
            self.approval_signature_base_64 = m.get('ApprovalSignatureBase64')
        if m.get('ApprovalSqlTemplate') is not None:
            self.approval_sql_template = m.get('ApprovalSqlTemplate')
        if m.get('ApprovalStatus') is not None:
            self.approval_status = m.get('ApprovalStatus')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataReady') is not None:
            self.data_ready = m.get('DataReady')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Mekid') is not None:
            self.mekid = m.get('Mekid')
        if m.get('PathPrefix') is not None:
            self.path_prefix = m.get('PathPrefix')
        if m.get('ResultParty') is not None:
            self.result_party = m.get('ResultParty')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserConfirmed') is not None:
            self.user_confirmed = m.get('UserConfirmed')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserPublicKeyPem') is not None:
            self.user_public_key_pem = m.get('UserPublicKeyPem')
        return self


class AddDesensitizationRuleRequest(TeaModel):
    def __init__(self, function_params=None, function_type=None, rule_description=None, rule_name=None,
                 rule_type=None, tid=None):
        # Algorithm parameters.
        self.function_params = function_params  # type: list[dict[str, str]]
        # The type of the masking algorithm.
        self.function_type = function_type  # type: str
        # The description of the rule.
        self.rule_description = rule_description  # type: str
        # The name of the rule.
        self.rule_name = rule_name  # type: str
        # The masking algorithm.
        self.rule_type = rule_type  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddDesensitizationRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_params is not None:
            result['FunctionParams'] = self.function_params
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FunctionParams') is not None:
            self.function_params = m.get('FunctionParams')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddDesensitizationRuleResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, rule_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID generated for the masking rule.
        self.rule_id = rule_id  # type: int
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddDesensitizationRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDesensitizationRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddDesensitizationRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddDesensitizationRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLhMembersRequestMembers(TeaModel):
    def __init__(self, roles=None, user_id=None):
        # The role. Valid values:
        # 
        # *   **ADMIN**: workspace administrator. You can add a workspace administrator only as a DMS administrator or a DBA.
        # *   **MEMBER**: workspace member.
        # *   **DEVELOPER**: task flow developer. Only a workspace member can be added as a task flow developer.
        self.roles = roles  # type: list[str]
        # The ID of the user to be added. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.user_id = user_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddLhMembersRequestMembers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddLhMembersRequest(TeaModel):
    def __init__(self, members=None, object_id=None, object_type=None, tid=None):
        # The information about the users to be added.
        self.members = members  # type: list[AddLhMembersRequestMembers]
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id  # type: long
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddLhMembersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddLhMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersShrinkRequest(TeaModel):
    def __init__(self, members_shrink=None, object_id=None, object_type=None, tid=None):
        # The information about the users to be added.
        self.members_shrink = members_shrink  # type: str
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id  # type: long
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddLhMembersShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddLhMembersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLhMembersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddLhMembersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddLhMembersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLogicTableRouteConfigRequest(TeaModel):
    def __init__(self, route_expr=None, route_key=None, table_id=None, tid=None):
        # The routing algorithm expression. For more information about how to configure a routing algorithm expression, see [Configure a routing algorithm](https://www.alibabacloud.com/help/en/data-management-service/latest/configure-a-routing-algorithm).
        self.route_expr = route_expr  # type: str
        # The unique key of the routing algorithm. 
        # 
        # > - You can create a custom unique key for the routing algorithm. No requirements are imposed on custom unique keys.
        # > - The unique key of the routing algorithm in the same logical table must be unique.
        self.route_key = route_key  # type: str
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddLogicTableRouteConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddLogicTableRouteConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLogicTableRouteConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddLogicTableRouteConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddLogicTableRouteConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(self, node_end=None, node_from=None):
        # The ID of the node where the end node of the edge is located.
        self.node_end = node_end  # type: long
        # The ID of the node where the start node of the edge is located.
        self.node_from = node_from  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTaskFlowEdgesRequestEdges, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class AddTaskFlowEdgesRequest(TeaModel):
    def __init__(self, dag_id=None, edges=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of edges of the task flow.
        self.edges = edges  # type: list[AddTaskFlowEdgesRequestEdges]
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddTaskFlowEdgesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = AddTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(self, dag_id=None, edges_shrink=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of edges of the task flow.
        self.edges_shrink = edges_shrink  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTaskFlowEdgesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesResponseBodyEdgeIds(TeaModel):
    def __init__(self, edge_id=None):
        self.edge_id = edge_id  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTaskFlowEdgesResponseBodyEdgeIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_id is not None:
            result['EdgeId'] = self.edge_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EdgeId') is not None:
            self.edge_id = m.get('EdgeId')
        return self


class AddTaskFlowEdgesResponseBody(TeaModel):
    def __init__(self, edge_ids=None, error_code=None, error_message=None, request_id=None, success=None):
        # The list of task flow edge IDs.
        self.edge_ids = edge_ids  # type: AddTaskFlowEdgesResponseBodyEdgeIds
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.edge_ids:
            self.edge_ids.validate()

    def to_map(self):
        _map = super(AddTaskFlowEdgesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_ids is not None:
            result['EdgeIds'] = self.edge_ids.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EdgeIds') is not None:
            temp_model = AddTaskFlowEdgesResponseBodyEdgeIds()
            self.edge_ids = temp_model.from_map(m['EdgeIds'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTaskFlowEdgesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddTaskFlowEdgesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddTaskFlowEdgesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AnalyzeSQLLineageRequest(TeaModel):
    def __init__(self, db_id=None, sql_content=None, tid=None):
        self.db_id = db_id  # type: long
        self.sql_content = sql_content  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AnalyzeSQLLineageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.sql_content is not None:
            result['SqlContent'] = self.sql_content
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SqlContent') is not None:
            self.sql_content = m.get('SqlContent')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail(TeaModel):
    def __init__(self, cal_way=None, code=None):
        self.cal_way = cal_way  # type: str
        self.code = code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cal_way is not None:
            result['CalWay'] = self.cal_way
        if self.code is not None:
            result['Code'] = self.code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CalWay') is not None:
            self.cal_way = m.get('CalWay')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultLineages(TeaModel):
    def __init__(self, dst=None, lineage_type=None, oper_type=None, process_detail=None, src=None):
        self.dst = dst  # type: str
        self.lineage_type = lineage_type  # type: str
        self.oper_type = oper_type  # type: str
        self.process_detail = process_detail  # type: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail
        self.src = src  # type: str

    def validate(self):
        if self.process_detail:
            self.process_detail.validate()

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBodyLineageResultLineages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst is not None:
            result['Dst'] = self.dst
        if self.lineage_type is not None:
            result['LineageType'] = self.lineage_type
        if self.oper_type is not None:
            result['OperType'] = self.oper_type
        if self.process_detail is not None:
            result['ProcessDetail'] = self.process_detail.to_map()
        if self.src is not None:
            result['Src'] = self.src
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dst') is not None:
            self.dst = m.get('Dst')
        if m.get('LineageType') is not None:
            self.lineage_type = m.get('LineageType')
        if m.get('OperType') is not None:
            self.oper_type = m.get('OperType')
        if m.get('ProcessDetail') is not None:
            temp_model = AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail()
            self.process_detail = temp_model.from_map(m['ProcessDetail'])
        if m.get('Src') is not None:
            self.src = m.get('Src')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields(TeaModel):
    def __init__(self, name=None):
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata(TeaModel):
    def __init__(self, fields=None, name=None, source=None, type=None):
        self.fields = fields  # type: list[AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields]
        self.name = name  # type: str
        self.source = source  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['Fields'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fields = []
        if m.get('Fields') is not None:
            for k in m.get('Fields'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AnalyzeSQLLineageResponseBodyLineageResult(TeaModel):
    def __init__(self, lineages=None, object_metadata=None):
        self.lineages = lineages  # type: list[AnalyzeSQLLineageResponseBodyLineageResultLineages]
        self.object_metadata = object_metadata  # type: list[AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata]

    def validate(self):
        if self.lineages:
            for k in self.lineages:
                if k:
                    k.validate()
        if self.object_metadata:
            for k in self.object_metadata:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBodyLineageResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Lineages'] = []
        if self.lineages is not None:
            for k in self.lineages:
                result['Lineages'].append(k.to_map() if k else None)
        result['ObjectMetadata'] = []
        if self.object_metadata is not None:
            for k in self.object_metadata:
                result['ObjectMetadata'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.lineages = []
        if m.get('Lineages') is not None:
            for k in m.get('Lineages'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultLineages()
                self.lineages.append(temp_model.from_map(k))
        self.object_metadata = []
        if m.get('ObjectMetadata') is not None:
            for k in m.get('ObjectMetadata'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata()
                self.object_metadata.append(temp_model.from_map(k))
        return self


class AnalyzeSQLLineageResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, lineage_result=None, request_id=None, success=None):
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.lineage_result = lineage_result  # type: AnalyzeSQLLineageResponseBodyLineageResult
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.lineage_result:
            self.lineage_result.validate()

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.lineage_result is not None:
            result['LineageResult'] = self.lineage_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LineageResult') is not None:
            temp_model = AnalyzeSQLLineageResponseBodyLineageResult()
            self.lineage_result = temp_model.from_map(m['LineageResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AnalyzeSQLLineageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AnalyzeSQLLineageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AnalyzeSQLLineageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AnalyzeSQLLineageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApproveOrderRequest(TeaModel):
    def __init__(self, approval_node_id=None, approval_node_pos=None, approval_type=None, comment=None,
                 new_approver=None, old_approver=None, tid=None, workflow_instance_id=None):
        self.approval_node_id = approval_node_id  # type: long
        self.approval_node_pos = approval_node_pos  # type: str
        # The action that you want to perform on the ticket. Valid values:
        # 
        # *   AGREE: approve
        # *   CANCEL: cancel
        # *   REJECT: reject
        self.approval_type = approval_type  # type: str
        # The description of the ticket.
        self.comment = comment  # type: str
        self.new_approver = new_approver  # type: long
        self.old_approver = old_approver  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
        self.workflow_instance_id = workflow_instance_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApproveOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_node_id is not None:
            result['ApprovalNodeId'] = self.approval_node_id
        if self.approval_node_pos is not None:
            result['ApprovalNodePos'] = self.approval_node_pos
        if self.approval_type is not None:
            result['ApprovalType'] = self.approval_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.new_approver is not None:
            result['NewApprover'] = self.new_approver
        if self.old_approver is not None:
            result['OldApprover'] = self.old_approver
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApprovalNodeId') is not None:
            self.approval_node_id = m.get('ApprovalNodeId')
        if m.get('ApprovalNodePos') is not None:
            self.approval_node_pos = m.get('ApprovalNodePos')
        if m.get('ApprovalType') is not None:
            self.approval_type = m.get('ApprovalType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('NewApprover') is not None:
            self.new_approver = m.get('NewApprover')
        if m.get('OldApprover') is not None:
            self.old_approver = m.get('OldApprover')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ApproveOrderResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApproveOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ApproveOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApproveOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApproveOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApproveOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BackFillRequest(TeaModel):
    def __init__(self, asc=None, back_fill_date=None, back_fill_date_begin=None, back_fill_date_end=None,
                 dag_id=None, filter_node_ids=None, history_dag_id=None, interval=None, is_trigger_sub_tree=None,
                 start_node_ids=None, tid=None):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc  # type: bool
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date  # type: str
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin  # type: str
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end  # type: str
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
        self.filter_node_ids = filter_node_ids  # type: list[long]
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id  # type: long
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval  # type: int
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree  # type: bool
        # The number of nodes for which you want to backfill data.
        self.start_node_ids = start_node_ids  # type: list[long]
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(BackFillRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.filter_node_ids is not None:
            result['FilterNodeIds'] = self.filter_node_ids
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids is not None:
            result['StartNodeIds'] = self.start_node_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('FilterNodeIds') is not None:
            self.filter_node_ids = m.get('FilterNodeIds')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillShrinkRequest(TeaModel):
    def __init__(self, asc=None, back_fill_date=None, back_fill_date_begin=None, back_fill_date_end=None,
                 dag_id=None, filter_node_ids_shrink=None, history_dag_id=None, interval=None, is_trigger_sub_tree=None,
                 start_node_ids_shrink=None, tid=None):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc  # type: bool
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date  # type: str
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin  # type: str
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end  # type: str
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
        self.filter_node_ids_shrink = filter_node_ids_shrink  # type: str
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id  # type: long
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval  # type: int
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree  # type: bool
        # The number of nodes for which you want to backfill data.
        self.start_node_ids_shrink = start_node_ids_shrink  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(BackFillShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.filter_node_ids_shrink is not None:
            result['FilterNodeIds'] = self.filter_node_ids_shrink
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids_shrink is not None:
            result['StartNodeIds'] = self.start_node_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('FilterNodeIds') is not None:
            self.filter_node_ids_shrink = m.get('FilterNodeIds')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids_shrink = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillResponseBody(TeaModel):
    def __init__(self, dag_instance_id=None, error_code=None, error_message=None, node_id=None, request_id=None,
                 success=None):
        self.dag_instance_id = dag_instance_id  # type: long
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the node.
        self.node_id = node_id  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(BackFillResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BackFillResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BackFillResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BackFillResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BackFillResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BuyPayAsYouGoOrderRequest(TeaModel):
    def __init__(self, commodity_type=None, ins_num=None, tid=None, version_type=None):
        # The type of the resource that you want to purchase.
        # 
        # *   **VersionType**: DMS that supports control modes
        # *   **SensitiveDataProtection**: DMS that supports sensitive data protection
        self.commodity_type = commodity_type  # type: str
        # The number of database instances that you want to use DMS to manage.
        # 
        # > A quota can be used for only one database instance.
        self.ins_num = ins_num  # type: int
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long
        # The control mode of DMS. Valid values:
        # 
        # *   **stand**: Stable Change
        # *   **safety**: Security Collaboration
        self.version_type = version_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BuyPayAsYouGoOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class BuyPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, instance_id=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # If the purchase is successful, the ID of the purchased instance is returned.
        self.instance_id = instance_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(BuyPayAsYouGoOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BuyPayAsYouGoOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BuyPayAsYouGoOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BuyPayAsYouGoOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BuyPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeColumnSecLevelRequest(TeaModel):
    def __init__(self, column_name=None, db_id=None, is_logic=None, new_level=None, schema_name=None,
                 table_name=None, tid=None):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the field.
        # 
        # > You can also call the [ListColumns](~~141870~~) operation to obtain the name of the field.
        self.column_name = column_name  # type: str
        # The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to obtain the ID of the database.
        # 
        # > You can also call the [ListDatabases](~~141873~~) operation to obtain the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to obtain the ID of a logical database.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a physical database.
        # *   false: The database is a logical database.
        self.is_logic = is_logic  # type: bool
        # The new sensitivity level of the field that you want to specify. Valid values:
        # 
        # *   INNER: low sensitivity level
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        self.new_level = new_level  # type: str
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the database.
        # 
        # *   You can also call the [SearchDatabase](~~141876~~) operation to obtain the name of the database.
        # *   You can also call the [ListDatabases](~~141873~~) operation to obtain the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to obtain the name of a logical database.
        self.schema_name = schema_name  # type: str
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the table.
        # 
        # > You can also call the [ListTables](~~141878~~) operation to obtain the name of the table.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeColumnSecLevelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.new_level is not None:
            result['NewLevel'] = self.new_level
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('NewLevel') is not None:
            self.new_level = m.get('NewLevel')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeColumnSecLevelResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeColumnSecLevelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeColumnSecLevelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ChangeColumnSecLevelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ChangeColumnSecLevelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeColumnSecLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeColumnSecurityLevelRequest(TeaModel):
    def __init__(self, column_name=None, db_id=None, is_logic=None, new_sensitivity_level=None, schema_name=None,
                 table_name=None, tid=None):
        self.column_name = column_name  # type: str
        self.db_id = db_id  # type: long
        self.is_logic = is_logic  # type: bool
        self.new_sensitivity_level = new_sensitivity_level  # type: str
        self.schema_name = schema_name  # type: str
        self.table_name = table_name  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeColumnSecurityLevelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.new_sensitivity_level is not None:
            result['NewSensitivityLevel'] = self.new_sensitivity_level
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('NewSensitivityLevel') is not None:
            self.new_sensitivity_level = m.get('NewSensitivityLevel')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeColumnSecurityLevelResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeColumnSecurityLevelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeColumnSecurityLevelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ChangeColumnSecurityLevelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ChangeColumnSecurityLevelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeColumnSecurityLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeLhDagOwnerRequest(TeaModel):
    def __init__(self, dag_id=None, owner_user_id=None, tid=None):
        # The ID of the task flow. You can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the user to be specified as the new owner of the task flow. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.owner_user_id = owner_user_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeLhDagOwnerRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.owner_user_id is not None:
            result['OwnerUserId'] = self.owner_user_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('OwnerUserId') is not None:
            self.owner_user_id = m.get('OwnerUserId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeLhDagOwnerResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeLhDagOwnerResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeLhDagOwnerResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ChangeLhDagOwnerResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ChangeLhDagOwnerResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeLhDagOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseOrderRequest(TeaModel):
    def __init__(self, close_reason=None, order_id=None, tid=None):
        # The reason why the ticket is closed.
        self.close_reason = close_reason  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CloseOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_reason is not None:
            result['CloseReason'] = self.close_reason
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CloseReason') is not None:
            self.close_reason = m.get('CloseReason')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CloseOrderResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CloseOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CloseOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CloseOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAuthorityTemplateRequest(TeaModel):
    def __init__(self, description=None, name=None, tid=None):
        # The description of the permission template.
        self.description = description  # type: str
        # The name of the permission template.
        self.name = name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAuthorityTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(self, create_time=None, creator_id=None, description=None, name=None, template_id=None):
        # The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.create_time = create_time  # type: str
        # The ID of the user who created the permission template.
        self.creator_id = creator_id  # type: long
        # The description of the permission template.
        self.description = description  # type: str
        # The name of the permission template.
        self.name = name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAuthorityTemplateResponseBodyAuthorityTemplateView, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateAuthorityTemplateResponseBody(TeaModel):
    def __init__(self, authority_template_view=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the permission template.
        self.authority_template_view = authority_template_view  # type: CreateAuthorityTemplateResponseBodyAuthorityTemplateView
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super(CreateAuthorityTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = CreateAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateAuthorityTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAuthorityTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAuthorityTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataArchiveOrderRequestParamTableIncludes(TeaModel):
    def __init__(self, table_name=None, table_where=None):
        self.table_name = table_name  # type: str
        self.table_where = table_where  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataArchiveOrderRequestParamTableIncludes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_where is not None:
            result['TableWhere'] = self.table_where
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableWhere') is not None:
            self.table_where = m.get('TableWhere')
        return self


class CreateDataArchiveOrderRequestParam(TeaModel):
    def __init__(self, archive_method=None, db_schema=None, logic=None, order_after=None, run_method=None,
                 source_database_id=None, table_includes=None, table_mapping=None, target_instance_id=None, variables=None):
        self.archive_method = archive_method  # type: str
        self.db_schema = db_schema  # type: str
        self.logic = logic  # type: bool
        self.order_after = order_after  # type: list[str]
        self.run_method = run_method  # type: str
        self.source_database_id = source_database_id  # type: long
        self.table_includes = table_includes  # type: list[CreateDataArchiveOrderRequestParamTableIncludes]
        self.table_mapping = table_mapping  # type: list[str]
        self.target_instance_id = target_instance_id  # type: str
        self.variables = variables  # type: list[str]

    def validate(self):
        if self.table_includes:
            for k in self.table_includes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDataArchiveOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_method is not None:
            result['ArchiveMethod'] = self.archive_method
        if self.db_schema is not None:
            result['DbSchema'] = self.db_schema
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_after is not None:
            result['OrderAfter'] = self.order_after
        if self.run_method is not None:
            result['RunMethod'] = self.run_method
        if self.source_database_id is not None:
            result['SourceDatabaseId'] = self.source_database_id
        result['TableIncludes'] = []
        if self.table_includes is not None:
            for k in self.table_includes:
                result['TableIncludes'].append(k.to_map() if k else None)
        if self.table_mapping is not None:
            result['TableMapping'] = self.table_mapping
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.variables is not None:
            result['Variables'] = self.variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ArchiveMethod') is not None:
            self.archive_method = m.get('ArchiveMethod')
        if m.get('DbSchema') is not None:
            self.db_schema = m.get('DbSchema')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderAfter') is not None:
            self.order_after = m.get('OrderAfter')
        if m.get('RunMethod') is not None:
            self.run_method = m.get('RunMethod')
        if m.get('SourceDatabaseId') is not None:
            self.source_database_id = m.get('SourceDatabaseId')
        self.table_includes = []
        if m.get('TableIncludes') is not None:
            for k in m.get('TableIncludes'):
                temp_model = CreateDataArchiveOrderRequestParamTableIncludes()
                self.table_includes.append(temp_model.from_map(k))
        if m.get('TableMapping') is not None:
            self.table_mapping = m.get('TableMapping')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('Variables') is not None:
            self.variables = m.get('Variables')
        return self


class CreateDataArchiveOrderRequest(TeaModel):
    def __init__(self, comment=None, param=None, parent_id=None, plugin_type=None, related_user_list=None, tid=None):
        self.comment = comment  # type: str
        self.param = param  # type: CreateDataArchiveOrderRequestParam
        self.parent_id = parent_id  # type: long
        self.plugin_type = plugin_type  # type: str
        self.related_user_list = related_user_list  # type: list[str]
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateDataArchiveOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataArchiveOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataArchiveOrderShrinkRequest(TeaModel):
    def __init__(self, comment=None, param_shrink=None, parent_id=None, plugin_type=None,
                 related_user_list_shrink=None, tid=None):
        self.comment = comment  # type: str
        self.param_shrink = param_shrink  # type: str
        self.parent_id = parent_id  # type: long
        self.plugin_type = plugin_type  # type: str
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataArchiveOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataArchiveOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        self.create_order_result = create_order_result  # type: list[long]
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataArchiveOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataArchiveOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataArchiveOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataArchiveOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataArchiveOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(self, db_id=None, logic=None):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCorrectOrderRequestParamDbItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCorrectOrderRequestParam(TeaModel):
    def __init__(self, attachment_name=None, classify=None, db_item_list=None, estimate_affect_rows=None,
                 exec_mode=None, exec_sql=None, rollback_attachment_name=None, rollback_sql=None, rollback_sql_type=None,
                 sql_type=None):
        # The key of the attachment that contains the SQL statements used to change data. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **SqlType** parameter to **ATTACHMENT**.
        self.attachment_name = attachment_name  # type: str
        # The reason for the data change.
        self.classify = classify  # type: str
        # The databases in which you want to change data.
        self.db_item_list = db_item_list  # type: list[CreateDataCorrectOrderRequestParamDbItemList]
        # The estimated number of data rows to be affected by the data change.
        self.estimate_affect_rows = estimate_affect_rows  # type: long
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The data change is performed by the user who submits the ticket.
        # *   **AUTO**: The data change is automatically performed after the ticket is approved.
        # *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode  # type: str
        # The SQL statements that you want to execute to change data.
        # 
        # >  This parameter is required if you set the **SqlType** parameter to **TEXT**.
        self.exec_sql = exec_sql  # type: str
        # The key of the attachment that contains the SQL statements used to roll back the data change. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name  # type: str
        # The SQL statements used to roll back the data change.
        # 
        # > This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
        self.rollback_sql = rollback_sql  # type: str
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.rollback_sql_type = rollback_sql_type  # type: str
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.sql_type = sql_type  # type: str

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDataCorrectOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateDataCorrectOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateDataCorrectOrderRequestParam
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateDataCorrectOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCorrectOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The IDs of the tickets.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCorrectOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCorrectOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataCorrectOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataCorrectOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCronClearOrderRequestParamCronClearItemList(TeaModel):
    def __init__(self, column_name=None, filter_sql=None, remain_days=None, table_name=None, time_unit=None):
        # The name of the field.
        self.column_name = column_name  # type: str
        # The filter conditions.
        self.filter_sql = filter_sql  # type: str
        # The retention period of the historical data. Unit: days. For example, if you set the parameter to 7, DMS deletes the data that is retained for more than seven days.
        self.remain_days = remain_days  # type: long
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the name of the table.
        self.table_name = table_name  # type: str
        # The type of time granularity. If the ColumnName parameter specifies a field of a time type, this parameter is required. Valid values:
        # 
        # *   **MILLISECONDS**: milliseconds
        # *   **SECONDS**: seconds
        self.time_unit = time_unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCronClearOrderRequestParamCronClearItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.filter_sql is not None:
            result['FilterSQL'] = self.filter_sql
        if self.remain_days is not None:
            result['RemainDays'] = self.remain_days
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FilterSQL') is not None:
            self.filter_sql = m.get('FilterSQL')
        if m.get('RemainDays') is not None:
            self.remain_days = m.get('RemainDays')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        return self


class CreateDataCronClearOrderRequestParamDbItemList(TeaModel):
    def __init__(self, db_id=None, logic=None):
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        self.db_id = db_id  # type: long
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCronClearOrderRequestParamDbItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCronClearOrderRequestParam(TeaModel):
    def __init__(self, classify=None, cron_clear_item_list=None, cron_format=None, db_item_list=None,
                 duration_hour=None, specify_duration=None):
        # The reason for the data change.
        self.classify = classify  # type: str
        # The tables for which you want to clear historical data.
        self.cron_clear_item_list = cron_clear_item_list  # type: list[CreateDataCronClearOrderRequestParamCronClearItemList]
        # The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](~~206581~~).
        self.cron_format = cron_format  # type: str
        # The databases for which you want to clear historical data.
        self.db_item_list = db_item_list  # type: list[CreateDataCronClearOrderRequestParamDbItemList]
        # The amount of time taken to run the task. Unit: hours.
        # 
        # >  If the **specifyDuration** parameter is set to **true**, this parameter is required.
        self.duration_hour = duration_hour  # type: long
        # Specifies whether to specify an end time for the task. Valid values:
        # 
        # *   **true**: specifies an end time for the task. The task is automatically suspended after this end time.
        # *   **false**: does not specify an end time for the task. The task is stopped after the historical data is cleared.
        self.specify_duration = specify_duration  # type: bool

    def validate(self):
        if self.cron_clear_item_list:
            for k in self.cron_clear_item_list:
                if k:
                    k.validate()
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDataCronClearOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['CronClearItemList'] = []
        if self.cron_clear_item_list is not None:
            for k in self.cron_clear_item_list:
                result['CronClearItemList'].append(k.to_map() if k else None)
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.duration_hour is not None:
            result['DurationHour'] = self.duration_hour
        if self.specify_duration is not None:
            result['specifyDuration'] = self.specify_duration
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.cron_clear_item_list = []
        if m.get('CronClearItemList') is not None:
            for k in m.get('CronClearItemList'):
                temp_model = CreateDataCronClearOrderRequestParamCronClearItemList()
                self.cron_clear_item_list.append(temp_model.from_map(k))
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCronClearOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('DurationHour') is not None:
            self.duration_hour = m.get('DurationHour')
        if m.get('specifyDuration') is not None:
            self.specify_duration = m.get('specifyDuration')
        return self


class CreateDataCronClearOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This reduces unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateDataCronClearOrderRequestParam
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateDataCronClearOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCronClearOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This reduces unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCronClearOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the ticket.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataCronClearOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCronClearOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataCronClearOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataCronClearOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCronClearOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataExportOrderRequestPluginParamWatermark(TeaModel):
    def __init__(self, column_name=None, data_watermark=None, file_watermark=None, keys=None, watermark_types=None):
        # The field into which the watermark is to be embedded.
        self.column_name = column_name  # type: str
        # The information to be embedded as a watermark into data.
        self.data_watermark = data_watermark  # type: str
        # The information to be embedded as a watermark into files.
        self.file_watermark = file_watermark  # type: str
        # One or more primary keys or unique keys.
        self.keys = keys  # type: list[str]
        # The methods in which the watermark is embedded.
        self.watermark_types = watermark_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataExportOrderRequestPluginParamWatermark, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.data_watermark is not None:
            result['DataWatermark'] = self.data_watermark
        if self.file_watermark is not None:
            result['FileWatermark'] = self.file_watermark
        if self.keys is not None:
            result['Keys'] = self.keys
        if self.watermark_types is not None:
            result['WatermarkTypes'] = self.watermark_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DataWatermark') is not None:
            self.data_watermark = m.get('DataWatermark')
        if m.get('FileWatermark') is not None:
            self.file_watermark = m.get('FileWatermark')
        if m.get('Keys') is not None:
            self.keys = m.get('Keys')
        if m.get('WatermarkTypes') is not None:
            self.watermark_types = m.get('WatermarkTypes')
        return self


class CreateDataExportOrderRequestPluginParam(TeaModel):
    def __init__(self, affect_rows=None, classify=None, db_id=None, exe_sql=None, ignore_affect_rows=None,
                 ignore_affect_rows_reason=None, instance_id=None, logic=None, watermark=None):
        # The estimated number of data rows to be affected.
        self.affect_rows = affect_rows  # type: long
        # The reason for the export ticket.
        self.classify = classify  # type: str
        # The database ID.
        self.db_id = db_id  # type: long
        # The SQL statements that can be executed.
        self.exe_sql = exe_sql  # type: str
        # Specifies whether to skip verification. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.ignore_affect_rows = ignore_affect_rows  # type: bool
        # The reason for skipping verification. This parameter is required if you set IgnoreAffectRows to true.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason  # type: str
        # The instance ID.
        self.instance_id = instance_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # > If you set this parameter to **true**, the database that you specify must be a logical database.
        self.logic = logic  # type: bool
        # The information about the watermarks.
        self.watermark = watermark  # type: CreateDataExportOrderRequestPluginParamWatermark

    def validate(self):
        if self.watermark:
            self.watermark.validate()

    def to_map(self):
        _map = super(CreateDataExportOrderRequestPluginParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.watermark is not None:
            result['Watermark'] = self.watermark.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Watermark') is not None:
            temp_model = CreateDataExportOrderRequestPluginParamWatermark()
            self.watermark = temp_model.from_map(m['Watermark'])
        return self


class CreateDataExportOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, parent_id=None, plugin_param=None, related_user_list=None,
                 tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        self.comment = comment  # type: str
        # The ID of the parent ticket.
        self.parent_id = parent_id  # type: long
        # The parameters of the ticket.
        self.plugin_param = plugin_param  # type: CreateDataExportOrderRequestPluginParam
        # The stakeholders involved in this operation.
        self.related_user_list = related_user_list  # type: list[long]
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super(CreateDataExportOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            temp_model = CreateDataExportOrderRequestPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataExportOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, parent_id=None, plugin_param_shrink=None,
                 related_user_list_shrink=None, tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        self.comment = comment  # type: str
        # The ID of the parent ticket.
        self.parent_id = parent_id  # type: long
        # The parameters of the ticket.
        self.plugin_param_shrink = plugin_param_shrink  # type: str
        # The stakeholders involved in this operation.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataExportOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataExportOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(self, create_order_result=None):
        self.create_order_result = create_order_result  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataExportOrderResponseBodyCreateOrderResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        return self


class CreateDataExportOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The content of the ticket.
        self.create_order_result = create_order_result  # type: CreateDataExportOrderResponseBodyCreateOrderResult
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super(CreateDataExportOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateDataExportOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataExportOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataExportOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataExportOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataExportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataImportOrderRequestParamDbItemList(TeaModel):
    def __init__(self, db_id=None, logic=None):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # >  If you set this parameter to **true**, the database that you specify must be a logical database.
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataImportOrderRequestParamDbItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataImportOrderRequestParam(TeaModel):
    def __init__(self, attachment_name=None, classify=None, csv_first_row_is_column_def=None, db_item_list=None,
                 file_encoding=None, file_type=None, ignore_error=None, import_mode=None, insert_type=None,
                 rollback_attachment_name=None, rollback_sql=None, rollback_sql_type=None, table_name=None):
        # The key of the attachment that contains the SQL statements used to import data. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
        self.attachment_name = attachment_name  # type: str
        # The reason for the data import.
        self.classify = classify  # type: str
        # The type of the CSV file. Valid values:
        # 
        # *   **true**: The first row in the CSV file contains field names.
        # *   **false**: The first row in the CSV file contains data.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.csv_first_row_is_column_def = csv_first_row_is_column_def  # type: bool
        # The database to which you want to import data. You can specify only one database.
        self.db_item_list = db_item_list  # type: list[CreateDataImportOrderRequestParamDbItemList]
        # The encoding algorithm to be used by the destination database. Valid values:
        # 
        # *   **AUTO**: automatic identification
        # *   **UTF-8**: UTF-8 encoding
        # *   **GBK**: GBK encoding
        # *   **ISO-8859-1**: ISO-8859-1 encoding
        self.file_encoding = file_encoding  # type: str
        # The format of the file for the data import. Valid values:
        # 
        # *   **SQL**: an SQL file
        # *   **CSV**: a CSV file
        self.file_type = file_type  # type: str
        # Specifies whether to skip an error that occurs. Valid values:
        # 
        # *   **true**: skips the error and continues to execute SQL statements.
        # *   **false**: stops executing SQL statements.
        self.ignore_error = ignore_error  # type: bool
        # The import mode. Valid values:
        # 
        # *   **FAST_MODE**: In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
        # *   **SAFE_MODE**: In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. This mode can be used to import data in a more secure but less efficient manner.
        self.import_mode = import_mode  # type: str
        # The mode in which the data in the CSV format is to be written to the destination table. Valid values:
        # 
        # *   **INSERT**: The database checks the primary key when data is written. If a duplicate primary key value exists, an error message is returned.
        # *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
        # *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as one row in the destination table, the database deletes the existing row and inserts the new row into the destination table.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.insert_type = insert_type  # type: str
        # The key of the attachment that contains the SQL statements used to roll back the data import. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name  # type: str
        # The SQL statements used to roll back the data import.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
        self.rollback_sql = rollback_sql  # type: str
        # The format of the SQL statements used to roll back the data import. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.rollback_sql_type = rollback_sql_type  # type: str
        # The destination table to which you want to import the data in the CSV format.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.table_name = table_name  # type: str

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDataImportOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.csv_first_row_is_column_def is not None:
            result['CsvFirstRowIsColumnDef'] = self.csv_first_row_is_column_def
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.file_encoding is not None:
            result['FileEncoding'] = self.file_encoding
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.import_mode is not None:
            result['ImportMode'] = self.import_mode
        if self.insert_type is not None:
            result['InsertType'] = self.insert_type
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('CsvFirstRowIsColumnDef') is not None:
            self.csv_first_row_is_column_def = m.get('CsvFirstRowIsColumnDef')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataImportOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('FileEncoding') is not None:
            self.file_encoding = m.get('FileEncoding')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('ImportMode') is not None:
            self.import_mode = m.get('ImportMode')
        if m.get('InsertType') is not None:
            self.insert_type = m.get('InsertType')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class CreateDataImportOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateDataImportOrderRequestParam
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateDataImportOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataImportOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataImportOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the ticket.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataImportOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataImportOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataImportOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataImportOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataImportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataTrackOrderRequestParam(TeaModel):
    def __init__(self, db_id=None, job_end_time=None, job_start_time=None, table_names=None, track_types=None):
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        # 
        # > You can call this operation to create a data tracking ticket for only physical databases. This operation is not applicable to logical databases.
        self.db_id = db_id  # type: str
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.job_end_time = job_end_time  # type: str
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.job_start_time = job_start_time  # type: str
        # The names of the tables for which you want to track data operations.
        self.table_names = table_names  # type: list[str]
        # The types of data operations that you want to track.
        self.track_types = track_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataTrackOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.job_end_time is not None:
            result['JobEndTime'] = self.job_end_time
        if self.job_start_time is not None:
            result['JobStartTime'] = self.job_start_time
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        if self.track_types is not None:
            result['TrackTypes'] = self.track_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('JobEndTime') is not None:
            self.job_end_time = m.get('JobEndTime')
        if m.get('JobStartTime') is not None:
            self.job_start_time = m.get('JobStartTime')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        if m.get('TrackTypes') is not None:
            self.track_types = m.get('TrackTypes')
        return self


class CreateDataTrackOrderRequest(TeaModel):
    def __init__(self, comment=None, param=None, related_user_list=None, tid=None):
        # The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateDataTrackOrderRequestParam
        # The IDs of the operators that are related to the ticket.
        self.related_user_list = related_user_list  # type: list[str]
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateDataTrackOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataTrackOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataTrackOrderShrinkRequest(TeaModel):
    def __init__(self, comment=None, param_shrink=None, related_user_list_shrink=None, tid=None):
        # The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The IDs of the operators that are related to the ticket.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataTrackOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataTrackOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The IDs of the data tracking tickets.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDataTrackOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataTrackOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDataTrackOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDataTrackOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataTrackOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDatabaseExportOrderRequestPluginParamConfig(TeaModel):
    def __init__(self, data_option=None, export_content=None, export_types=None, sqlext_option=None,
                 selected_tables=None, tables=None, target_option=None):
        # The export options for big data. The options are used to filter the big data to be exported. You can leave this parameter empty.
        self.data_option = data_option  # type: list[str]
        # The type of data that you want to export. Valid values:
        # 
        # *   **DATA**: The data of the database is exported.
        # *   **STRUCT**: The schema of the database is exported.
        # *   **DATA_STRUCT**: The data and schema of the database are exported.
        self.export_content = export_content  # type: str
        # The types of schemas that you want to export.
        self.export_types = export_types  # type: list[str]
        # The extension options of the SQL script. You can leave this parameter empty.
        self.sqlext_option = sqlext_option  # type: list[str]
        # The tables that you want to export.
        self.selected_tables = selected_tables  # type: list[str]
        # The conditions used to filter the tables to be exported.
        self.tables = tables  # type: dict[str, str]
        # The format in which the database is exported. Valid values:
        # 
        # *   **SQL**\
        # *   **CSV**\
        # *   **XLSX**\
        self.target_option = target_option  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDatabaseExportOrderRequestPluginParamConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_option is not None:
            result['DataOption'] = self.data_option
        if self.export_content is not None:
            result['ExportContent'] = self.export_content
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables
        if self.tables is not None:
            result['Tables'] = self.tables
        if self.target_option is not None:
            result['TargetOption'] = self.target_option
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataOption') is not None:
            self.data_option = m.get('DataOption')
        if m.get('ExportContent') is not None:
            self.export_content = m.get('ExportContent')
        if m.get('ExportTypes') is not None:
            self.export_types = m.get('ExportTypes')
        if m.get('SQLExtOption') is not None:
            self.sqlext_option = m.get('SQLExtOption')
        if m.get('SelectedTables') is not None:
            self.selected_tables = m.get('SelectedTables')
        if m.get('Tables') is not None:
            self.tables = m.get('Tables')
        if m.get('TargetOption') is not None:
            self.target_option = m.get('TargetOption')
        return self


class CreateDatabaseExportOrderRequestPluginParam(TeaModel):
    def __init__(self, classify=None, config=None, db_id=None, instance_id=None, logic=None, search_name=None):
        # The reason for the database export.
        self.classify = classify  # type: str
        # The configurations for database export.
        self.config = config  # type: CreateDatabaseExportOrderRequestPluginParamConfig
        # The database ID.
        self.db_id = db_id  # type: long
        # The instance ID.
        self.instance_id = instance_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic  # type: bool
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super(CreateDatabaseExportOrderRequestPluginParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Config') is not None:
            temp_model = CreateDatabaseExportOrderRequestPluginParamConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class CreateDatabaseExportOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, parent_id=None, plugin_param=None, related_user_list=None,
                 tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        self.comment = comment  # type: str
        # The ID of the parent ticket.
        self.parent_id = parent_id  # type: long
        # The parameters of the ticket.
        self.plugin_param = plugin_param  # type: CreateDatabaseExportOrderRequestPluginParam
        # The stakeholders involved in this operation.
        self.related_user_list = related_user_list  # type: list[long]
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super(CreateDatabaseExportOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            temp_model = CreateDatabaseExportOrderRequestPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDatabaseExportOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, parent_id=None, plugin_param_shrink=None,
                 related_user_list_shrink=None, tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        self.comment = comment  # type: str
        # The ID of the parent ticket.
        self.parent_id = parent_id  # type: long
        # The parameters of the ticket.
        self.plugin_param_shrink = plugin_param_shrink  # type: str
        # The stakeholders involved in this operation.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDatabaseExportOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDatabaseExportOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(self, create_order_result=None):
        self.create_order_result = create_order_result  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDatabaseExportOrderResponseBodyCreateOrderResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        return self


class CreateDatabaseExportOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The information about the ticket.
        self.create_order_result = create_order_result  # type: CreateDatabaseExportOrderResponseBodyCreateOrderResult
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super(CreateDatabaseExportOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateDatabaseExportOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDatabaseExportOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDatabaseExportOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDatabaseExportOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDatabaseExportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFreeLockCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(self, db_id=None, logic=None):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderRequestParamDbItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateFreeLockCorrectOrderRequestParam(TeaModel):
    def __init__(self, attachment_name=None, classify=None, db_item_list=None, exec_mode=None, exec_sql=None,
                 rollback_attachment_name=None, rollback_sql=None, rollback_sql_type=None, sql_type=None):
        # The key of the attachment that contains the SQL statements used to change data. This parameter is not supported.
        self.attachment_name = attachment_name  # type: str
        # The reason for the data change.
        self.classify = classify  # type: str
        # The databases in which you want to change data.
        self.db_item_list = db_item_list  # type: list[CreateFreeLockCorrectOrderRequestParamDbItemList]
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The data change is performed by the user who submits the ticket.
        # *   **AUTO**: The data change is automatically performed after the ticket is approved.
        # *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode  # type: str
        # The SQL statements that you want to execute to change data.
        self.exec_sql = exec_sql  # type: str
        # The key of the attachment that contains the SQL statements used to roll back the data change.
        self.rollback_attachment_name = rollback_attachment_name  # type: str
        # The SQL statements used to roll back the data change.
        self.rollback_sql = rollback_sql  # type: str
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        self.rollback_sql_type = rollback_sql_type  # type: str
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        self.sql_type = sql_type  # type: str

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateFreeLockCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateFreeLockCorrectOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateFreeLockCorrectOrderRequestParam
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateFreeLockCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key  # type: str
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the ticket.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateFreeLockCorrectOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateFreeLockCorrectOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateFreeLockCorrectOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFreeLockCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLakeHouseSpaceRequest(TeaModel):
    def __init__(self, description=None, dev_db_id=None, dw_db_type=None, mode=None, prod_db_id=None,
                 space_config=None, space_name=None, tid=None):
        # The description of the workspace.
        self.description = description  # type: str
        # The ID of the development database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
        self.dev_db_id = dev_db_id  # type: str
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        self.dw_db_type = dw_db_type  # type: str
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode. This mode is unavailable.
        # *   **1**: standard mode.
        self.mode = mode  # type: str
        # The ID of the production database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
        self.prod_db_id = prod_db_id  # type: str
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\&M.
        self.space_config = space_config  # type: str
        # The name of the workspace.
        self.space_name = space_name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLakeHouseSpaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLakeHouseSpaceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, space_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the workspace.
        self.space_id = space_id  # type: long
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLakeHouseSpaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLakeHouseSpaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLakeHouseSpaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLakeHouseSpaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLogicDatabaseRequest(TeaModel):
    def __init__(self, alias=None, database_ids=None, tid=None):
        # The alias of the logical database.
        self.alias = alias  # type: str
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        self.database_ids = database_ids  # type: list[long]
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLogicDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseShrinkRequest(TeaModel):
    def __init__(self, alias=None, database_ids_shrink=None, tid=None):
        # The alias of the logical database.
        self.alias = alias  # type: str
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        self.database_ids_shrink = database_ids_shrink  # type: str
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLogicDatabaseShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, logic_db_id=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLogicDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLogicDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLogicDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLogicDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, plugin_param=None, plugin_type=None,
                 related_user_list=None, tid=None):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The description of the ticket to be created.
        self.comment = comment  # type: str
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        self.plugin_param = plugin_param  # type: dict[str, any]
        # The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type  # type: str
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, plugin_param_shrink=None, plugin_type=None,
                 related_user_list=None, tid=None):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The description of the ticket to be created.
        self.comment = comment  # type: str
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        self.plugin_param_shrink = plugin_param_shrink  # type: str
        # The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type  # type: str
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(self, order_ids=None):
        self.order_ids = order_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOrderResponseBodyCreateOrderResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_ids is not None:
            result['OrderIds'] = self.order_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderIds') is not None:
            self.order_ids = m.get('OrderIds')
        return self


class CreateOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the ticket.
        self.create_order_result = create_order_result  # type: CreateOrderResponseBodyCreateOrderResult
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super(CreateOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProcCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(self, db_id=None, logic=None):
        self.db_id = db_id  # type: long
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProcCorrectOrderRequestParamDbItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateProcCorrectOrderRequestParam(TeaModel):
    def __init__(self, classify=None, db_item_list=None, exec_sql=None, rollback_attachment_name=None,
                 rollback_sql=None, rollback_sql_type=None):
        self.classify = classify  # type: str
        self.db_item_list = db_item_list  # type: list[CreateProcCorrectOrderRequestParamDbItemList]
        self.exec_sql = exec_sql  # type: str
        self.rollback_attachment_name = rollback_attachment_name  # type: str
        self.rollback_sql = rollback_sql  # type: str
        self.rollback_sql_type = rollback_sql_type  # type: str

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateProcCorrectOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateProcCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        return self


class CreateProcCorrectOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        self.attachment_key = attachment_key  # type: str
        self.comment = comment  # type: str
        self.param = param  # type: CreateProcCorrectOrderRequestParam
        self.related_user_list = related_user_list  # type: list[long]
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateProcCorrectOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateProcCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateProcCorrectOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        self.attachment_key = attachment_key  # type: str
        self.comment = comment  # type: str
        self.param_shrink = param_shrink  # type: str
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProcCorrectOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateProcCorrectOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        self.create_order_result = create_order_result  # type: list[long]
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProcCorrectOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProcCorrectOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateProcCorrectOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateProcCorrectOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProcCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyRequest(TeaModel):
    def __init__(self, instance_id=None, password=None, tid=None, username=None):
        # The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
        self.instance_id = instance_id  # type: long
        # The password of the database account.
        self.password = password  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The username of the database account.
        self.username = username  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProxyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class CreateProxyResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_id=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProxyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateProxyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateProxyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyAccessRequest(TeaModel):
    def __init__(self, indep_account=None, indep_password=None, proxy_id=None, tid=None, user_id=None):
        # The database account.
        self.indep_account = indep_account  # type: str
        # The password that is used to log on to the database.
        self.indep_password = indep_password  # type: str
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        self.proxy_id = proxy_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid  # type: long
        # The ID of the user. You can call the [ListUsers](https://www.alibabacloud.com/help/en/data-management-service/latest/listusers) or [GetUser](https://www.alibabacloud.com/help/en/data-management-service/latest/getuser) operation to obtain this parameter.
        self.user_id = user_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProxyAccessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.indep_password is not None:
            result['IndepPassword'] = self.indep_password
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('IndepPassword') is not None:
            self.indep_password = m.get('IndepPassword')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProxyAccessResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_access_id=None, request_id=None, success=None):
        # The error code returned to the query task.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProxyAccessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyAccessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateProxyAccessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateProxyAccessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePublishGroupTaskRequest(TeaModel):
    def __init__(self, db_id=None, logic=None, order_id=None, plan_time=None, publish_strategy=None, tid=None):
        # The ID of the database for which the schema design is executed.
        self.db_id = db_id  # type: int
        # Indicates whether the database is a logical database.
        self.logic = logic  # type: bool
        # The ID of the ticket.
        # 
        # > : You can create a schema design ticket in the DMS console. For more information, see [Design schemas](~~69711~~). You can also create a schema design ticket by calling the [CreateOrder](~~144649~~) operation and obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The time to execute the schema design ticket.
        self.plan_time = plan_time  # type: str
        # The policy to execute the schema design ticket. Valid values:
        # 
        # *   IMMEDIATELY: immediately executes the schema design ticket.
        # *   REGULARLY: executes the schema design ticket at a scheduled time.
        self.publish_strategy = publish_strategy  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePublishGroupTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreatePublishGroupTaskResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, task_id=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The ID of the job.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePublishGroupTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreatePublishGroupTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreatePublishGroupTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreatePublishGroupTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePublishGroupTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSQLReviewOrderRequestParam(TeaModel):
    def __init__(self, attachment_key_list=None, db_id=None, project_name=None):
        # The files to be reviewed. Multiple files can be reviewed at a time.
        self.attachment_key_list = attachment_key_list  # type: list[str]
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        # 
        # >  You can call this operation to query only physical databases. This operation is unavailable to query logical databases.
        self.db_id = db_id  # type: long
        # The name of the project.
        self.project_name = project_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSQLReviewOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key_list is not None:
            result['AttachmentKeyList'] = self.attachment_key_list
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKeyList') is not None:
            self.attachment_key_list = m.get('AttachmentKeyList')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class CreateSQLReviewOrderRequest(TeaModel):
    def __init__(self, comment=None, param=None, related_user_list=None, tid=None):
        # The purpose or objective of the SQL review. This reduces unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateSQLReviewOrderRequestParam
        # The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateSQLReviewOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateSQLReviewOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderShrinkRequest(TeaModel):
    def __init__(self, comment=None, param_shrink=None, related_user_list_shrink=None, tid=None):
        # The purpose or objective of the SQL review. This reduces unnecessary communication.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSQLReviewOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The result of the ticket creation task.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSQLReviewOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSQLReviewOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSQLReviewOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSQLReviewOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSQLReviewOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScenarioRequest(TeaModel):
    def __init__(self, description=None, scenario_name=None, tid=None):
        # The description of the business scenario.
        self.description = description  # type: str
        # The name of the business scenario.
        self.scenario_name = scenario_name  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateScenarioRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateScenarioResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, scenario_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the business scenario.
        self.scenario_id = scenario_id  # type: long
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateScenarioResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateScenarioResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateScenarioResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateScenarioResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStandardGroupRequest(TeaModel):
    def __init__(self, db_type=None, description=None, group_name=None, tid=None):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The description of the security rule set.
        self.description = description  # type: str
        # The name of the security rule set.
        self.group_name = group_name  # type: str
        # The ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStandardGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStandardGroupResponseBodyStandardGroup(TeaModel):
    def __init__(self, db_type=None, description=None, group_mode=None, group_name=None, last_mender_id=None):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The description of the security rule set.
        self.description = description  # type: str
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode  # type: str
        # The name of the security rule set.
        self.group_name = group_name  # type: str
        # The ID of the user who creates the security rule set.
        self.last_mender_id = last_mender_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStandardGroupResponseBodyStandardGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class CreateStandardGroupResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, standard_group=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The created security rule set.
        self.standard_group = standard_group  # type: CreateStandardGroupResponseBodyStandardGroup
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super(CreateStandardGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StandardGroup') is not None:
            temp_model = CreateStandardGroupResponseBodyStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStandardGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateStandardGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateStandardGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStructSyncOrderRequestParamSource(TeaModel):
    def __init__(self, db_id=None, db_search_name=None, logic=None, version_id=None):
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        self.db_id = db_id  # type: long
        # The name that is used to search for the database. You can call the [SearchDatabases](~~141876~~) operation to query the name of the database.
        self.db_search_name = db_search_name  # type: str
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic  # type: bool
        # The version number of the schema. The default value is the latest schema version number. For more information, see [Manage schema versions](~~202275~~).
        self.version_id = version_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStructSyncOrderRequestParamSource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParamTableInfoList(TeaModel):
    def __init__(self, source_table_name=None, target_table_name=None):
        # The name of the source table.
        self.source_table_name = source_table_name  # type: str
        # The name of the destination table.
        self.target_table_name = target_table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStructSyncOrderRequestParamTableInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class CreateStructSyncOrderRequestParamTarget(TeaModel):
    def __init__(self, db_id=None, db_search_name=None, logic=None, version_id=None):
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        self.db_id = db_id  # type: long
        # The name that is used to search for the database. You can call the [SearchDatabases](~~141876~~) operation to query the name of the database.
        self.db_search_name = db_search_name  # type: str
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic  # type: bool
        # The version number. By default, this parameter is left empty.
        # 
        # >  If you specify the schema version number of the destination database, Data Management (DMS) only compares the schemas of the two databases.
        self.version_id = version_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStructSyncOrderRequestParamTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParam(TeaModel):
    def __init__(self, ignore_error=None, source=None, table_info_list=None, target=None):
        # Specifies whether to skip an error that occurs in executing an SQL statement. Valid values:
        # 
        # *   **true**: continues to execute subsequent SQL statements if an error occurs in executing an SQL statement.
        # *   **false**: stops executing subsequent SQL statements if an error occurs in executing an SQL statement.
        self.ignore_error = ignore_error  # type: bool
        # The information about the base database.
        self.source = source  # type: CreateStructSyncOrderRequestParamSource
        # The information about the table of which you want to synchronize the schema.
        self.table_info_list = table_info_list  # type: list[CreateStructSyncOrderRequestParamTableInfoList]
        # The information about the database to which you want to synchronize the schema of a table.
        self.target = target  # type: CreateStructSyncOrderRequestParamTarget

    def validate(self):
        if self.source:
            self.source.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super(CreateStructSyncOrderRequestParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source is not None:
            result['Source'] = self.source.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target is not None:
            result['Target'] = self.target.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('Source') is not None:
            temp_model = CreateStructSyncOrderRequestParamSource()
            self.source = temp_model.from_map(m['Source'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = CreateStructSyncOrderRequestParamTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('Target') is not None:
            temp_model = CreateStructSyncOrderRequestParamTarget()
            self.target = temp_model.from_map(m['Target'])
        return self


class CreateStructSyncOrderRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param=None, related_user_list=None, tid=None):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The remarks of the ticket.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param = param  # type: CreateStructSyncOrderRequestParam
        # The IDs of the stakeholders.
        self.related_user_list = related_user_list  # type: list[long]
        # The ID of the tenant.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super(CreateStructSyncOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateStructSyncOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderShrinkRequest(TeaModel):
    def __init__(self, attachment_key=None, comment=None, param_shrink=None, related_user_list_shrink=None,
                 tid=None):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key  # type: str
        # The remarks of the ticket.
        self.comment = comment  # type: str
        # The parameters of the ticket.
        self.param_shrink = param_shrink  # type: str
        # The IDs of the stakeholders.
        self.related_user_list_shrink = related_user_list_shrink  # type: str
        # The ID of the tenant.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStructSyncOrderShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderResponseBody(TeaModel):
    def __init__(self, create_order_result=None, error_code=None, error_message=None, request_id=None, success=None):
        # The result of creating the ticket.
        self.create_order_result = create_order_result  # type: list[long]
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStructSyncOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStructSyncOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateStructSyncOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateStructSyncOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStructSyncOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskRequest(TeaModel):
    def __init__(self, dag_id=None, graph_param=None, node_content=None, node_name=None, node_output=None,
                 node_type=None, tid=None, time_variables=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param  # type: str
        # The configuration of the node.
        self.node_content = node_content  # type: str
        # The name of the node that you want to create.
        self.node_name = node_name  # type: str
        # The output variables configured for the task.
        self.node_output = node_output  # type: str
        # The type of the node that you want to create. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type  # type: str
        # The tenant ID.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The time variables configured for the node.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class CreateTaskResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, node_id=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the task node returned when the task was created.
        self.node_id = node_id  # type: long
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskFlowRequest(TeaModel):
    def __init__(self, dag_name=None, description=None, scenario_id=None, tid=None):
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The description of the task flow.
        self.description = description  # type: str
        # The ID of the scenario.
        self.scenario_id = scenario_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateTaskFlowResponseBody(TeaModel):
    def __init__(self, dag_id=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadFileJobRequest(TeaModel):
    def __init__(self, file_name=None, file_source=None, tid=None, upload_url=None):
        # The name of the attachment file.
        # 
        # >  The file name must end with .txt or .sql. For example, the file name can be test.txt or test.sql.
        self.file_name = file_name  # type: str
        # The purpose of the attachment file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source  # type: str
        # The ID of the tenant.
        # 
        # >  You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The URL of the attachment file. The URL must be an HTTP URL or an HTTPS URL.
        # 
        # >  You can upload the attachment file to an Object Storage Service (OSS) bucket and obtain the URL of the file in the OSS console. For more information, see [Share objects](~~195674~~).
        self.upload_url = upload_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadFileJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        return self


class CreateUploadFileJobResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, job_key=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The key of the task.
        # 
        # >  You can call the [GetUserUploadFileJob](~~206069~~) operation to query the progress and details of the task.
        self.job_key = job_key  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadFileJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadFileJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUploadFileJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUploadFileJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadOSSFileJobRequestUploadTarget(TeaModel):
    def __init__(self, bucket_name=None, endpoint=None, object_name=None):
        # The name of the OSS bucket.
        self.bucket_name = bucket_name  # type: str
        # The endpoint of the OSS bucket.
        self.endpoint = endpoint  # type: str
        # The name of the OSS object.
        self.object_name = object_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadOSSFileJobRequestUploadTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class CreateUploadOSSFileJobRequest(TeaModel):
    def __init__(self, file_name=None, file_source=None, tid=None, upload_target=None):
        # The name of the file.
        # 
        # > The file name must end with .txt or .sql. For example, the file name can be text.txt.
        self.file_name = file_name  # type: str
        # The purpose of the file upload task. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The information about the OSS file to be uploaded.
        self.upload_target = upload_target  # type: CreateUploadOSSFileJobRequestUploadTarget

    def validate(self):
        if self.upload_target:
            self.upload_target.validate()

    def to_map(self):
        _map = super(CreateUploadOSSFileJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target is not None:
            result['UploadTarget'] = self.upload_target.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            temp_model = CreateUploadOSSFileJobRequestUploadTarget()
            self.upload_target = temp_model.from_map(m['UploadTarget'])
        return self


class CreateUploadOSSFileJobShrinkRequest(TeaModel):
    def __init__(self, file_name=None, file_source=None, tid=None, upload_target_shrink=None):
        # The name of the file.
        # 
        # > The file name must end with .txt or .sql. For example, the file name can be text.txt.
        self.file_name = file_name  # type: str
        # The purpose of the file upload task. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The information about the OSS file to be uploaded.
        self.upload_target_shrink = upload_target_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadOSSFileJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target_shrink is not None:
            result['UploadTarget'] = self.upload_target_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            self.upload_target_shrink = m.get('UploadTarget')
        return self


class CreateUploadOSSFileJobResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, job_key=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The key of the file upload task. You can query the upload progress and task details. For more information, see [GetUserUploadFileJob](~~206069~~).
        self.job_key = job_key  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadOSSFileJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadOSSFileJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUploadOSSFileJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUploadOSSFileJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadOSSFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(self, host=None, port=None, sid=None, tid=None):
        # The endpoint of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the endpoint.
        self.host = host  # type: str
        # The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the port number.
        self.port = port  # type: int
        # The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the SID.
        self.sid = sid  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code that is returned.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLakeHouseSpaceRequest(TeaModel):
    def __init__(self, space_id=None, tid=None):
        # The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        self.space_id = space_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLakeHouseSpaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLakeHouseSpaceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLakeHouseSpaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLakeHouseSpaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLakeHouseSpaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLakeHouseSpaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLhMembersRequest(TeaModel):
    def __init__(self, member_ids=None, object_id=None, object_type=None, tid=None):
        # The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.member_ids = member_ids  # type: list[int]
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id  # type: long
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLhMembersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids is not None:
            result['MemberIds'] = self.member_ids
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersShrinkRequest(TeaModel):
    def __init__(self, member_ids_shrink=None, object_id=None, object_type=None, tid=None):
        # The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.member_ids_shrink = member_ids_shrink  # type: str
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id  # type: long
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLhMembersShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids_shrink is not None:
            result['MemberIds'] = self.member_ids_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids_shrink = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLhMembersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLhMembersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLhMembersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLhMembersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicDatabaseRequest(TeaModel):
    def __init__(self, logic_db_id=None, tid=None):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogicDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicDatabaseResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogicDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLogicDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLogicDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicTableRouteConfigRequest(TeaModel):
    def __init__(self, route_key=None, table_id=None, tid=None):
        # The unique key of the routing algorithm. You can call the [ListLogicTableRouteConfig](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictablerouteconfig) operation to query the unique key.
        self.route_key = route_key  # type: str
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogicTableRouteConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogicTableRouteConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicTableRouteConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLogicTableRouteConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLogicTableRouteConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyRequest(TeaModel):
    def __init__(self, proxy_id=None, tid=None):
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        self.proxy_id = proxy_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProxyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned to the query task.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProxyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteProxyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteProxyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyAccessRequest(TeaModel):
    def __init__(self, proxy_access_id=None, tid=None):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProxyAccessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyAccessResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned to the query task.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProxyAccessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyAccessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteProxyAccessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteProxyAccessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScenarioRequest(TeaModel):
    def __init__(self, scenario_id=None, tid=None):
        # The ID of the business scenario.
        self.scenario_id = scenario_id  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteScenarioRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteScenarioResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteScenarioResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteScenarioResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteScenarioResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteScenarioResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskRequest(TeaModel):
    def __init__(self, node_id=None, tid=None):
        # The ID of the node you want to delete.
        self.node_id = node_id  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(self, dag_id=None, id=None, node_end=None, node_from=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the task flow edge to delete.
        self.id = id  # type: long
        # The ID of the end node of the edge to delete.
        self.node_end = node_end  # type: long
        # The ID of the start node on the edge to delete.
        self.node_from = node_from  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskFlowEdgesByConditionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTaskFlowEdgesByConditionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTaskFlowEdgesByConditionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTaskFlowEdgesByConditionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserRequest(TeaModel):
    def __init__(self, tid=None, uid=None):
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long
        # The unique ID (UID) of Alibaba Cloud account to delete.
        self.uid = uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DeleteUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableUserRequest(TeaModel):
    def __init__(self, tid=None, uid=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The UID of the Alibaba Cloud account.
        self.uid = uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DisableUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DownloadDataTrackResultRequestColumnFilter(TeaModel):
    def __init__(self, between_end=None, between_start=None, column_name=None, in_list=None, operator=None,
                 value=None):
        # The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_end = between_end  # type: str
        # The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_start = between_start  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The IN list used in the filter condition.
        self.in_list = in_list  # type: list[str]
        # The type of the operator used to configure the filter condition. Valid values:
        # 
        # *   **EQUAL**: retrieves the column whose value is equal to the specified value.
        # *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
        # *   **IN**: retrieves the column whose value is in the IN list.
        # *   **BETWEEN**: retrieves the column whose value is in the specified range.
        # *   **LESS**: retrieves the column whose value is less than the specified value.
        # *   **MORE**: retrieves the column whose value is greater than the specified value.
        # *   **NOT_IN**: retrieves the column whose value is not in the IN list.
        self.operator = operator  # type: str
        # The value used in the filter condition.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DownloadDataTrackResultRequestColumnFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.between_end is not None:
            result['BetweenEnd'] = self.between_end
        if self.between_start is not None:
            result['BetweenStart'] = self.between_start
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.in_list is not None:
            result['InList'] = self.in_list
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BetweenEnd') is not None:
            self.between_end = m.get('BetweenEnd')
        if m.get('BetweenStart') is not None:
            self.between_start = m.get('BetweenStart')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('InList') is not None:
            self.in_list = m.get('InList')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DownloadDataTrackResultRequest(TeaModel):
    def __init__(self, column_filter=None, event_id_list=None, filter_end_time=None, filter_start_time=None,
                 filter_table_list=None, filter_type_list=None, order_id=None, rollback_sqltype=None, tid=None):
        # The condition to filter columns.
        self.column_filter = column_filter  # type: DownloadDataTrackResultRequestColumnFilter
        # The IDs of the events.
        self.event_id_list = event_id_list  # type: list[long]
        # The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time  # type: str
        # The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time  # type: str
        # The names of the tables for which you want to track data operations.
        self.filter_table_list = filter_table_list  # type: list[str]
        # The types of data operations that you want to track.
        self.filter_type_list = filter_type_list  # type: list[str]
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The type of the SQL statement.
        # 
        # *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
        # *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
        self.rollback_sqltype = rollback_sqltype  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.column_filter:
            self.column_filter.validate()

    def to_map(self):
        _map = super(DownloadDataTrackResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter is not None:
            result['ColumnFilter'] = self.column_filter.to_map()
        if self.event_id_list is not None:
            result['EventIdList'] = self.event_id_list
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list is not None:
            result['FilterTableList'] = self.filter_table_list
        if self.filter_type_list is not None:
            result['FilterTypeList'] = self.filter_type_list
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.rollback_sqltype is not None:
            result['RollbackSQLType'] = self.rollback_sqltype
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            temp_model = DownloadDataTrackResultRequestColumnFilter()
            self.column_filter = temp_model.from_map(m['ColumnFilter'])
        if m.get('EventIdList') is not None:
            self.event_id_list = m.get('EventIdList')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RollbackSQLType') is not None:
            self.rollback_sqltype = m.get('RollbackSQLType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DownloadDataTrackResultShrinkRequest(TeaModel):
    def __init__(self, column_filter_shrink=None, event_id_list_shrink=None, filter_end_time=None,
                 filter_start_time=None, filter_table_list_shrink=None, filter_type_list_shrink=None, order_id=None,
                 rollback_sqltype=None, tid=None):
        # The condition to filter columns.
        self.column_filter_shrink = column_filter_shrink  # type: str
        # The IDs of the events.
        self.event_id_list_shrink = event_id_list_shrink  # type: str
        # The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time  # type: str
        # The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time  # type: str
        # The names of the tables for which you want to track data operations.
        self.filter_table_list_shrink = filter_table_list_shrink  # type: str
        # The types of data operations that you want to track.
        self.filter_type_list_shrink = filter_type_list_shrink  # type: str
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The type of the SQL statement.
        # 
        # *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
        # *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
        self.rollback_sqltype = rollback_sqltype  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DownloadDataTrackResultShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter_shrink is not None:
            result['ColumnFilter'] = self.column_filter_shrink
        if self.event_id_list_shrink is not None:
            result['EventIdList'] = self.event_id_list_shrink
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list_shrink is not None:
            result['FilterTableList'] = self.filter_table_list_shrink
        if self.filter_type_list_shrink is not None:
            result['FilterTypeList'] = self.filter_type_list_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.rollback_sqltype is not None:
            result['RollbackSQLType'] = self.rollback_sqltype
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            self.column_filter_shrink = m.get('ColumnFilter')
        if m.get('EventIdList') is not None:
            self.event_id_list_shrink = m.get('EventIdList')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list_shrink = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list_shrink = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RollbackSQLType') is not None:
            self.rollback_sqltype = m.get('RollbackSQLType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DownloadDataTrackResultResponseBody(TeaModel):
    def __init__(self, download_key_id=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the download key, which is used to download the parsing result of the data tracking task.
        self.download_key_id = download_key_id  # type: str
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DownloadDataTrackResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_key_id is not None:
            result['DownloadKeyId'] = self.download_key_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadKeyId') is not None:
            self.download_key_id = m.get('DownloadKeyId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DownloadDataTrackResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DownloadDataTrackResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DownloadDataTrackResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DownloadDataTrackResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditLogicDatabaseRequest(TeaModel):
    def __init__(self, alias=None, database_ids=None, logic_db_id=None, tid=None):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        self.alias = alias  # type: str
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        self.database_ids = database_ids  # type: list[long]
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(EditLogicDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseShrinkRequest(TeaModel):
    def __init__(self, alias=None, database_ids_shrink=None, logic_db_id=None, tid=None):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        self.alias = alias  # type: str
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        self.database_ids_shrink = database_ids_shrink  # type: str
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(EditLogicDatabaseShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EditLogicDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EditLogicDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EditLogicDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EditLogicDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableUserRequest(TeaModel):
    def __init__(self, tid=None, uid=None):
        # The ID of the tenant.
        # 
        # >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
        self.tid = tid  # type: long
        # The UID of the Alibaba Cloud account.
        self.uid = uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class EnableUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataCorrectRequest(TeaModel):
    def __init__(self, action_detail=None, order_id=None, tid=None):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail = action_detail  # type: dict[str, any]
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataCorrectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectShrinkRequest(TeaModel):
    def __init__(self, action_detail_shrink=None, order_id=None, tid=None):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail_shrink = action_detail_shrink  # type: str
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataCorrectShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataCorrectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataCorrectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExecuteDataCorrectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExecuteDataCorrectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataCorrectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataExportRequest(TeaModel):
    def __init__(self, action_detail=None, order_id=None, tid=None):
        # The parameters that are required to perform the operation:
        # 
        # ```json
        # {
        #    "fileType": "CSV", // The format of the exported file.
        #    "encoding": "" // The encoding format.
        #  }
        # ```
        self.action_detail = action_detail  # type: dict[str, any]
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataExportRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportShrinkRequest(TeaModel):
    def __init__(self, action_detail_shrink=None, order_id=None, tid=None):
        # The parameters that are required to perform the operation:
        # 
        # ```json
        # {
        #    "fileType": "CSV", // The format of the exported file.
        #    "encoding": "" // The encoding format.
        #  }
        # ```
        self.action_detail_shrink = action_detail_shrink  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataExportShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteDataExportResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataExportResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExecuteDataExportResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExecuteDataExportResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataExportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteScriptRequest(TeaModel):
    def __init__(self, db_id=None, logic=None, script=None, tid=None):
        # The ID of the database.
        # 
        # >  This parameter is equivalent to the DatabaseId parameter in the SearchDatabase, ListDatabases, and GetDatabase operations. You can call one of these operations to obtain the required database ID. For more information, see [SearchDatabase](~~141876~~), [ListDatabases](~~141873~~), and [GetDatabase](~~141869~~).
        self.db_id = db_id  # type: int
        # Specifies whether the database is a logical database.
        self.logic = logic  # type: bool
        # The SQL statements to be executed. Data query language (DQL) statements, data definition language (DDL) statements, and data manipulation language (DML) statements are supported. The control mode of the instance that you want to query determines whether you can execute DDL and DML statements.
        self.script = script  # type: str
        # The ID of the tenant.
        # 
        # >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteScriptRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.script is not None:
            result['Script'] = self.script
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteScriptResponseBodyResults(TeaModel):
    def __init__(self, column_names=None, message=None, row_count=None, rows=None, success=None):
        # The fields that are queried after the SQL statement is executed.
        self.column_names = column_names  # type: list[str]
        # The error message that is returned if the SQL statement fails to be executed. For example, an error message is returned because the SQL statement is invalid.
        self.message = message  # type: str
        # The total number of entries that are returned.
        self.row_count = row_count  # type: long
        # The rows that are queried after the SQL statement is executed.
        self.rows = rows  # type: list[dict[str, any]]
        # Indicates whether the SQL statement is executed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteScriptResponseBodyResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_names is not None:
            result['ColumnNames'] = self.column_names
        if self.message is not None:
            result['Message'] = self.message
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.rows is not None:
            result['Rows'] = self.rows
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnNames') is not None:
            self.column_names = m.get('ColumnNames')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Rows') is not None:
            self.rows = m.get('Rows')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, results=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message about the gateway.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The results of the SQL statements that are executed, in the format of an array. Each entry in the array indicates the result of an SQL statement.
        self.results = results  # type: list[ExecuteScriptResponseBodyResults]
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ExecuteScriptResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = ExecuteScriptResponseBodyResults()
                self.results.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExecuteScriptResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExecuteScriptResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteStructSyncRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteStructSyncRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteStructSyncResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecuteStructSyncResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteStructSyncResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExecuteStructSyncResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExecuteStructSyncResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteStructSyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApprovalDetailRequest(TeaModel):
    def __init__(self, tid=None, workflow_instance_id=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
        self.workflow_instance_id = workflow_instance_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetApprovalDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler(TeaModel):
    def __init__(self, id=None, nick_name=None):
        # The ID of the user.
        self.id = id  # type: long
        # The nickname of the user.
        self.nick_name = nick_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers(TeaModel):
    def __init__(self, current_handler=None):
        self.current_handler = current_handler  # type: list[GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler]

    def validate(self):
        if self.current_handler:
            for k in self.current_handler:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentHandler'] = []
        if self.current_handler is not None:
            for k in self.current_handler:
                result['CurrentHandler'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.current_handler = []
        if m.get('CurrentHandler') is not None:
            for k in m.get('CurrentHandler'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler()
                self.current_handler.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetailReasonList(TeaModel):
    def __init__(self, reasons=None):
        self.reasons = reasons  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailReasonList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reasons is not None:
            result['Reasons'] = self.reasons
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Reasons') is not None:
            self.reasons = m.get('Reasons')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList(TeaModel):
    def __init__(self, audit_user_ids=None):
        self.audit_user_ids = audit_user_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_ids is not None:
            result['AuditUserIds'] = self.audit_user_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditUserIds') is not None:
            self.audit_user_ids = m.get('AuditUserIds')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode(TeaModel):
    def __init__(self, audit_user_id_list=None, node_name=None, operate_comment=None, operate_time=None,
                 operator_id=None, workflow_ins_code=None):
        # The IDs of the approvers.
        self.audit_user_id_list = audit_user_id_list  # type: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList
        # The name of the approval node.
        self.node_name = node_name  # type: str
        # The remarks of the approval.
        self.operate_comment = operate_comment  # type: str
        # The time when the ticket was submitted.
        self.operate_time = operate_time  # type: str
        # The ID of the user who submitted the ticket.
        self.operator_id = operator_id  # type: long
        # The approval status of the ticket. Valid values:
        # 
        # *   **START**: The ticket was submitted.
        # *   **ERROR**: An error occurred.
        # *   **AUDITING**: The ticket is being reviewed.
        # *   **REJECT**: The ticket was rejected.
        # *   **CANCEL**: The ticket was revoked.
        # *   **APPROVED**: The ticket was approved.
        self.workflow_ins_code = workflow_ins_code  # type: str

    def validate(self):
        if self.audit_user_id_list:
            self.audit_user_id_list.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_id_list is not None:
            result['AuditUserIdList'] = self.audit_user_id_list.to_map()
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.operate_comment is not None:
            result['OperateComment'] = self.operate_comment
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditUserIdList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList()
            self.audit_user_id_list = temp_model.from_map(m['AuditUserIdList'])
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('OperateComment') is not None:
            self.operate_comment = m.get('OperateComment')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes(TeaModel):
    def __init__(self, workflow_node=None):
        self.workflow_node = workflow_node  # type: list[GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode]

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetail(TeaModel):
    def __init__(self, audit_id=None, create_time=None, current_handlers=None, description=None, order_id=None,
                 order_type=None, reason_list=None, template_id=None, title=None, workflow_ins_code=None, workflow_nodes=None):
        # The ID of the approval process.
        self.audit_id = audit_id  # type: long
        # The time when the approval process was created.
        self.create_time = create_time  # type: str
        # The information about the approver.
        self.current_handlers = current_handlers  # type: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers
        # The description of the approval process.
        self.description = description  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The type of the ticket. Valid values:
        # 
        # *   **NDDL**: a schema design ticket
        # *   **DATA_TRACK**: a data tracking ticket
        # *   **TABLE_SYNC**: a table synchronization ticket
        # *   **PERM_APPLY**: a permission application ticket
        # *   **DATA_EXPORT**: a data export ticket
        # *   **DATA_CORRECT**: a data change ticket
        # *   **OWNER_APPLY**: an owner role application ticket
        # *   **SENSITIVITY**: a column sensitivity level change ticket
        self.order_type = order_type  # type: str
        # The reasons for the approval.
        self.reason_list = reason_list  # type: GetApprovalDetailResponseBodyApprovalDetailReasonList
        # The ID of the workflow template.
        self.template_id = template_id  # type: long
        # The title of the approval process.
        self.title = title  # type: str
        # The approval status of the ticket. Valid values:
        # 
        # *   **AUDITING**: The ticket is being reviewed.
        # *   **REJECT**: The ticket was rejected.
        # *   **CANCEL**: The ticket was revoked.
        # *   **APPROVED**: The ticket was approved.
        # 
        # > An approval process contains multiple approval nodes, and this parameter is returned for each approval node.
        self.workflow_ins_code = workflow_ins_code  # type: str
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes  # type: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes

    def validate(self):
        if self.current_handlers:
            self.current_handlers.validate()
        if self.reason_list:
            self.reason_list.validate()
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponseBodyApprovalDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_id is not None:
            result['AuditId'] = self.audit_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_handlers is not None:
            result['CurrentHandlers'] = self.current_handlers.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.reason_list is not None:
            result['ReasonList'] = self.reason_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditId') is not None:
            self.audit_id = m.get('AuditId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentHandlers') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers()
            self.current_handlers = temp_model.from_map(m['CurrentHandlers'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ReasonList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailReasonList()
            self.reason_list = temp_model.from_map(m['ReasonList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        if m.get('WorkflowNodes') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class GetApprovalDetailResponseBody(TeaModel):
    def __init__(self, approval_detail=None, error_code=None, error_message=None, request_id=None, success=None):
        # The approval details of the ticket.
        self.approval_detail = approval_detail  # type: GetApprovalDetailResponseBodyApprovalDetail
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.approval_detail:
            self.approval_detail.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_detail is not None:
            result['ApprovalDetail'] = self.approval_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApprovalDetail') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetail()
            self.approval_detail = temp_model.from_map(m['ApprovalDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetApprovalDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetApprovalDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetApprovalDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApprovalDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuthorityTemplateRequest(TeaModel):
    def __init__(self, template_id=None, tid=None):
        # The ID of the permission template.
        self.template_id = template_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuthorityTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem(TeaModel):
    def __init__(self, attribute=None, db_id=None, instance_id=None, item_id=None, modifier_id=None,
                 resource_type=None, table_name=None, template_id=None):
        # Other information. For example, you can add the logon permission on an instance to the permission template.
        self.attribute = attribute  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # The ID of the resource.
        self.item_id = item_id  # type: long
        # The ID of the user who modified the resource.
        self.modifier_id = modifier_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   **INSTANCE**: instance
        # *   **LOGIC_DB**: logical database
        # *   **META_DB**: physical database
        # *   **LOGIC_TABLE**: logical table
        # *   **SINGLE_TABLE**: physical table
        self.resource_type = resource_type  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList(TeaModel):
    def __init__(self, authority_template_item=None):
        self.authority_template_item = authority_template_item  # type: list[GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem]

    def validate(self):
        if self.authority_template_item:
            for k in self.authority_template_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorityTemplateItem'] = []
        if self.authority_template_item is not None:
            for k in self.authority_template_item:
                result['AuthorityTemplateItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.authority_template_item = []
        if m.get('AuthorityTemplateItem') is not None:
            for k in m.get('AuthorityTemplateItem'):
                temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem()
                self.authority_template_item.append(temp_model.from_map(k))
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(self, authority_template_item_list=None, create_time=None, creator_id=None, description=None,
                 name=None, template_id=None):
        # The resource information in the permission template.
        self.authority_template_item_list = authority_template_item_list  # type: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList
        # The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.create_time = create_time  # type: str
        # The ID of the user who created the permission template.
        self.creator_id = creator_id  # type: long
        # The description of the permission template.
        self.description = description  # type: str
        # The name of the permission template.
        self.name = name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long

    def validate(self):
        if self.authority_template_item_list:
            self.authority_template_item_list.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateResponseBodyAuthorityTemplateView, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_item_list is not None:
            result['AuthorityTemplateItemList'] = self.authority_template_item_list.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorityTemplateItemList') is not None:
            temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList()
            self.authority_template_item_list = temp_model.from_map(m['AuthorityTemplateItemList'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateResponseBody(TeaModel):
    def __init__(self, authority_template_view=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the permission template.
        self.authority_template_view = authority_template_view  # type: GetAuthorityTemplateResponseBodyAuthorityTemplateView
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAuthorityTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAuthorityTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuthorityTemplateItemRequest(TeaModel):
    def __init__(self, template_id=None, tid=None):
        # The ID of the permission template.
        self.template_id = template_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuthorityTemplateItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem(TeaModel):
    def __init__(self, attribute=None, db_id=None, instance_id=None, item_id=None, modifier_id=None,
                 resource_type=None, table_name=None, template_id=None):
        # The additional information. For example, permissions to log on to an instance are added to the permission template.
        self.attribute = attribute  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # The ID of the resource.
        self.item_id = item_id  # type: long
        # The ID of the user who modifies the resource.
        self.modifier_id = modifier_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   **INSTANCE**: instance
        # *   **LOGIC_DB**: logical database
        # *   **META_DB**: physical database
        # *   **LOGIC_TABLE**: logical table
        # *   **LOGIC_TABLE**: physical table
        self.resource_type = resource_type  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList(TeaModel):
    def __init__(self, authority_template_item=None):
        self.authority_template_item = authority_template_item  # type: list[GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem]

    def validate(self):
        if self.authority_template_item:
            for k in self.authority_template_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorityTemplateItem'] = []
        if self.authority_template_item is not None:
            for k in self.authority_template_item:
                result['AuthorityTemplateItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.authority_template_item = []
        if m.get('AuthorityTemplateItem') is not None:
            for k in m.get('AuthorityTemplateItem'):
                temp_model = GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem()
                self.authority_template_item.append(temp_model.from_map(k))
        return self


class GetAuthorityTemplateItemResponseBody(TeaModel):
    def __init__(self, authority_template_item_list=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The permission templates.
        self.authority_template_item_list = authority_template_item_list  # type: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.authority_template_item_list:
            self.authority_template_item_list.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_item_list is not None:
            result['AuthorityTemplateItemList'] = self.authority_template_item_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorityTemplateItemList') is not None:
            temp_model = GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList()
            self.authority_template_item_list = temp_model.from_map(m['AuthorityTemplateItemList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAuthorityTemplateItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAuthorityTemplateItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAuthorityTemplateItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuthorityTemplateItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClassificationTemplateRequest(TeaModel):
    def __init__(self, instance_id=None, tid=None):
        self.instance_id = instance_id  # type: long
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClassificationTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetClassificationTemplateResponseBodyClassificationResourceTemplateMap(TeaModel):
    def __init__(self, resource_id=None, resource_type=None, template_id=None, template_type=None):
        self.resource_id = resource_id  # type: long
        self.resource_type = resource_type  # type: str
        self.template_id = template_id  # type: long
        self.template_type = template_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClassificationTemplateResponseBodyClassificationResourceTemplateMap, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class GetClassificationTemplateResponseBody(TeaModel):
    def __init__(self, classification_resource_template_map=None, error_code=None, error_message=None,
                 request_id=None, success=None):
        self.classification_resource_template_map = classification_resource_template_map  # type: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.classification_resource_template_map:
            self.classification_resource_template_map.validate()

    def to_map(self):
        _map = super(GetClassificationTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classification_resource_template_map is not None:
            result['ClassificationResourceTemplateMap'] = self.classification_resource_template_map.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClassificationResourceTemplateMap') is not None:
            temp_model = GetClassificationTemplateResponseBodyClassificationResourceTemplateMap()
            self.classification_resource_template_map = temp_model.from_map(m['ClassificationResourceTemplateMap'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetClassificationTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetClassificationTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetClassificationTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClassificationTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTaskSQLJobLogRequest(TeaModel):
    def __init__(self, job_id=None, tid=None):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the ID of the SQL task.
        self.job_id = job_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDBTaskSQLJobLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTaskSQLJobLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, log=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The log that records the scheduling details.
        self.log = log  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDBTaskSQLJobLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.log is not None:
            result['Log'] = self.log
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTaskSQLJobLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDBTaskSQLJobLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDBTaskSQLJobLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTaskSQLJobLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTopologyRequest(TeaModel):
    def __init__(self, logic_db_id=None, tid=None):
        # The ID of the logical database.
        # 
        # > You can call the [ListLogicDatabases](~~141874~~) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDBTopologyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList(TeaModel):
    def __init__(self, catalog_name=None, db_id=None, db_type=None, env_type=None, instance_id=None,
                 instance_resource_id=None, instance_source=None, region_id=None, schema_name=None, search_name=None):
        # The name of the catalog to which the database belongs.
        # 
        # > If the database is a PostgreSQL database, the value of this parameter is the name of the database.
        self.catalog_name = catalog_name  # type: str
        # The ID of the logical database.
        self.db_id = db_id  # type: long
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the logical database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: UAT environment
        # *   **pet**: stress testing environment
        # *   **stag**: staging environment
        # 
        # > For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The ID of the instance in which the logical database resides.
        self.instance_id = instance_id  # type: long
        # The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
        # 
        # *   If the value of the InstanceSource parameter is RDS, the ID of an ApsaraDB RDS instance is returned.
        # *   If the value of the InstanceSource parameter is ECS_OWN, the ID of a self-managed database that is hosted on an Elastic Compute Service (ECS) instance is returned.
        # *   If the value of the InstanceSource parameter is PUBLIC_OWN, an empty string is returned.
        # *   If the value of the InstanceSource parameter is VPC_ID, the ID of a self-managed database instance in a virtual private cloud (VPC) that is connected over Express Connect circuits is returned.
        # *   If the value of the InstanceSource parameter is GATEWAY, the ID of a database instance connected by using a database gateway is returned.
        self.instance_resource_id = instance_resource_id  # type: str
        # The type of the database instance. Valid values:
        # 
        # *   **RDS**: an ApsaraDB RDS instance.
        # *   **ECS_OWN**: a self-managed database that is hosted on an ECS instance.
        # *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
        # *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
        # *   **GATEWAY**: a database instance connected by using a database gateway.
        self.instance_source = instance_source  # type: str
        # The ID of the region in which the instance resides.
        self.region_id = region_id  # type: str
        # The name of the logical database.
        # 
        # > If the database is a PostgreSQL database, the value of this parameter is the name of the database schema.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(self, alias=None, dbtopology_info_list=None, db_type=None, env_type=None, logic_db_id=None,
                 logic_db_name=None, search_name=None):
        # The alias of the logical database.
        self.alias = alias  # type: str
        # The topologies of the physical database shards.
        self.dbtopology_info_list = dbtopology_info_list  # type: list[GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList]
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the logical database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: staging environment
        # 
        # > For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The ID of the logical database.
        self.logic_db_id = logic_db_id  # type: long
        # The name of the logical database.
        self.logic_db_name = logic_db_name  # type: str
        # The name that is used to search for the logical database.
        self.search_name = search_name  # type: str

    def validate(self):
        if self.dbtopology_info_list:
            for k in self.dbtopology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDBTopologyResponseBodyDBTopology, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['DBTopologyInfoList'] = []
        if self.dbtopology_info_list is not None:
            for k in self.dbtopology_info_list:
                result['DBTopologyInfoList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.logic_db_name is not None:
            result['LogicDbName'] = self.logic_db_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.dbtopology_info_list = []
        if m.get('DBTopologyInfoList') is not None:
            for k in m.get('DBTopologyInfoList'):
                temp_model = GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList()
                self.dbtopology_info_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('LogicDbName') is not None:
            self.logic_db_name = m.get('LogicDbName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBody(TeaModel):
    def __init__(self, dbtopology=None, error_code=None, error_message=None, request_id=None, success=None):
        # The topology of the logical database.
        self.dbtopology = dbtopology  # type: GetDBTopologyResponseBodyDBTopology
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super(GetDBTopologyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTopologyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDBTopologyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDBTopologyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataArchiveCountRequest(TeaModel):
    def __init__(self, order_result_type=None, plugin_type=None, search_date_type=None, tid=None):
        self.order_result_type = order_result_type  # type: str
        self.plugin_type = plugin_type  # type: str
        self.search_date_type = search_date_type  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_result_type is not None:
            result['OrderResultType'] = self.order_result_type
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.search_date_type is not None:
            result['SearchDateType'] = self.search_date_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderResultType') is not None:
            self.order_result_type = m.get('OrderResultType')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('SearchDateType') is not None:
            self.search_date_type = m.get('SearchDateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataArchiveCountResponseBodyData(TeaModel):
    def __init__(self, fail_count=None, processing_count=None, success_count=None, total_count=None):
        self.fail_count = fail_count  # type: long
        self.processing_count = processing_count  # type: long
        self.success_count = success_count  # type: long
        self.total_count = total_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveCountResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.processing_count is not None:
            result['ProcessingCount'] = self.processing_count
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ProcessingCount') is not None:
            self.processing_count = m.get('ProcessingCount')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDataArchiveCountResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None, success=None):
        self.data = data  # type: GetDataArchiveCountResponseBodyData
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetDataArchiveCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDataArchiveCountResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataArchiveCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataArchiveCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataArchiveCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataArchiveCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataArchiveOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        self.order_id = order_id  # type: long
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo(TeaModel):
    def __init__(self, creator_id=None, cron_begin_date=None, cron_end_date=None, cron_trigger=None, dwdevelop=None,
                 dag_name=None, dag_owner_id=None, deploy_id=None, description=None, edit_dag_id=None, gmt_create=None,
                 gmt_modified=None, id=None, is_public=None, legacy=None, system=None, tenant_id=None, trigger_once=None):
        self.creator_id = creator_id  # type: str
        self.cron_begin_date = cron_begin_date  # type: str
        self.cron_end_date = cron_end_date  # type: str
        self.cron_trigger = cron_trigger  # type: bool
        self.dwdevelop = dwdevelop  # type: bool
        self.dag_name = dag_name  # type: str
        self.dag_owner_id = dag_owner_id  # type: str
        self.deploy_id = deploy_id  # type: long
        self.description = description  # type: str
        self.edit_dag_id = edit_dag_id  # type: long
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.id = id  # type: long
        self.is_public = is_public  # type: long
        self.legacy = legacy  # type: bool
        self.system = system  # type: bool
        self.tenant_id = tenant_id  # type: str
        self.trigger_once = trigger_once  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_trigger is not None:
            result['CronTrigger'] = self.cron_trigger
        if self.dwdevelop is not None:
            result['DWDevelop'] = self.dwdevelop
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.description is not None:
            result['Description'] = self.description
        if self.edit_dag_id is not None:
            result['EditDagId'] = self.edit_dag_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.is_public is not None:
            result['IsPublic'] = self.is_public
        if self.legacy is not None:
            result['Legacy'] = self.legacy
        if self.system is not None:
            result['System'] = self.system
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger_once is not None:
            result['TriggerOnce'] = self.trigger_once
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronTrigger') is not None:
            self.cron_trigger = m.get('CronTrigger')
        if m.get('DWDevelop') is not None:
            self.dwdevelop = m.get('DWDevelop')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditDagId') is not None:
            self.edit_dag_id = m.get('EditDagId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsPublic') is not None:
            self.is_public = m.get('IsPublic')
        if m.get('Legacy') is not None:
            self.legacy = m.get('Legacy')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TriggerOnce') is not None:
            self.trigger_once = m.get('TriggerOnce')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup(TeaModel):
    def __init__(self, db_type=None, description=None, free_or_stable=None, gmt_create=None, gmt_modified=None,
                 group_mode=None, group_name=None, id=None, last_mender_id=None):
        self.db_type = db_type  # type: str
        self.description = description  # type: str
        self.free_or_stable = free_or_stable  # type: bool
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.group_mode = group_mode  # type: str
        self.group_name = group_name  # type: str
        self.id = id  # type: long
        self.last_mender_id = last_mender_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.free_or_stable is not None:
            result['FreeOrStable'] = self.free_or_stable
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FreeOrStable') is not None:
            self.free_or_stable = m.get('FreeOrStable')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo(TeaModel):
    def __init__(self, alias=None, alter_timeout=None, asset_control=None, catalog_name=None, cluster_node=None,
                 db_id=None, db_type=None, dba_id=None, dba_name=None, description=None, encoding=None, env_type=None,
                 follow=None, host=None, idc=None, idc_title=None, instance_id=None, instance_source=None,
                 last_sync_time=None, level=None, logic=None, owner_ids=None, owner_names=None, port=None, schema_name=None,
                 search_name=None, standard_group=None, state=None, table_count=None, tns_name=None, unit_type=None):
        self.alias = alias  # type: str
        self.alter_timeout = alter_timeout  # type: long
        self.asset_control = asset_control  # type: bool
        self.catalog_name = catalog_name  # type: str
        self.cluster_node = cluster_node  # type: str
        self.db_id = db_id  # type: long
        self.db_type = db_type  # type: str
        self.dba_id = dba_id  # type: long
        self.dba_name = dba_name  # type: str
        self.description = description  # type: str
        self.encoding = encoding  # type: str
        self.env_type = env_type  # type: str
        self.follow = follow  # type: bool
        self.host = host  # type: str
        self.idc = idc  # type: str
        self.idc_title = idc_title  # type: str
        self.instance_id = instance_id  # type: long
        self.instance_source = instance_source  # type: str
        self.last_sync_time = last_sync_time  # type: str
        self.level = level  # type: str
        self.logic = logic  # type: bool
        self.owner_ids = owner_ids  # type: list[long]
        self.owner_names = owner_names  # type: list[str]
        self.port = port  # type: long
        self.schema_name = schema_name  # type: str
        self.search_name = search_name  # type: str
        self.standard_group = standard_group  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup
        self.state = state  # type: str
        self.table_count = table_count  # type: long
        self.tns_name = tns_name  # type: str
        self.unit_type = unit_type  # type: str

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.alter_timeout is not None:
            result['AlterTimeout'] = self.alter_timeout
        if self.asset_control is not None:
            result['AssetControl'] = self.asset_control
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.cluster_node is not None:
            result['ClusterNode'] = self.cluster_node
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.follow is not None:
            result['Follow'] = self.follow
        if self.host is not None:
            result['Host'] = self.host
        if self.idc is not None:
            result['Idc'] = self.idc
        if self.idc_title is not None:
            result['IdcTitle'] = self.idc_title
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.last_sync_time is not None:
            result['LastSyncTime'] = self.last_sync_time
        if self.level is not None:
            result['Level'] = self.level
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.tns_name is not None:
            result['TnsName'] = self.tns_name
        if self.unit_type is not None:
            result['UnitType'] = self.unit_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('AlterTimeout') is not None:
            self.alter_timeout = m.get('AlterTimeout')
        if m.get('AssetControl') is not None:
            self.asset_control = m.get('AssetControl')
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('ClusterNode') is not None:
            self.cluster_node = m.get('ClusterNode')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Follow') is not None:
            self.follow = m.get('Follow')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Idc') is not None:
            self.idc = m.get('Idc')
        if m.get('IdcTitle') is not None:
            self.idc_title = m.get('IdcTitle')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('LastSyncTime') is not None:
            self.last_sync_time = m.get('LastSyncTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StandardGroup') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TnsName') is not None:
            self.tns_name = m.get('TnsName')
        if m.get('UnitType') is not None:
            self.unit_type = m.get('UnitType')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances(TeaModel):
    def __init__(self, business_time=None, dag_id=None, end_time=None, gmt_create=None, gmt_modified=None,
                 history_dag_id=None, id=None, last_running_context=None, msg=None, status=None, tenant_id=None, trigger_type=None,
                 version=None):
        self.business_time = business_time  # type: str
        self.dag_id = dag_id  # type: long
        self.end_time = end_time  # type: str
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.history_dag_id = history_dag_id  # type: long
        self.id = id  # type: long
        self.last_running_context = last_running_context  # type: str
        self.msg = msg  # type: str
        self.status = status  # type: long
        self.tenant_id = tenant_id  # type: str
        self.trigger_type = trigger_type  # type: long
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.last_running_context is not None:
            result['LastRunningContext'] = self.last_running_context
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastRunningContext') is not None:
            self.last_running_context = m.get('LastRunningContext')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult(TeaModel):
    def __init__(self, cron_fire_type=None):
        self.cron_fire_type = cron_fire_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_fire_type is not None:
            result['CronFireType'] = self.cron_fire_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronFireType') is not None:
            self.cron_fire_type = m.get('CronFireType')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData(TeaModel):
    def __init__(self, dag_info=None, db_base_info=None, instance_total=None, instances=None,
                 next_fire_time_result=None, page_index=None, page_size=None, temp_table_name_map=None):
        self.dag_info = dag_info  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo
        self.db_base_info = db_base_info  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo
        self.instance_total = instance_total  # type: long
        self.instances = instances  # type: list[GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances]
        self.next_fire_time_result = next_fire_time_result  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult
        self.page_index = page_index  # type: long
        self.page_size = page_size  # type: long
        self.temp_table_name_map = temp_table_name_map  # type: dict[str, any]

    def validate(self):
        if self.dag_info:
            self.dag_info.validate()
        if self.db_base_info:
            self.db_base_info.validate()
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.next_fire_time_result:
            self.next_fire_time_result.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_info is not None:
            result['DagInfo'] = self.dag_info.to_map()
        if self.db_base_info is not None:
            result['DbBaseInfo'] = self.db_base_info.to_map()
        if self.instance_total is not None:
            result['InstanceTotal'] = self.instance_total
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.next_fire_time_result is not None:
            result['NextFireTimeResult'] = self.next_fire_time_result.to_map()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.temp_table_name_map is not None:
            result['TempTableNameMap'] = self.temp_table_name_map
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagInfo') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo()
            self.dag_info = temp_model.from_map(m['DagInfo'])
        if m.get('DbBaseInfo') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo()
            self.db_base_info = temp_model.from_map(m['DbBaseInfo'])
        if m.get('InstanceTotal') is not None:
            self.instance_total = m.get('InstanceTotal')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('NextFireTimeResult') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult()
            self.next_fire_time_result = temp_model.from_map(m['NextFireTimeResult'])
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TempTableNameMap') is not None:
            self.temp_table_name_map = m.get('TempTableNameMap')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes(TeaModel):
    def __init__(self, table_name=None, table_where=None):
        self.table_name = table_name  # type: str
        self.table_where = table_where  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_where is not None:
            result['TableWhere'] = self.table_where
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableWhere') is not None:
            self.table_where = m.get('TableWhere')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam(TeaModel):
    def __init__(self, archive_method=None, db_schema=None, logic=None, order_after=None, run_method=None,
                 source_database_id=None, table_includes=None, table_mapping=None, target_instance_id=None, variables=None):
        self.archive_method = archive_method  # type: str
        self.db_schema = db_schema  # type: str
        self.logic = logic  # type: bool
        self.order_after = order_after  # type: list[str]
        self.run_method = run_method  # type: str
        self.source_database_id = source_database_id  # type: long
        self.table_includes = table_includes  # type: list[GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes]
        self.table_mapping = table_mapping  # type: list[str]
        self.target_instance_id = target_instance_id  # type: str
        self.variables = variables  # type: list[str]

    def validate(self):
        if self.table_includes:
            for k in self.table_includes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_method is not None:
            result['ArchiveMethod'] = self.archive_method
        if self.db_schema is not None:
            result['DbSchema'] = self.db_schema
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_after is not None:
            result['OrderAfter'] = self.order_after
        if self.run_method is not None:
            result['RunMethod'] = self.run_method
        if self.source_database_id is not None:
            result['SourceDatabaseId'] = self.source_database_id
        result['TableIncludes'] = []
        if self.table_includes is not None:
            for k in self.table_includes:
                result['TableIncludes'].append(k.to_map() if k else None)
        if self.table_mapping is not None:
            result['TableMapping'] = self.table_mapping
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.variables is not None:
            result['Variables'] = self.variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ArchiveMethod') is not None:
            self.archive_method = m.get('ArchiveMethod')
        if m.get('DbSchema') is not None:
            self.db_schema = m.get('DbSchema')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderAfter') is not None:
            self.order_after = m.get('OrderAfter')
        if m.get('RunMethod') is not None:
            self.run_method = m.get('RunMethod')
        if m.get('SourceDatabaseId') is not None:
            self.source_database_id = m.get('SourceDatabaseId')
        self.table_includes = []
        if m.get('TableIncludes') is not None:
            for k in m.get('TableIncludes'):
                temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes()
                self.table_includes.append(temp_model.from_map(k))
        if m.get('TableMapping') is not None:
            self.table_mapping = m.get('TableMapping')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('Variables') is not None:
            self.variables = m.get('Variables')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail(TeaModel):
    def __init__(self, comment=None, committer=None, committer_id=None, gmt_create=None, gmt_modified=None, id=None,
                 plugin_extra_data=None, plugin_param=None, plugin_type=None, related_user_list=None, related_user_nick_list=None,
                 status_code=None, status_desc=None, workflow_instance_id=None, workflow_status_desc=None):
        self.comment = comment  # type: str
        self.committer = committer  # type: str
        self.committer_id = committer_id  # type: long
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.id = id  # type: long
        self.plugin_extra_data = plugin_extra_data  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData
        self.plugin_param = plugin_param  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam
        self.plugin_type = plugin_type  # type: str
        self.related_user_list = related_user_list  # type: list[long]
        self.related_user_nick_list = related_user_nick_list  # type: list[str]
        self.status_code = status_code  # type: str
        self.status_desc = status_desc  # type: str
        self.workflow_instance_id = workflow_instance_id  # type: long
        self.workflow_status_desc = workflow_status_desc  # type: str

    def validate(self):
        if self.plugin_extra_data:
            self.plugin_extra_data.validate()
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.plugin_extra_data is not None:
            result['PluginExtraData'] = self.plugin_extra_data.to_map()
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.related_user_nick_list is not None:
            result['RelatedUserNickList'] = self.related_user_nick_list
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PluginExtraData') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData()
            self.plugin_extra_data = temp_model.from_map(m['PluginExtraData'])
        if m.get('PluginParam') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('RelatedUserNickList') is not None:
            self.related_user_nick_list = m.get('RelatedUserNickList')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetDataArchiveOrderDetailResponseBody(TeaModel):
    def __init__(self, data_archive_order_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None, trace_id=None):
        self.data_archive_order_detail = data_archive_order_detail  # type: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.trace_id = trace_id  # type: str

    def validate(self):
        if self.data_archive_order_detail:
            self.data_archive_order_detail.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_archive_order_detail is not None:
            result['DataArchiveOrderDetail'] = self.data_archive_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataArchiveOrderDetail') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail()
            self.data_archive_order_detail = temp_model.from_map(m['DataArchiveOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetDataArchiveOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataArchiveOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataArchiveOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectBackupFilesRequest(TeaModel):
    def __init__(self, action_detail=None, order_id=None, tid=None):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail = action_detail  # type: dict[str, any]
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectBackupFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesShrinkRequest(TeaModel):
    def __init__(self, action_detail_shrink=None, order_id=None, tid=None):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail_shrink = action_detail_shrink  # type: str
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectBackupFilesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles(TeaModel):
    def __init__(self, file_url=None):
        self.file_url = file_url  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetDataCorrectBackupFilesResponseBody(TeaModel):
    def __init__(self, data_correct_backup_files=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The download URL of the backup file for the ticket.
        self.data_correct_backup_files = data_correct_backup_files  # type: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.data_correct_backup_files:
            self.data_correct_backup_files.validate()

    def to_map(self):
        _map = super(GetDataCorrectBackupFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_backup_files is not None:
            result['DataCorrectBackupFiles'] = self.data_correct_backup_files.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataCorrectBackupFiles') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles()
            self.data_correct_backup_files = temp_model.from_map(m['DataCorrectBackupFiles'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectBackupFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCorrectBackupFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCorrectBackupFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase(TeaModel):
    def __init__(self, db_id=None, db_type=None, env_type=None, logic=None, search_name=None):
        # The ID of the database.
        self.db_id = db_id  # type: int
        # The engine of the database.
        self.db_type = db_type  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: system integration testing (SIT) environment
        # - uat: user acceptance testing (UAT) environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # - **true**: The database is a logical database.
        # - **false**: The database is a physical database.
        self.logic = logic  # type: bool
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList(TeaModel):
    def __init__(self, database=None):
        self.database = database  # type: list[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase]

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail(TeaModel):
    def __init__(self, actual_affect_rows=None, attachment_name=None, classify=None, estimate_affect_rows=None,
                 exe_sql=None, ignore_affect_rows=None, ignore_affect_rows_reason=None, rb_attachment_name=None,
                 rb_sql=None, rb_sqltype=None, sql_type=None):
        # The number of affected rows that is obtained by the precheck.
        self.actual_affect_rows = actual_affect_rows  # type: long
        # The name of the attachment that contains the SQL statements used to change data.
        self.attachment_name = attachment_name  # type: str
        # The category of the reason for the data change.
        self.classify = classify  # type: str
        # The estimated number of affected rows.
        self.estimate_affect_rows = estimate_affect_rows  # type: long
        # The executed SQL statements.
        self.exe_sql = exe_sql  # type: str
        # Indicates whether the precheck result is ignored. Valid values:
        # 
        # - **true**: The precheck result is ignored.
        # - **false**: The precheck result is not ignored.
        self.ignore_affect_rows = ignore_affect_rows  # type: bool
        # The reason why the precheck result is ignored.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason  # type: str
        # The name of the attachment that contains the SQL statements used to roll back the data change.
        self.rb_attachment_name = rb_attachment_name  # type: str
        # The SQL statements used to roll back the data change.
        self.rb_sql = rb_sql  # type: str
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.rb_sqltype = rb_sqltype  # type: str
        # The format of the SQL statements used to change data. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.sql_type = sql_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.rb_attachment_name is not None:
            result['RbAttachmentName'] = self.rb_attachment_name
        if self.rb_sql is not None:
            result['RbSQL'] = self.rb_sql
        if self.rb_sqltype is not None:
            result['RbSQLType'] = self.rb_sqltype
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('RbAttachmentName') is not None:
            self.rb_attachment_name = m.get('RbAttachmentName')
        if m.get('RbSQL') is not None:
            self.rb_sql = m.get('RbSQL')
        if m.get('RbSQLType') is not None:
            self.rb_sqltype = m.get('RbSQLType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO(TeaModel):
    def __init__(self, check_status=None, check_step=None, user_tip=None):
        # The status of the precheck. Valid values:
        # 
        # *   **WAITING**: The ticket is pending precheck.
        # *   **RUNNING**: The ticket is being prechecked.
        # *   **SUCCESS**: The ticket passes the precheck.
        # *   **FAIL**: The ticket fails the precheck.
        self.check_status = check_status  # type: str
        # The check step of the precheck. Valid values:
        # 
        # *   **SQL_PARSE**: The system checks the syntax of the SQL statement.
        # *   **SQL_TYPE_CHECK**: The system checks the type of the SQL statement.
        # *   **PERMISSION_CHECK**: The system checks the permissions required for the data change.
        # *   **ROW_CHECK**: The system checks the number of affected rows.
        self.check_step = check_step  # type: str
        # The message that indicates a check step.
        self.user_tip = user_tip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.check_step is not None:
            result['CheckStep'] = self.check_step
        if self.user_tip is not None:
            result['UserTip'] = self.user_tip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckStep') is not None:
            self.check_step = m.get('CheckStep')
        if m.get('UserTip') is not None:
            self.user_tip = m.get('UserTip')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail(TeaModel):
    def __init__(self, task_check_do=None):
        self.task_check_do = task_check_do  # type: list[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO]

    def validate(self):
        if self.task_check_do:
            for k in self.task_check_do:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskCheckDO'] = []
        if self.task_check_do is not None:
            for k in self.task_check_do:
                result['TaskCheckDO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.task_check_do = []
        if m.get('TaskCheckDO') is not None:
            for k in m.get('TaskCheckDO'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO()
                self.task_check_do.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail(TeaModel):
    def __init__(self, database_list=None, exec_mode=None, order_detail=None, pre_check_detail=None, status=None):
        # The information about the database in which data is changed.
        self.database_list = database_list  # type: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # - **COMMITOR**: The data change is performed by the user who submits the ticket.
        # - **AUTO**: The data change is automatically performed after the ticket is approved.
        # - **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode  # type: str
        # The details of the ticket.
        self.order_detail = order_detail  # type: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail
        # The precheck details of the ticket.
        self.pre_check_detail = pre_check_detail  # type: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail
        # The status of the ticket. Valid values:
        # 
        # - **new**: The ticket is created.
        # - **precheck**: The ticket is being prechecked.
        # - **precheck_fail**: The ticket fails the precheck.
        # - **precheck_success**: The ticket passes the precheck and waits to be submitted for approval.
        # - **toaudit**: The ticket is being reviewed.
        # - **Approved**: The ticket is approved.
        # - **reject**: The ticket is rejected.
        # - **waiting**: The ticket is submitted and waits to be scheduled.
        # - **processing**: The ticket is being executed.
        # - **success**: The ticket is executed.
        # - **closed**: The ticket is closed.
        self.status = status  # type: str

    def validate(self):
        if self.database_list:
            self.database_list.validate()
        if self.order_detail:
            self.order_detail.validate()
        if self.pre_check_detail:
            self.pre_check_detail.validate()

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        if self.pre_check_detail is not None:
            result['PreCheckDetail'] = self.pre_check_detail.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseList') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('OrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        if m.get('PreCheckDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail()
            self.pre_check_detail = temp_model.from_map(m['PreCheckDetail'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDataCorrectOrderDetailResponseBody(TeaModel):
    def __init__(self, data_correct_order_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The information about the data change ticket.
        self.data_correct_order_detail = data_correct_order_detail  # type: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.data_correct_order_detail:
            self.data_correct_order_detail.validate()

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_order_detail is not None:
            result['DataCorrectOrderDetail'] = self.data_correct_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataCorrectOrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail()
            self.data_correct_order_detail = temp_model.from_map(m['DataCorrectOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCorrectOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCorrectOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectRollbackFileRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectRollbackFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectRollbackFileResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, file_url=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The download URL of the attachment.
        self.file_url = file_url  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectRollbackFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectRollbackFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCorrectRollbackFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCorrectRollbackFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectRollbackFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectSQLFileRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectSQLFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectSQLFileResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, file_url=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The download URL of the SQL script.
        self.file_url = file_url  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectSQLFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectSQLFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCorrectSQLFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCorrectSQLFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectSQLFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectTaskDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [CreateDataCorrectOrder](~~208388~~), [CreateDataImportOrder](~~208387~~), or [CreateFreeLockCorrectOrder](~~208386~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectTaskDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail(TeaModel):
    def __init__(self, actual_affect_rows=None, create_time=None, dbtask_group_id=None, job_status=None):
        # The number of rows affected by the SQL statement.
        self.actual_affect_rows = actual_affect_rows  # type: long
        # The time when the task was created.
        self.create_time = create_time  # type: str
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id  # type: long
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.job_status = job_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCorrectTaskDetailResponseBody(TeaModel):
    def __init__(self, data_correct_task_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the data change task.
        self.data_correct_task_detail = data_correct_task_detail  # type: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.data_correct_task_detail:
            self.data_correct_task_detail.validate()

    def to_map(self):
        _map = super(GetDataCorrectTaskDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_task_detail is not None:
            result['DataCorrectTaskDetail'] = self.data_correct_task_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataCorrectTaskDetail') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail()
            self.data_correct_task_detail = temp_model.from_map(m['DataCorrectTaskDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectTaskDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCorrectTaskDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCorrectTaskDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearConfigRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCronClearConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearConfigResponseBodyDataCronClearConfig(TeaModel):
    def __init__(self, cron_call_times=None, cron_format=None, cron_last_call_start_time=None,
                 cron_next_call_time=None, cron_status=None, current_clear_task_count=None, duration=None,
                 optimize_table_after_every_clear_times=None):
        # The number of times that the task is run.
        self.cron_call_times = cron_call_times  # type: str
        # The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](~~206581~~).
        self.cron_format = cron_format  # type: str
        # The time when the task was last run.
        self.cron_last_call_start_time = cron_last_call_start_time  # type: str
        # The time when the task is run next time. This parameter is displayed only when the status of the scheduled task is SUCCESS.
        self.cron_next_call_time = cron_next_call_time  # type: str
        # The status of the scheduled task. If this parameter is empty, it indicates the task is not run. Valid values:
        # 
        # *   PAUSE: The task is suspended.
        # *   WAITING: The task is waiting to be run.
        # *   SUCCESS: The task is complete.
        self.cron_status = cron_status  # type: str
        # The number of times that the Optimize Table statement is automatically exeuted. This parameter is valid only when the value of the OptimizeTableAfterEveryClearTimes parameter is greater than 0.
        self.current_clear_task_count = current_clear_task_count  # type: long
        # The execution duration of the task. Unit: hours. If the value is 0, it indicates the duration is not specified.
        self.duration = duration  # type: str
        # Specifies whether to enable automatic execution of the OPTIMIZE TABLE statement. Valid values:
        # 
        # *   0: disables automatic execution
        # *   A number greater than 0: enables automatic execution. The number specifies the number of times that cleanup operations must be performed before the OPTIMIZE TABLE statement is automatically executed.
        self.optimize_table_after_every_clear_times = optimize_table_after_every_clear_times  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCronClearConfigResponseBodyDataCronClearConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_call_times is not None:
            result['CronCallTimes'] = self.cron_call_times
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        if self.cron_last_call_start_time is not None:
            result['CronLastCallStartTime'] = self.cron_last_call_start_time
        if self.cron_next_call_time is not None:
            result['CronNextCallTime'] = self.cron_next_call_time
        if self.cron_status is not None:
            result['CronStatus'] = self.cron_status
        if self.current_clear_task_count is not None:
            result['CurrentClearTaskCount'] = self.current_clear_task_count
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.optimize_table_after_every_clear_times is not None:
            result['OptimizeTableAfterEveryClearTimes'] = self.optimize_table_after_every_clear_times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronCallTimes') is not None:
            self.cron_call_times = m.get('CronCallTimes')
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        if m.get('CronLastCallStartTime') is not None:
            self.cron_last_call_start_time = m.get('CronLastCallStartTime')
        if m.get('CronNextCallTime') is not None:
            self.cron_next_call_time = m.get('CronNextCallTime')
        if m.get('CronStatus') is not None:
            self.cron_status = m.get('CronStatus')
        if m.get('CurrentClearTaskCount') is not None:
            self.current_clear_task_count = m.get('CurrentClearTaskCount')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OptimizeTableAfterEveryClearTimes') is not None:
            self.optimize_table_after_every_clear_times = m.get('OptimizeTableAfterEveryClearTimes')
        return self


class GetDataCronClearConfigResponseBody(TeaModel):
    def __init__(self, data_cron_clear_config=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # Data configuration.
        self.data_cron_clear_config = data_cron_clear_config  # type: GetDataCronClearConfigResponseBodyDataCronClearConfig
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data_cron_clear_config:
            self.data_cron_clear_config.validate()

    def to_map(self):
        _map = super(GetDataCronClearConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cron_clear_config is not None:
            result['DataCronClearConfig'] = self.data_cron_clear_config.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataCronClearConfig') is not None:
            temp_model = GetDataCronClearConfigResponseBodyDataCronClearConfig()
            self.data_cron_clear_config = temp_model.from_map(m['DataCronClearConfig'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCronClearConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCronClearConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCronClearConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearTaskDetailListRequest(TeaModel):
    def __init__(self, order_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the ticket. You can query the ticket ID from the response parameters of the [CreateDataCronClearOrder](~~208385~~) operation.
        self.order_id = order_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCronClearTaskDetailListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList(TeaModel):
    def __init__(self, actual_affect_rows=None, create_time=None, dbtask_group_id=None, job_status=None):
        # The number of rows affected by the SQL task.
        self.actual_affect_rows = actual_affect_rows  # type: long
        # The time when the SQL task was created.
        self.create_time = create_time  # type: str
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id  # type: long
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.job_status = job_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCronClearTaskDetailListResponseBody(TeaModel):
    def __init__(self, data_cron_clear_task_detail_list=None, error_code=None, error_message=None, request_id=None,
                 success=None, total_count=None):
        # The historical data cleansing tasks
        self.data_cron_clear_task_detail_list = data_cron_clear_task_detail_list  # type: list[GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool
        # The total number of SQL tasks.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data_cron_clear_task_detail_list:
            for k in self.data_cron_clear_task_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataCronClearTaskDetailListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataCronClearTaskDetailList'] = []
        if self.data_cron_clear_task_detail_list is not None:
            for k in self.data_cron_clear_task_detail_list:
                result['DataCronClearTaskDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_cron_clear_task_detail_list = []
        if m.get('DataCronClearTaskDetailList') is not None:
            for k in m.get('DataCronClearTaskDetailList'):
                temp_model = GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList()
                self.data_cron_clear_task_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDataCronClearTaskDetailListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataCronClearTaskDetailListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataCronClearTaskDetailListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearTaskDetailListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportDownloadURLRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportDownloadURLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportDownloadURLResponseBodyDownloadURLResult(TeaModel):
    def __init__(self, has_result=None, tip_message=None, url=None):
        # Indicates whether export results are available for download. Valid values:
        # 
        # *   **true**: Export results are available for download.
        # *   **false**: No export results are available for download.
        self.has_result = has_result  # type: bool
        # The message that indicates an exception.
        self.tip_message = tip_message  # type: str
        # The download URL of the file that records the export results for the ticket.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportDownloadURLResponseBodyDownloadURLResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_result is not None:
            result['HasResult'] = self.has_result
        if self.tip_message is not None:
            result['TipMessage'] = self.tip_message
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HasResult') is not None:
            self.has_result = m.get('HasResult')
        if m.get('TipMessage') is not None:
            self.tip_message = m.get('TipMessage')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class GetDataExportDownloadURLResponseBody(TeaModel):
    def __init__(self, download_urlresult=None, error_code=None, error_message=None, request_id=None, success=None):
        # The details about the download URL of the file that records the export results for the ticket.
        self.download_urlresult = download_urlresult  # type: GetDataExportDownloadURLResponseBodyDownloadURLResult
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.download_urlresult:
            self.download_urlresult.validate()

    def to_map(self):
        _map = super(GetDataExportDownloadURLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_urlresult is not None:
            result['DownloadURLResult'] = self.download_urlresult.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadURLResult') is not None:
            temp_model = GetDataExportDownloadURLResponseBodyDownloadURLResult()
            self.download_urlresult = temp_model.from_map(m['DownloadURLResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportDownloadURLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataExportDownloadURLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataExportDownloadURLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportDownloadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~465867~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo(TeaModel):
    def __init__(self, job_status=None, pre_check_id=None):
        # The state of the data export ticket. Valid values:
        # 
        # *   **PRE_CHECKING**: The ticket was being prechecked.
        # *   **PRE_CHECK_SUCCESS**: The ticket passed the precheck.
        # *   **PRE_CHECK_FAIL**: The ticket failed to pass the prechecked.
        # *   **WAITING_APPLY_AUDIT**: The ticket was to be submitted for approval.
        # *   **APPLY_AUDIT_SUCCESS**: The ticket was submitted for approval.
        # *   **ENABLE_EXPORT**: The ticket was approved. Data can be exported.
        # *   **WAITING_EXPORT**: Data was to be scheduled for export.
        # *   **DOING_EXPORT**: Data was being exported.
        # *   **EXPORT_FAIL**: Data failed to be exported.
        # *   **EXPORT_SUCCESS**: Data was exported.
        self.job_status = job_status  # type: str
        # The precheck ID.
        self.pre_check_id = pre_check_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.pre_check_id is not None:
            result['PreCheckId'] = self.pre_check_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('PreCheckId') is not None:
            self.pre_check_id = m.get('PreCheckId')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail(TeaModel):
    def __init__(self, actual_affect_rows=None, classify=None, database=None, db_id=None, env_type=None,
                 exe_sql=None, ignore_affect_rows=None, ignore_affect_rows_reason=None, logic=None):
        # The number of rows that were affected by the SQL statement.
        self.actual_affect_rows = actual_affect_rows  # type: long
        # The category of the reason for the data export.
        self.classify = classify  # type: str
        # The name of the database from which data was exported.
        self.database = database  # type: str
        # The ID of the database from which data was exported.
        self.db_id = db_id  # type: int
        # The type of the environment to which the database belongs.
        self.env_type = env_type  # type: str
        # The SQL statement that was executed to export data.
        self.exe_sql = exe_sql  # type: str
        # Indicates whether the affected rows are skipped.
        self.ignore_affect_rows = ignore_affect_rows  # type: bool
        # The reason why the affected rows are skipped.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason  # type: str
        # Indicates whether the database is a logical database.
        self.logic = logic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.database is not None:
            result['Database'] = self.database
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetail(TeaModel):
    def __init__(self, key_info=None, order_detail=None):
        # The information about the ticket.
        self.key_info = key_info  # type: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo
        # The details of the ticket.
        self.order_detail = order_detail  # type: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail

    def validate(self):
        if self.key_info:
            self.key_info.validate()
        if self.order_detail:
            self.order_detail.validate()

    def to_map(self):
        _map = super(GetDataExportOrderDetailResponseBodyDataExportOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_info is not None:
            result['KeyInfo'] = self.key_info.to_map()
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyInfo') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo()
            self.key_info = temp_model.from_map(m['KeyInfo'])
        if m.get('OrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        return self


class GetDataExportOrderDetailResponseBody(TeaModel):
    def __init__(self, data_export_order_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The information about the data export ticket.
        self.data_export_order_detail = data_export_order_detail  # type: GetDataExportOrderDetailResponseBodyDataExportOrderDetail
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values: Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        if self.data_export_order_detail:
            self.data_export_order_detail.validate()

    def to_map(self):
        _map = super(GetDataExportOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_export_order_detail is not None:
            result['DataExportOrderDetail'] = self.data_export_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataExportOrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetail()
            self.data_export_order_detail = temp_model.from_map(m['DataExportOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataExportOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataExportOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportPreCheckDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        self.order_id = order_id  # type: long
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList(TeaModel):
    def __init__(self, affect_rows=None, sql=None):
        self.affect_rows = affect_rows  # type: long
        self.sql = sql  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.sql is not None:
            result['SQL'] = self.sql
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList(TeaModel):
    def __init__(self, pre_check_detail_list=None):
        self.pre_check_detail_list = pre_check_detail_list  # type: list[GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList]

    def validate(self):
        if self.pre_check_detail_list:
            for k in self.pre_check_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PreCheckDetailList'] = []
        if self.pre_check_detail_list is not None:
            for k in self.pre_check_detail_list:
                result['PreCheckDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.pre_check_detail_list = []
        if m.get('PreCheckDetailList') is not None:
            for k in m.get('PreCheckDetailList'):
                temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList()
                self.pre_check_detail_list.append(temp_model.from_map(k))
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResult(TeaModel):
    def __init__(self, ignore_affect_rows=None, pre_check_detail_list=None):
        self.ignore_affect_rows = ignore_affect_rows  # type: bool
        self.pre_check_detail_list = pre_check_detail_list  # type: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList

    def validate(self):
        if self.pre_check_detail_list:
            self.pre_check_detail_list.validate()

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailResponseBodyPreCheckResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.pre_check_detail_list is not None:
            result['PreCheckDetailList'] = self.pre_check_detail_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('PreCheckDetailList') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList()
            self.pre_check_detail_list = temp_model.from_map(m['PreCheckDetailList'])
        return self


class GetDataExportPreCheckDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, pre_check_result=None, request_id=None, success=None):
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.pre_check_result = pre_check_result  # type: GetDataExportPreCheckDetailResponseBodyPreCheckResult
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.pre_check_result:
            self.pre_check_result.validate()

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.pre_check_result is not None:
            result['PreCheckResult'] = self.pre_check_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PreCheckResult') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResult()
            self.pre_check_result = temp_model.from_map(m['PreCheckResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportPreCheckDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataExportPreCheckDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataExportPreCheckDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataImportSQLRequest(TeaModel):
    def __init__(self, order_id=None, sql_id=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The SQL ID. You can call the ListDataImportSQLPreCheckDetail operation to query the SQL ID.
        self.sql_id = sql_id  # type: long
        # The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataImportSQLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataImportSQLResponseBodySQLDetail(TeaModel):
    def __init__(self, exec_sql=None):
        # The SQL script.
        self.exec_sql = exec_sql  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataImportSQLResponseBodySQLDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSql'] = self.exec_sql
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecSql') is not None:
            self.exec_sql = m.get('ExecSql')
        return self


class GetDataImportSQLResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sqldetail=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The details of SQL statements.
        self.sqldetail = sqldetail  # type: GetDataImportSQLResponseBodySQLDetail
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        if self.sqldetail:
            self.sqldetail.validate()

    def to_map(self):
        _map = super(GetDataImportSQLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqldetail is not None:
            result['SQLDetail'] = self.sqldetail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLDetail') is not None:
            temp_model = GetDataImportSQLResponseBodySQLDetail()
            self.sqldetail = temp_model.from_map(m['SQLDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataImportSQLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataImportSQLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataImportSQLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataImportSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackJobDegreeRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackJobDegreeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackJobDegreeResponseBodyJobDegree(TeaModel):
    def __init__(self, download_completion_degree=None, filter_completion_degree=None, job_status=None,
                 list_completion_degree=None, status_desc=None):
        # The progress of binary log download. Valid values: 0 to 1. A value of 1 indicates that binary log download is complete.
        self.download_completion_degree = download_completion_degree  # type: float
        # The progress of binary log parsing. Valid values: 0 to 1. A value of 1 indicates that binary log parsing is complete.
        self.filter_completion_degree = filter_completion_degree  # type: float
        # The status of the data tracking task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **LISTING**: The binary logs are being obtained.
        # *   **LIST_SUCCESS**: The binary logs are successfully obtained.
        # *   **DOWNLOADING**: The binary logs are being downloaded.
        # *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
        # *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
        # *   **FILTERING**: The binary logs are being parsed.
        # *   **FILTER_FAIL**: The binary logs failed to be parsed.
        # *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
        self.job_status = job_status  # type: str
        # The progress of binary log obtaining. Valid values: 0 to 1. A value of 1 indicates that binary log obtaining is complete.
        self.list_completion_degree = list_completion_degree  # type: float
        # The description of the task status.
        self.status_desc = status_desc  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackJobDegreeResponseBodyJobDegree, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_completion_degree is not None:
            result['DownloadCompletionDegree'] = self.download_completion_degree
        if self.filter_completion_degree is not None:
            result['FilterCompletionDegree'] = self.filter_completion_degree
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.list_completion_degree is not None:
            result['ListCompletionDegree'] = self.list_completion_degree
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadCompletionDegree') is not None:
            self.download_completion_degree = m.get('DownloadCompletionDegree')
        if m.get('FilterCompletionDegree') is not None:
            self.filter_completion_degree = m.get('FilterCompletionDegree')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('ListCompletionDegree') is not None:
            self.list_completion_degree = m.get('ListCompletionDegree')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class GetDataTrackJobDegreeResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, job_degree=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The progress details of the data tracking task.
        self.job_degree = job_degree  # type: GetDataTrackJobDegreeResponseBodyJobDegree
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        if self.job_degree:
            self.job_degree.validate()

    def to_map(self):
        _map = super(GetDataTrackJobDegreeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_degree is not None:
            result['JobDegree'] = self.job_degree.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobDegree') is not None:
            temp_model = GetDataTrackJobDegreeResponseBodyJobDegree()
            self.job_degree = temp_model.from_map(m['JobDegree'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataTrackJobDegreeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataTrackJobDegreeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataTrackJobDegreeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackJobDegreeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackJobTableMetaRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackJobTableMetaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackJobTableMetaResponseBodyTableMetaListColumns(TeaModel):
    def __init__(self, charset=None, column_name=None, column_position=None, column_type=None, fictive=None):
        # The name of the character set.
        self.charset = charset  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The position of the column.
        self.column_position = column_position  # type: int
        # The data type of the column. Examples: BIGINT, INT, and VARCHAR.
        self.column_type = column_type  # type: str
        # Indicates whether the column is a virtual column. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.fictive = fictive  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackJobTableMetaResponseBodyTableMetaListColumns, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_position is not None:
            result['ColumnPosition'] = self.column_position
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.fictive is not None:
            result['Fictive'] = self.fictive
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPosition') is not None:
            self.column_position = m.get('ColumnPosition')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Fictive') is not None:
            self.fictive = m.get('Fictive')
        return self


class GetDataTrackJobTableMetaResponseBodyTableMetaList(TeaModel):
    def __init__(self, columns=None, schema_name=None, table_name=None):
        # The information about columns.
        self.columns = columns  # type: list[GetDataTrackJobTableMetaResponseBodyTableMetaListColumns]
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataTrackJobTableMetaResponseBodyTableMetaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = GetDataTrackJobTableMetaResponseBodyTableMetaListColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetDataTrackJobTableMetaResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, table_meta_list=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The metadata of tables.
        self.table_meta_list = table_meta_list  # type: list[GetDataTrackJobTableMetaResponseBodyTableMetaList]

    def validate(self):
        if self.table_meta_list:
            for k in self.table_meta_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDataTrackJobTableMetaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TableMetaList'] = []
        if self.table_meta_list is not None:
            for k in self.table_meta_list:
                result['TableMetaList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.table_meta_list = []
        if m.get('TableMetaList') is not None:
            for k in m.get('TableMetaList'):
                temp_model = GetDataTrackJobTableMetaResponseBodyTableMetaList()
                self.table_meta_list.append(temp_model.from_map(k))
        return self


class GetDataTrackJobTableMetaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataTrackJobTableMetaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataTrackJobTableMetaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackJobTableMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail(TeaModel):
    def __init__(self, database_search_name=None, db_id=None, job_end_time=None, job_start_time=None,
                 job_status=None, logic=None, schema_name=None, status_desc=None, table_names=None, track_types=None):
        # The name that is used to search for the database.
        self.database_search_name = database_search_name  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The end time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.job_end_time = job_end_time  # type: str
        # The start time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.job_start_time = job_start_time  # type: str
        # The status of the data tracking task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **LISTING**: The binary logs are being obtained.
        # *   **LIST_SUCCESS**: The binary logs are successfully obtained.
        # *   **DOWNLOADING**: The binary logs are being downloaded.
        # *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
        # *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
        # *   **FILTERING**: The binary logs are being parsed.
        # *   **FILTER_FAIL**: The binary logs failed to be parsed.
        # *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
        self.job_status = job_status  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic  # type: bool
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The description of the task status.
        self.status_desc = status_desc  # type: str
        # The names of the tables for which data operations are tracked.
        self.table_names = table_names  # type: list[str]
        # The types of data operations that are tracked.
        self.track_types = track_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_search_name is not None:
            result['DatabaseSearchName'] = self.database_search_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.job_end_time is not None:
            result['JobEndTime'] = self.job_end_time
        if self.job_start_time is not None:
            result['JobStartTime'] = self.job_start_time
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        if self.track_types is not None:
            result['TrackTypes'] = self.track_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseSearchName') is not None:
            self.database_search_name = m.get('DatabaseSearchName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('JobEndTime') is not None:
            self.job_end_time = m.get('JobEndTime')
        if m.get('JobStartTime') is not None:
            self.job_start_time = m.get('JobStartTime')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        if m.get('TrackTypes') is not None:
            self.track_types = m.get('TrackTypes')
        return self


class GetDataTrackOrderDetailResponseBody(TeaModel):
    def __init__(self, data_track_order_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the ticket.
        self.data_track_order_detail = data_track_order_detail  # type: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data_track_order_detail:
            self.data_track_order_detail.validate()

    def to_map(self):
        _map = super(GetDataTrackOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_track_order_detail is not None:
            result['DataTrackOrderDetail'] = self.data_track_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataTrackOrderDetail') is not None:
            temp_model = GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail()
            self.data_track_order_detail = temp_model.from_map(m['DataTrackOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataTrackOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDataTrackOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDataTrackOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseRequest(TeaModel):
    def __init__(self, host=None, port=None, schema_name=None, sid=None, tid=None):
        # The endpoint that is used to connect to the database.
        self.host = host  # type: str
        # The port that is used to connect to the database.
        self.port = port  # type: int
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The system identifier (SID) of the database.
        # 
        # >  The SID uniquely identifies an Oracle database. After a database is created, a SID is generated for the database.
        self.sid = sid  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseResponseBodyDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseResponseBodyDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetDatabaseResponseBodyDatabase(TeaModel):
    def __init__(self, catalog_name=None, database_id=None, db_type=None, dba_id=None, dba_name=None, encoding=None,
                 env_type=None, host=None, instance_alias=None, instance_id=None, owner_id_list=None, owner_name_list=None,
                 port=None, schema_name=None, search_name=None, sid=None, state=None):
        # The name of the catalog to which the database belongs.
        self.catalog_name = catalog_name  # type: str
        # The ID of the database.
        self.database_id = database_id  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The ID of the database administrator (DBA).
        self.dba_id = dba_id  # type: str
        # The nickname of the DBA.
        self.dba_name = dba_name  # type: str
        # The encoding format of the database.
        self.encoding = encoding  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type  # type: str
        # The endpoint that is used to connect to the database.
        self.host = host  # type: str
        # The alias of the instance.
        self.instance_alias = instance_alias  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list  # type: GetDatabaseResponseBodyDatabaseOwnerIdList
        # The names of the owners of the database.
        self.owner_name_list = owner_name_list  # type: GetDatabaseResponseBodyDatabaseOwnerNameList
        # The port that is used to connect to the database.
        self.port = port  # type: int
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The keyword that is used to search for the database.
        self.search_name = search_name  # type: str
        # The SID of the database.
        # 
        # >  The value of the parameter is returned only for Oracle databases.
        self.sid = sid  # type: str
        # The status of the database. Valid values:
        # 
        # *   **NORMAL**: The database is running as expected.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(GetDatabaseResponseBodyDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetDatabaseResponseBody(TeaModel):
    def __init__(self, database=None, error_code=None, error_message=None, request_id=None, success=None):
        # The details of the database.
        self.database = database  # type: GetDatabaseResponseBodyDatabase
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super(GetDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseExportOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes(TeaModel):
    def __init__(self, export_types=None):
        self.export_types = export_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportTypes') is not None:
            self.export_types = m.get('ExportTypes')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption(TeaModel):
    def __init__(self, sqlext_option=None):
        self.sqlext_option = sqlext_option  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SQLExtOption') is not None:
            self.sqlext_option = m.get('SQLExtOption')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables(TeaModel):
    def __init__(self, selected_tables=None):
        self.selected_tables = selected_tables  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SelectedTables') is not None:
            self.selected_tables = m.get('SelectedTables')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig(TeaModel):
    def __init__(self, db_name=None, export_content=None, export_types=None, sqlext_option=None,
                 selected_tables=None, target_option=None):
        # The database name.
        self.db_name = db_name  # type: str
        # The type of data that was exported. Valid values:
        # 
        # *   **DATA**: The data of the database was exported.
        # *   **STRUCT**: The schema of the database was exported.
        # *   **DATA_STRUCT**: The data and schema of the database were exported.
        self.export_content = export_content  # type: str
        # The type of schema that was exported.
        self.export_types = export_types  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes
        # The extension options of the SQL script.
        self.sqlext_option = sqlext_option  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption
        # The tables that were exported from the database.
        self.selected_tables = selected_tables  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables
        # The format in which the database was exported. Valid values:
        # 
        # *   **SQL**\
        # *   **CSV**\
        # *   **XLSX**\
        self.target_option = target_option  # type: str

    def validate(self):
        if self.export_types:
            self.export_types.validate()
        if self.sqlext_option:
            self.sqlext_option.validate()
        if self.selected_tables:
            self.selected_tables.validate()

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.export_content is not None:
            result['ExportContent'] = self.export_content
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types.to_map()
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option.to_map()
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables.to_map()
        if self.target_option is not None:
            result['TargetOption'] = self.target_option
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('ExportContent') is not None:
            self.export_content = m.get('ExportContent')
        if m.get('ExportTypes') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes()
            self.export_types = temp_model.from_map(m['ExportTypes'])
        if m.get('SQLExtOption') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption()
            self.sqlext_option = temp_model.from_map(m['SQLExtOption'])
        if m.get('SelectedTables') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables()
            self.selected_tables = temp_model.from_map(m['SelectedTables'])
        if m.get('TargetOption') is not None:
            self.target_option = m.get('TargetOption')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo(TeaModel):
    def __init__(self, audit_date=None, config=None, db_id=None, download_url=None):
        # The time when the ticket was submitted.
        self.audit_date = audit_date  # type: str
        # The configuration information about the ticket.
        self.config = config  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig
        # The database ID.
        self.db_id = db_id  # type: long
        # The URL that is used to download the export result.
        self.download_url = download_url  # type: str

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_date is not None:
            result['AuditDate'] = self.audit_date
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.download_url is not None:
            result['DownloadURL'] = self.download_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditDate') is not None:
            self.audit_date = m.get('AuditDate')
        if m.get('Config') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DownloadURL') is not None:
            self.download_url = m.get('DownloadURL')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail(TeaModel):
    def __init__(self, comment=None, committer=None, committer_id=None, id=None, key_info=None, log=None,
                 search_name=None, status_desc=None, workflow_status_desc=None):
        # The business background information of the database export ticket.
        self.comment = comment  # type: str
        # The user who submitted the ticket.
        self.committer = committer  # type: str
        # The ID of the user who submitted the ticket. This ID is a user ID and is not the ID of an Alibaba Cloud account.
        self.committer_id = committer_id  # type: str
        # The ticket ID.
        self.id = id  # type: long
        # The key information about the ticket.
        self.key_info = key_info  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo
        # The execution logs.
        self.log = log  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str
        # The status description of the ticket.
        self.status_desc = status_desc  # type: str
        # The status description of the workflow.
        self.workflow_status_desc = workflow_status_desc  # type: str

    def validate(self):
        if self.key_info:
            self.key_info.validate()

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.id is not None:
            result['Id'] = self.id
        if self.key_info is not None:
            result['KeyInfo'] = self.key_info.to_map()
        if self.log is not None:
            result['Log'] = self.log
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeyInfo') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo()
            self.key_info = temp_model.from_map(m['KeyInfo'])
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetDatabaseExportOrderDetailResponseBody(TeaModel):
    def __init__(self, database_export_order_detail=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the database export ticket.
        self.database_export_order_detail = database_export_order_detail  # type: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        if self.database_export_order_detail:
            self.database_export_order_detail.validate()

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_export_order_detail is not None:
            result['DatabaseExportOrderDetail'] = self.database_export_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseExportOrderDetail') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail()
            self.database_export_order_detail = temp_model.from_map(m['DatabaseExportOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseExportOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDatabaseExportOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDatabaseExportOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceRequest(TeaModel):
    def __init__(self, host=None, port=None, sid=None, tid=None):
        # The endpoint of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the endpoint.
        self.host = host  # type: str
        # The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the port number.
        self.port = port  # type: int
        # The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the SID.
        self.sid = sid  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetInstanceResponseBodyInstanceOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceResponseBodyInstanceOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetInstanceResponseBodyInstanceOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceResponseBodyInstanceOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetInstanceResponseBodyInstanceStandardGroup(TeaModel):
    def __init__(self, group_mode=None, group_name=None):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode  # type: str
        # The name of the security rule set corresponding to the control mode.
        self.group_name = group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceResponseBodyInstanceStandardGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetInstanceResponseBodyInstance(TeaModel):
    def __init__(self, data_link_name=None, database_password=None, database_user=None, dba_id=None,
                 dba_nick_name=None, ddl_online=None, ecs_instance_id=None, ecs_region=None, env_type=None, export_timeout=None,
                 host=None, instance_alias=None, instance_id=None, instance_source=None, instance_type=None,
                 owner_id_list=None, owner_name_list=None, port=None, query_timeout=None, safe_rule_id=None, sell_sitd=None,
                 sid=None, standard_group=None, state=None, use_dsql=None, vpc_id=None):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name  # type: str
        # The password that is used to log on to the database.
        self.database_password = database_password  # type: str
        # The account that is used to log on to the database instance.
        self.database_user = database_user  # type: str
        # The ID of the database administrator (DBA) for the database instance.
        self.dba_id = dba_id  # type: str
        # The nickname of the DBA for the database instance.
        self.dba_nick_name = dba_nick_name  # type: str
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online  # type: int
        # The ID of the Elastic Compute Service (ECS) instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id  # type: str
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region  # type: str
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type  # type: str
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout  # type: int
        # The host address that is used to connect to the database instance.
        self.host = host  # type: str
        # The alias of the database instance.
        self.instance_alias = instance_alias  # type: str
        # The ID of the database instance.
        self.instance_id = instance_id  # type: str
        # The source of the database instance.
        self.instance_source = instance_source  # type: str
        # The type of the database instance.
        self.instance_type = instance_type  # type: str
        # The IDs of the owners for the database instance.
        self.owner_id_list = owner_id_list  # type: GetInstanceResponseBodyInstanceOwnerIdList
        # The nicknames of the owners for the database instance.
        self.owner_name_list = owner_name_list  # type: GetInstanceResponseBodyInstanceOwnerNameList
        # The port number that is used to connect to the database instance.
        self.port = port  # type: int
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout  # type: int
        # The ID of the security rule set for the database instance.
        self.safe_rule_id = safe_rule_id  # type: str
        # Whether sensitive data protection is enabled.  Valid values:
        # 
        # - **true**: Enable.
        # 
        # - **false**: Close.
        self.sell_sitd = sell_sitd  # type: str
        # The SID of the database instance.
        self.sid = sid  # type: str
        # The control mode of the database instance.
        self.standard_group = standard_group  # type: GetInstanceResponseBodyInstanceStandardGroup
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**: normal
        # *   **DISABLE**: disabled
        self.state = state  # type: str
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.use_dsql = use_dsql  # type: int
        # The ID of the virtual private cloud (VPC) to which the database instance belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super(GetInstanceResponseBodyInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = GetInstanceResponseBodyInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, instance=None, request_id=None, success=None):
        # The error code that is returned.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The details of the database instance.
        self.instance = instance  # type: GetInstanceResponseBodyInstance
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super(GetInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Instance') is not None:
            temp_model = GetInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntervalLimitOfSLARequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetIntervalLimitOfSLARequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetIntervalLimitOfSLAResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, interval_limit=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The minimum scheduling cycle. Unit: minutes.
        self.interval_limit = interval_limit  # type: int
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetIntervalLimitOfSLAResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.interval_limit is not None:
            result['IntervalLimit'] = self.interval_limit
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IntervalLimit') is not None:
            self.interval_limit = m.get('IntervalLimit')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetIntervalLimitOfSLAResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetIntervalLimitOfSLAResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetIntervalLimitOfSLAResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntervalLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLhSpaceByNameRequest(TeaModel):
    def __init__(self, space_name=None, tid=None):
        # The name of the workspace.
        self.space_name = space_name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLhSpaceByNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLhSpaceByNameResponseBodyLakehouseSpace(TeaModel):
    def __init__(self, creator_id=None, description=None, dev_db_id=None, dw_db_type=None, id=None, is_deleted=None,
                 mode=None, prod_db_id=None, space_config=None, space_name=None, tenant_id=None):
        # The ID of the user who creates the workspace.
        self.creator_id = creator_id  # type: str
        # The description of the workspace.
        self.description = description  # type: str
        # The ID of the development database.
        self.dev_db_id = dev_db_id  # type: int
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        self.dw_db_type = dw_db_type  # type: str
        # The ID of the workspace.
        self.id = id  # type: long
        # Indicates whether the workspace is deleted. Valid values:
        # 
        # *   **true**: The workspace is deleted.
        # *   **false**: The workspace is not deleted.
        self.is_deleted = is_deleted  # type: bool
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode
        # *   **1**: standard mode
        self.mode = mode  # type: int
        # The ID of the production database.
        self.prod_db_id = prod_db_id  # type: int
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\&M.
        self.space_config = space_config  # type: str
        # The name of the workspace.
        self.space_name = space_name  # type: str
        # The ID of the tenant to which the workspace belongs.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLhSpaceByNameResponseBodyLakehouseSpace, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class GetLhSpaceByNameResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, lakehouse_space=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The workspace for data warehouse development.
        self.lakehouse_space = lakehouse_space  # type: GetLhSpaceByNameResponseBodyLakehouseSpace
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.lakehouse_space:
            self.lakehouse_space.validate()

    def to_map(self):
        _map = super(GetLhSpaceByNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.lakehouse_space is not None:
            result['LakehouseSpace'] = self.lakehouse_space.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LakehouseSpace') is not None:
            temp_model = GetLhSpaceByNameResponseBodyLakehouseSpace()
            self.lakehouse_space = temp_model.from_map(m['LakehouseSpace'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLhSpaceByNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLhSpaceByNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLhSpaceByNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLhSpaceByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLogicDatabaseRequest(TeaModel):
    def __init__(self, db_id=None, tid=None):
        # The ID of the logical database. You can call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the ID of the logical database.
        self.db_id = db_id  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLogicDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds(TeaModel):
    def __init__(self, database_ids=None):
        self.database_ids = database_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetLogicDatabaseResponseBodyLogicDatabase(TeaModel):
    def __init__(self, alias=None, database_id=None, database_ids=None, db_type=None, env_type=None, logic=None,
                 owner_id_list=None, owner_name_list=None, schema_name=None, search_name=None):
        # The alias of the logical database.
        self.alias = alias  # type: str
        # The ID of the logical database.
        self.database_id = database_id  # type: str
        # The IDs of database shards of the logical database.
        self.database_ids = database_ids  # type: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds
        # The database engine. For more information about the valid values of the DbType parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: pre-release environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: staging environment
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic  # type: bool
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list  # type: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list  # type: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList
        # The name of the logical database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the logical database.
        self.search_name = search_name  # type: str

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(GetLogicDatabaseResponseBodyLogicDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetLogicDatabaseResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, logic_database=None, request_id=None, success=None):
        # The status code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The details of the logical database.
        self.logic_database = logic_database  # type: GetLogicDatabaseResponseBodyLogicDatabase
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.logic_database:
            self.logic_database.validate()

    def to_map(self):
        _map = super(GetLogicDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database is not None:
            result['LogicDatabase'] = self.logic_database.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabase') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabase()
            self.logic_database = temp_model.from_map(m['LogicDatabase'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLogicDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLogicDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLogicDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableColumnRequest(TeaModel):
    def __init__(self, table_guid=None, tid=None):
        # The globally unique identifier (GUID) of the table in Data Management (DMS).
        # 
        # *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](~~141875~~) operation to obtain the value of this parameter.
        # *   If the database to which the table belongs is a physical database, you can call the [ListTables](~~141878~~) operation to obtain the value of this parameter.
        self.table_guid = table_guid  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMetaTableColumnRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableColumnResponseBodyColumnList(TeaModel):
    def __init__(self, auto_increment=None, column_id=None, column_name=None, column_type=None, data_length=None,
                 data_precision=None, data_scale=None, description=None, nullable=None, position=None, primary_key=None,
                 security_level=None):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   **true**: The column is an auto-increment column.
        # *   **false**: The column is not an auto-increment column.
        self.auto_increment = auto_increment  # type: bool
        # The ID of the column.
        self.column_id = column_id  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The data type of the column.
        # 
        # > The return value of a column is not unique, such as **bigint** or **int**.
        self.column_type = column_type  # type: str
        # The length of the field.
        self.data_length = data_length  # type: long
        # The precision of the field.
        self.data_precision = data_precision  # type: int
        # The number of decimal places for the field.
        self.data_scale = data_scale  # type: int
        # The description of the column.
        self.description = description  # type: str
        # Indicates whether the field can be empty. Valid values:
        # 
        # *   **true**: The field can be empty.
        # *   **false**: The field cannot be empty.
        self.nullable = nullable  # type: bool
        # The position of the field in the table.
        self.position = position  # type: int
        # Indicates whether the field is the primary key. Valid values:
        # 
        # *   **true**: The field is the primary key.
        # *   **false**: The field is not the primary key.
        self.primary_key = primary_key  # type: str
        # The sensitivity level of the column. Valid values:
        # 
        # *   **INNER**: The column is not sensitive.
        # *   **SENSITIVE**: The column is sensitive.
        # *   **CONFIDENTIAL**: The column is confidential.
        # 
        # > For more information, see [Sensitivity levels of columns](~~66091~~).
        self.security_level = security_level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMetaTableColumnResponseBodyColumnList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        return self


class GetMetaTableColumnResponseBody(TeaModel):
    def __init__(self, column_list=None, error_code=None, error_message=None, request_id=None, success=None):
        # The details about fields in the table.
        self.column_list = column_list  # type: list[GetMetaTableColumnResponseBodyColumnList]
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetMetaTableColumnResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableColumnResponseBodyColumnList()
                self.column_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableColumnResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMetaTableColumnResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMetaTableColumnResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableColumnResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableDetailInfoRequest(TeaModel):
    def __init__(self, table_guid=None, tid=None):
        # The GUID of the table in Data Management (DMS).
        # 
        # > 
        # 
        # *   You can call the [ListLogicTables](~~141875~~) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
        # 
        # *   You can call the [ListTables](~~141878~~) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
        self.table_guid = table_guid  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMetaTableDetailInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList(TeaModel):
    def __init__(self, auto_increment=None, column_id=None, column_name=None, column_type=None, data_length=None,
                 data_precision=None, data_scale=None, description=None, nullable=None, position=None):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   true: The column is an auto-increment column.
        # *   false: The column is not an auto-increment column.
        self.auto_increment = auto_increment  # type: bool
        # The ID of the column.
        self.column_id = column_id  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The data type of the column. Examples: Bigint, Int, and Varchar.
        self.column_type = column_type  # type: str
        # The length of the field.
        self.data_length = data_length  # type: long
        # The precision of the field.
        self.data_precision = data_precision  # type: int
        # The scale of the column.
        self.data_scale = data_scale  # type: int
        # The description of the column.
        self.description = description  # type: str
        # Indicates whether the column is nullable. Valid values:
        # 
        # *   true: The column is nullable.
        # *   false: The column is not nullable.
        self.nullable = nullable  # type: bool
        # The position of the field in the table.
        self.position = position  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMetaTableDetailInfoResponseBodyDetailInfoColumnList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList(TeaModel):
    def __init__(self, index_columns=None, index_id=None, index_name=None, index_type=None, unique=None):
        # The index column.
        self.index_columns = index_columns  # type: list[str]
        # The ID of the index.
        self.index_id = index_id  # type: str
        # The name of the index.
        self.index_name = index_name  # type: str
        # The type of the index. Examples: Primary, Unique, and Normal.
        self.index_type = index_type  # type: str
        # Indicates whether the index is unique. Valid values:
        # 
        # *   true: The index is unique.
        # *   false: The index is not unique.
        self.unique = unique  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMetaTableDetailInfoResponseBodyDetailInfoIndexList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_columns is not None:
            result['IndexColumns'] = self.index_columns
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.unique is not None:
            result['Unique'] = self.unique
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IndexColumns') is not None:
            self.index_columns = m.get('IndexColumns')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('Unique') is not None:
            self.unique = m.get('Unique')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfo(TeaModel):
    def __init__(self, column_list=None, index_list=None):
        # The columns in the table.
        self.column_list = column_list  # type: list[GetMetaTableDetailInfoResponseBodyDetailInfoColumnList]
        # The list of indexes.
        self.index_list = index_list  # type: list[GetMetaTableDetailInfoResponseBodyDetailInfoIndexList]

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()
        if self.index_list:
            for k in self.index_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetMetaTableDetailInfoResponseBodyDetailInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        result['IndexList'] = []
        if self.index_list is not None:
            for k in self.index_list:
                result['IndexList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoColumnList()
                self.column_list.append(temp_model.from_map(k))
        self.index_list = []
        if m.get('IndexList') is not None:
            for k in m.get('IndexList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoIndexList()
                self.index_list.append(temp_model.from_map(k))
        return self


class GetMetaTableDetailInfoResponseBody(TeaModel):
    def __init__(self, detail_info=None, error_code=None, error_message=None, request_id=None, success=None):
        # The details of the table.
        self.detail_info = detail_info  # type: GetMetaTableDetailInfoResponseBodyDetailInfo
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.detail_info:
            self.detail_info.validate()

    def to_map(self):
        _map = super(GetMetaTableDetailInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail_info is not None:
            result['DetailInfo'] = self.detail_info.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DetailInfo') is not None:
            temp_model = GetMetaTableDetailInfoResponseBodyDetailInfo()
            self.detail_info = temp_model.from_map(m['DetailInfo'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableDetailInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMetaTableDetailInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMetaTableDetailInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableDetailInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnlineDDLProgressRequest(TeaModel):
    def __init__(self, job_detail_id=None, tid=None):
        # The ID of the OnlineDDL SQL task details. You can call the [ListDBTaskSQLJobDetail](~~207073~~) operation to obtain the task detail ID.
        self.job_detail_id = job_detail_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOnlineDDLProgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail(TeaModel):
    def __init__(self, clean_strategy=None, copy_chunk_mode=None, copy_chunk_size=None, copy_count=None,
                 copy_total=None, cutover_fail_retry_times=None, cutover_lock_time_seconds=None,
                 cutover_window_end_time=None, cutover_window_start_time=None, delay_seconds=None, job_status=None, progress_ratio=None,
                 status_desc=None):
        # The cleanup policy of the original table after the cut-over. Valid values:
        # 
        # *   **DROP**: Invalid original tables are deleted.
        # *   **MOVE**: Invalid original tables are moved to the test database. You can delete the tables manually.
        # *   **NOTHING**: Invalid original tables are retained in the original database. You can delete the tables manually.
        self.clean_strategy = clean_strategy  # type: str
        # The policy of full replication. Valid values:
        # 
        # *   **AUTO**: DMS dynamically adjusts the chunk size based on the performance of the database. Tables are locked for less than 1.5 seconds during a single replication operation.
        # *   **RUNNING**: DMS uses the specified value of the CopyChunkSize parameter. The valid value of the CopyChunkSize parameter ranges from 1 to 60000. If you set this parameter to RUNNING, you must specify the CopyChunkSize parameter.
        self.copy_chunk_mode = copy_chunk_mode  # type: str
        # The size of each chunk that is used to replicate data. This parameter is used to specify the size of each chunk. A larger chunk size increases the replication efficiency and decreases the business performance.
        # 
        # > During full replication, the original table is divided into N small chunks and each chunk is replicated to the temporary table one by one. By default, DMS dynamically adjusts the size of each chunk.
        self.copy_chunk_size = copy_chunk_size  # type: long
        # The actual amount of data replicated from the original table in the lock-free change operation.
        self.copy_count = copy_count  # type: long
        # The estimated total number of rows of the data. The value is obtained from the statistical data in the information_schema database. In most cases, the estimated total number of rows is smaller than the actual number of rows in a table.
        self.copy_total = copy_total  # type: long
        # The number of retries when the cut-over fails.
        self.cutover_fail_retry_times = cutover_fail_retry_times  # type: long
        # The maximum period of time that a table can be locked during cut-over. Unit: seconds.
        self.cutover_lock_time_seconds = cutover_lock_time_seconds  # type: long
        # The end of the time window of the cut-over operation. This value is at least 30 minutes later than the CutoverWindowStartTime parameter. Default value: 23:59:59
        self.cutover_window_end_time = cutover_window_end_time  # type: str
        # The beginning of the time window of the cut-over operation. Default value: 00:00:00. This parameter controls the time window of the cut-over. Cut-over can be performed only when the cut-over conditions are met and the time is within the specified time window. If the time is not within the time window, the cut-over operation is not performed until the time reaches the beginning of the time window.
        self.cutover_window_start_time = cutover_window_start_time  # type: str
        # The replay latency of DMS. Unit: seconds. The replay latency is the period of time that is taken to replay the binary logs of the table to the temporary table. The latency does not indicate the data migration latency between a primary database and a secondary database.
        self.delay_seconds = delay_seconds  # type: long
        # The state of the task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **SUCCESS**: The task is complete.
        # *   **RUNNING**: The task is being executed.
        # *   **WAITING_CUTOVER**: The task is waiting for cut-over.
        # *   **RESTARTING**: The task is restarting.
        # *   **PAUSE**: The task is suspended.
        # *   **UNSUPPORTED**: The task is not supported.
        # *   **CANCELED**: The task is canceled.
        # *   **FAIL**: The task failed.
        # *   **INTERRUPT**: The task is interrupted.
        self.job_status = job_status  # type: str
        # The estimated execution progress. The actual progress is subject to the task status.
        self.progress_ratio = progress_ratio  # type: str
        # The description of the task status.
        self.status_desc = status_desc  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_strategy is not None:
            result['CleanStrategy'] = self.clean_strategy
        if self.copy_chunk_mode is not None:
            result['CopyChunkMode'] = self.copy_chunk_mode
        if self.copy_chunk_size is not None:
            result['CopyChunkSize'] = self.copy_chunk_size
        if self.copy_count is not None:
            result['CopyCount'] = self.copy_count
        if self.copy_total is not None:
            result['CopyTotal'] = self.copy_total
        if self.cutover_fail_retry_times is not None:
            result['CutoverFailRetryTimes'] = self.cutover_fail_retry_times
        if self.cutover_lock_time_seconds is not None:
            result['CutoverLockTimeSeconds'] = self.cutover_lock_time_seconds
        if self.cutover_window_end_time is not None:
            result['CutoverWindowEndTime'] = self.cutover_window_end_time
        if self.cutover_window_start_time is not None:
            result['CutoverWindowStartTime'] = self.cutover_window_start_time
        if self.delay_seconds is not None:
            result['DelaySeconds'] = self.delay_seconds
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.progress_ratio is not None:
            result['ProgressRatio'] = self.progress_ratio
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CleanStrategy') is not None:
            self.clean_strategy = m.get('CleanStrategy')
        if m.get('CopyChunkMode') is not None:
            self.copy_chunk_mode = m.get('CopyChunkMode')
        if m.get('CopyChunkSize') is not None:
            self.copy_chunk_size = m.get('CopyChunkSize')
        if m.get('CopyCount') is not None:
            self.copy_count = m.get('CopyCount')
        if m.get('CopyTotal') is not None:
            self.copy_total = m.get('CopyTotal')
        if m.get('CutoverFailRetryTimes') is not None:
            self.cutover_fail_retry_times = m.get('CutoverFailRetryTimes')
        if m.get('CutoverLockTimeSeconds') is not None:
            self.cutover_lock_time_seconds = m.get('CutoverLockTimeSeconds')
        if m.get('CutoverWindowEndTime') is not None:
            self.cutover_window_end_time = m.get('CutoverWindowEndTime')
        if m.get('CutoverWindowStartTime') is not None:
            self.cutover_window_start_time = m.get('CutoverWindowStartTime')
        if m.get('DelaySeconds') is not None:
            self.delay_seconds = m.get('DelaySeconds')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('ProgressRatio') is not None:
            self.progress_ratio = m.get('ProgressRatio')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class GetOnlineDDLProgressResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, online_ddltask_detail=None, request_id=None,
                 success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The details of the task.
        self.online_ddltask_detail = online_ddltask_detail  # type: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.online_ddltask_detail:
            self.online_ddltask_detail.validate()

    def to_map(self):
        _map = super(GetOnlineDDLProgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.online_ddltask_detail is not None:
            result['OnlineDDLTaskDetail'] = self.online_ddltask_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OnlineDDLTaskDetail') is not None:
            temp_model = GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail()
            self.online_ddltask_detail = temp_model.from_map(m['OnlineDDLTaskDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOnlineDDLProgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOnlineDDLProgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOnlineDDLProgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnlineDDLProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOpLogRequest(TeaModel):
    def __init__(self, database_name=None, end_time=None, module=None, page_number=None, page_size=None,
                 start_time=None, tid=None, user_nick=None):
        # DatabaseName.
        self.database_name = database_name  # type: str
        # The end of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time  # type: str
        # The functional module for which you want to query operation logs. If you do not specify this parameter, operation logs for all functional modules are returned. Valid values:
        # 
        # *   **PERMISSION**: permissions
        # *   **OWNER**: data owner
        # *   **SQL_CONSOLE**: data query
        # *   **SQL_CONSOLE_EXPORT**: query result export
        # *   **DATA_CHANGE**: data change
        # *   **DATA_EXPORT**: data export
        # *   **SQL_REVIEW**: SQL review
        # *   **DT_SYNC**: database and table synchronization
        # *   **DT_DETAIL**: database and table details
        # *   **DB_TASK**: task management
        # *   **INSTANCE_MANAGE**: instance management
        # *   **USER_MANAGE**: user management
        # *   **SECURITY_RULE**: security rules
        # *   **CONFIG_MANAGE**: configuration management
        # *   **RESOURCE_AUTH**: resource authorization
        # *   **ACCESS_WHITE_IP**: access IP address whitelist
        # *   **NDDL**: schema design
        # *   **DSQL_CONSOLE**: cross-database data query
        # *   **DSQL_CONSOLE_EXPORT**: cross-database query result export
        # *   **DATA_TRACT**: data tracking
        # *   **DATA_QUALITY**: data quality
        # *   **DATALINK_MANAGE** :DBLink management
        # *   **DATASEC_MANAGE**: sensitive data management
        # *   **SELL**: sales
        self.module = module  # type: str
        # The number of the page to return. Pages start from page 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values:
        # 
        # *   30
        # *   50
        # *   100
        self.page_size = page_size  # type: int
        # The beginning of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # UserNick.
        self.user_nick = user_nick  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOpLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module is not None:
            result['Module'] = self.module
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class GetOpLogResponseBodyOpLogDetailsOpLogDetail(TeaModel):
    def __init__(self, database=None, module=None, op_content=None, op_time=None, op_user_id=None, order_id=None,
                 user_id=None, user_nick=None):
        # The endpoint of the database instance.
        # 
        # > 
        # 
        # *   This parameter is valid only for database instances of the LocalInstance type.
        # 
        # *   This parameter is valid only for operations on the functional modules related to tasks.
        self.database = database  # type: str
        # The functional module for which the operation log is queried.
        self.module = module  # type: str
        # The details of the operation.
        self.op_content = op_content  # type: str
        # The time when the operation was performed.
        self.op_time = op_time  # type: str
        # The ID of the user who performed the operation.
        self.op_user_id = op_user_id  # type: long
        # The ID of the ticket or task.
        # 
        # >  This parameter is valid only for operations on the functional modules related to tasks and the task management module in system management.
        self.order_id = order_id  # type: long
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id  # type: str
        # The display name of the user.
        self.user_nick = user_nick  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOpLogResponseBodyOpLogDetailsOpLogDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.module is not None:
            result['Module'] = self.module
        if self.op_content is not None:
            result['OpContent'] = self.op_content
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.op_user_id is not None:
            result['OpUserId'] = self.op_user_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('OpContent') is not None:
            self.op_content = m.get('OpContent')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('OpUserId') is not None:
            self.op_user_id = m.get('OpUserId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class GetOpLogResponseBodyOpLogDetails(TeaModel):
    def __init__(self, op_log_detail=None):
        self.op_log_detail = op_log_detail  # type: list[GetOpLogResponseBodyOpLogDetailsOpLogDetail]

    def validate(self):
        if self.op_log_detail:
            for k in self.op_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetOpLogResponseBodyOpLogDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OpLogDetail'] = []
        if self.op_log_detail is not None:
            for k in self.op_log_detail:
                result['OpLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.op_log_detail = []
        if m.get('OpLogDetail') is not None:
            for k in m.get('OpLogDetail'):
                temp_model = GetOpLogResponseBodyOpLogDetailsOpLogDetail()
                self.op_log_detail.append(temp_model.from_map(k))
        return self


class GetOpLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, op_log_details=None, request_id=None, success=None,
                 total_count=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The details of the operation log.
        self.op_log_details = op_log_details  # type: GetOpLogResponseBodyOpLogDetails
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The total number of operation logs that are returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.op_log_details:
            self.op_log_details.validate()

    def to_map(self):
        _map = super(GetOpLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.op_log_details is not None:
            result['OpLogDetails'] = self.op_log_details.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OpLogDetails') is not None:
            temp_model = GetOpLogResponseBodyOpLogDetails()
            self.op_log_details = temp_model.from_map(m['OpLogDetails'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOpLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOpLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOpLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOpLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderAttachmentFileRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOrderAttachmentFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderAttachmentFileResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, file_url=None, request_id=None, success=None):
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request is successful.
        # *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section of this topic.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The download URL of the attachment.
        self.file_url = file_url  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOrderAttachmentFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderAttachmentFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOrderAttachmentFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOrderAttachmentFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderAttachmentFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderBaseInfoRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOrderBaseInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList(TeaModel):
    def __init__(self, user_ids=None):
        self.user_ids = user_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList(TeaModel):
    def __init__(self, user_nicks=None):
        self.user_nicks = user_nicks  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_nicks is not None:
            result['UserNicks'] = self.user_nicks
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('UserNicks') is not None:
            self.user_nicks = m.get('UserNicks')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfo(TeaModel):
    def __init__(self, comment=None, committer=None, committer_id=None, create_time=None, last_modify_time=None,
                 order_id=None, plugin_type=None, related_user_list=None, related_user_nick_list=None, status_code=None,
                 status_desc=None, workflow_instance_id=None, workflow_status_desc=None):
        # The remarks of the ticket.
        self.comment = comment  # type: str
        # The applicant.
        self.committer = committer  # type: str
        # The ID of the applicant. Note: The ID is different from the Alibaba Cloud account ID of the applicant.
        self.committer_id = committer_id  # type: long
        # The time when the ticket was created.
        self.create_time = create_time  # type: str
        # The time when the ticket was last modified.
        self.last_modify_time = last_modify_time  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The type of the ticket. For more information about the value of this parameter, see the request parameters of the [CreateOrder](~~465865~~) operation.
        self.plugin_type = plugin_type  # type: str
        # The IDs of the operators that are related to the ticket.
        self.related_user_list = related_user_list  # type: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList
        # The nicknames of the operators that are related to the ticket.
        self.related_user_nick_list = related_user_nick_list  # type: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList
        # The status code of the ticket. Valid values:
        # 
        # *   **new**: The ticket is created.
        # *   **toaudit**: The ticket is being reviewed.
        # *   **Approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **processing**: The ticket is being executed.
        # *   **success**: The ticket is executed.
        # *   **closed**: The ticket is closed.
        self.status_code = status_code  # type: str
        # The description of the status.
        self.status_desc = status_desc  # type: str
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id  # type: long
        # The description of the approval process.
        self.workflow_status_desc = workflow_status_desc  # type: str

    def validate(self):
        if self.related_user_list:
            self.related_user_list.validate()
        if self.related_user_nick_list:
            self.related_user_nick_list.validate()

    def to_map(self):
        _map = super(GetOrderBaseInfoResponseBodyOrderBaseInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list.to_map()
        if self.related_user_nick_list is not None:
            result['RelatedUserNickList'] = self.related_user_nick_list.to_map()
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList()
            self.related_user_list = temp_model.from_map(m['RelatedUserList'])
        if m.get('RelatedUserNickList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList()
            self.related_user_nick_list = temp_model.from_map(m['RelatedUserNickList'])
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetOrderBaseInfoResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, order_base_info=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The basic information about the ticket.
        self.order_base_info = order_base_info  # type: GetOrderBaseInfoResponseBodyOrderBaseInfo
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.order_base_info:
            self.order_base_info.validate()

    def to_map(self):
        _map = super(GetOrderBaseInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.order_base_info is not None:
            result['OrderBaseInfo'] = self.order_base_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OrderBaseInfo') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfo()
            self.order_base_info = temp_model.from_map(m['OrderBaseInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderBaseInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOrderBaseInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOrderBaseInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOwnerApplyOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail(TeaModel):
    def __init__(self, db_type=None, env_type=None, owner_ids=None, owner_nick_names=None, search_name=None,
                 table_name=None):
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The IDs of the original owners.
        self.owner_ids = owner_ids  # type: list[long]
        # The nicknames of the owners.
        self.owner_nick_names = owner_nick_names  # type: list[str]
        # The search name of the resource.
        self.search_name = search_name  # type: str
        # The name of the table.
        # 
        # > : This parameter is returned when you submit a Database-OWNER ticket.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources(TeaModel):
    def __init__(self, logic=None, resource_detail=None, target_id=None):
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The instance is a logical database.
        # *   **false**: The instance is not a logical database.
        self.logic = logic  # type: bool
        # The details of the resource.
        self.resource_detail = resource_detail  # type: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail
        # The ID of the resource.
        self.target_id = target_id  # type: str

    def validate(self):
        if self.resource_detail:
            self.resource_detail.validate()

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.resource_detail is not None:
            result['ResourceDetail'] = self.resource_detail.to_map()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('ResourceDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail()
            self.resource_detail = temp_model.from_map(m['ResourceDetail'])
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail(TeaModel):
    def __init__(self, apply_type=None, resources=None):
        # The type of the submitted ticket. Valid values:
        # 
        # *   **INSTANCE**: the ticket that applies for the permissions to be an instance owner
        # *   **DB**: the ticket that applies for the permissions to be a database owner
        # *   **TABLE**: the ticket that applies for the permissions to be a table owner
        self.apply_type = apply_type  # type: str
        # The details of the requested resource.
        self.resources = resources  # type: list[GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources]

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        return self


class GetOwnerApplyOrderDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, owner_apply_order_detail=None, request_id=None,
                 success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The details of the ticket.
        self.owner_apply_order_detail = owner_apply_order_detail  # type: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.owner_apply_order_detail:
            self.owner_apply_order_detail.validate()

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.owner_apply_order_detail is not None:
            result['OwnerApplyOrderDetail'] = self.owner_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OwnerApplyOrderDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail()
            self.owner_apply_order_detail = temp_model.from_map(m['OwnerApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOwnerApplyOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOwnerApplyOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOwnerApplyOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPermApplyOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~465867~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPermApplyOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo(TeaModel):
    def __init__(self, column_name=None, table_name=None):
        # The name of the column.
        self.column_name = column_name  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo(TeaModel):
    def __init__(self, db_id=None, db_type=None, env_type=None, logic=None, owner_ids=None, owner_nick_names=None,
                 search_name=None):
        # The database ID.
        self.db_id = db_id  # type: long
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic  # type: bool
        # The IDs of the owners of the database.
        self.owner_ids = owner_ids  # type: list[long]
        # The nicknames of the owners of the database.
        self.owner_nick_names = owner_nick_names  # type: list[str]
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo(TeaModel):
    def __init__(self, db_type=None, dba_id=None, dba_nick_name=None, env_type=None, host=None, instance_id=None,
                 owner_ids=None, owner_nick_name=None, port=None, search_name=None):
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The ID of the database administrator (DBA) of the instance.
        self.dba_id = dba_id  # type: long
        # The nickname of the DBA of the instance.
        self.dba_nick_name = dba_nick_name  # type: str
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The endpoint of the instance.
        self.host = host  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The IDs of the owners of the instance.
        self.owner_ids = owner_ids  # type: list[long]
        # The nicknames of the owners of the instance.
        self.owner_nick_name = owner_nick_name  # type: list[str]
        # The port that is used to connect to the instance.
        self.port = port  # type: long
        # The name that is used to search for the instance.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_name is not None:
            result['OwnerNickName'] = self.owner_nick_name
        if self.port is not None:
            result['Port'] = self.port
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickName') is not None:
            self.owner_nick_name = m.get('OwnerNickName')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo(TeaModel):
    def __init__(self, table_name=None):
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources(TeaModel):
    def __init__(self, column_info=None, database_info=None, instance_info=None, table_info=None):
        # The information about the column.
        self.column_info = column_info  # type: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo
        # The information about the database.
        self.database_info = database_info  # type: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo
        # The information about the instance.
        self.instance_info = instance_info  # type: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo
        # The information about the table.
        self.table_info = table_info  # type: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo

    def validate(self):
        if self.column_info:
            self.column_info.validate()
        if self.database_info:
            self.database_info.validate()
        if self.instance_info:
            self.instance_info.validate()
        if self.table_info:
            self.table_info.validate()

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_info is not None:
            result['ColumnInfo'] = self.column_info.to_map()
        if self.database_info is not None:
            result['DatabaseInfo'] = self.database_info.to_map()
        if self.instance_info is not None:
            result['InstanceInfo'] = self.instance_info.to_map()
        if self.table_info is not None:
            result['TableInfo'] = self.table_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo()
            self.column_info = temp_model.from_map(m['ColumnInfo'])
        if m.get('DatabaseInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo()
            self.database_info = temp_model.from_map(m['DatabaseInfo'])
        if m.get('InstanceInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo()
            self.instance_info = temp_model.from_map(m['InstanceInfo'])
        if m.get('TableInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo()
            self.table_info = temp_model.from_map(m['TableInfo'])
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail(TeaModel):
    def __init__(self, apply_type=None, perm_type=None, resources=None, seconds=None):
        # The type of objects on which you apply for permissions. Valid values:
        # 
        # *   **DB**: database
        # *   **TAB**: table
        # *   **COL**: column
        # *   **INSTANT**: instance
        self.apply_type = apply_type  # type: str
        # The type of the permissions that you apply for. Valid values:
        # 
        # *   **1**: the permissions to query information.
        # *   **2**: the permissions to export information.
        # *   **3**: the permissions to query and export information.
        # *   **4**: the permissions to modify information.
        # *   **5**: the permissions to query and modify information.
        # *   **6**: the permissions to export and modify information.
        # *   **7**: the permissions to query, export, and modify information.
        # *   **8**: the permissions to log on to the database.
        self.perm_type = perm_type  # type: long
        # The list of resources.
        self.resources = resources  # type: list[GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources]
        # The validity duration of the permissions. Unit: seconds.
        self.seconds = seconds  # type: long

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.seconds is not None:
            result['Seconds'] = self.seconds
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('Seconds') is not None:
            self.seconds = m.get('Seconds')
        return self


class GetPermApplyOrderDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, perm_apply_order_detail=None, request_id=None,
                 success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The details of the permission application ticket.
        self.perm_apply_order_detail = perm_apply_order_detail  # type: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.perm_apply_order_detail:
            self.perm_apply_order_detail.validate()

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.perm_apply_order_detail is not None:
            result['PermApplyOrderDetail'] = self.perm_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PermApplyOrderDetail') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail()
            self.perm_apply_order_detail = temp_model.from_map(m['PermApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPermApplyOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPermApplyOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPermApplyOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPermApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPhysicalDatabaseRequest(TeaModel):
    def __init__(self, db_id=None, tid=None):
        # The ID of the physical database. You can call the [SearchDatabase](~~141876~~) operation to obtain the ID.
        self.db_id = db_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPhysicalDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetPhysicalDatabaseResponseBodyDatabase(TeaModel):
    def __init__(self, catalog_name=None, database_id=None, db_type=None, dba_id=None, dba_name=None, encoding=None,
                 env_type=None, host=None, instance_alias=None, instance_id=None, owner_id_list=None, owner_name_list=None,
                 port=None, schema_name=None, search_name=None, sid=None, state=None):
        # The name of the catalog to which the database belongs.
        # 
        # > : If the database is a PostgreSQL database, the name of the database is displayed.
        self.catalog_name = catalog_name  # type: str
        # The ID of the physical database.
        self.database_id = database_id  # type: str
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The user ID of the DBA in the destination database.
        self.dba_id = dba_id  # type: str
        # The nickname of the database administrator (DBA) in the destination database.
        self.dba_name = dba_name  # type: str
        # The encoding format of the database.
        self.encoding = encoding  # type: str
        # The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The endpoint that is used to connect to the database.
        self.host = host  # type: str
        self.instance_alias = instance_alias  # type: str
        # The instance ID of the destination database.
        self.instance_id = instance_id  # type: str
        # The user IDs of the database owners.
        self.owner_id_list = owner_id_list  # type: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list  # type: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList
        # The port that is used to connect to the database.
        self.port = port  # type: int
        # The name of the database.
        # 
        # > : If the database is a PostgreSQL database, the name of the mode is displayed.
        self.schema_name = schema_name  # type: str
        # The name that is used for searching the database.
        self.search_name = search_name  # type: str
        # The system ID (SID) of the database.
        # 
        # > : The value of the parameter is returned only for Oracle databases.
        self.sid = sid  # type: str
        # The state of the database. Valid values:
        # 
        # *   **NORMAL**: The database is normal.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(GetPhysicalDatabaseResponseBodyDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetPhysicalDatabaseResponseBody(TeaModel):
    def __init__(self, database=None, error_code=None, error_message=None, request_id=None, success=None):
        # The information about the physical database.
        self.database = database  # type: GetPhysicalDatabaseResponseBodyDatabase
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super(GetPhysicalDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPhysicalDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPhysicalDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPhysicalDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPhysicalDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyRequest(TeaModel):
    def __init__(self, proxy_id=None, tid=None):
        # The ID of the secure access proxy. You can call the [ListProxies](~~295371~~) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetProxyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyResponseBody(TeaModel):
    def __init__(self, creator_id=None, creator_name=None, error_code=None, error_message=None, https_port=None,
                 instance_id=None, private_enable=None, private_host=None, protocol_port=None, protocol_type=None,
                 proxy_id=None, public_enable=None, public_host=None, region_id=None, request_id=None, success=None):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id  # type: long
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name  # type: str
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The port number used by the HTTPS protocol.
        self.https_port = https_port  # type: int
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # Indicates whether the internal endpoint was enabled. Default value: **true**.
        self.private_enable = private_enable  # type: bool
        # The internal endpoint.
        self.private_host = private_host  # type: str
        # The port number used by the protocol.
        self.protocol_port = protocol_port  # type: int
        # The protocol type of the database. Example: MYSQL.
        self.protocol_type = protocol_type  # type: str
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # Indicates whether the public endpoint was enabled. Valid values:
        # 
        # *   **true**: The public endpoint was enabled.
        # *   **false**: The public endpoint was disabled.
        self.public_enable = public_enable  # type: bool
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
        # 
        # > 
        # 
        # *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS is returned.
        # 
        # *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using Alibaba Cloud DNS is returned.
        self.public_host = public_host  # type: str
        # The ID of the region in which the instance resides.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetProxyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetProxyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetProxyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyAccessRequest(TeaModel):
    def __init__(self, proxy_access_id=None, tid=None):
        # The ID that Data Management (DMS) generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](~~295386~~) operation to query the ID.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetProxyAccessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyAccessResponseBodyProxyAccess(TeaModel):
    def __init__(self, access_id=None, gmt_create=None, indep_account=None, instance_id=None, origin_info=None,
                 proxy_access_id=None, proxy_id=None, user_id=None, user_name=None, user_uid=None):
        # The username of the database account that is authorized to enable the secure access proxy feature for an instance.
        self.access_id = access_id  # type: str
        # The time when the user is authorized to enable the secure access proxy feature for an instance.
        self.gmt_create = gmt_create  # type: str
        # The username of the independent database account.
        self.indep_account = indep_account  # type: str
        # The ID of the instance for which the secure access proxy feature is enabled.
        self.instance_id = instance_id  # type: long
        # The method that is used to authorize the user to enable the secure access proxy feature for an instance. Valid values:
        # 
        # *   **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the ID of the Alibaba Cloud account.
        # *   **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
        self.origin_info = origin_info  # type: str
        # The ID that DMS generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](~~295386~~) operation to query the ID.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the secure access proxy.
        # 
        # >  You can call the [ListProxies](~~295371~~) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # The ID of the user.
        self.user_id = user_id  # type: long
        # The nickname of the user.
        self.user_name = user_name  # type: str
        # The ID of the Alibaba Cloud account.
        self.user_uid = user_uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetProxyAccessResponseBodyProxyAccess, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class GetProxyAccessResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_access=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The authorization information about the secure access proxy feature.
        self.proxy_access = proxy_access  # type: GetProxyAccessResponseBodyProxyAccess
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.proxy_access:
            self.proxy_access.validate()

    def to_map(self):
        _map = super(GetProxyAccessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access is not None:
            result['ProxyAccess'] = self.proxy_access.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccess') is not None:
            temp_model = GetProxyAccessResponseBodyProxyAccess()
            self.proxy_access = temp_model.from_map(m['ProxyAccess'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyAccessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetProxyAccessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetProxyAccessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRuleNumLimitOfSLARequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetRuleNumLimitOfSLARequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetRuleNumLimitOfSLAResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, rule_num_limit=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The maximum number of SLA rules.
        self.rule_num_limit = rule_num_limit  # type: int
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetRuleNumLimitOfSLAResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_num_limit is not None:
            result['RuleNumLimit'] = self.rule_num_limit
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleNumLimit') is not None:
            self.rule_num_limit = m.get('RuleNumLimit')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRuleNumLimitOfSLAResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetRuleNumLimitOfSLAResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetRuleNumLimitOfSLAResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRuleNumLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewCheckResultStatusRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket. You can obtain the ticket ID from the response parameters of the [CreateSQLReviewOrder](~~257777~~) operation.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult(TeaModel):
    def __init__(self, check_not_pass=None, check_pass=None, force_not_pass=None, force_pass=None, new=None,
                 unknown=None):
        # The number of SQL statements that failed to pass the review.
        self.check_not_pass = check_not_pass  # type: long
        # The number of SQL statements that passed the review.
        self.check_pass = check_pass  # type: long
        # The number of SQL statements that failed to pass the manual review.
        self.force_not_pass = force_not_pass  # type: long
        # The number of SQL statements that passed the manual review.
        self.force_pass = force_pass  # type: long
        # The number of SQL statements to be reviewed.
        self.new = new  # type: long
        # The number of abnormal SQL statements.
        self.unknown = unknown  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_not_pass is not None:
            result['CheckNotPass'] = self.check_not_pass
        if self.check_pass is not None:
            result['CheckPass'] = self.check_pass
        if self.force_not_pass is not None:
            result['ForceNotPass'] = self.force_not_pass
        if self.force_pass is not None:
            result['ForcePass'] = self.force_pass
        if self.new is not None:
            result['New'] = self.new
        if self.unknown is not None:
            result['Unknown'] = self.unknown
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckNotPass') is not None:
            self.check_not_pass = m.get('CheckNotPass')
        if m.get('CheckPass') is not None:
            self.check_pass = m.get('CheckPass')
        if m.get('ForceNotPass') is not None:
            self.force_not_pass = m.get('ForceNotPass')
        if m.get('ForcePass') is not None:
            self.force_pass = m.get('ForcePass')
        if m.get('New') is not None:
            self.new = m.get('New')
        if m.get('Unknown') is not None:
            self.unknown = m.get('Unknown')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult(TeaModel):
    def __init__(self, must_improve=None, potential_issue=None, suggest_improve=None, table_index_suggest=None,
                 use_dms_dml_unlock=None, use_dms_toolkit=None):
        # The number of SQL statements that must be modified.
        self.must_improve = must_improve  # type: long
        # The number of SQL statements that have potential issues.
        self.potential_issue = potential_issue  # type: long
        # The number of SQL statements that can be modified.
        self.suggest_improve = suggest_improve  # type: long
        # The number of SQL statements that can use indexes.
        self.table_index_suggest = table_index_suggest  # type: long
        # The number of SQL statements that can be used for lock-free data changes.
        self.use_dms_dml_unlock = use_dms_dml_unlock  # type: long
        # The number of SQL statements that can be used for lock-free schema changes.
        self.use_dms_toolkit = use_dms_toolkit  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.must_improve is not None:
            result['MustImprove'] = self.must_improve
        if self.potential_issue is not None:
            result['PotentialIssue'] = self.potential_issue
        if self.suggest_improve is not None:
            result['SuggestImprove'] = self.suggest_improve
        if self.table_index_suggest is not None:
            result['TableIndexSuggest'] = self.table_index_suggest
        if self.use_dms_dml_unlock is not None:
            result['UseDmsDmlUnlock'] = self.use_dms_dml_unlock
        if self.use_dms_toolkit is not None:
            result['UseDmsToolkit'] = self.use_dms_toolkit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MustImprove') is not None:
            self.must_improve = m.get('MustImprove')
        if m.get('PotentialIssue') is not None:
            self.potential_issue = m.get('PotentialIssue')
        if m.get('SuggestImprove') is not None:
            self.suggest_improve = m.get('SuggestImprove')
        if m.get('TableIndexSuggest') is not None:
            self.table_index_suggest = m.get('TableIndexSuggest')
        if m.get('UseDmsDmlUnlock') is not None:
            self.use_dms_dml_unlock = m.get('UseDmsDmlUnlock')
        if m.get('UseDmsToolkit') is not None:
            self.use_dms_toolkit = m.get('UseDmsToolkit')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus(TeaModel):
    def __init__(self, check_status_result=None, checked_count=None, sqlreview_result=None, total_sqlcount=None):
        # The result of the SQL status check.
        self.check_status_result = check_status_result  # type: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult
        # The number of SQL statements that were reviewed.
        self.checked_count = checked_count  # type: long
        # The optimization suggestion for SQL statements.
        self.sqlreview_result = sqlreview_result  # type: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult
        # The total number of SQL statements.
        self.total_sqlcount = total_sqlcount  # type: long

    def validate(self):
        if self.check_status_result:
            self.check_status_result.validate()
        if self.sqlreview_result:
            self.sqlreview_result.validate()

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result.to_map()
        if self.checked_count is not None:
            result['CheckedCount'] = self.checked_count
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result.to_map()
        if self.total_sqlcount is not None:
            result['TotalSQLCount'] = self.total_sqlcount
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult()
            self.check_status_result = temp_model.from_map(m['CheckStatusResult'])
        if m.get('CheckedCount') is not None:
            self.checked_count = m.get('CheckedCount')
        if m.get('SQLReviewResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult()
            self.sqlreview_result = temp_model.from_map(m['SQLReviewResult'])
        if m.get('TotalSQLCount') is not None:
            self.total_sqlcount = m.get('TotalSQLCount')
        return self


class GetSQLReviewCheckResultStatusResponseBody(TeaModel):
    def __init__(self, check_result_status=None, error_code=None, error_message=None, request_id=None, success=None):
        # The result of the SQL review.
        self.check_result_status = check_result_status  # type: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.check_result_status:
            self.check_result_status.validate()

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result_status is not None:
            result['CheckResultStatus'] = self.check_result_status.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckResultStatus') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus()
            self.check_result_status = temp_model.from_map(m['CheckResultStatus'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewCheckResultStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSQLReviewCheckResultStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSQLReviewCheckResultStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewOptimizeDetailRequest(TeaModel):
    def __init__(self, sqlreview_query_key=None, tid=None):
        # The key that is used to query the details of optimization suggestions. You can call the [ListSQLReviewOriginSQL](~~257870~~) operation to query the key.
        self.sqlreview_query_key = sqlreview_query_key  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts(TeaModel):
    def __init__(self, content=None, op_type=None, table_name=None):
        # The content of the SQL script.
        self.content = content  # type: str
        # The purpose of the SQL script. The value is set to AddIndex.
        self.op_type = op_type  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults(TeaModel):
    def __init__(self, comments=None, feedback=None, messages=None, rule_name=None, rule_type=None, scripts=None):
        # The comment that is specified when you create the SQL review rule. For more information, see [SQL review optimization](~~194114~~).
        self.comments = comments  # type: str
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
        self.feedback = feedback  # type: str
        # The review results.
        self.messages = messages  # type: list[str]
        # The name of the rule. For more information, see [SQL review optimization](~~194114~~).
        self.rule_name = rule_name  # type: str
        # The type of the SQL review rule. Valid values:
        # 
        # *   **REVIEW**: a rule that is used to review SQL statements based on standards.
        # *   **OPTIMIZE**: a rule that is used to provide optimization suggestions.
        self.rule_type = rule_type  # type: str
        # The SQL script for data changes.
        self.scripts = scripts  # type: list[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts]

    def validate(self):
        if self.scripts:
            for k in self.scripts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.messages is not None:
            result['Messages'] = self.messages
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        result['Scripts'] = []
        if self.scripts is not None:
            for k in self.scripts:
                result['Scripts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('Messages') is not None:
            self.messages = m.get('Messages')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        self.scripts = []
        if m.get('Scripts') is not None:
            for k in m.get('Scripts'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts()
                self.scripts.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult(TeaModel):
    def __init__(self, error_message=None, occur_error=None, results=None):
        # The error message returned.
        self.error_message = error_message  # type: str
        # Indicates whether an error occurs. Valid values:
        # 
        # *   **true**: An error occurs.
        # *   **false**: No error occurs.
        self.occur_error = occur_error  # type: bool
        # The review results based on rules.
        self.results = results  # type: list[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults]

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.occur_error is not None:
            result['OccurError'] = self.occur_error
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OccurError') is not None:
            self.occur_error = m.get('OccurError')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults()
                self.results.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail(TeaModel):
    def __init__(self, db_id=None, instance_id=None, quality_result=None, query_key=None, sql_type=None):
        # The ID of the database.
        self.db_id = db_id  # type: int
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id  # type: int
        # The quality of the SQL statement.
        self.quality_result = quality_result  # type: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult
        # The key that is used to query the details of optimization suggestions.
        self.query_key = query_key  # type: str
        # The type of the SQL statement. Valid values: DELETE, UPDATE, and ALTER_TABLE.
        self.sql_type = sql_type  # type: str

    def validate(self):
        if self.quality_result:
            self.quality_result.validate()

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.quality_result is not None:
            result['QualityResult'] = self.quality_result.to_map()
        if self.query_key is not None:
            result['QueryKey'] = self.query_key
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('QualityResult') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult()
            self.quality_result = temp_model.from_map(m['QualityResult'])
        if m.get('QueryKey') is not None:
            self.query_key = m.get('QueryKey')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetSQLReviewOptimizeDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, optimize_detail=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The details of optimization suggestions for SQL statements.
        self.optimize_detail = optimize_detail  # type: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.optimize_detail:
            self.optimize_detail.validate()

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.optimize_detail is not None:
            result['OptimizeDetail'] = self.optimize_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OptimizeDetail') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail()
            self.optimize_detail = temp_model.from_map(m['OptimizeDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewOptimizeDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSQLReviewOptimizeDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSQLReviewOptimizeDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncExecSqlDetailRequest(TeaModel):
    def __init__(self, order_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncExecSqlDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail(TeaModel):
    def __init__(self, exec_sql=None, total_sql_count=None):
        # The SQL statements that are executed.
        self.exec_sql = exec_sql  # type: str
        # The total number of SQL statements.
        self.total_sql_count = total_sql_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSql'] = self.exec_sql
        if self.total_sql_count is not None:
            result['TotalSqlCount'] = self.total_sql_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecSql') is not None:
            self.exec_sql = m.get('ExecSql')
        if m.get('TotalSqlCount') is not None:
            self.total_sql_count = m.get('TotalSqlCount')
        return self


class GetStructSyncExecSqlDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, struct_sync_exec_sql_detail=None,
                 success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the SQL statements.
        self.struct_sync_exec_sql_detail = struct_sync_exec_sql_detail  # type: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.struct_sync_exec_sql_detail:
            self.struct_sync_exec_sql_detail.validate()

    def to_map(self):
        _map = super(GetStructSyncExecSqlDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_exec_sql_detail is not None:
            result['StructSyncExecSqlDetail'] = self.struct_sync_exec_sql_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncExecSqlDetail') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail()
            self.struct_sync_exec_sql_detail = temp_model.from_map(m['StructSyncExecSqlDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncExecSqlDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetStructSyncExecSqlDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetStructSyncExecSqlDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobAnalyzeResultRequest(TeaModel):
    def __init__(self, compare_type=None, order_id=None, page_number=None, page_size=None, tid=None):
        # The type of the comparison. Valid values:
        # 
        # *   **CREATE_TABLE**: compares the created tables.
        # *   **ALTER_TABLE**: compares the modified tables.
        # *   **EQUAL_TABLE**: compares the identical tables.
        # *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
        # *   **NOT_COMPARE**: does not compare tables.
        self.compare_type = compare_type  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList(TeaModel):
    def __init__(self, script=None, source_table_name=None, target_table_name=None):
        # The SQL script.
        self.script = script  # type: str
        # The name of the source table.
        self.source_table_name = source_table_name  # type: str
        # The name of the destination table.
        self.target_table_name = target_table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.script is not None:
            result['Script'] = self.script
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList(TeaModel):
    def __init__(self, compare_type=None, count=None):
        # The type of the comparison. Valid values:
        # 
        # *   **CREATE_TABLE**: compares the created tables.
        # *   **ALTER_TABLE**: compares the modified tables.
        # *   **EQUAL_TABLE**: compares the identical tables.
        # *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
        # *   **NOT_COMPARE**: does not compare tables.
        self.compare_type = compare_type  # type: str
        # The number of tables.
        self.count = count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult(TeaModel):
    def __init__(self, result_list=None, summary_list=None):
        # The details of the analysis results.
        self.result_list = result_list  # type: list[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList]
        # The statistics on the analysis results.
        self.summary_list = summary_list  # type: list[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList]

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()
        if self.summary_list:
            for k in self.summary_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        result['SummaryList'] = []
        if self.summary_list is not None:
            for k in self.summary_list:
                result['SummaryList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList()
                self.result_list.append(temp_model.from_map(k))
        self.summary_list = []
        if m.get('SummaryList') is not None:
            for k in m.get('SummaryList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList()
                self.summary_list.append(temp_model.from_map(k))
        return self


class GetStructSyncJobAnalyzeResultResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, struct_sync_job_analyze_result=None,
                 success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The analysis result of the schema synchronization task.
        self.struct_sync_job_analyze_result = struct_sync_job_analyze_result  # type: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.struct_sync_job_analyze_result:
            self.struct_sync_job_analyze_result.validate()

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_analyze_result is not None:
            result['StructSyncJobAnalyzeResult'] = self.struct_sync_job_analyze_result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobAnalyzeResult') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult()
            self.struct_sync_job_analyze_result = temp_model.from_map(m['StructSyncJobAnalyzeResult'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobAnalyzeResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetStructSyncJobAnalyzeResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetStructSyncJobAnalyzeResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ticket ID.
        self.order_id = order_id  # type: long
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncJobDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobDetailResponseBodyStructSyncJobDetail(TeaModel):
    def __init__(self, dbtask_group_id=None, execute_count=None, job_status=None, message=None, security_rule=None,
                 sql_count=None, table_analyzed=None, table_count=None):
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id  # type: long
        # The number of SQL statements that have been executed.
        self.execute_count = execute_count  # type: long
        # The status of the task. Valid values:
        # 
        # *   **NEW**: The task was created.
        # *   **COMPARING**: The schemas of tables were being compared.
        # *   **COMPARE_BREAK**: The schema comparison was interrupted.
        # *   **COMPARE_FINISH**: The comparison was finished.
        # *   **NOT_SCRIPTS**: The comparison was finished but no executable script was available.
        # *   **SUBMITED_DBTASK**: The task was submitted.
        # *   **DBTASK_SUCCESS**: The task was complete.
        # *   **SUBMITED_WORKFLOW**: The ticket was submitted.
        # *   **WORKFLOW_SUCCESS**: The ticket was approved.
        self.job_status = job_status  # type: str
        # The description of the task.
        self.message = message  # type: str
        # The type of security rule. Valid values:
        # 
        # *   **CANNOT_SYNC**: Synchronization cannot be performed.
        # *   **WITH_APPROVE**: The schema synchronization can be performed after the ticket is approved. You can call the [SubmitStructSyncOrderApproval](~~206166~~) operation to submit the ticket for approval.
        # *   **WITHOUT_APPROVE**: The schema synchronization can be performed without approval.
        self.security_rule = security_rule  # type: str
        # The total number of SQL statements.
        self.sql_count = sql_count  # type: long
        # The number of tables that have been analyzed.
        self.table_analyzed = table_analyzed  # type: long
        # The total number of tables.
        self.table_count = table_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncJobDetailResponseBodyStructSyncJobDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.message is not None:
            result['Message'] = self.message
        if self.security_rule is not None:
            result['SecurityRule'] = self.security_rule
        if self.sql_count is not None:
            result['SqlCount'] = self.sql_count
        if self.table_analyzed is not None:
            result['TableAnalyzed'] = self.table_analyzed
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('SecurityRule') is not None:
            self.security_rule = m.get('SecurityRule')
        if m.get('SqlCount') is not None:
            self.sql_count = m.get('SqlCount')
        if m.get('TableAnalyzed') is not None:
            self.table_analyzed = m.get('TableAnalyzed')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        return self


class GetStructSyncJobDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, struct_sync_job_detail=None,
                 success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The details of the schema synchronization task.
        self.struct_sync_job_detail = struct_sync_job_detail  # type: GetStructSyncJobDetailResponseBodyStructSyncJobDetail
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.struct_sync_job_detail:
            self.struct_sync_job_detail.validate()

    def to_map(self):
        _map = super(GetStructSyncJobDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_detail is not None:
            result['StructSyncJobDetail'] = self.struct_sync_job_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobDetail') is not None:
            temp_model = GetStructSyncJobDetailResponseBodyStructSyncJobDetail()
            self.struct_sync_job_detail = temp_model.from_map(m['StructSyncJobDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetStructSyncJobDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetStructSyncJobDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncOrderDetailRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo(TeaModel):
    def __init__(self, db_id=None, db_type=None, env_type=None, logic=None, search_name=None):
        # The ID of the source database.
        self.db_id = db_id  # type: long
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database
        self.logic = logic  # type: bool
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo(TeaModel):
    def __init__(self, version_id=None):
        # The version number.
        self.version_id = version_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList(TeaModel):
    def __init__(self, source_table_name=None, target_table_name=None):
        # The name of the table whose schema you want to synchronize.
        self.source_table_name = source_table_name  # type: str
        # The name of the table to which you want to synchronize the schema of a table.
        self.target_table_name = target_table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo(TeaModel):
    def __init__(self, db_id=None, db_type=None, env_type=None, logic=None, search_name=None):
        # The ID of the destination database.
        self.db_id = db_id  # type: long
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database
        self.logic = logic  # type: bool
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo(TeaModel):
    def __init__(self, version_id=None):
        # The version number.
        self.version_id = version_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail(TeaModel):
    def __init__(self, ignore_error=None, source_database_info=None, source_type=None, source_version_info=None,
                 table_info_list=None, target_database_info=None, target_type=None, target_version_info=None):
        # Indicates whether to skip errors. Valid values:
        # 
        # *   **true**: skips the error and continues to execute SQL statements.
        # *   **false**: stops executing SQL statements.
        self.ignore_error = ignore_error  # type: bool
        # The information about the source database.
        self.source_database_info = source_database_info  # type: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo
        # The schema version of the source database. Valid values:
        # 
        # *   **DATASOURCE**: the default latest version of the system
        # *   **VERSION**: a previous schema version that you manually specify
        self.source_type = source_type  # type: str
        # The version information about the source instance.
        # 
        # > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
        self.source_version_info = source_version_info  # type: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo
        # The information about the table whose schema you want to synchronize.
        self.table_info_list = table_info_list  # type: list[GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList]
        # The information about the destination database.
        self.target_database_info = target_database_info  # type: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo
        # The schema version of the destination database. Valid values:
        # 
        # *   **DATASOURCE**: the default latest version of the system
        # *   **VERSION**: a previous schema version that you manually specify
        self.target_type = target_type  # type: str
        # The version information about the destination instance.
        # 
        # > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
        self.target_version_info = target_version_info  # type: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo

    def validate(self):
        if self.source_database_info:
            self.source_database_info.validate()
        if self.source_version_info:
            self.source_version_info.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target_database_info:
            self.target_database_info.validate()
        if self.target_version_info:
            self.target_version_info.validate()

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source_database_info is not None:
            result['SourceDatabaseInfo'] = self.source_database_info.to_map()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_version_info is not None:
            result['SourceVersionInfo'] = self.source_version_info.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target_database_info is not None:
            result['TargetDatabaseInfo'] = self.target_database_info.to_map()
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.target_version_info is not None:
            result['TargetVersionInfo'] = self.target_version_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('SourceDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo()
            self.source_database_info = temp_model.from_map(m['SourceDatabaseInfo'])
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo()
            self.source_version_info = temp_model.from_map(m['SourceVersionInfo'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('TargetDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo()
            self.target_database_info = temp_model.from_map(m['TargetDatabaseInfo'])
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TargetVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo()
            self.target_version_info = temp_model.from_map(m['TargetVersionInfo'])
        return self


class GetStructSyncOrderDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, struct_sync_order_detail=None,
                 success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the schema synchronization ticket.
        self.struct_sync_order_detail = struct_sync_order_detail  # type: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.struct_sync_order_detail:
            self.struct_sync_order_detail.validate()

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_order_detail is not None:
            result['StructSyncOrderDetail'] = self.struct_sync_order_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncOrderDetail') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail()
            self.struct_sync_order_detail = temp_model.from_map(m['StructSyncOrderDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncOrderDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetStructSyncOrderDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetStructSyncOrderDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableDBTopologyRequest(TeaModel):
    def __init__(self, table_guid=None, tid=None):
        # The GUID of the table in DMS.
        # 
        # > 
        # 
        # *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](~~141875~~) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
        # 
        # *   If the database to which the table belongs is a physical database, you can call the [ListTables](~~141878~~) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
        self.table_guid = table_guid  # type: str
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTableDBTopologyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList(TeaModel):
    def __init__(self, table_id=None, table_name=None, table_type=None):
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The name of the physical table.
        self.table_name = table_name  # type: str
        # The type of the table. This is a reserved parameter.
        self.table_type = table_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList(TeaModel):
    def __init__(self, db_id=None, db_name=None, db_type=None, env_type=None, table_list=None):
        # The ID of the database.
        self.db_id = db_id  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: staging environment
        # 
        # > For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The physical tables.
        self.table_list = table_list  # type: list[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList]

    def validate(self):
        if self.table_list:
            for k in self.table_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        result['TableList'] = []
        if self.table_list is not None:
            for k in self.table_list:
                result['TableList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        self.table_list = []
        if m.get('TableList') is not None:
            for k in m.get('TableList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList()
                self.table_list.append(temp_model.from_map(k))
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceList(TeaModel):
    def __init__(self, database_list=None, db_type=None, host=None, port=None, sid=None):
        # The physical databases.
        self.database_list = database_list  # type: list[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList]
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The endpoint of the data source.
        self.host = host  # type: str
        # The port that is used to connect to the data source.
        self.port = port  # type: int
        # The system ID (SID) of the data source.
        self.sid = sid  # type: str

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTableDBTopologyResponseBodyDBTopologyDataSourceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList()
                self.database_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class GetTableDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(self, data_source_list=None, table_guid=None, table_name=None):
        # The data sources.
        self.data_source_list = data_source_list  # type: list[GetTableDBTopologyResponseBodyDBTopologyDataSourceList]
        # The GUID of the table in DMS.
        self.table_guid = table_guid  # type: str
        # The name of the table.
        # 
        # > 
        # 
        # *   If a logical table is queried, the name of the logical table is returned.
        # 
        # *   If a physical table is queried, the name of the physical table is returned.
        self.table_name = table_name  # type: str

    def validate(self):
        if self.data_source_list:
            for k in self.data_source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTableDBTopologyResponseBodyDBTopology, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSourceList'] = []
        if self.data_source_list is not None:
            for k in self.data_source_list:
                result['DataSourceList'].append(k.to_map() if k else None)
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_source_list = []
        if m.get('DataSourceList') is not None:
            for k in m.get('DataSourceList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceList()
                self.data_source_list.append(temp_model.from_map(k))
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetTableDBTopologyResponseBody(TeaModel):
    def __init__(self, dbtopology=None, error_code=None, error_message=None, request_id=None, success=None):
        # The topology of the data table.
        self.dbtopology = dbtopology  # type: GetTableDBTopologyResponseBodyDBTopology
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super(GetTableDBTopologyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetTableDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTableDBTopologyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTableDBTopologyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTableDBTopologyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableTopologyRequest(TeaModel):
    def __init__(self, table_guid=None, tid=None):
        # The GUID of the table in Data Management (DMS).
        # 
        # > 
        # > - You can call the [ListLogicTables](~~141875~~) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
        # > - You can call the [ListTables](~~141878~~) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
        self.table_guid = table_guid  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Tenant information](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTableTopologyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList(TeaModel):
    def __init__(self, db_id=None, db_name=None, db_search_name=None, db_type=None, instance_id=None,
                 instance_resource_id=None, instance_source=None, region_id=None, table_count=None, table_name_expr=None,
                 table_name_list=None):
        # The ID of the physical database.
        self.db_id = db_id  # type: long
        # The name of the database.
        self.db_name = db_name  # type: str
        # The name that is used to search for the database.
        # > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
        self.db_search_name = db_search_name  # type: str
        # The database engine.
        self.db_type = db_type  # type: str
        # The ID of the instance to which the physical database belongs.
        self.instance_id = instance_id  # type: long
        # The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
        # 
        # *   **RDS**:The ID of the ApsaraDB RDS instance.
        # *   **ECS_OWN**: The ID of the Elastic Compute Service (ECS) instance.
        # *   **PUBLIC_OWN**: This parameter is left empty for self-managed database instances that are connected over the Internet.
        # *   **VPC_ID**:The ID of the virtual private cloud (VPC).
        # *   **GATEWAY**: The ID of the database gateway.
        self.instance_resource_id = instance_resource_id  # type: str
        # The type of the database instance. Valid values:
        # 
        # *   **RDS**: an ApsaraDB RDS instance.
        # *   **ECS_OWN**: a self-managed database that is deployed on an ECS instance
        # *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
        # *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
        # *   **GATEWAY**: a database instance connected by using a database gateway.
        self.instance_source = instance_source  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The number of tables.
        self.table_count = table_count  # type: long
        # The expression of the names of logical tables.
        # 
        # **\
        # 
        # **Description** This parameter is not returned for physical tables.
        self.table_name_expr = table_name_expr  # type: str
        # The names of tables.
        # 
        # > The table names are separated by commas (,).
        self.table_name_list = table_name_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_name_expr is not None:
            result['TableNameExpr'] = self.table_name_expr
        if self.table_name_list is not None:
            result['TableNameList'] = self.table_name_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableNameExpr') is not None:
            self.table_name_expr = m.get('TableNameExpr')
        if m.get('TableNameList') is not None:
            self.table_name_list = m.get('TableNameList')
        return self


class GetTableTopologyResponseBodyTableTopology(TeaModel):
    def __init__(self, logic=None, table_guid=None, table_name=None, table_topology_info_list=None):
        # Indicates whether the table is a logical table. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic  # type: bool
        # The GUID of the table in DMS.
        self.table_guid = table_guid  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # Information of the topology of the table.
        self.table_topology_info_list = table_topology_info_list  # type: list[GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList]

    def validate(self):
        if self.table_topology_info_list:
            for k in self.table_topology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTableTopologyResponseBodyTableTopology, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        result['TableTopologyInfoList'] = []
        if self.table_topology_info_list is not None:
            for k in self.table_topology_info_list:
                result['TableTopologyInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        self.table_topology_info_list = []
        if m.get('TableTopologyInfoList') is not None:
            for k in m.get('TableTopologyInfoList'):
                temp_model = GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList()
                self.table_topology_info_list.append(temp_model.from_map(k))
        return self


class GetTableTopologyResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, table_topology=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The topology information.
        self.table_topology = table_topology  # type: GetTableTopologyResponseBodyTableTopology

    def validate(self):
        if self.table_topology:
            self.table_topology.validate()

    def to_map(self):
        _map = super(GetTableTopologyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_topology is not None:
            result['TableTopology'] = self.table_topology.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableTopology') is not None:
            temp_model = GetTableTopologyResponseBodyTableTopology()
            self.table_topology = temp_model.from_map(m['TableTopology'])
        return self


class GetTableTopologyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTableTopologyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTableTopologyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskRequest(TeaModel):
    def __init__(self, node_id=None, tid=None):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskResponseBodyTask(TeaModel):
    def __init__(self, dag_id=None, graph_param=None, node_config=None, node_content=None, node_name=None,
                 node_output=None, node_type=None, time_variables=None):
        # The ID of the task flow to which the node belongs.
        self.dag_id = dag_id  # type: long
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param  # type: str
        # The advanced configuration for the node.
        self.node_config = node_config  # type: str
        # The configuration for the node.
        self.node_content = node_content  # type: str
        # The name of the node.
        self.node_name = node_name  # type: str
        # The output variables for the node. This parameter is available only for some types of nodes.
        self.node_output = node_output  # type: str
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type  # type: str
        # The time variables configured for the node.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskResponseBodyTask, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, task=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The task node.
        self.task = task  # type: GetTaskResponseBodyTask

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super(GetTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Task') is not None:
            temp_model = GetTaskResponseBodyTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class GetTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowGraphRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskFlowGraphRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge(TeaModel):
    def __init__(self, dag_id=None, id=None, node_end=None, node_from=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the task flow edge.
        self.id = id  # type: long
        # The ID of the end node on the edge.
        self.node_end = node_end  # type: long
        # The ID of the start node on the edge.
        self.node_from = node_from  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges(TeaModel):
    def __init__(self, edge=None):
        self.edge = edge  # type: list[GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge]

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBodyTaskFlowGraphEdges, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode(TeaModel):
    def __init__(self, dag_id=None, graph_param=None, node_config=None, node_content=None, node_id=None,
                 node_name=None, node_type=None, time_variables=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The position of the node in the DAG.
        self.graph_param = graph_param  # type: str
        # The advanced configuration of the node.
        self.node_config = node_config  # type: str
        # The configuration of the node.
        self.node_content = node_content  # type: str
        # The ID of the node.
        self.node_id = node_id  # type: long
        # The name of the node.
        self.node_name = node_name  # type: str
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type  # type: long
        # The time variables for the node.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes(TeaModel):
    def __init__(self, node=None):
        self.node = node  # type: list[GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode]

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBodyTaskFlowGraphNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraph(TeaModel):
    def __init__(self, can_edit=None, dag_name=None, edges=None, nodes=None, status=None):
        # Indicates whether the task flow is editable. Valid values:
        # 
        # - **true**: editable
        # - **false**: non-editable
        self.can_edit = can_edit  # type: bool
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The list of task flow edges.
        self.edges = edges  # type: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges
        # The node list of the task flow.
        self.nodes = nodes  # type: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: not scheduled
        # - **2**: to be scheduled
        self.status = status  # type: long

    def validate(self):
        if self.edges:
            self.edges.validate()
        if self.nodes:
            self.nodes.validate()

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBodyTaskFlowGraph, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.nodes is not None:
            result['Nodes'] = self.nodes.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Edges') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('Nodes') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodes()
            self.nodes = temp_model.from_map(m['Nodes'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskFlowGraphResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, task_flow_graph=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The list of DAG variables of the task flow.
        self.task_flow_graph = task_flow_graph  # type: GetTaskFlowGraphResponseBodyTaskFlowGraph

    def validate(self):
        if self.task_flow_graph:
            self.task_flow_graph.validate()

    def to_map(self):
        _map = super(GetTaskFlowGraphResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_graph is not None:
            result['TaskFlowGraph'] = self.task_flow_graph.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowGraph') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraph()
            self.task_flow_graph = temp_model.from_map(m['TaskFlowGraph'])
        return self


class GetTaskFlowGraphResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTaskFlowGraphResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTaskFlowGraphResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowGraphResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowNotificationRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskFlowNotificationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowNotificationResponseBodyNotification(TeaModel):
    def __init__(self, dag_notification_fail=None, dag_notification_sla=None, dag_notification_success=None):
        # Indicates whether notifications for failed task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_fail = dag_notification_fail  # type: bool
        # Indicates whether service level agreement (SLA) global notifications for task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_sla = dag_notification_sla  # type: bool
        # Indicates whether notifications for successful task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_success = dag_notification_success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskFlowNotificationResponseBodyNotification, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        return self


class GetTaskFlowNotificationResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, notification=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The notification settings specified by the user.
        self.notification = notification  # type: GetTaskFlowNotificationResponseBodyNotification
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.notification:
            self.notification.validate()

    def to_map(self):
        _map = super(GetTaskFlowNotificationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Notification') is not None:
            temp_model = GetTaskFlowNotificationResponseBodyNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskFlowNotificationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTaskFlowNotificationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTaskFlowNotificationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceRelationRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to obtain the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskInstanceRelationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskInstanceRelationResponseBodyNodeListNode(TeaModel):
    def __init__(self, business_time=None, end_time=None, execute_time=None, id=None, message=None, node_id=None,
                 node_name=None, node_type=None, status=None):
        # The business time of the node.
        self.business_time = business_time  # type: str
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time  # type: str
        # The amount of time consumed for running the node. Unit: milliseconds.
        self.execute_time = execute_time  # type: long
        # The ID of the execution record of the task flow.
        self.id = id  # type: long
        # The description of the task.
        self.message = message  # type: str
        # The ID of the node.
        self.node_id = node_id  # type: long
        # The name of the node.
        self.node_name = node_name  # type: str
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type  # type: int
        # The status of the node. Valid values:
        # 
        # *   **0**: The node is waiting to be scheduled.
        # *   **1**: The node is running.
        # *   **2**: The node is suspended.
        # *   **3**: The node failed to run.
        # *   **4**: The node is run.
        # *   **5**: The node is complete.
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTaskInstanceRelationResponseBodyNodeListNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskInstanceRelationResponseBodyNodeList(TeaModel):
    def __init__(self, node=None):
        self.node = node  # type: list[GetTaskInstanceRelationResponseBodyNodeListNode]

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTaskInstanceRelationResponseBodyNodeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskInstanceRelationResponseBodyNodeListNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskInstanceRelationResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, node_list=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The information about the nodes in the execution record of the task flow.
        self.node_list = node_list  # type: GetTaskInstanceRelationResponseBodyNodeList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.node_list:
            self.node_list.validate()

    def to_map(self):
        _map = super(GetTaskInstanceRelationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_list is not None:
            result['NodeList'] = self.node_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeList') is not None:
            temp_model = GetTaskInstanceRelationResponseBodyNodeList()
            self.node_list = temp_model.from_map(m['NodeList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskInstanceRelationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTaskInstanceRelationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTaskInstanceRelationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserRequest(TeaModel):
    def __init__(self, tid=None, uid=None, user_id=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The UID of the Alibaba Cloud account. You can view your UID by moving the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console.
        self.uid = uid  # type: str
        # The ID of the user. You can call the [ListUsers](~~141938~~) operation to query the ID of the user.
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetUserResponseBodyUserRoleIdList(TeaModel):
    def __init__(self, role_ids=None):
        self.role_ids = role_ids  # type: list[int]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserResponseBodyUserRoleIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class GetUserResponseBodyUserRoleNameList(TeaModel):
    def __init__(self, role_names=None):
        self.role_names = role_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserResponseBodyUserRoleNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class GetUserResponseBodyUser(TeaModel):
    def __init__(self, cur_execute_count=None, cur_result_count=None, ding_robot=None, email=None,
                 last_login_time=None, max_execute_count=None, max_result_count=None, mobile=None, nick_name=None,
                 notification_mode=None, parent_uid=None, role_id_list=None, role_name_list=None, signature_method=None, state=None,
                 uid=None, user_id=None, webhook=None):
        # The number of queries that are performed on the current day.
        self.cur_execute_count = cur_execute_count  # type: long
        # The number of rows that are queried on the current day.
        self.cur_result_count = cur_result_count  # type: long
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot  # type: str
        # The email address that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set an email address.
        self.email = email  # type: str
        # The last point in time when the user logged on to the console.
        self.last_login_time = last_login_time  # type: str
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count  # type: long
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count  # type: long
        # The mobile number of the user.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set a mobile phone number.
        self.mobile = mobile  # type: str
        # The nickname of the user.
        self.nick_name = nick_name  # type: str
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message
        # *   **EMAIL**: email.
        # *   **DINGDING**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode  # type: str
        # The UID of the Alibaba Cloud account of the user.
        # 
        # > An Alibaba Cloud account can contain one or more RAM users.
        self.parent_uid = parent_uid  # type: long
        # The list of role IDs.
        self.role_id_list = role_id_list  # type: GetUserResponseBodyUserRoleIdList
        # The list of role names.
        self.role_name_list = role_name_list  # type: GetUserResponseBodyUserRoleNameList
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC_SHA1.
        self.signature_method = signature_method  # type: str
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state  # type: str
        # The UID of the user.
        self.uid = uid  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: str
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
        # 
        # *   The system does not return this parameter if the user has not set a webhook URL.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super(GetUserResponseBodyUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = GetUserResponseBodyUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = GetUserResponseBodyUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class GetUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, user=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The information about the user.
        self.user = user  # type: GetUserResponseBodyUser

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super(GetUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.user is not None:
            result['User'] = self.user.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('User') is not None:
            temp_model = GetUserResponseBodyUser()
            self.user = temp_model.from_map(m['User'])
        return self


class GetUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserActiveTenantRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserActiveTenantRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBodyTenant(TeaModel):
    def __init__(self, status=None, tenant_name=None, tid=None):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status  # type: str
        # The name of the tenant.
        self.tenant_name = tenant_name  # type: str
        # The ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserActiveTenantResponseBodyTenant, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, tenant=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The details of the tenant.
        self.tenant = tenant  # type: GetUserActiveTenantResponseBodyTenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        _map = super(GetUserActiveTenantResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tenant is not None:
            result['Tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tenant') is not None:
            temp_model = GetUserActiveTenantResponseBodyTenant()
            self.tenant = temp_model.from_map(m['Tenant'])
        return self


class GetUserActiveTenantResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetUserActiveTenantResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetUserActiveTenantResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserActiveTenantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserUploadFileJobRequest(TeaModel):
    def __init__(self, job_key=None, tid=None):
        # The key of the file upload task. The key is returned when you call the [CreateUploadFileJob](~~206059~~) or [CreateUploadOSSFileJob](~~206060~~) operation.
        self.job_key = job_key  # type: str
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserUploadFileJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam(TeaModel):
    def __init__(self, bucket_name=None, endpoint=None, object_name=None):
        # The name of the OSS bucket.
        self.bucket_name = bucket_name  # type: str
        # The endpoint of the OSS bucket.
        self.endpoint = endpoint  # type: str
        # The name of the OSS object.
        self.object_name = object_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetail(TeaModel):
    def __init__(self, attachment_key=None, file_name=None, file_size=None, file_source=None, job_key=None,
                 job_status=None, job_status_desc=None, upload_ossparam=None, upload_type=None, upload_url=None,
                 uploaded_size=None):
        # The key of the file that is returned after the file is uploaded. You can use this key when you upload the file as an attachment in a ticket.
        self.attachment_key = attachment_key  # type: str
        # The name of the file.
        self.file_name = file_name  # type: str
        # The size of the file. Unit: byte.
        self.file_size = file_size  # type: long
        # The purpose of the uploaded file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source  # type: str
        # The key of the file upload task.
        self.job_key = job_key  # type: str
        # The status of the file upload task. Valid values:
        # 
        # *   **INIT**: The file upload task was initialized.
        # *   **PENDING**: The file upload task waited to be run.
        # *   **BE_SCHEDULED**: The file upload task waited to be scheduled.
        # *   **FAIL**: The file upload task failed.
        # *   **SUCCESS**: The file upload task was successful.
        # *   **RUNNING**: The file upload task was being run.
        self.job_status = job_status  # type: str
        # The information about the status of the file upload task.
        self.job_status_desc = job_status_desc  # type: str
        # The information about the Object Storage Service (OSS) bucket from which the file is uploaded.
        # 
        # > This parameter is returned if the value of **UploadType** is **OSS**.
        self.upload_ossparam = upload_ossparam  # type: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam
        # The method used to upload the file. Valid values:
        # 
        # *   **URL**\
        # *   **OSS**\
        self.upload_type = upload_type  # type: str
        # The URL of the file.
        # 
        # > This parameter is returned if the value of **UploadType** is **URL**.
        self.upload_url = upload_url  # type: str
        # The size of the uploaded file. Unit: byte.
        self.uploaded_size = uploaded_size  # type: long

    def validate(self):
        if self.upload_ossparam:
            self.upload_ossparam.validate()

    def to_map(self):
        _map = super(GetUserUploadFileJobResponseBodyUploadFileJobDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_status_desc is not None:
            result['JobStatusDesc'] = self.job_status_desc
        if self.upload_ossparam is not None:
            result['UploadOSSParam'] = self.upload_ossparam.to_map()
        if self.upload_type is not None:
            result['UploadType'] = self.upload_type
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        if self.uploaded_size is not None:
            result['UploadedSize'] = self.uploaded_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobStatusDesc') is not None:
            self.job_status_desc = m.get('JobStatusDesc')
        if m.get('UploadOSSParam') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam()
            self.upload_ossparam = temp_model.from_map(m['UploadOSSParam'])
        if m.get('UploadType') is not None:
            self.upload_type = m.get('UploadType')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        if m.get('UploadedSize') is not None:
            self.uploaded_size = m.get('UploadedSize')
        return self


class GetUserUploadFileJobResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None,
                 upload_file_job_detail=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool
        # The details of the file upload task.
        self.upload_file_job_detail = upload_file_job_detail  # type: GetUserUploadFileJobResponseBodyUploadFileJobDetail

    def validate(self):
        if self.upload_file_job_detail:
            self.upload_file_job_detail.validate()

    def to_map(self):
        _map = super(GetUserUploadFileJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.upload_file_job_detail is not None:
            result['UploadFileJobDetail'] = self.upload_file_job_detail.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('UploadFileJobDetail') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetail()
            self.upload_file_job_detail = temp_model.from_map(m['UploadFileJobDetail'])
        return self


class GetUserUploadFileJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetUserUploadFileJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetUserUploadFileJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantTemplateAuthorityRequest(TeaModel):
    def __init__(self, comment=None, expire_date=None, template_id=None, tid=None, user_ids=None):
        # The reason why you want to grant permissions on resources to the users by using the permission template.
        self.comment = comment  # type: str
        # The time when the permission expires. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.expire_date = expire_date  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The IDs of users to which you want to grant permissions on resources by using the permission template.
        self.user_ids = user_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GrantTemplateAuthorityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GrantTemplateAuthorityResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, result=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the permissions on resources were granted to the users by using the permission template.
        self.result = result  # type: bool
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GrantTemplateAuthorityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GrantTemplateAuthorityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GrantTemplateAuthorityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GrantTemplateAuthorityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantTemplateAuthorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantUserPermissionRequest(TeaModel):
    def __init__(self, db_id=None, ds_type=None, expire_date=None, instance_id=None, logic=None, perm_types=None,
                 table_id=None, table_name=None, tid=None, user_id=None):
        # The ID of the database. You can call the [ListDatabases](~~141873~~) operation to query the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
        # 
        # >  The value of the DatabaseId parameter is that of the DbId parameter.
        self.db_id = db_id  # type: str
        # The permissions on a specific type of object that you want to grant to the user. Valid values:
        # 
        # *   INSTANCE: permissions on instances
        # *   DATABASE: permissions on physical databases
        # *   LOGIC_DATABASE: permissions on logical databases
        # *   TABLE: permissions on physical tables
        # *   LOGIC_TABLE: permissions on logical tables
        self.ds_type = ds_type  # type: str
        # The time when the permissions expire.
        self.expire_date = expire_date  # type: str
        # The ID of the instance. You must specify this parameter if you grant permissions on an instance to the user. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
        self.instance_id = instance_id  # type: long
        # Specifies whether the database is a logical database. You must specify this parameter if you grant permissions on a database to the user. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic  # type: bool
        # The permission type. Separate multiple permission types with commas (,). Valid values:
        # 
        # *   **QUERY**: the query permissions
        # *   **EXPORT**: the export permissions
        # *   **CORRECT**: the change permissions
        # *   **LOGIN**: the logon permissions
        # *   **PERF**: the query permissions on the performance details of the instance
        self.perm_types = perm_types  # type: str
        # The ID of the table. You must specify this parameter if you grant permissions on a table to the user. You can call the [ListTables](~~141878~~) operation to query the table ID.
        self.table_id = table_id  # type: str
        # The name of the table. You must specify this parameter if you grant permissions on a table to the user.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GrantUserPermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantUserPermissionResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GrantUserPermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GrantUserPermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GrantUserPermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GrantUserPermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InspectProxyAccessSecretRequest(TeaModel):
    def __init__(self, proxy_access_id=None, tid=None):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(InspectProxyAccessSecretRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class InspectProxyAccessSecretResponseBody(TeaModel):
    def __init__(self, access_secret=None, error_code=None, error_message=None, request_id=None, success=None):
        # The authorization password of the security protection agent.
        self.access_secret = access_secret  # type: str
        # The error code returned to the query task.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(InspectProxyAccessSecretResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_secret is not None:
            result['AccessSecret'] = self.access_secret
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessSecret') is not None:
            self.access_secret = m.get('AccessSecret')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InspectProxyAccessSecretResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InspectProxyAccessSecretResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InspectProxyAccessSecretResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InspectProxyAccessSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClassificationTemplatesRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClassificationTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListClassificationTemplatesResponseBodyTemplateList(TeaModel):
    def __init__(self, name=None, remark=None, template_id=None, template_type=None):
        # The name of the classification template.
        self.name = name  # type: str
        # The remarks.
        self.remark = remark  # type: str
        # The ID of the classification template.
        self.template_id = template_id  # type: long
        # The type of the classification template. Valid values:
        # 
        # *   **INNER**: built-in template
        # *   **USER_DEFINE**: custom template
        self.template_type = template_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClassificationTemplatesResponseBodyTemplateList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListClassificationTemplatesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, template_list=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The list of templates.
        self.template_list = template_list  # type: list[ListClassificationTemplatesResponseBodyTemplateList]

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListClassificationTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TemplateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['TemplateList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.template_list = []
        if m.get('TemplateList') is not None:
            for k in m.get('TemplateList'):
                temp_model = ListClassificationTemplatesResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        return self


class ListClassificationTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListClassificationTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListClassificationTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClassificationTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListColumnsRequest(TeaModel):
    def __init__(self, logic=None, table_id=None, tid=None):
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool
        # The ID of the table. You can call the [ListTables](~~141878~~) operation to obtain the table ID.
        self.table_id = table_id  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListColumnsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListColumnsResponseBodyColumnListColumn(TeaModel):
    def __init__(self, auto_increment=None, column_id=None, column_name=None, column_type=None, data_length=None,
                 data_precision=None, data_scale=None, default_value=None, description=None, function_type=None, nullable=None,
                 security_level=None, sensitive=None):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   true: The column is an auto-increment column.
        # *   false: The column is not an auto-increment column.
        self.auto_increment = auto_increment  # type: bool
        # The ID of the column.
        self.column_id = column_id  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The data type of the column.
        self.column_type = column_type  # type: str
        # The length of the field.
        self.data_length = data_length  # type: long
        # The number of valid digits for the field.
        self.data_precision = data_precision  # type: int
        # The number of decimal places for the field.
        self.data_scale = data_scale  # type: int
        # The default value of the column.
        self.default_value = default_value  # type: str
        # The description of the column.
        self.description = description  # type: str
        # The type of the masking algorithm that is used for the field. Valid values:
        # 
        # *   null: No masking algorithm is used.
        # *   DEFAULT: A full masking algorithm is used.
        # *   FIX_POS: The fixed position is masked.
        # *   FIX_CHAR: The fixed characters are replaced.
        self.function_type = function_type  # type: str
        # Indicates whether the column can be empty. Valid values:
        # 
        # *   **true**: The column can be empty.
        # *   **false**: The column cannot be empty.
        self.nullable = nullable  # type: bool
        # The security level of the column. Valid values:
        # 
        # *   INNER: The column is an internal column but not sensitive.
        # *   SENSITIVE: The column is a sensitive column.
        # *   CONFIDENTIAL: The column is a confidential column.
        # 
        # > For more information, see [Sensitivity levels of fields](~~66091~~).
        self.security_level = security_level  # type: str
        # Indicates whether the column is a sensitive column. Valid values:
        # 
        # *   **true**: The column is a sensitive column.
        # *   **false**: The column is not a sensitive column.
        self.sensitive = sensitive  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListColumnsResponseBodyColumnListColumn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.sensitive is not None:
            result['Sensitive'] = self.sensitive
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('Sensitive') is not None:
            self.sensitive = m.get('Sensitive')
        return self


class ListColumnsResponseBodyColumnList(TeaModel):
    def __init__(self, column=None):
        self.column = column  # type: list[ListColumnsResponseBodyColumnListColumn]

    def validate(self):
        if self.column:
            for k in self.column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListColumnsResponseBodyColumnList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Column'] = []
        if self.column is not None:
            for k in self.column:
                result['Column'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.column = []
        if m.get('Column') is not None:
            for k in m.get('Column'):
                temp_model = ListColumnsResponseBodyColumnListColumn()
                self.column.append(temp_model.from_map(k))
        return self


class ListColumnsResponseBody(TeaModel):
    def __init__(self, column_list=None, error_code=None, error_message=None, request_id=None, success=None):
        # The details about columns.
        self.column_list = column_list  # type: ListColumnsResponseBodyColumnList
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.column_list:
            self.column_list.validate()

    def to_map(self):
        _map = super(ListColumnsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_list is not None:
            result['ColumnList'] = self.column_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnList') is not None:
            temp_model = ListColumnsResponseBodyColumnList()
            self.column_list = temp_model.from_map(m['ColumnList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListColumnsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListColumnsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListColumnsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDAGVersionsRequest(TeaModel):
    def __init__(self, dag_id=None, page_index=None, page_size=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The number of the page to return.
        self.page_index = page_index  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDAGVersionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDAGVersionsResponseBodyDagVersionListDagVersion(TeaModel):
    def __init__(self, dag_name=None, dag_owner_id=None, dag_owner_nick_name=None, last_version_id=None,
                 version_comments=None, version_id=None):
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The ID of the task flow owner.
        self.dag_owner_id = dag_owner_id  # type: str
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name  # type: str
        # The ID of the previously published version.
        self.last_version_id = last_version_id  # type: long
        # The description of the version.
        self.version_comments = version_comments  # type: str
        # The ID of the version.
        self.version_id = version_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDAGVersionsResponseBodyDagVersionListDagVersion, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.last_version_id is not None:
            result['LastVersionId'] = self.last_version_id
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('LastVersionId') is not None:
            self.last_version_id = m.get('LastVersionId')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class ListDAGVersionsResponseBodyDagVersionList(TeaModel):
    def __init__(self, dag_version=None):
        self.dag_version = dag_version  # type: list[ListDAGVersionsResponseBodyDagVersionListDagVersion]

    def validate(self):
        if self.dag_version:
            for k in self.dag_version:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDAGVersionsResponseBodyDagVersionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagVersion'] = []
        if self.dag_version is not None:
            for k in self.dag_version:
                result['DagVersion'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dag_version = []
        if m.get('DagVersion') is not None:
            for k in m.get('DagVersion'):
                temp_model = ListDAGVersionsResponseBodyDagVersionListDagVersion()
                self.dag_version.append(temp_model.from_map(k))
        return self


class ListDAGVersionsResponseBody(TeaModel):
    def __init__(self, dag_version_list=None, error_code=None, error_message=None, request_id=None, success=None,
                 total_count=None):
        # The information about the published versions.
        self.dag_version_list = dag_version_list  # type: ListDAGVersionsResponseBodyDagVersionList
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.dag_version_list:
            self.dag_version_list.validate()

    def to_map(self):
        _map = super(ListDAGVersionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_version_list is not None:
            result['DagVersionList'] = self.dag_version_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagVersionList') is not None:
            temp_model = ListDAGVersionsResponseBodyDagVersionList()
            self.dag_version_list = temp_model.from_map(m['DagVersionList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDAGVersionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDAGVersionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDAGVersionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDAGVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobRequest(TeaModel):
    def __init__(self, dbtask_group_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the SQL task group. You can call the [GetStructSyncJobDetail](~~206160~~) operation to obtain this parameter.
        self.dbtask_group_id = dbtask_group_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDBTaskSQLJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList(TeaModel):
    def __init__(self, comment=None, create_time=None, db_id=None, db_search_name=None, db_task_group_id=None,
                 job_id=None, job_type=None, last_exec_time=None, logic=None, status=None, transactional=None):
        # The description of the SQL task.
        self.comment = comment  # type: str
        # The time when the SQL task was created.
        self.create_time = create_time  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The name that is used to search for the database.
        self.db_search_name = db_search_name  # type: str
        # The ID of the SQL task group.
        self.db_task_group_id = db_task_group_id  # type: long
        # The ID of the SQL task.
        self.job_id = job_id  # type: long
        # The type of the SQL task.
        self.job_type = job_type  # type: str
        # The time when the SQL task was last executed.
        self.last_exec_time = last_exec_time  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a logical database.
        self.logic = logic  # type: bool
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.status = status  # type: str
        # Indicates whether the SQL task is executed as a transaction. Valid values:
        # 
        # *   **true**: The SQL task is executed as a transaction.
        # *   **false**: The SQL task is not executed as a transaction.
        self.transactional = transactional  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDBTaskSQLJobResponseBodyDBTaskSQLJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_task_group_id is not None:
            result['DbTaskGroupId'] = self.db_task_group_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.last_exec_time is not None:
            result['LastExecTime'] = self.last_exec_time
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.status is not None:
            result['Status'] = self.status
        if self.transactional is not None:
            result['Transactional'] = self.transactional
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbTaskGroupId') is not None:
            self.db_task_group_id = m.get('DbTaskGroupId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('LastExecTime') is not None:
            self.last_exec_time = m.get('LastExecTime')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Transactional') is not None:
            self.transactional = m.get('Transactional')
        return self


class ListDBTaskSQLJobResponseBody(TeaModel):
    def __init__(self, dbtask_sqljob_list=None, error_code=None, error_message=None, request_id=None, success=None,
                 total_count=None):
        # The list of the SQL tasks.
        self.dbtask_sqljob_list = dbtask_sqljob_list  # type: list[ListDBTaskSQLJobResponseBodyDBTaskSQLJobList]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The total number of the SQL tasks.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.dbtask_sqljob_list:
            for k in self.dbtask_sqljob_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDBTaskSQLJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobList'] = []
        if self.dbtask_sqljob_list is not None:
            for k in self.dbtask_sqljob_list:
                result['DBTaskSQLJobList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dbtask_sqljob_list = []
        if m.get('DBTaskSQLJobList') is not None:
            for k in m.get('DBTaskSQLJobList'):
                temp_model = ListDBTaskSQLJobResponseBodyDBTaskSQLJobList()
                self.dbtask_sqljob_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDBTaskSQLJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDBTaskSQLJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobDetailRequest(TeaModel):
    def __init__(self, job_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the SQL task ID.
        self.job_id = job_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDBTaskSQLJobDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList(TeaModel):
    def __init__(self, affect_rows=None, current_sql=None, db_id=None, end_time=None, execute_count=None,
                 job_detail_id=None, job_id=None, log=None, logic=None, skip=None, sql_type=None, start_time=None, status=None,
                 time_delay=None):
        # The number of rows affected by the SQL task.
        self.affect_rows = affect_rows  # type: long
        # The SQL statement that was executed in the SQL task.
        self.current_sql = current_sql  # type: str
        # The ID of the physical database.
        self.db_id = db_id  # type: long
        # The point in time when the SQL task ended.
        self.end_time = end_time  # type: str
        # The number of times that the SQL statement was executed.
        self.execute_count = execute_count  # type: long
        # The ID of the details of the SQL task.
        self.job_detail_id = job_detail_id  # type: long
        # The ID of the SQL task.
        self.job_id = job_id  # type: long
        # The details of the operational log.
        self.log = log  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool
        # Indicates whether the SQL statement was skipped. Valid values:
        # 
        # *   **true**: The SQL statement was skipped.
        # *   **false**: The SQL statement was not skipped.
        self.skip = skip  # type: bool
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type  # type: str
        # The point in time when the SQL task started.
        self.start_time = start_time  # type: str
        # The status of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.status = status  # type: str
        # The duration of the SQL task. Unit: milliseconds.
        self.time_delay = time_delay  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.current_sql is not None:
            result['CurrentSql'] = self.current_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.log is not None:
            result['Log'] = self.log
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.time_delay is not None:
            result['TimeDelay'] = self.time_delay
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CurrentSql') is not None:
            self.current_sql = m.get('CurrentSql')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimeDelay') is not None:
            self.time_delay = m.get('TimeDelay')
        return self


class ListDBTaskSQLJobDetailResponseBody(TeaModel):
    def __init__(self, dbtask_sqljob_detail_list=None, error_code=None, error_message=None, request_id=None,
                 success=None, total_count=None):
        # The details of SQL tasks.
        self.dbtask_sqljob_detail_list = dbtask_sqljob_detail_list  # type: list[ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList]
        # The error code that is returned.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The total number of SQL tasks.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.dbtask_sqljob_detail_list:
            for k in self.dbtask_sqljob_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDBTaskSQLJobDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobDetailList'] = []
        if self.dbtask_sqljob_detail_list is not None:
            for k in self.dbtask_sqljob_detail_list:
                result['DBTaskSQLJobDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dbtask_sqljob_detail_list = []
        if m.get('DBTaskSQLJobDetailList') is not None:
            for k in m.get('DBTaskSQLJobDetailList'):
                temp_model = ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList()
                self.dbtask_sqljob_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDBTaskSQLJobDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDBTaskSQLJobDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDDLPublishRecordsRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        # 
        # > You can create a schema design ticket in the Data Management (DMS) console. For more information, see [Design schemas](~~69711~~). You can also call the [CreateOrder](~~144649~~) operation to create a schema design ticket and obtain the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, log on to the DMS console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDDLPublishRecordsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList(TeaModel):
    def __init__(self, dbtask_group_id=None, execute_count=None, scripts=None, status_desc=None, table_name=None,
                 task_job_status=None):
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id  # type: long
        # The number of SQL statements that are executed.
        self.execute_count = execute_count  # type: long
        # The script for data changes.
        self.scripts = scripts  # type: str
        # The description of the state.
        self.status_desc = status_desc  # type: str
        # The name of the table after the change.
        self.table_name = table_name  # type: str
        # The state of the publishing task. Valid values:
        # 
        # *   **NONE**: The state of the task is unknown.
        # *   **SUCCESS**: The task is successful.
        # *   **FAIL**: The task fails.
        self.task_job_status = task_job_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.scripts is not None:
            result['Scripts'] = self.scripts
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('Scripts') is not None:
            self.scripts = m.get('Scripts')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList(TeaModel):
    def __init__(self, db_id=None, logic=None, plan_time=None, publish_job_list=None, publish_strategy=None,
                 status_desc=None, task_job_status=None):
        # The ID of the database.
        self.db_id = db_id  # type: long
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: the database is not a logical database.
        self.logic = logic  # type: bool
        # The time to publish the ticket.
        self.plan_time = plan_time  # type: str
        # The list of the publishing tasks.
        self.publish_job_list = publish_job_list  # type: list[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList]
        # The publishing policy. Valid values:
        # 
        # *   **IMMEDIATELY**: immediately publishes the ticket.
        # *   **REGULARLY**: publishes the ticket at a scheduled time.
        self.publish_strategy = publish_strategy  # type: str
        # The description of the state.
        self.status_desc = status_desc  # type: str
        # The state of the task.
        self.task_job_status = task_job_status  # type: str

    def validate(self):
        if self.publish_job_list:
            for k in self.publish_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        result['PublishJobList'] = []
        if self.publish_job_list is not None:
            for k in self.publish_job_list:
                result['PublishJobList'].append(k.to_map() if k else None)
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        self.publish_job_list = []
        if m.get('PublishJobList') is not None:
            for k in m.get('PublishJobList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList()
                self.publish_job_list.append(temp_model.from_map(k))
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordList(TeaModel):
    def __init__(self, audit_expire_time=None, audit_status=None, comment=None, creator_id=None, finality=None,
                 finality_reason=None, publish_status=None, publish_task_info_list=None, risk_level=None, status_desc=None,
                 workflow_instance_id=None):
        # The time when the approval expires.
        self.audit_expire_time = audit_expire_time  # type: str
        # The approval state of the ticket. Valid values:
        # 
        # *   **EXEMPT_PASS**: The ticket passes without approval.
        # *   **TO_AUDIT**: The ticket is pending for approval.
        # *   **CANCEL**: The ticket is canceled.
        # *   **SUCCESS**: The ticket is approved.
        # *   **FAIL**: The ticket fails to pass the approval.
        self.audit_status = audit_status  # type: str
        self.comment = comment  # type: str
        # The ID of the user who creates the ticket. You can obtain the user ID by calling the [GetUser](~~147098~~) operation and querying the value of the UserId parameter. The value is not the unique ID (UID) of the Alibaba Cloud account.
        self.creator_id = creator_id  # type: long
        # Indicates whether the approval is terminated. Valid values:
        # 
        # *   **true**: The approval is terminated.
        # *   **false**: The approval is not terminated.
        # 
        # > Multiple reasons can terminate the approval. For example, you withdraw the application or your ticket is not approved before the specified time.
        self.finality = finality  # type: bool
        # The reason for the termination.
        self.finality_reason = finality_reason  # type: str
        # The publishing state of the ticket. Valid values:
        # 
        # *   **START**: The ticket is created.
        # *   **ANALYZE**: The ticket is under analysis.
        # *   **AUDIT**: The ticket is under approval.
        # *   **DISPATCH**: A task is generated for the ticket.
        # *   **SUCCESS**: The task is successful.
        self.publish_status = publish_status  # type: str
        # The list of publishing tasks.
        self.publish_task_info_list = publish_task_info_list  # type: list[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList]
        # The risk level of the operation. Valid values:
        # 
        # *   **NONE_RISK**: The operation does not have risks.
        # *   **LOW_RISK**: The operation is at low risk.
        # *   **MIDDLE_RISK**: The operation is at medium risk.
        # *   **HIGH_RISK**: The operation is at high risk.
        self.risk_level = risk_level  # type: str
        # The description of the publishing state.
        self.status_desc = status_desc  # type: str
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id  # type: long

    def validate(self):
        if self.publish_task_info_list:
            for k in self.publish_task_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDDLPublishRecordsResponseBodyDDLPublishRecordList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_expire_time is not None:
            result['AuditExpireTime'] = self.audit_expire_time
        if self.audit_status is not None:
            result['AuditStatus'] = self.audit_status
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.finality is not None:
            result['Finality'] = self.finality
        if self.finality_reason is not None:
            result['FinalityReason'] = self.finality_reason
        if self.publish_status is not None:
            result['PublishStatus'] = self.publish_status
        result['PublishTaskInfoList'] = []
        if self.publish_task_info_list is not None:
            for k in self.publish_task_info_list:
                result['PublishTaskInfoList'].append(k.to_map() if k else None)
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditExpireTime') is not None:
            self.audit_expire_time = m.get('AuditExpireTime')
        if m.get('AuditStatus') is not None:
            self.audit_status = m.get('AuditStatus')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Finality') is not None:
            self.finality = m.get('Finality')
        if m.get('FinalityReason') is not None:
            self.finality_reason = m.get('FinalityReason')
        if m.get('PublishStatus') is not None:
            self.publish_status = m.get('PublishStatus')
        self.publish_task_info_list = []
        if m.get('PublishTaskInfoList') is not None:
            for k in m.get('PublishTaskInfoList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList()
                self.publish_task_info_list.append(temp_model.from_map(k))
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ListDDLPublishRecordsResponseBody(TeaModel):
    def __init__(self, ddlpublish_record_list=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the publishing records.
        self.ddlpublish_record_list = ddlpublish_record_list  # type: list[ListDDLPublishRecordsResponseBodyDDLPublishRecordList]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.ddlpublish_record_list:
            for k in self.ddlpublish_record_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDDLPublishRecordsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DDLPublishRecordList'] = []
        if self.ddlpublish_record_list is not None:
            for k in self.ddlpublish_record_list:
                result['DDLPublishRecordList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ddlpublish_record_list = []
        if m.get('DDLPublishRecordList') is not None:
            for k in m.get('DDLPublishRecordList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordList()
                self.ddlpublish_record_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDDLPublishRecordsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDDLPublishRecordsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDDLPublishRecordsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDDLPublishRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckDBRequest(TeaModel):
    def __init__(self, order_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the ticket for the data change.
        self.order_id = order_id  # type: long
        # The number of the page to return.
        # 
        # Valid values: an integer that is greater than 0.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataCorrectPreCheckDBRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList(TeaModel):
    def __init__(self, db_id=None, search_name=None, sql_num=None):
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The name of the database.
        self.search_name = search_name  # type: str
        # The number of SQL statements.
        self.sql_num = sql_num  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataCorrectPreCheckDBResponseBodyPreCheckDBList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_num is not None:
            result['SqlNum'] = self.sql_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlNum') is not None:
            self.sql_num = m.get('SqlNum')
        return self


class ListDataCorrectPreCheckDBResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, pre_check_dblist=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The information about the databases that are involved in the precheck.
        self.pre_check_dblist = pre_check_dblist  # type: list[ListDataCorrectPreCheckDBResponseBodyPreCheckDBList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.pre_check_dblist:
            for k in self.pre_check_dblist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDataCorrectPreCheckDBResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckDBList'] = []
        if self.pre_check_dblist is not None:
            for k in self.pre_check_dblist:
                result['PreCheckDBList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_dblist = []
        if m.get('PreCheckDBList') is not None:
            for k in m.get('PreCheckDBList'):
                temp_model = ListDataCorrectPreCheckDBResponseBodyPreCheckDBList()
                self.pre_check_dblist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckDBResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDataCorrectPreCheckDBResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDataCorrectPreCheckDBResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckDBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckSQLRequest(TeaModel):
    def __init__(self, db_id=None, order_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: long
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataCorrectPreCheckSQLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList(TeaModel):
    def __init__(self, affect_rows=None, check_sql=None, db_id=None, sqlreview_query_key=None,
                 sql_review_status=None, sql_type=None, table_names=None):
        # The estimated number of affected rows.
        self.affect_rows = affect_rows  # type: long
        # The SQL statement.
        self.check_sql = check_sql  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](~~265977~~) operation to query the details of optimization suggestions based on the key.
        self.sqlreview_query_key = sqlreview_query_key  # type: str
        # The review status of the SQL statement. Valid values:
        # 
        # *   **WAITING**: The SQL statement is pending for review.
        # *   **RUNNING**: The SQL statement is being reviewed.
        # *   **IGNORE**: The SQL statement review is skipped.
        # *   **PASS**: The SQL statement passed the review.
        # *   **BLOCK**: The SQL statement failed the review.
        self.sql_review_status = sql_review_status  # type: str
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type  # type: str
        # The name of the table whose data is changed.
        self.table_names = table_names  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.check_sql is not None:
            result['CheckSQL'] = self.check_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_review_status is not None:
            result['SqlReviewStatus'] = self.sql_review_status
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CheckSQL') is not None:
            self.check_sql = m.get('CheckSQL')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlReviewStatus') is not None:
            self.sql_review_status = m.get('SqlReviewStatus')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        return self


class ListDataCorrectPreCheckSQLResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, pre_check_sqllist=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The precheck information about SQL statements.
        self.pre_check_sqllist = pre_check_sqllist  # type: list[ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.pre_check_sqllist:
            for k in self.pre_check_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDataCorrectPreCheckSQLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckSQLList'] = []
        if self.pre_check_sqllist is not None:
            for k in self.pre_check_sqllist:
                result['PreCheckSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_sqllist = []
        if m.get('PreCheckSQLList') is not None:
            for k in m.get('PreCheckSQLList'):
                temp_model = ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList()
                self.pre_check_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckSQLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDataCorrectPreCheckSQLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDataCorrectPreCheckSQLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataImportSQLPreCheckDetailRequest(TeaModel):
    def __init__(self, order_id=None, page_numer=None, page_size=None, sql_type=None, status_code=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The page number. Pages start from page 1.
        self.page_numer = page_numer  # type: long
        # The number of entries per page.
        self.page_size = page_size  # type: long
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # > You can log on to the Data Management (DMS) console and choose **Security and Specifications** > **Operation Audit** in the top navigation bar to view more types of SQL statements.
        self.sql_type = sql_type  # type: str
        # The state of the ticket. If you leave this parameter empty, all the states are queried by default. Valid values:
        # 
        # *   **INIT**: The ticket is being initialized.
        # *   **RUNNING**: The ticket is in progress.
        # *   **SUCCESS**: The ticket is complete.
        # *   **TIMEOUT**: The ticket is skipped due to timeout.
        # *   **FAIL**: The ticket fails.
        self.status_code = status_code  # type: str
        # The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataImportSQLPreCheckDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_numer is not None:
            result['PageNumer'] = self.page_numer
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumer') is not None:
            self.page_numer = m.get('PageNumer')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList(TeaModel):
    def __init__(self, skip=None, sql_id=None, sql_type=None, status_code=None):
        # Indicates whether the precheck of the SQL statement was skipped. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.skip = skip  # type: bool
        # The SQL ID, which indicates the sequence number of the SQL statement. The number starts with 1.
        self.sql_id = sql_id  # type: long
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type  # type: str
        # The state of the ticket. Valid values:
        # 
        # *   **INIT**: The ticket was being initialized.
        # *   **RUNNING**: The ticket was in progress.
        # *   **SUCCESS**: The ticket was complete.
        # *   **TIMEOUT**: The ticket was skipped due to timeout.
        # *   **FAIL**: The ticket failed.
        self.status_code = status_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class ListDataImportSQLPreCheckDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, pre_check_sqldetail_list=None, request_id=None,
                 success=None, total_count=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The precheck information of SQL statements.
        self.pre_check_sqldetail_list = pre_check_sqldetail_list  # type: list[ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList]
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool
        # The number of SQL statements.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.pre_check_sqldetail_list:
            for k in self.pre_check_sqldetail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDataImportSQLPreCheckDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckSQLDetailList'] = []
        if self.pre_check_sqldetail_list is not None:
            for k in self.pre_check_sqldetail_list:
                result['PreCheckSQLDetailList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_sqldetail_list = []
        if m.get('PreCheckSQLDetailList') is not None:
            for k in m.get('PreCheckSQLDetailList'):
                temp_model = ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList()
                self.pre_check_sqldetail_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataImportSQLPreCheckDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDataImportSQLPreCheckDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDataImportSQLPreCheckDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataImportSQLPreCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataImportSQLTypeRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataImportSQLTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataImportSQLTypeResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sql_type_result=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The types of SQL statements.
        self.sql_type_result = sql_type_result  # type: list[str]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataImportSQLTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sql_type_result is not None:
            result['SqlTypeResult'] = self.sql_type_result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SqlTypeResult') is not None:
            self.sql_type_result = m.get('SqlTypeResult')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataImportSQLTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDataImportSQLTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDataImportSQLTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataImportSQLTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabaseUserPermssionsRequest(TeaModel):
    def __init__(self, db_id=None, logic=None, page_number=None, page_size=None, perm_type=None, tid=None,
                 user_name=None):
        # The ID of the database.
        self.db_id = db_id  # type: str
        # Specifies whether the database is a logical database.
        self.logic = logic  # type: bool
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The type of the permission. Valid values:
        # 
        # *   DATABASE: permissions on databases
        # *   TABLE: permissions on tables
        # *   COLUMN: permissions on fields
        self.perm_type = perm_type  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long
        # The nickname of the user.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(self, create_date=None, expire_date=None, extra_data=None, origin_from=None, perm_type=None,
                 user_access_id=None):
        # The time when the permission was created.
        self.create_date = create_date  # type: str
        # The time when the permissions expire.
        self.expire_date = expire_date  # type: str
        # The extra information. This parameter is reserved.
        self.extra_data = extra_data  # type: str
        # The description of the entity that authorizes the permission.
        self.origin_from = origin_from  # type: str
        # The type of the permission. Valid values:
        # 
        # *   QUERY: the query permissions
        # *   EXPORT: the export permissions
        # *   CORRECT: the change permissions
        self.perm_type = perm_type  # type: str
        # The ID of the authorization record.
        self.user_access_id = user_access_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(self, perm_detail=None):
        self.perm_detail = perm_detail  # type: list[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail]

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(self, alias=None, column_name=None, db_id=None, db_type=None, ds_type=None, env_type=None,
                 instance_id=None, logic=None, perm_details=None, schema_name=None, search_name=None, table_id=None,
                 table_name=None, user_id=None, user_nick_name=None):
        # The alias of the database instance.
        self.alias = alias  # type: str
        # The name of a column.
        self.column_name = column_name  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: str
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The type of resources on which the user has permissions.
        self.ds_type = ds_type  # type: str
        # The type of the environment to which the database belongs.
        self.env_type = env_type  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Indicates whether the database is a logical database.
        self.logic = logic  # type: bool
        # The details of user permissions.
        self.perm_details = perm_details  # type: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: str
        # The nickname of the user.
        self.user_nick_name = user_nick_name  # type: str

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissions(TeaModel):
    def __init__(self, user_permission=None):
        self.user_permission = user_permission  # type: list[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission]

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponseBodyUserPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, total_count=None,
                 user_permissions=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total_count = total_count  # type: long
        # The details of user permissions.
        self.user_permissions = user_permissions  # type: ListDatabaseUserPermssionsResponseBodyUserPermissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListDatabaseUserPermssionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDatabaseUserPermssionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDatabaseUserPermssionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabasesRequest(TeaModel):
    def __init__(self, instance_id=None, page_number=None, page_size=None, tid=None):
        # The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
        self.instance_id = instance_id  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return per page.
        self.page_size = page_size  # type: int
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDatabasesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListDatabasesResponseBodyDatabaseListDatabase(TeaModel):
    def __init__(self, catalog_name=None, database_id=None, db_type=None, dba_id=None, dba_name=None, encoding=None,
                 env_type=None, host=None, instance_id=None, owner_id_list=None, owner_name_list=None, port=None,
                 schema_name=None, search_name=None, sid=None, state=None):
        # The name of the catalog to which the database belongs.
        self.catalog_name = catalog_name  # type: str
        # The ID of the database.
        self.database_id = database_id  # type: str
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The ID of the DBA.
        self.dba_id = dba_id  # type: str
        # The nickname of the Database administrator (DBA) to which the database belongs.
        self.dba_name = dba_name  # type: str
        # The encoding format of the database.
        self.encoding = encoding  # type: str
        # The type of the environment to which the database belongs.
        self.env_type = env_type  # type: str
        # The endpoint of the instance to which the database belongs.
        self.host = host  # type: str
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id  # type: str
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list  # type: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list  # type: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList
        # The connection port of the instance to which the database belongs.
        self.port = port  # type: int
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name that is used for searching the database.
        self.search_name = search_name  # type: str
        # The system ID (SID) of the instance to which the database belongs.
        self.sid = sid  # type: str
        # The state of the database. Valid values:
        # 
        # *   NORMAL: The database is normal.
        # *   DISABLE: The database is disabled.
        # *   OFFLINE: The database is unpublished.
        # *   NOT_EXIST: The database does not exist.
        self.state = state  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(ListDatabasesResponseBodyDatabaseListDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListDatabasesResponseBodyDatabaseList(TeaModel):
    def __init__(self, database=None):
        self.database = database  # type: list[ListDatabasesResponseBodyDatabaseListDatabase]

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDatabasesResponseBodyDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = ListDatabasesResponseBodyDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class ListDatabasesResponseBody(TeaModel):
    def __init__(self, database_list=None, error_code=None, error_message=None, request_id=None, success=None,
                 total_count=None):
        # The details of the databases.
        self.database_list = database_list  # type: ListDatabasesResponseBodyDatabaseList
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The number of databases that belong to an instance.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.database_list:
            self.database_list.validate()

    def to_map(self):
        _map = super(ListDatabasesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatabasesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDatabasesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDatabasesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDefaultSLARulesRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDefaultSLARulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDefaultSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(self, dag_id=None, id=None, interval_minutes=None, node_id=None, rule_type=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the SLA rule.
        self.id = id  # type: long
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes  # type: int
        # The ID of the task node.
        self.node_id = node_id  # type: long
        # The type of the rule. Valid values:
        # 
        # *   **0**: an SLA rule for a task flow
        # *   **1**: an SLA rule for a task node
        self.rule_type = rule_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDefaultSLARulesResponseBodySLARuleListSLARule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDefaultSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(self, slarule=None):
        self.slarule = slarule  # type: list[ListDefaultSLARulesResponseBodySLARuleListSLARule]

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDefaultSLARulesResponseBodySLARuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListDefaultSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListDefaultSLARulesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, slarule_list=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The list of SLA rules.
        self.slarule_list = slarule_list  # type: ListDefaultSLARulesResponseBodySLARuleList
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super(ListDefaultSLARulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListDefaultSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDefaultSLARulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDefaultSLARulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDefaultSLARulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDefaultSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDesensitizationRuleRequest(TeaModel):
    def __init__(self, func_type=None, page_number=None, page_size=None, rule_id=None, rule_name=None,
                 rule_type=None, tid=None):
        # The type of the masking algorithm.
        self.func_type = func_type  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. The maximum value is 100.
        self.page_size = page_size  # type: int
        # The ID of the masking rule.
        self.rule_id = rule_id  # type: int
        # The name of the masking rule.
        self.rule_name = rule_name  # type: str
        # The algorithm used for masking.
        self.rule_type = rule_type  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDesensitizationRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_type is not None:
            result['FuncType'] = self.func_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FuncType') is not None:
            self.func_type = m.get('FuncType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDesensitizationRuleResponseBodyDesensitizationRuleList(TeaModel):
    def __init__(self, func_params=None, func_sample=None, function_type=None, last_modifier_id=None,
                 last_modifier_name=None, reference_count=None, rule_desc=None, rule_id=None, rule_name=None, rule_type=None):
        # The parameter.
        self.func_params = func_params  # type: str
        # The example.
        self.func_sample = func_sample  # type: str
        # The algorithm type.
        self.function_type = function_type  # type: str
        # The ID of the user who last modified the masking rule.
        self.last_modifier_id = last_modifier_id  # type: str
        # The name of the user who last modified the masking rule.
        self.last_modifier_name = last_modifier_name  # type: str
        # The number of times that the masking was used.
        self.reference_count = reference_count  # type: int
        # The description of the rule.
        self.rule_desc = rule_desc  # type: str
        # The ID of the masking rule.
        self.rule_id = rule_id  # type: int
        # The name of the masking rule.
        self.rule_name = rule_name  # type: str
        # The algorithm used for masking.
        self.rule_type = rule_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDesensitizationRuleResponseBodyDesensitizationRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_params is not None:
            result['FuncParams'] = self.func_params
        if self.func_sample is not None:
            result['FuncSample'] = self.func_sample
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.last_modifier_id is not None:
            result['LastModifierId'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['LastModifierName'] = self.last_modifier_name
        if self.reference_count is not None:
            result['ReferenceCount'] = self.reference_count
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FuncParams') is not None:
            self.func_params = m.get('FuncParams')
        if m.get('FuncSample') is not None:
            self.func_sample = m.get('FuncSample')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('LastModifierId') is not None:
            self.last_modifier_id = m.get('LastModifierId')
        if m.get('LastModifierName') is not None:
            self.last_modifier_name = m.get('LastModifierName')
        if m.get('ReferenceCount') is not None:
            self.reference_count = m.get('ReferenceCount')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDesensitizationRuleResponseBody(TeaModel):
    def __init__(self, desensitization_rule_list=None, error_code=None, error_message=None, request_id=None,
                 success=None, total_count=None):
        # The list of masking rules.
        self.desensitization_rule_list = desensitization_rule_list  # type: list[ListDesensitizationRuleResponseBodyDesensitizationRuleList]
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool
        # The total number of entries returned. By default, this parameter is not returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.desensitization_rule_list:
            for k in self.desensitization_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDesensitizationRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesensitizationRuleList'] = []
        if self.desensitization_rule_list is not None:
            for k in self.desensitization_rule_list:
                result['DesensitizationRuleList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desensitization_rule_list = []
        if m.get('DesensitizationRuleList') is not None:
            for k in m.get('DesensitizationRuleList'):
                temp_model = ListDesensitizationRuleResponseBodyDesensitizationRuleList()
                self.desensitization_rule_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDesensitizationRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDesensitizationRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDesensitizationRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEffectiveOrdersRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListEffectiveOrdersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListEffectiveOrdersResponseBodyOrderSummaryOrderList(TeaModel):
    def __init__(self, buyer_id=None, end_time=None, ins_num=None, instance_id=None, order_id=None, start_time=None):
        # The UID of the user who placed the order.
        self.buyer_id = buyer_id  # type: str
        # The time when the instance expires.
        self.end_time = end_time  # type: str
        # The maximum number of database instances that you can use DMS to manage.
        self.ins_num = ins_num  # type: str
        # The ID of the instance for the purchased service.
        self.instance_id = instance_id  # type: str
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The time when the instance is started.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListEffectiveOrdersResponseBodyOrderSummaryOrderList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buyer_id is not None:
            result['BuyerId'] = self.buyer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuyerId') is not None:
            self.buyer_id = m.get('BuyerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListEffectiveOrdersResponseBodyOrderSummary(TeaModel):
    def __init__(self, commodity_code=None, commodity_type=None, order_list=None, total_quota=None,
                 version_type=None):
        # The commodity code of DMS.
        # 
        # *   dms_pre_public_cn: DMS that uses the subscription billing method
        # *   dms_post_public_cn: DMS that uses the pay-as-you-go billing method
        self.commodity_code = commodity_code  # type: str
        # The type of the service.
        # 
        # *   **VersionType**: DMS that supports control modes
        # *   **SensitiveDataProtection**: DMS that supports sensitive data protection
        self.commodity_type = commodity_type  # type: str
        # Details about the orders.
        self.order_list = order_list  # type: list[ListEffectiveOrdersResponseBodyOrderSummaryOrderList]
        # The sum of the number of instances that you can use DMS to manage in all orders.
        self.total_quota = total_quota  # type: int
        # The control mode of DMS. Valid values:
        # 
        # *   **stand**: Stable Change
        # *   **safety**: Security Collaboration
        self.version_type = version_type  # type: str

    def validate(self):
        if self.order_list:
            for k in self.order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListEffectiveOrdersResponseBodyOrderSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        result['OrderList'] = []
        if self.order_list is not None:
            for k in self.order_list:
                result['OrderList'].append(k.to_map() if k else None)
        if self.total_quota is not None:
            result['TotalQuota'] = self.total_quota
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        self.order_list = []
        if m.get('OrderList') is not None:
            for k in m.get('OrderList'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummaryOrderList()
                self.order_list.append(temp_model.from_map(k))
        if m.get('TotalQuota') is not None:
            self.total_quota = m.get('TotalQuota')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class ListEffectiveOrdersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, order_summary=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The information about orders.
        self.order_summary = order_summary  # type: list[ListEffectiveOrdersResponseBodyOrderSummary]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.order_summary:
            for k in self.order_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListEffectiveOrdersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OrderSummary'] = []
        if self.order_summary is not None:
            for k in self.order_summary:
                result['OrderSummary'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.order_summary = []
        if m.get('OrderSummary') is not None:
            for k in m.get('OrderSummary'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummary()
                self.order_summary.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEffectiveOrdersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListEffectiveOrdersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListEffectiveOrdersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEffectiveOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIndexesRequest(TeaModel):
    def __init__(self, logic=None, table_id=None, tid=None):
        # Specifies whether the table is a logical table.
        self.logic = logic  # type: bool
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListIndexesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListIndexesResponseBodyIndexListIndex(TeaModel):
    def __init__(self, index_comment=None, index_id=None, index_name=None, index_type=None, table_id=None):
        # The description of the index.
        self.index_comment = index_comment  # type: str
        # The ID of the index.
        self.index_id = index_id  # type: str
        # The name of the index.
        self.index_name = index_name  # type: str
        # The type of the index. Valid values:
        # 
        # *   Primary
        # *   Unique
        # *   Normal
        # *   FullText
        # *   Spatial
        self.index_type = index_type  # type: str
        # The ID of the table.
        self.table_id = table_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListIndexesResponseBodyIndexListIndex, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_comment is not None:
            result['IndexComment'] = self.index_comment
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IndexComment') is not None:
            self.index_comment = m.get('IndexComment')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListIndexesResponseBodyIndexList(TeaModel):
    def __init__(self, index=None):
        self.index = index  # type: list[ListIndexesResponseBodyIndexListIndex]

    def validate(self):
        if self.index:
            for k in self.index:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListIndexesResponseBodyIndexList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Index'] = []
        if self.index is not None:
            for k in self.index:
                result['Index'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.index = []
        if m.get('Index') is not None:
            for k in m.get('Index'):
                temp_model = ListIndexesResponseBodyIndexListIndex()
                self.index.append(temp_model.from_map(k))
        return self


class ListIndexesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, index_list=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The details of indexes.
        self.index_list = index_list  # type: ListIndexesResponseBodyIndexList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        if self.index_list:
            self.index_list.validate()

    def to_map(self):
        _map = super(ListIndexesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.index_list is not None:
            result['IndexList'] = self.index_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IndexList') is not None:
            temp_model = ListIndexesResponseBodyIndexList()
            self.index_list = temp_model.from_map(m['IndexList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListIndexesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListIndexesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListIndexesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIndexesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceLoginAuditLogRequest(TeaModel):
    def __init__(self, end_time=None, op_user_name=None, page_number=None, page_size=None, search_name=None,
                 start_time=None, tid=None):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. This way, the returned entries can be displayed by page to increase query efficiency.
        self.end_time = end_time  # type: str
        # The alias of the user.
        self.op_user_name = op_user_name  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size  # type: int
        # The name of the database or instance whose logon records you want to query.
        # 
        # >  If SQL statements are executed at the instance level, you can set this parameter to an instance name. If SQL statements are executed at the database level, you can set this parameter to a database name.
        self.search_name = search_name  # type: str
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        self.start_time = start_time  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstanceLoginAuditLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog(TeaModel):
    def __init__(self, db_user=None, instance_id=None, instance_name=None, op_time=None, request_ip=None,
                 user_id=None, user_name=None):
        # The database account that is used to log on to the instance.
        self.db_user = db_user  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The time when the user performed an operation on the instance.
        self.op_time = op_time  # type: str
        # The source IP address of the request.
        self.request_ip = request_ip  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: long
        # The alias of the user.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_user is not None:
            result['DbUser'] = self.db_user
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.request_ip is not None:
            result['RequestIp'] = self.request_ip
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbUser') is not None:
            self.db_user = m.get('DbUser')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('RequestIp') is not None:
            self.request_ip = m.get('RequestIp')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList(TeaModel):
    def __init__(self, instance_login_audit_log=None):
        self.instance_login_audit_log = instance_login_audit_log  # type: list[ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog]

    def validate(self):
        if self.instance_login_audit_log:
            for k in self.instance_login_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceLoginAuditLog'] = []
        if self.instance_login_audit_log is not None:
            for k in self.instance_login_audit_log:
                result['InstanceLoginAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_login_audit_log = []
        if m.get('InstanceLoginAuditLog') is not None:
            for k in m.get('InstanceLoginAuditLog'):
                temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog()
                self.instance_login_audit_log.append(temp_model.from_map(k))
        return self


class ListInstanceLoginAuditLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, instance_login_audit_log_list=None, request_id=None,
                 success=None, total_count=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The logon records of the instance.
        self.instance_login_audit_log_list = instance_login_audit_log_list  # type: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.instance_login_audit_log_list:
            self.instance_login_audit_log_list.validate()

    def to_map(self):
        _map = super(ListInstanceLoginAuditLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_login_audit_log_list is not None:
            result['InstanceLoginAuditLogList'] = self.instance_login_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceLoginAuditLogList') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList()
            self.instance_login_audit_log_list = temp_model.from_map(m['InstanceLoginAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstanceLoginAuditLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListInstanceLoginAuditLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListInstanceLoginAuditLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceUserPermissionsRequest(TeaModel):
    def __init__(self, instance_id=None, page_number=None, page_size=None, tid=None, user_name=None):
        # The ID of the instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
        self.instance_id = instance_id  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The nickname of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the nickname of the user.
        # 
        # >  The value of the NickName parameter is that of the UserName parameter.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstanceUserPermissionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(self, create_date=None, expire_date=None, extra_data=None, origin_from=None, perm_type=None,
                 user_access_id=None):
        # The time when the permissions were granted.
        self.create_date = create_date  # type: str
        # The time when the permissions expire.
        self.expire_date = expire_date  # type: str
        # This parameter is reserved.
        self.extra_data = extra_data  # type: str
        # The user who grants the permissions.
        self.origin_from = origin_from  # type: str
        # The type of the permissions. Valid values:
        # 
        # *   LOGIN: the logon permissions
        # *   PERF: the query permissions on the instance
        self.perm_type = perm_type  # type: str
        # The ID of the authorization record.
        self.user_access_id = user_access_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(self, perm_detail=None):
        self.perm_detail = perm_detail  # type: list[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail]

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(self, instance_id=None, perm_details=None, user_id=None, user_nick_name=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The details of permissions.
        self.perm_details = perm_details  # type: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails
        # The ID of the user.
        self.user_id = user_id  # type: str
        # The nickname of the user.
        self.user_nick_name = user_nick_name  # type: str

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PermDetails') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(self, user_permission=None):
        self.user_permission = user_permission  # type: list[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission]

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponseBodyUserPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, total_count=None,
                 user_permissions=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total_count = total_count  # type: long
        # The permissions of the user on the instance.
        self.user_permissions = user_permissions  # type: ListInstanceUserPermissionsResponseBodyUserPermissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListInstanceUserPermissionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListInstanceUserPermissionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListInstanceUserPermissionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstancesRequest(TeaModel):
    def __init__(self, db_type=None, env_type=None, instance_source=None, instance_state=None, net_type=None,
                 page_number=None, page_size=None, search_key=None, tid=None):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type  # type: str
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
        # *   **RDS**: an ApsaraDB RDS instance
        # *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source  # type: str
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**: normal
        # *   **DISABLE**: disabled
        self.instance_state = instance_state  # type: str
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC**: classic network
        # *   **VPC**: VPC
        self.net_type = net_type  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. The number cannot exceed 100.
        self.page_size = page_size  # type: int
        # The keyword that is used to search for database instances.
        self.search_key = search_key  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_state is not None:
            result['InstanceState'] = self.instance_state
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceState') is not None:
            self.instance_state = m.get('InstanceState')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstancesResponseBodyInstanceListInstanceOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstancesResponseBodyInstanceListInstanceOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListInstancesResponseBodyInstanceListInstanceStandardGroup(TeaModel):
    def __init__(self, group_mode=None, group_name=None):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode  # type: str
        # The name of the security rule set corresponding to the control mode.
        self.group_name = group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInstancesResponseBodyInstanceListInstanceStandardGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListInstancesResponseBodyInstanceListInstance(TeaModel):
    def __init__(self, data_link_name=None, database_password=None, database_user=None, dba_id=None,
                 dba_nick_name=None, ddl_online=None, ecs_instance_id=None, ecs_region=None, env_type=None, export_timeout=None,
                 host=None, instance_alias=None, instance_id=None, instance_source=None, instance_type=None,
                 owner_id_list=None, owner_name_list=None, port=None, query_timeout=None, safe_rule_id=None, sell_sitd=None,
                 sid=None, standard_group=None, state=None, use_dsql=None, vpc_id=None):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name  # type: str
        # The password that is used to log on to the database.
        self.database_password = database_password  # type: str
        # The account that is used to log on to the database.
        self.database_user = database_user  # type: str
        # The ID of the database administrator (DBA) for the database instance.
        self.dba_id = dba_id  # type: str
        # The nickname of the DBA for the database instance.
        self.dba_nick_name = dba_nick_name  # type: str
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online  # type: int
        # The ID of the ECS instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id  # type: str
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region  # type: str
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: UAT environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type  # type: str
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout  # type: int
        # The host address that is used to connect to the database instance.
        self.host = host  # type: str
        # The alias of the database instance.
        self.instance_alias = instance_alias  # type: str
        # The ID of the database instance.
        self.instance_id = instance_id  # type: str
        # The source of the database instance.
        self.instance_source = instance_source  # type: str
        # The type of the database instance.
        self.instance_type = instance_type  # type: str
        # The ID of the owner for the database instance.
        self.owner_id_list = owner_id_list  # type: ListInstancesResponseBodyInstanceListInstanceOwnerIdList
        # The nickname of the owner for the database instance.
        self.owner_name_list = owner_name_list  # type: ListInstancesResponseBodyInstanceListInstanceOwnerNameList
        # The port number that is used to connect to the database instance.
        self.port = port  # type: int
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout  # type: int
        # The ID of the security rule set for the database instance.
        self.safe_rule_id = safe_rule_id  # type: str
        self.sell_sitd = sell_sitd  # type: bool
        # The system ID (SID) of the database instance.
        self.sid = sid  # type: str
        # The control mode of the database instance.
        self.standard_group = standard_group  # type: ListInstancesResponseBodyInstanceListInstanceStandardGroup
        # The status of the database instance.
        self.state = state  # type: str
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.use_dsql = use_dsql  # type: int
        # The ID of the VPC to which the database instance belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super(ListInstancesResponseBodyInstanceListInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListInstancesResponseBodyInstanceList(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[ListInstancesResponseBodyInstanceListInstance]

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListInstancesResponseBodyInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = ListInstancesResponseBodyInstanceListInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class ListInstancesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, instance_list=None, request_id=None, success=None,
                 total_count=None):
        # The error code that is returned.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The information about the database instances that are returned.
        self.instance_list = instance_list  # type: ListInstancesResponseBodyInstanceList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool
        # The total number of database instances that are returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.instance_list:
            self.instance_list.validate()

    def to_map(self):
        _map = super(ListInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceList') is not None:
            temp_model = ListInstancesResponseBodyInstanceList()
            self.instance_list = temp_model.from_map(m['InstanceList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLhTaskFlowAndScenarioRequest(TeaModel):
    def __init__(self, space_id=None, tid=None, user_id=None):
        # The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        self.space_id = space_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.user_id = user_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag(TeaModel):
    def __init__(self, can_edit=None, creator_id=None, creator_nick_name=None, dag_name=None, dag_owner_id=None,
                 dag_owner_nick_name=None, data_flow_id=None, demo_id=None, deploy_id=None, id=None, is_deleted=None,
                 latest_instance_status=None, latest_instance_time=None, scenario_id=None, space_id=None, status=None):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # *   **true**: The task flow can be modified.
        # *   **false**: The task flow cannot be modified.
        self.can_edit = can_edit  # type: bool
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id  # type: str
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name  # type: str
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id  # type: str
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name  # type: str
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id  # type: long
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id  # type: str
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id  # type: long
        # The ID of the task flow.
        self.id = id  # type: long
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # *   **true**: deleted
        # *   **false**: not deleted
        self.is_deleted = is_deleted  # type: bool
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.latest_instance_status = latest_instance_status  # type: int
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time  # type: int
        # The ID of the business scenario.
        self.scenario_id = scenario_id  # type: long
        # The ID of the workspace.
        self.space_id = space_id  # type: long
        # The status of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGList(TeaModel):
    def __init__(self, dag=None):
        self.dag = dag  # type: list[ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag]

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyRawDAGList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag(TeaModel):
    def __init__(self, can_edit=None, creator_id=None, creator_nick_name=None, dag_name=None, dag_owner_id=None,
                 dag_owner_nick_name=None, data_flow_id=None, demo_id=None, deploy_id=None, id=None, is_deleted=None,
                 latest_instance_status=None, latest_instance_time=None, scenario_id=None, space_id=None, status=None):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # - **true**: The task flow can be modified.
        # - **false**: The task flow cannot be modified.
        self.can_edit = can_edit  # type: bool
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id  # type: str
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name  # type: str
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id  # type: str
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name  # type: str
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id  # type: long
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id  # type: str
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id  # type: long
        # The ID of the task flow.
        self.id = id  # type: long
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # - **true**: deleted
        # - **false**: not deleted
        self.is_deleted = is_deleted  # type: bool
        # The status of the latest execution. Valid values:
        # 
        # - 0: invalid
        # - 1: scheduling disabled
        # - 2: waiting to be scheduled
        self.latest_instance_status = latest_instance_status  # type: int
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time  # type: int
        # The ID of the business scenario.
        self.scenario_id = scenario_id  # type: long
        # The ID of the workspace.
        self.space_id = space_id  # type: long
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: scheduling disabled
        # - **2**: waiting to be scheduled
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList(TeaModel):
    def __init__(self, dag=None):
        self.dag = dag  # type: list[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag]

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario(TeaModel):
    def __init__(self, creator_id=None, description=None, scenario_name=None):
        # The ID of the user who creates the business scenario.
        self.creator_id = creator_id  # type: str
        # The description of the business scenario.
        self.description = description  # type: str
        # The name of the business scenario.
        self.scenario_name = scenario_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG(TeaModel):
    def __init__(self, dag_list=None, scenario=None):
        # The list of task flows.
        self.dag_list = dag_list  # type: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList
        # The information about the business scenario.
        self.scenario = scenario  # type: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario

    def validate(self):
        if self.dag_list:
            self.dag_list.validate()
        if self.scenario:
            self.scenario.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_list is not None:
            result['DagList'] = self.dag_list.to_map()
        if self.scenario is not None:
            result['Scenario'] = self.scenario.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList()
            self.dag_list = temp_model.from_map(m['DagList'])
        if m.get('Scenario') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario()
            self.scenario = temp_model.from_map(m['Scenario'])
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList(TeaModel):
    def __init__(self, scenario_dag=None):
        self.scenario_dag = scenario_dag  # type: list[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG]

    def validate(self):
        if self.scenario_dag:
            for k in self.scenario_dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ScenarioDAG'] = []
        if self.scenario_dag is not None:
            for k in self.scenario_dag:
                result['ScenarioDAG'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.scenario_dag = []
        if m.get('ScenarioDAG') is not None:
            for k in m.get('ScenarioDAG'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG()
                self.scenario_dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, raw_daglist=None, request_id=None,
                 scenario_daglist=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The task flows in the default business scenario.
        self.raw_daglist = raw_daglist  # type: ListLhTaskFlowAndScenarioResponseBodyRawDAGList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The task flows in other business scenarios.
        self.scenario_daglist = scenario_daglist  # type: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.raw_daglist:
            self.raw_daglist.validate()
        if self.scenario_daglist:
            self.scenario_daglist.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.raw_daglist is not None:
            result['RawDAGList'] = self.raw_daglist.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_daglist is not None:
            result['ScenarioDAGList'] = self.scenario_daglist.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RawDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGList()
            self.raw_daglist = temp_model.from_map(m['RawDAGList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList()
            self.scenario_daglist = temp_model.from_map(m['ScenarioDAGList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLhTaskFlowAndScenarioResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLhTaskFlowAndScenarioResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLhTaskFlowAndScenarioResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicDatabasesRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, tid=None):
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicDatabasesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds(TeaModel):
    def __init__(self, database_ids=None):
        self.database_ids = database_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase(TeaModel):
    def __init__(self, alias=None, database_id=None, database_ids=None, db_type=None, env_type=None, logic=None,
                 owner_id_list=None, owner_name_list=None, schema_name=None, search_name=None):
        # The alias of the logical database.
        self.alias = alias  # type: str
        # The ID of the logical database.
        self.database_id = database_id  # type: str
        # Logical database sub-ID list.
        self.database_ids = database_ids  # type: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds
        # The type of the logical database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type  # type: str
        # The type of the environment to which the logical database belongs. Valid values:
        # 
        # - **product**: production environment
        # - **dev**: development environment
        # - **pre**: staging environment
        # - **test**: test environment
        # - **sit**: system integration testing (SIT) environment
        # - **uat**: user acceptance testing (UAT) environment
        # - **pet**: stress testing environment
        # - **stag**: STAG environment
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic  # type: bool
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list  # type: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list  # type: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList
        # The name of the logical database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the logical database.
        # 
        # > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
        self.search_name = search_name  # type: str

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseList(TeaModel):
    def __init__(self, logic_database=None):
        self.logic_database = logic_database  # type: list[ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase]

    def validate(self):
        if self.logic_database:
            for k in self.logic_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBodyLogicDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicDatabase'] = []
        if self.logic_database is not None:
            for k in self.logic_database:
                result['LogicDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.logic_database = []
        if m.get('LogicDatabase') is not None:
            for k in m.get('LogicDatabase'):
                temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase()
                self.logic_database.append(temp_model.from_map(k))
        return self


class ListLogicDatabasesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, logic_database_list=None, request_id=None, success=None,
                 total_count=None):
        # The error code that is returned.
        self.error_code = error_code  # type: str
        # The error message that is returned.
        self.error_message = error_message  # type: str
        # The details of logical databases.
        self.logic_database_list = logic_database_list  # type: ListLogicDatabasesResponseBodyLogicDatabaseList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success  # type: bool
        # The total number of logical databases.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.logic_database_list:
            self.logic_database_list.validate()

    def to_map(self):
        _map = super(ListLogicDatabasesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database_list is not None:
            result['LogicDatabaseList'] = self.logic_database_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabaseList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseList()
            self.logic_database_list = temp_model.from_map(m['LogicDatabaseList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicDatabasesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLogicDatabasesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLogicDatabasesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTableRouteConfigRequest(TeaModel):
    def __init__(self, table_id=None, tid=None):
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicTableRouteConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig(TeaModel):
    def __init__(self, route_expr=None, route_key=None, table_id=None):
        # The routing algorithm expression.
        self.route_expr = route_expr  # type: str
        # The unique key of the routing algorithm.
        self.route_key = route_key  # type: str
        # The ID of the logical table.
        self.table_id = table_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList(TeaModel):
    def __init__(self, logic_table_route_config=None):
        self.logic_table_route_config = logic_table_route_config  # type: list[ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig]

    def validate(self):
        if self.logic_table_route_config:
            for k in self.logic_table_route_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTableRouteConfig'] = []
        if self.logic_table_route_config is not None:
            for k in self.logic_table_route_config:
                result['LogicTableRouteConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.logic_table_route_config = []
        if m.get('LogicTableRouteConfig') is not None:
            for k in m.get('LogicTableRouteConfig'):
                temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig()
                self.logic_table_route_config.append(temp_model.from_map(k))
        return self


class ListLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, logic_table_route_config_list=None, request_id=None,
                 success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The routing algorithms.
        self.logic_table_route_config_list = logic_table_route_config_list  # type: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.logic_table_route_config_list:
            self.logic_table_route_config_list.validate()

    def to_map(self):
        _map = super(ListLogicTableRouteConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_route_config_list is not None:
            result['LogicTableRouteConfigList'] = self.logic_table_route_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableRouteConfigList') is not None:
            temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList()
            self.logic_table_route_config_list = temp_model.from_map(m['LogicTableRouteConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLogicTableRouteConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLogicTableRouteConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLogicTableRouteConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTablesRequest(TeaModel):
    def __init__(self, database_id=None, page_number=None, page_size=None, return_guid=None, search_name=None,
                 tid=None):
        # The ID of the logical database.
        self.database_id = database_id  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # Specifies whether to return the GUID of the table.
        self.return_guid = return_guid  # type: bool
        # The keyword that is used to search for the logical tables. Prefix match is supported.
        self.search_name = search_name  # type: str
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicTablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTable(TeaModel):
    def __init__(self, database_id=None, logic=None, owner_id_list=None, owner_name_list=None, schema_name=None,
                 table_count=None, table_expr=None, table_guid=None, table_id=None, table_name=None):
        # The ID of the logical database.
        self.database_id = database_id  # type: str
        # Indicates whether the table is a logical table. The value is fixed to true.
        self.logic = logic  # type: bool
        # The IDs of the owners of the logical tables.
        self.owner_id_list = owner_id_list  # type: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList
        # The nicknames of the owners of the logical tables.
        self.owner_name_list = owner_name_list  # type: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList
        # The logical database to which the logical table belongs.
        self.schema_name = schema_name  # type: str
        # The number of logical tables.
        self.table_count = table_count  # type: str
        # The expression of the logical table.
        self.table_expr = table_expr  # type: str
        # The GUID of the logical table.
        self.table_guid = table_guid  # type: str
        # The ID of the logical table.
        self.table_id = table_id  # type: str
        # The name of the logical table.
        self.table_name = table_name  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(ListLogicTablesResponseBodyLogicTableListLogicTable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_expr is not None:
            result['TableExpr'] = self.table_expr
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableExpr') is not None:
            self.table_expr = m.get('TableExpr')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListLogicTablesResponseBodyLogicTableList(TeaModel):
    def __init__(self, logic_table=None):
        self.logic_table = logic_table  # type: list[ListLogicTablesResponseBodyLogicTableListLogicTable]

    def validate(self):
        if self.logic_table:
            for k in self.logic_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLogicTablesResponseBodyLogicTableList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTable'] = []
        if self.logic_table is not None:
            for k in self.logic_table:
                result['LogicTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.logic_table = []
        if m.get('LogicTable') is not None:
            for k in m.get('LogicTable'):
                temp_model = ListLogicTablesResponseBodyLogicTableListLogicTable()
                self.logic_table.append(temp_model.from_map(k))
        return self


class ListLogicTablesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, logic_table_list=None, request_id=None, success=None,
                 total_count=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The details of the logical tables.
        self.logic_table_list = logic_table_list  # type: ListLogicTablesResponseBodyLogicTableList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The total number of logical tables that meet the query conditions.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.logic_table_list:
            self.logic_table_list.validate()

    def to_map(self):
        _map = super(ListLogicTablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_list is not None:
            result['LogicTableList'] = self.logic_table_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableList()
            self.logic_table_list = temp_model.from_map(m['LogicTableList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicTablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLogicTablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLogicTablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOrdersRequest(TeaModel):
    def __init__(self, end_time=None, order_result_type=None, order_status=None, page_number=None, page_size=None,
                 plugin_type=None, search_content=None, search_date_type=None, start_time=None, tid=None):
        # The end of the time range to query.
        self.end_time = end_time  # type: str
        # The scope of the tickets that you want to query. Valid values:
        # 
        # *   **AS_ADMIN**: all tickets.
        # *   **AS_COMMITTER**: the tickets that are submitted by the current user.
        # *   **AS_HANDLER**: the tickets to be processed by the current user.
        # *   **AS_OWNER**: the tickets that are processed by the current user.
        # *   **AS_Related**: the tickets that are related to the current user.
        self.order_result_type = order_result_type  # type: str
        # The status of the tickets that you want to query. Valid values:
        # 
        # *   **ALL**: queries the tickets of all statuses.
        # *   **FINISHED**: queries the tickets that are completed.
        # *   **RUNNING**: queries the tickets that are being processed.
        self.order_status = order_status  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The type of the tickets that you want to query. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type  # type: str
        # The keyword that is used to query tickets.
        self.search_content = search_content  # type: str
        # The time condition based on which you want to query tickets. Valid values:
        # 
        # *   **CREATE_TIME**: the time when a ticket was created.
        # *   **MODIFY_TIME**: the time when a ticket was last modified.
        self.search_date_type = search_date_type  # type: str
        # The beginning of the time range to query.
        self.start_time = start_time  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOrdersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order_result_type is not None:
            result['OrderResultType'] = self.order_result_type
        if self.order_status is not None:
            result['OrderStatus'] = self.order_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.search_content is not None:
            result['SearchContent'] = self.search_content
        if self.search_date_type is not None:
            result['SearchDateType'] = self.search_date_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OrderResultType') is not None:
            self.order_result_type = m.get('OrderResultType')
        if m.get('OrderStatus') is not None:
            self.order_status = m.get('OrderStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('SearchContent') is not None:
            self.search_content = m.get('SearchContent')
        if m.get('SearchDateType') is not None:
            self.search_date_type = m.get('SearchDateType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListOrdersResponseBodyOrdersOrder(TeaModel):
    def __init__(self, comment=None, committer=None, committer_id=None, create_time=None, last_modify_time=None,
                 order_id=None, plugin_type=None, status_code=None, status_desc=None):
        # The remarks of the ticket.
        self.comment = comment  # type: str
        # The user who submitted the ticket.
        self.committer = committer  # type: str
        # The ID of the user who submitted the ticket.
        self.committer_id = committer_id  # type: long
        # The time when the ticket was created.
        self.create_time = create_time  # type: str
        # The time when the ticket was last modified.
        self.last_modify_time = last_modify_time  # type: str
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The type of the ticket.
        self.plugin_type = plugin_type  # type: str
        # The status code of the ticket. Valid values:
        # 
        # *   **fail**: The ticket fails to be executed.
        # *   **toaudit**: The ticket is waiting for approval.
        # *   **cancel**: The ticket is cancelled.
        # *   **processing**: The ticket is being executed.
        # *   **approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **success**: The ticket is executed.
        # *   **closed**: The ticket is closed.
        self.status_code = status_code  # type: str
        # The status description of the ticket.
        self.status_desc = status_desc  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOrdersResponseBodyOrdersOrder, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListOrdersResponseBodyOrders(TeaModel):
    def __init__(self, order=None):
        self.order = order  # type: list[ListOrdersResponseBodyOrdersOrder]

    def validate(self):
        if self.order:
            for k in self.order:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListOrdersResponseBodyOrders, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Order'] = []
        if self.order is not None:
            for k in self.order:
                result['Order'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.order = []
        if m.get('Order') is not None:
            for k in m.get('Order'):
                temp_model = ListOrdersResponseBodyOrdersOrder()
                self.order.append(temp_model.from_map(k))
        return self


class ListOrdersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, orders=None, request_id=None, success=None,
                 total_count=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The details about the tickets.
        self.orders = orders  # type: ListOrdersResponseBodyOrders
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool
        # The total number of entries that are returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.orders:
            self.orders.validate()

    def to_map(self):
        _map = super(ListOrdersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.orders is not None:
            result['Orders'] = self.orders.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Orders') is not None:
            temp_model = ListOrdersResponseBodyOrders()
            self.orders = temp_model.from_map(m['Orders'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListOrdersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListOrdersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListOrdersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxiesRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxiesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxiesResponseBodyProxyList(TeaModel):
    def __init__(self, creator_id=None, creator_name=None, https_port=None, instance_id=None, private_enable=None,
                 private_host=None, protocol_port=None, protocol_type=None, proxy_id=None, public_enable=None, public_host=None,
                 region_id=None):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id  # type: long
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name  # type: str
        # The number of the port that was used by HTTPS clients to connect to the database instance.
        self.https_port = https_port  # type: int
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # Indicates whether the internal endpoint is enabled. Default value: **true**.
        self.private_enable = private_enable  # type: bool
        # The internal endpoint.
        self.private_host = private_host  # type: str
        # The number of the port that is used to connect the database instance.
        self.protocol_port = protocol_port  # type: int
        # The type of the database. Example: MYSQL.
        self.protocol_type = protocol_type  # type: str
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # Indicates whether the public endpoint is enabled. Valid values:
        # 
        # *   **true**: The public endpoint is enabled.
        # *   **false**: The public endpoint is disabled.
        self.public_enable = public_enable  # type: bool
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
        # 
        # > 
        # 
        # *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
        # 
        # *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
        self.public_host = public_host  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxiesResponseBodyProxyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListProxiesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_list=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The proxies that are generated by the secure access proxy feature.
        self.proxy_list = proxy_list  # type: list[ListProxiesResponseBodyProxyList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.proxy_list:
            for k in self.proxy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProxiesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyList'] = []
        if self.proxy_list is not None:
            for k in self.proxy_list:
                result['ProxyList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_list = []
        if m.get('ProxyList') is not None:
            for k in m.get('ProxyList'):
                temp_model = ListProxiesResponseBodyProxyList()
                self.proxy_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxiesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListProxiesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListProxiesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxyAccessesRequest(TeaModel):
    def __init__(self, proxy_id=None, tid=None):
        # The ID of the secure access proxy. 
        # 
        # >  You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # The ID of the tenant. 
        # 
        # >  You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxyAccessesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxyAccessesResponseBodyProxyAccessList(TeaModel):
    def __init__(self, access_id=None, gmt_create=None, indep_account=None, instance_id=None, origin_info=None,
                 proxy_access_id=None, proxy_id=None, user_id=None, user_name=None, user_uid=None):
        # The username of the database account that is authorized to access the database instance by using the secure access proxy feature.
        self.access_id = access_id  # type: str
        # The time when the user is authorized to access the database instance by using the secure access proxy feature.
        self.gmt_create = gmt_create  # type: str
        # The username of the independent database account.
        self.indep_account = indep_account  # type: str
        # The ID of the database instance.
        self.instance_id = instance_id  # type: long
        # The method that is used to authorize the user to access the database instance by using the secure access proxy feature. Valid values: 
        # 
        # - **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the user ID (UID) of the Alibaba Cloud account.
        # - **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
        self.origin_info = origin_info  # type: str
        # The ID that DMS generates after the user is authorized to access the database instance by using the secure access proxy feature. The ID is unique in DMS.
        self.proxy_access_id = proxy_access_id  # type: long
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id  # type: long
        # The ID of the user.
        self.user_id = user_id  # type: long
        # The nickname of the user.
        self.user_name = user_name  # type: str
        # The UID of the Alibaba Cloud account.
        self.user_uid = user_uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxyAccessesResponseBodyProxyAccessList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class ListProxyAccessesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_access_list=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The information about the users that are authorized to access the database instance by using the secure access proxy feature.
        self.proxy_access_list = proxy_access_list  # type: list[ListProxyAccessesResponseBodyProxyAccessList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.proxy_access_list:
            for k in self.proxy_access_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProxyAccessesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyAccessList'] = []
        if self.proxy_access_list is not None:
            for k in self.proxy_access_list:
                result['ProxyAccessList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_access_list = []
        if m.get('ProxyAccessList') is not None:
            for k in m.get('ProxyAccessList'):
                temp_model = ListProxyAccessesResponseBodyProxyAccessList()
                self.proxy_access_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxyAccessesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListProxyAccessesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListProxyAccessesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxyAccessesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxySQLExecAuditLogRequest(TeaModel):
    def __init__(self, end_time=None, exec_state=None, op_user_name=None, page_number=None, page_size=None,
                 sqltype=None, search_name=None, start_time=None, tid=None):
        # The end of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.end_time = end_time  # type: long
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state  # type: str
        # The alias of the user.
        self.op_user_name = op_user_name  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum values: 100.
        self.page_size = page_size  # type: int
        # The type of SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype  # type: str
        # The name of the database instance.
        self.search_name = search_name  # type: str
        # The beginning of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.start_time = start_time  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxySQLExecAuditLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog(TeaModel):
    def __init__(self, affect_rows=None, elapsed_time=None, exec_state=None, instance_id=None, instance_name=None,
                 op_time=None, remark=None, sql=None, sqltype=None, schema_name=None, user_id=None, user_name=None):
        # Indicates the total number of rows returned after the SQL statement was executed. If an SELECT SQL statement is executed, the return value of this parameter indicates the total number of the queried data rows.
        self.affect_rows = affect_rows  # type: long
        # The amount of time that is consumed to execute the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time  # type: long
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state  # type: str
        # The ID of the database instance.
        self.instance_id = instance_id  # type: long
        # The name of the database instance.
        self.instance_name = instance_name  # type: str
        # The time at which the user executes the SQL statement on the database instance. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.op_time = op_time  # type: str
        # The description.
        self.remark = remark  # type: str
        # The SQL statement that was executed.
        self.sql = sql  # type: str
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype  # type: str
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: long
        # The nickname of the user.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList(TeaModel):
    def __init__(self, proxy_sqlexec_audit_log=None):
        self.proxy_sqlexec_audit_log = proxy_sqlexec_audit_log  # type: list[ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog]

    def validate(self):
        if self.proxy_sqlexec_audit_log:
            for k in self.proxy_sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProxySQLExecAuditLog'] = []
        if self.proxy_sqlexec_audit_log is not None:
            for k in self.proxy_sqlexec_audit_log:
                result['ProxySQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.proxy_sqlexec_audit_log = []
        if m.get('ProxySQLExecAuditLog') is not None:
            for k in m.get('ProxySQLExecAuditLog'):
                temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog()
                self.proxy_sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListProxySQLExecAuditLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, proxy_sqlexec_audit_log_list=None, request_id=None,
                 success=None, total_count=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The audit information about the database instance that is provided by the secure access proxy feature.
        self.proxy_sqlexec_audit_log_list = proxy_sqlexec_audit_log_list  # type: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.proxy_sqlexec_audit_log_list:
            self.proxy_sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super(ListProxySQLExecAuditLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_sqlexec_audit_log_list is not None:
            result['ProxySQLExecAuditLogList'] = self.proxy_sqlexec_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxySQLExecAuditLogList') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList()
            self.proxy_sqlexec_audit_log_list = temp_model.from_map(m['ProxySQLExecAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProxySQLExecAuditLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListProxySQLExecAuditLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListProxySQLExecAuditLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSLARulesRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSLARulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(self, dag_id=None, id=None, interval_minutes=None, node_id=None, rule_type=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the SLA rule.
        self.id = id  # type: long
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes  # type: int
        # The ID of the task node.
        self.node_id = node_id  # type: long
        # The type of the rule. Valid values:
        # 
        # *   **0**: an SLA rule for a task flow
        # *   **1**: an SLA rule for a task node
        self.rule_type = rule_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSLARulesResponseBodySLARuleListSLARule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(self, slarule=None):
        self.slarule = slarule  # type: list[ListSLARulesResponseBodySLARuleListSLARule]

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSLARulesResponseBodySLARuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListSLARulesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, slarule_list=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The list of SLA rules.
        self.slarule_list = slarule_list  # type: ListSLARulesResponseBodySLARuleList
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super(ListSLARulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSLARulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSLARulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSLARulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLExecAuditLogRequest(TeaModel):
    def __init__(self, end_time=None, exec_state=None, op_user_name=None, page_number=None, page_size=None,
                 search_name=None, sql_type=None, start_time=None, tid=None):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. The returned entries can be displayed by page to improve query efficiency.
        self.end_time = end_time  # type: str
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state  # type: str
        # The nickname of the user who wrote the SQL statement.
        self.op_user_name = op_user_name  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. The value cannot exceed 100.
        self.page_size = page_size  # type: int
        # The name of the database or instance based on which you want to query SQL statements.
        # 
        # >  If the SQL statements to be queried are at the instance level, you can set this parameter to an instance name. If the SQL statements to be queried are at the database level, you can set this parameter to a database name.
        self.search_name = search_name  # type: str
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sql_type = sql_type  # type: str
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        self.start_time = start_time  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSQLExecAuditLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog(TeaModel):
    def __init__(self, affect_rows=None, db_id=None, elapsed_time=None, exec_state=None, instance_id=None,
                 instance_name=None, logic=None, op_time=None, remark=None, sql=None, sqltype=None, schema_name=None, user_id=None,
                 user_name=None):
        # The number of rows affected by the SQL statement. For example, if you execute an SQL statement to query data, the number of retrieved rows is returned.
        self.affect_rows = affect_rows  # type: long
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The amount of time consumed by the execution of the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time  # type: long
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # The name of the database.
        # 
        # >  If the SQL statement takes effect on an instance, the name of the instance is returned.
        self.instance_name = instance_name  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool
        # The time when the operation specified by the SQL statement was performed on the instance or database.
        self.op_time = op_time  # type: str
        # The comment on the SQL statement.
        self.remark = remark  # type: str
        # The SQL statement that was written.
        self.sql = sql  # type: str
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sqltype = sqltype  # type: str
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The ID of the user who wrote the SQL statement.
        self.user_id = user_id  # type: long
        # The nickname of the user who wrote the SQL statement.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogList(TeaModel):
    def __init__(self, sqlexec_audit_log=None):
        self.sqlexec_audit_log = sqlexec_audit_log  # type: list[ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog]

    def validate(self):
        if self.sqlexec_audit_log:
            for k in self.sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSQLExecAuditLogResponseBodySQLExecAuditLogList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SQLExecAuditLog'] = []
        if self.sqlexec_audit_log is not None:
            for k in self.sqlexec_audit_log:
                result['SQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.sqlexec_audit_log = []
        if m.get('SQLExecAuditLog') is not None:
            for k in m.get('SQLExecAuditLog'):
                temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog()
                self.sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListSQLExecAuditLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sqlexec_audit_log_list=None,
                 success=None, total_count=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The entries returned.
        self.sqlexec_audit_log_list = sqlexec_audit_log_list  # type: ListSQLExecAuditLogResponseBodySQLExecAuditLogList
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.sqlexec_audit_log_list:
            self.sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super(ListSQLExecAuditLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqlexec_audit_log_list is not None:
            result['SQLExecAuditLogList'] = self.sqlexec_audit_log_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLExecAuditLogList') is not None:
            temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogList()
            self.sqlexec_audit_log_list = temp_model.from_map(m['SQLExecAuditLogList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLExecAuditLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSQLExecAuditLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSQLExecAuditLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetailPage(TeaModel):
    def __init__(self, page_number=None, page_size=None):
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLRequestOrderActionDetailPage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetail(TeaModel):
    def __init__(self, check_status_result=None, file_id=None, page=None, sqlreview_result=None):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement is pending for analysis.
        # *   **unknown**: The SQL statement failed to be parsed.
        # *   **check_not_pass**: The SQL statement failed the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the review by manual effort.
        # *   **force_not_pass**: The SQL statement failed the review by manual effort.
        self.check_status_result = check_status_result  # type: str
        # The ID of the file.
        self.file_id = file_id  # type: long
        # The paging settings.
        self.page = page  # type: ListSQLReviewOriginSQLRequestOrderActionDetailPage
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USE_DMS_TOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USE_DMS_DML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLE_INDEX_SUGGEST**: We recommend that you use SQL statements that use indexes.
        self.sqlreview_result = sqlreview_result  # type: str

    def validate(self):
        if self.page:
            self.page.validate()

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLRequestOrderActionDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.page is not None:
            result['Page'] = self.page.to_map()
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            self.check_status_result = m.get('CheckStatusResult')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('Page') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetailPage()
            self.page = temp_model.from_map(m['Page'])
        if m.get('SQLReviewResult') is not None:
            self.sqlreview_result = m.get('SQLReviewResult')
        return self


class ListSQLReviewOriginSQLRequest(TeaModel):
    def __init__(self, order_action_detail=None, order_id=None, tid=None):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail = order_action_detail  # type: ListSQLReviewOriginSQLRequestOrderActionDetail
        # The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~465818~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        if self.order_action_detail:
            self.order_action_detail.validate()

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail is not None:
            result['OrderActionDetail'] = self.order_action_detail.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetail()
            self.order_action_detail = temp_model.from_map(m['OrderActionDetail'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLShrinkRequest(TeaModel):
    def __init__(self, order_action_detail_shrink=None, order_id=None, tid=None):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail_shrink = order_action_detail_shrink  # type: str
        # The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~465818~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail_shrink is not None:
            result['OrderActionDetail'] = self.order_action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            self.order_action_detail_shrink = m.get('OrderActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLResponseBodyOriginSQLList(TeaModel):
    def __init__(self, check_status=None, checked_time=None, file_id=None, file_name=None, review_summary=None,
                 sqlcontent=None, sqlid=None, sqlname=None, sqlreview_query_key=None, sql_hash=None, status_desc=None):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement is pending for analysis.
        # *   **unknown**: The SQL statement failed to be parsed.
        # *   **check_not_pass**: The SQL statement failed the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the review by manual effort.
        # *   **force_not_pass**: The SQL statement failed the review by manual effort.
        self.check_status = check_status  # type: str
        # The time when the SQL statement is reviewed.
        self.checked_time = checked_time  # type: str
        # The ID of the file.
        self.file_id = file_id  # type: long
        # The name of the file.
        self.file_name = file_name  # type: str
        # The statistics of optimization suggestions for SQL statements. The value is a JSON string. The following optimization suggestions are involved:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
        self.review_summary = review_summary  # type: str
        # The SQL statement.
        self.sqlcontent = sqlcontent  # type: str
        # The ID of the SQL statement.
        self.sqlid = sqlid  # type: long
        # SQLName.
        self.sqlname = sqlname  # type: str
        # The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://icms.alibaba-inc.com/content/dms/doc?l=1\&m=61777\&n=2712723\&spm) operation to query the details of optimization suggestions based on the key.
        self.sqlreview_query_key = sqlreview_query_key  # type: str
        # The MD5 hash value of the SQL statement.
        self.sql_hash = sql_hash  # type: str
        # The description of the review status.
        self.status_desc = status_desc  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLResponseBodyOriginSQLList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.checked_time is not None:
            result['CheckedTime'] = self.checked_time
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.review_summary is not None:
            result['ReviewSummary'] = self.review_summary
        if self.sqlcontent is not None:
            result['SQLContent'] = self.sqlcontent
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqlname is not None:
            result['SQLName'] = self.sqlname
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_hash is not None:
            result['SqlHash'] = self.sql_hash
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckedTime') is not None:
            self.checked_time = m.get('CheckedTime')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('ReviewSummary') is not None:
            self.review_summary = m.get('ReviewSummary')
        if m.get('SQLContent') is not None:
            self.sqlcontent = m.get('SQLContent')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLName') is not None:
            self.sqlname = m.get('SQLName')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlHash') is not None:
            self.sql_hash = m.get('SqlHash')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListSQLReviewOriginSQLResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, origin_sqllist=None, request_id=None, success=None,
                 total_count=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The information about the parsed SQL statements.
        self.origin_sqllist = origin_sqllist  # type: list[ListSQLReviewOriginSQLResponseBodyOriginSQLList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The total number of the SQL statements.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.origin_sqllist:
            for k in self.origin_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OriginSQLList'] = []
        if self.origin_sqllist is not None:
            for k in self.origin_sqllist:
                result['OriginSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.origin_sqllist = []
        if m.get('OriginSQLList') is not None:
            for k in m.get('OriginSQLList'):
                temp_model = ListSQLReviewOriginSQLResponseBodyOriginSQLList()
                self.origin_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLReviewOriginSQLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSQLReviewOriginSQLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSQLReviewOriginSQLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLReviewOriginSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScenariosRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListScenariosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListScenariosResponseBodyScenarioList(TeaModel):
    def __init__(self, creator_id=None, description=None, id=None, scenario_name=None):
        # The ID of the user who created the business scenario.
        self.creator_id = creator_id  # type: str
        # The description of the business scenario.
        self.description = description  # type: str
        # The ID of the business scenario.
        self.id = id  # type: long
        # The name of the business scenario.
        self.scenario_name = scenario_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListScenariosResponseBodyScenarioList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListScenariosResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, scenario_list=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the returned business scenarios.
        self.scenario_list = scenario_list  # type: list[ListScenariosResponseBodyScenarioList]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.scenario_list:
            for k in self.scenario_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListScenariosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ScenarioList'] = []
        if self.scenario_list is not None:
            for k in self.scenario_list:
                result['ScenarioList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scenario_list = []
        if m.get('ScenarioList') is not None:
            for k in m.get('ScenarioList'):
                temp_model = ListScenariosResponseBodyScenarioList()
                self.scenario_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListScenariosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListScenariosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListScenariosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScenariosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsRequest(TeaModel):
    def __init__(self, column_name=None, db_id=None, logic=None, page_number=None, page_size=None, schema_name=None,
                 security_level=None, table_name=None, tid=None):
        # The name of the field. You can call the [ListColumns](~~141870~~) operation to query the name of the field.
        self.column_name = column_name  # type: str
        # The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to query the ID of the database.
        # 
        # >  You can also call the [ListDatabases](~~141873~~) operation to query the ID of the physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic  # type: bool
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The name of the database. You can call the [SearchDatabase](~~141876~~) operation to query the name of the database.
        # 
        # >  You can also call the [ListDatabases](~~141873~~) operation to query the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the name of a logical database.
        self.schema_name = schema_name  # type: str
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        self.security_level = security_level  # type: str
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the ID of the table.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveColumnsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn(TeaModel):
    def __init__(self, column_count=None, column_name=None, function_type=None, schema_name=None,
                 security_level=None, table_name=None):
        # The number of sensitive fields.
        self.column_count = column_count  # type: long
        # The name of the field.
        self.column_name = column_name  # type: str
        # The type of the de-identification algorithm. Valid values:
        # 
        # *   DEFAULT: All characters are masked. This is the default value.
        # *   FIX_POS: The characters at specific positions are masked.
        # *   FIX_CHAR: Specific characters are masked.
        self.function_type = function_type  # type: str
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE
        # *   CONFIDENTIAL
        self.security_level = security_level  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnList(TeaModel):
    def __init__(self, sensitive_column=None):
        self.sensitive_column = sensitive_column  # type: list[ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn]

    def validate(self):
        if self.sensitive_column:
            for k in self.sensitive_column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsResponseBodySensitiveColumnList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumn'] = []
        if self.sensitive_column is not None:
            for k in self.sensitive_column:
                result['SensitiveColumn'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.sensitive_column = []
        if m.get('SensitiveColumn') is not None:
            for k in m.get('SensitiveColumn'):
                temp_model = ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn()
                self.sensitive_column.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sensitive_column_list=None,
                 success=None, total_count=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The sensitive fields.
        self.sensitive_column_list = sensitive_column_list  # type: ListSensitiveColumnsResponseBodySensitiveColumnList
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.sensitive_column_list:
            self.sensitive_column_list.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_column_list is not None:
            result['SensitiveColumnList'] = self.sensitive_column_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnList') is not None:
            temp_model = ListSensitiveColumnsResponseBodySensitiveColumnList()
            self.sensitive_column_list = temp_model.from_map(m['SensitiveColumnList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveColumnsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSensitiveColumnsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsDetailRequest(TeaModel):
    def __init__(self, column_name=None, db_id=None, logic=None, schema_name=None, table_name=None, tid=None):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the field.
        # 
        # >  You can also call the [ListColumns](~~141870~~) operation to obtain the name of the field.
        self.column_name = column_name  # type: str
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic  # type: bool
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the database.
        # 
        # > * You can also call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a physical database.
        # > * You can also call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a logical database.
        self.schema_name = schema_name  # type: str
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the table.
        # 
        # >  You can also call the [ListTables](~~141878~~) operation to obtain the name of the table.
        self.table_name = table_name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveColumnsDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail(TeaModel):
    def __init__(self, column_description=None, column_name=None, column_type=None, db_id=None, db_type=None,
                 env_type=None, logic=None, schema_name=None, search_name=None, table_name=None):
        # The description of the field.
        self.column_description = column_description  # type: str
        # The name of the field.
        self.column_name = column_name  # type: str
        # The data type of the field.
        self.column_type = column_type  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: long
        # The type of the database.
        self.db_type = db_type  # type: str
        # The type of the environment to which the database belongs.
        self.env_type = env_type  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic  # type: bool
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_description is not None:
            result['ColumnDescription'] = self.column_description
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnDescription') is not None:
            self.column_description = m.get('ColumnDescription')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList(TeaModel):
    def __init__(self, sensitive_columns_detail=None):
        self.sensitive_columns_detail = sensitive_columns_detail  # type: list[ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail]

    def validate(self):
        if self.sensitive_columns_detail:
            for k in self.sensitive_columns_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumnsDetail'] = []
        if self.sensitive_columns_detail is not None:
            for k in self.sensitive_columns_detail:
                result['SensitiveColumnsDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.sensitive_columns_detail = []
        if m.get('SensitiveColumnsDetail') is not None:
            for k in m.get('SensitiveColumnsDetail'):
                temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail()
                self.sensitive_columns_detail.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsDetailResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sensitive_columns_detail_list=None,
                 success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the sensitive field.
        self.sensitive_columns_detail_list = sensitive_columns_detail_list  # type: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.sensitive_columns_detail_list:
            self.sensitive_columns_detail_list.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_columns_detail_list is not None:
            result['SensitiveColumnsDetailList'] = self.sensitive_columns_detail_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnsDetailList') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList()
            self.sensitive_columns_detail_list = temp_model.from_map(m['SensitiveColumnsDetailList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSensitiveColumnsDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSensitiveColumnsDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSensitiveColumnsDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveDataAuditLogRequest(TeaModel):
    def __init__(self, column_name=None, db_name=None, end_time=None, module_name=None, op_user_name=None,
                 page_number=None, page_size=None, start_time=None, table_name=None, tid=None):
        # The name of the column that contains sensitive data.
        self.column_name = column_name  # type: str
        # The name of the database that stores the sensitive data.
        self.db_name = db_name  # type: str
        # The end of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time  # type: str
        # The function module whose audit logs you want to query for sensitive data. If you do not specify this parameter, all audit logs are queried. Valid values:
        # 
        # *   **SQL_CONSOLE**: data query
        # *   **SQL_CONSOLE_EXPORT**: query result export
        # *   **DATA_CHANGE**: data change
        # *   **DATA_EXPORT**: data export
        self.module_name = module_name  # type: str
        # The username of the requester.
        self.op_user_name = op_user_name  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Example: 100
        self.page_size = page_size  # type: int
        # The beginning of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time  # type: str
        # The name of the table that stores the sensitive data.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveDataAuditLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog(TeaModel):
    def __init__(self, column_name=None, column_permission_type=None, desensitization_rule=None,
                 security_level=None, table_name=None):
        # The name of the column that contains sensitive data.
        self.column_name = column_name  # type: str
        # The permission that the user has on the column. Valid values:
        # 
        # *   **No permission**\
        # *   **Partial redaction**\
        # *   **Plaintext**\
        # *   **Change**\
        # *   **Enable data masking**\
        # *   **Disable data masking**\
        self.column_permission_type = column_permission_type  # type: str
        # The algorithm used for data masking.
        self.desensitization_rule = desensitization_rule  # type: str
        # The sensitivity level of the data. Valid values:
        # 
        # *   **Low**\
        # *   **Medium**\
        # *   **High**\
        self.security_level = security_level  # type: str
        # The name of the table that stores the sensitive data.
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_permission_type is not None:
            result['ColumnPermissionType'] = self.column_permission_type
        if self.desensitization_rule is not None:
            result['DesensitizationRule'] = self.desensitization_rule
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPermissionType') is not None:
            self.column_permission_type = m.get('ColumnPermissionType')
        if m.get('DesensitizationRule') is not None:
            self.desensitization_rule = m.get('DesensitizationRule')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList(TeaModel):
    def __init__(self, db_display_name=None, instance_id=None, module_name=None, op_time=None,
                 sensitive_data_log=None, target_name=None, user_id=None, user_name=None):
        # The name of the database that stores the sensitive data.
        self.db_display_name = db_display_name  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: long
        # The name of the function module whose audit logs were queried.
        self.module_name = module_name  # type: str
        # The time when the operation was performed. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.op_time = op_time  # type: str
        # The logs for sensitive data.
        self.sensitive_data_log = sensitive_data_log  # type: list[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog]
        # The details of the object on which the operation was performed. The value of this parameter is in one of the following formats:
        # 
        # *   Object name - object ID
        # *   Object name (object ID)
        self.target_name = target_name  # type: str
        # The user ID of the requester.
        self.user_id = user_id  # type: long
        # The username of the requester.
        self.user_name = user_name  # type: str

    def validate(self):
        if self.sensitive_data_log:
            for k in self.sensitive_data_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_display_name is not None:
            result['DbDisplayName'] = self.db_display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        result['SensitiveDataLog'] = []
        if self.sensitive_data_log is not None:
            for k in self.sensitive_data_log:
                result['SensitiveDataLog'].append(k.to_map() if k else None)
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbDisplayName') is not None:
            self.db_display_name = m.get('DbDisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        self.sensitive_data_log = []
        if m.get('SensitiveDataLog') is not None:
            for k in m.get('SensitiveDataLog'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog()
                self.sensitive_data_log.append(temp_model.from_map(k))
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSensitiveDataAuditLogResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sensitive_data_audit_log_list=None,
                 success=None, total_count=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The audit logs for sensitive data.
        self.sensitive_data_audit_log_list = sensitive_data_audit_log_list  # type: list[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.sensitive_data_audit_log_list:
            for k in self.sensitive_data_audit_log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSensitiveDataAuditLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveDataAuditLogList'] = []
        if self.sensitive_data_audit_log_list is not None:
            for k in self.sensitive_data_audit_log_list:
                result['SensitiveDataAuditLogList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_data_audit_log_list = []
        if m.get('SensitiveDataAuditLogList') is not None:
            for k in m.get('SensitiveDataAuditLogList'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList()
                self.sensitive_data_audit_log_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveDataAuditLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSensitiveDataAuditLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSensitiveDataAuditLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveDataAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitivityLevelRequest(TeaModel):
    def __init__(self, template_id=None, template_type=None, tid=None):
        self.template_id = template_id  # type: long
        self.template_type = template_type  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitivityLevelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitivityLevelResponseBodySensitivityLevelList(TeaModel):
    def __init__(self, is_plain=None, name=None, template_id=None, template_type=None):
        self.is_plain = is_plain  # type: bool
        self.name = name  # type: str
        self.template_id = template_id  # type: str
        self.template_type = template_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSensitivityLevelResponseBodySensitivityLevelList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_plain is not None:
            result['IsPlain'] = self.is_plain
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsPlain') is not None:
            self.is_plain = m.get('IsPlain')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListSensitivityLevelResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, sensitivity_level_list=None,
                 success=None):
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.sensitivity_level_list = sensitivity_level_list  # type: list[ListSensitivityLevelResponseBodySensitivityLevelList]
        self.success = success  # type: bool

    def validate(self):
        if self.sensitivity_level_list:
            for k in self.sensitivity_level_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSensitivityLevelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitivityLevelList'] = []
        if self.sensitivity_level_list is not None:
            for k in self.sensitivity_level_list:
                result['SensitivityLevelList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitivity_level_list = []
        if m.get('SensitivityLevelList') is not None:
            for k in m.get('SensitivityLevelList'):
                temp_model = ListSensitivityLevelResponseBodySensitivityLevelList()
                self.sensitivity_level_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSensitivityLevelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSensitivityLevelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSensitivityLevelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitivityLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListStandardGroupsRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListStandardGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListStandardGroupsResponseBodyStandardGroupList(TeaModel):
    def __init__(self, db_type=None, description=None, group_id=None, group_mode=None, group_name=None,
                 last_mender_id=None):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The description of the security rule set.
        self.description = description  # type: str
        # The ID of the security rule set.
        self.group_id = group_id  # type: long
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode  # type: str
        # The name of the security rule set.
        self.group_name = group_name  # type: str
        # The ID of the user who queries the security sets.
        self.last_mender_id = last_mender_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListStandardGroupsResponseBodyStandardGroupList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class ListStandardGroupsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, standard_group_list=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The security rule sets returned.
        self.standard_group_list = standard_group_list  # type: list[ListStandardGroupsResponseBodyStandardGroupList]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.standard_group_list:
            for k in self.standard_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListStandardGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StandardGroupList'] = []
        if self.standard_group_list is not None:
            for k in self.standard_group_list:
                result['StandardGroupList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standard_group_list = []
        if m.get('StandardGroupList') is not None:
            for k in m.get('StandardGroupList'):
                temp_model = ListStandardGroupsResponseBodyStandardGroupList()
                self.standard_group_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListStandardGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListStandardGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListStandardGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListStandardGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTablesRequest(TeaModel):
    def __init__(self, database_id=None, page_number=None, page_size=None, return_guid=None, search_name=None,
                 tid=None):
        # The ID of the physical database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID of the physical database.
        self.database_id = database_id  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # Specifies whether to return the GUID of a table. Valid values:
        # 
        # *   **true**: returns the GUID of a table.
        # *   **false**: does not return the GUID of a table.
        self.return_guid = return_guid  # type: bool
        # The name used to search for tables. Fuzzy search is supported.
        self.search_name = search_name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTablesResponseBodyTableListTableOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTablesResponseBodyTableListTableOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListTablesResponseBodyTableListTableOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTablesResponseBodyTableListTableOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListTablesResponseBodyTableListTable(TeaModel):
    def __init__(self, database_id=None, description=None, encoding=None, engine=None, num_rows=None,
                 owner_id_list=None, owner_name_list=None, store_capacity=None, table_guid=None, table_id=None, table_name=None,
                 table_schema_name=None, table_type=None):
        # The ID of the physical database.
        self.database_id = database_id  # type: str
        # The description of the table.
        self.description = description  # type: str
        # The encoding format of the table.
        self.encoding = encoding  # type: str
        # The engine of the table.
        self.engine = engine  # type: str
        # The number of rows in the table. This is a statistical value and does not indicate the actual number of rows.
        self.num_rows = num_rows  # type: long
        # The ID list of the table owners.
        self.owner_id_list = owner_id_list  # type: ListTablesResponseBodyTableListTableOwnerIdList
        # The nickname list of the table owners.
        self.owner_name_list = owner_name_list  # type: ListTablesResponseBodyTableListTableOwnerNameList
        # The storage space that is occupied by the table. This is a statistical value and does not indicate the accurate storage space. Unit: MB.
        self.store_capacity = store_capacity  # type: long
        # The GUID of the table in DMS.
        self.table_guid = table_guid  # type: str
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The table name.
        self.table_name = table_name  # type: str
        # The database in which the table resides.
        self.table_schema_name = table_schema_name  # type: str
        # The type of the table. Default value: NORMAL.
        self.table_type = table_type  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(ListTablesResponseBodyTableListTable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.num_rows is not None:
            result['NumRows'] = self.num_rows
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.store_capacity is not None:
            result['StoreCapacity'] = self.store_capacity
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('NumRows') is not None:
            self.num_rows = m.get('NumRows')
        if m.get('OwnerIdList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('StoreCapacity') is not None:
            self.store_capacity = m.get('StoreCapacity')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class ListTablesResponseBodyTableList(TeaModel):
    def __init__(self, table=None):
        self.table = table  # type: list[ListTablesResponseBodyTableListTable]

    def validate(self):
        if self.table:
            for k in self.table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTablesResponseBodyTableList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Table'] = []
        if self.table is not None:
            for k in self.table:
                result['Table'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.table = []
        if m.get('Table') is not None:
            for k in m.get('Table'):
                temp_model = ListTablesResponseBodyTableListTable()
                self.table.append(temp_model.from_map(k))
        return self


class ListTablesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, table_list=None,
                 total_count=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The details of the tables.
        self.table_list = table_list  # type: ListTablesResponseBodyTableList
        # The total number of tables that meet the query conditions.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.table_list:
            self.table_list.validate()

    def to_map(self):
        _map = super(ListTablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_list is not None:
            result['TableList'] = self.table_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableList') is not None:
            temp_model = ListTablesResponseBodyTableList()
            self.table_list = temp_model.from_map(m['TableList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(self, creator_id=None, creator_nick_name=None, dag_owner_nick_name=None, deploy_id=None, id=None,
                 latest_instance_status=None, latest_instance_time=None, status=None):
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id  # type: str
        # The name of the user who creates the task flow.
        self.creator_nick_name = creator_nick_name  # type: str
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name  # type: str
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id  # type: long
        # The ID of the task flow.
        self.id = id  # type: long
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid.
        # *   **1**: scheduling disabled.
        # *   **2**: waiting to be scheduled.
        self.latest_instance_status = latest_instance_status  # type: int
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time  # type: str
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is invalid.
        # *   **1**: Scheduling is disabled for the task flow.
        # *   **2**: The task flow is waiting to be scheduled.
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowResponseBodyTaskFlowListTaskFlow, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskFlowResponseBodyTaskFlowList(TeaModel):
    def __init__(self, task_flow=None):
        self.task_flow = task_flow  # type: list[ListTaskFlowResponseBodyTaskFlowListTaskFlow]

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowResponseBodyTaskFlowList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, task_flow_list=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The information about the task flows returned.
        self.task_flow_list = task_flow_list  # type: ListTaskFlowResponseBodyTaskFlowList

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super(ListTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        return self


class ListTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowConstantsRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowConstantsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant(TeaModel):
    def __init__(self, key=None, value=None):
        # The constant key.
        self.key = key  # type: str
        # The constant value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowConstantsResponseBodyDagConstantsDagConstant, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTaskFlowConstantsResponseBodyDagConstants(TeaModel):
    def __init__(self, dag_constant=None):
        self.dag_constant = dag_constant  # type: list[ListTaskFlowConstantsResponseBodyDagConstantsDagConstant]

    def validate(self):
        if self.dag_constant:
            for k in self.dag_constant:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowConstantsResponseBodyDagConstants, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstant'] = []
        if self.dag_constant is not None:
            for k in self.dag_constant:
                result['DagConstant'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dag_constant = []
        if m.get('DagConstant') is not None:
            for k in m.get('DagConstant'):
                temp_model = ListTaskFlowConstantsResponseBodyDagConstantsDagConstant()
                self.dag_constant.append(temp_model.from_map(k))
        return self


class ListTaskFlowConstantsResponseBody(TeaModel):
    def __init__(self, dag_constants=None, error_code=None, error_message=None, request_id=None, success=None):
        # A list of constant key-value pairs for the task flow.
        self.dag_constants = dag_constants  # type: ListTaskFlowConstantsResponseBodyDagConstants
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.dag_constants:
            self.dag_constants.validate()

    def to_map(self):
        _map = super(ListTaskFlowConstantsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants is not None:
            result['DagConstants'] = self.dag_constants.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            temp_model = ListTaskFlowConstantsResponseBodyDagConstants()
            self.dag_constants = temp_model.from_map(m['DagConstants'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowConstantsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowConstantsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowConstantsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowCooperatorsRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowCooperatorsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator(TeaModel):
    def __init__(self, email=None, login_name=None, nick_name=None, user_id=None):
        # The email address of the user.
        self.email = email  # type: str
        # The username.
        self.login_name = login_name  # type: str
        # The alias of the user.
        self.nick_name = nick_name  # type: str
        # userId.
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['Email'] = self.email
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorList(TeaModel):
    def __init__(self, cooperator=None):
        self.cooperator = cooperator  # type: list[ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator]

    def validate(self):
        if self.cooperator:
            for k in self.cooperator:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowCooperatorsResponseBodyCooperatorList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cooperator'] = []
        if self.cooperator is not None:
            for k in self.cooperator:
                result['Cooperator'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cooperator = []
        if m.get('Cooperator') is not None:
            for k in m.get('Cooperator'):
                temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator()
                self.cooperator.append(temp_model.from_map(k))
        return self


class ListTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(self, cooperator_list=None, error_code=None, error_message=None, request_id=None, success=None):
        # The users that are involved in the task flow.
        self.cooperator_list = cooperator_list  # type: ListTaskFlowCooperatorsResponseBodyCooperatorList
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.cooperator_list:
            self.cooperator_list.validate()

    def to_map(self):
        _map = super(ListTaskFlowCooperatorsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_list is not None:
            result['CooperatorList'] = self.cooperator_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CooperatorList') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorList()
            self.cooperator_list = temp_model.from_map(m['CooperatorList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowCooperatorsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowCooperatorsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowCooperatorsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(self, dag_id=None, id=None, node_end=None, node_from=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the task flow edge.
        self.id = id  # type: long
        # The ID of the end node on the edge.
        self.node_end = node_end  # type: long
        # The ID of the start node on the edge.
        self.node_from = node_from  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowEdgesByConditionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge(TeaModel):
    def __init__(self, id=None, node_end=None, node_from=None):
        # The ID of the task flow edge.
        self.id = id  # type: long
        # The ID of the end node on the edge.
        self.node_end = node_end  # type: long
        # The ID of the start node on the edge.
        self.node_from = node_from  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowEdgesByConditionResponseBodyEdgesEdge, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdges(TeaModel):
    def __init__(self, edge=None):
        self.edge = edge  # type: list[ListTaskFlowEdgesByConditionResponseBodyEdgesEdge]

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowEdgesByConditionResponseBodyEdges, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = ListTaskFlowEdgesByConditionResponseBodyEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class ListTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(self, edges=None, error_code=None, error_message=None, request_id=None, success=None):
        # The list of task flow edges.
        self.edges = edges  # type: ListTaskFlowEdgesByConditionResponseBodyEdges
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.edges:
            self.edges.validate()

    def to_map(self):
        _map = super(ListTaskFlowEdgesByConditionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Edges') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBodyEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowEdgesByConditionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowEdgesByConditionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowInstanceRequest(TeaModel):
    def __init__(self, dag_id=None, page_index=None, page_size=None, start_time_begin=None, start_time_end=None,
                 status=None, tid=None, trigger_type=None, use_biz_date=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The number of the page to return.
        self.page_index = page_index  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The beginning of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_begin = start_time_begin  # type: str
        # The end of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_end = start_time_end  # type: str
        # The running status of the task node. Valid values:
        # 
        # - **0**: Waiting for scheduling
        # 
        # - **1**: Running
        # 
        # - **2**: Suspend
        # 
        # - **3**: Failed to run
        # 
        # - **4**: Run successfully
        # 
        # - **5**: Completed
        self.status = status  # type: int
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type  # type: int
        # Adjust filter conditions:
        # 
        # - true: StartTimeBegin and StartTimeEnd are the time range for filtering services.
        # 
        # - false: StartTimeBegin and StartTimeEnd are the time range for the task to run.
        self.use_biz_date = use_biz_date  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time_begin is not None:
            result['StartTimeBegin'] = self.start_time_begin
        if self.start_time_end is not None:
            result['StartTimeEnd'] = self.start_time_end
        if self.status is not None:
            result['Status'] = self.status
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.use_biz_date is not None:
            result['UseBizDate'] = self.use_biz_date
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimeBegin') is not None:
            self.start_time_begin = m.get('StartTimeBegin')
        if m.get('StartTimeEnd') is not None:
            self.start_time_end = m.get('StartTimeEnd')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('UseBizDate') is not None:
            self.use_biz_date = m.get('UseBizDate')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance(TeaModel):
    def __init__(self, business_time=None, dag_id=None, dag_name=None, dag_version=None, end_time=None,
                 history_dag_id=None, id=None, message=None, owner_name=None, status=None, trigger_type=None, start_time=None):
        # The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.business_time = business_time  # type: str
        # The ID of the task flow.
        self.dag_id = dag_id  # type: str
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The version of the task flow.
        self.dag_version = dag_version  # type: str
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time  # type: str
        # The ID of the previously published version of the task flow.
        self.history_dag_id = history_dag_id  # type: long
        # The ID of the execution record.
        self.id = id  # type: long
        # The description of the task.
        self.message = message  # type: str
        # The name of the task flow owner.
        self.owner_name = owner_name  # type: str
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is waiting to be scheduled.
        # *   **1**: The task flow is being executed.
        # *   **2**: The task flow is paused.
        # *   **3**: The task flow failed.
        # *   **4**: The task flow is executed.
        # *   **5**: The task flow is complete.
        self.status = status  # type: int
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type  # type: int
        # The time when the execution of the task flow was start. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.owner_name is not None:
            result['OwnerName'] = self.owner_name
        if self.status is not None:
            result['Status'] = self.status
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OwnerName') is not None:
            self.owner_name = m.get('OwnerName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceList(TeaModel):
    def __init__(self, daginstance=None):
        self.daginstance = daginstance  # type: list[ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance]

    def validate(self):
        if self.daginstance:
            for k in self.daginstance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowInstanceResponseBodyDAGInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DAGInstance'] = []
        if self.daginstance is not None:
            for k in self.daginstance:
                result['DAGInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.daginstance = []
        if m.get('DAGInstance') is not None:
            for k in m.get('DAGInstance'):
                temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance()
                self.daginstance.append(temp_model.from_map(k))
        return self


class ListTaskFlowInstanceResponseBody(TeaModel):
    def __init__(self, daginstance_list=None, error_code=None, error_message=None, request_id=None, success=None,
                 total_count=None):
        # The information about the execution records returned.
        self.daginstance_list = daginstance_list  # type: ListTaskFlowInstanceResponseBodyDAGInstanceList
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The total number of execution records returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.daginstance_list:
            self.daginstance_list.validate()

    def to_map(self):
        _map = super(ListTaskFlowInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.daginstance_list is not None:
            result['DAGInstanceList'] = self.daginstance_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DAGInstanceList') is not None:
            temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceList()
            self.daginstance_list = temp_model.from_map(m['DAGInstanceList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowTimeVariablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable(TeaModel):
    def __init__(self, name=None, pattern=None):
        # The name of the time variable.
        self.name = name  # type: str
        # The format of the time variable.
        self.pattern = pattern  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariables(TeaModel):
    def __init__(self, time_variable=None):
        self.time_variable = time_variable  # type: list[ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable]

    def validate(self):
        if self.time_variable:
            for k in self.time_variable:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowTimeVariablesResponseBodyTimeVariables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TimeVariable'] = []
        if self.time_variable is not None:
            for k in self.time_variable:
                result['TimeVariable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.time_variable = []
        if m.get('TimeVariable') is not None:
            for k in m.get('TimeVariable'):
                temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable()
                self.time_variable.append(temp_model.from_map(k))
        return self


class ListTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, time_variables=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The time variables for the task flow.
        self.time_variables = time_variables  # type: ListTaskFlowTimeVariablesResponseBodyTimeVariables

    def validate(self):
        if self.time_variables:
            self.time_variables.validate()

    def to_map(self):
        _map = super(ListTaskFlowTimeVariablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeVariables') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariables()
            self.time_variables = temp_model.from_map(m['TimeVariables'])
        return self


class ListTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowTimeVariablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowTimeVariablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowsByPageRequest(TeaModel):
    def __init__(self, dag_id_list=None, page_index=None, page_size=None, scenario_id=None, search_key=None,
                 tid=None):
        # Filter condition, task flow ID list.
        self.dag_id_list = dag_id_list  # type: list[long]
        # The number of the page to return.
        self.page_index = page_index  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # Filter condition, application scenario ID.
        self.scenario_id = scenario_id  # type: long
        # The keyword that is used to search for task flow names.
        self.search_key = search_key  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowsByPageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id_list is not None:
            result['DagIdList'] = self.dag_id_list
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagIdList') is not None:
            self.dag_id_list = m.get('DagIdList')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowsByPageShrinkRequest(TeaModel):
    def __init__(self, dag_id_list_shrink=None, page_index=None, page_size=None, scenario_id=None, search_key=None,
                 tid=None):
        # Filter condition, task flow ID list.
        self.dag_id_list_shrink = dag_id_list_shrink  # type: str
        # The number of the page to return.
        self.page_index = page_index  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # Filter condition, application scenario ID.
        self.scenario_id = scenario_id  # type: long
        # The keyword that is used to search for task flow names.
        self.search_key = search_key  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowsByPageShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id_list_shrink is not None:
            result['DagIdList'] = self.dag_id_list_shrink
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagIdList') is not None:
            self.dag_id_list_shrink = m.get('DagIdList')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(self, creator_id=None, creator_nick_name=None, cron_begin_date=None, cron_end_date=None,
                 cron_str=None, cron_switch=None, cron_type=None, dag_name=None, dag_owner_id=None, dag_owner_nick_name=None,
                 deploy_id=None, description=None, id=None, latest_instance_status=None, latest_instance_time=None,
                 scenario_id=None, schedule_param=None, status=None, time_zone_id=None, trigger_type=None):
        # The ID of the user who created the task flow.
        self.creator_id = creator_id  # type: str
        # The username of the user who created the task flow.
        self.creator_nick_name = creator_nick_name  # type: str
        # The start time of scheduled scheduling. The task flow is not scheduled before this point in time.
        self.cron_begin_date = cron_begin_date  # type: str
        # The end time of scheduled scheduling. The task flow is not scheduled after this point in time.
        self.cron_end_date = cron_end_date  # type: str
        # Scheduled Cron.
        self.cron_str = cron_str  # type: str
        # Whether to enable scheduled scheduling.
        self.cron_switch = cron_switch  # type: bool
        # Scheduling cycle type. Valid values:
        # - **2**: Hourly scheduling
        # - **3**: Daily scheduling
        # - **4**: Weekly scheduling
        # - **5**: Monthly scheduling
        self.cron_type = cron_type  # type: int
        # The name of the task flow.
        self.dag_name = dag_name  # type: str
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id  # type: str
        # The username of the owner of the task flow.
        self.dag_owner_nick_name = dag_owner_nick_name  # type: str
        # The ID of the last deployment record of the task flow.
        self.deploy_id = deploy_id  # type: long
        # The description of the task flow.
        self.description = description  # type: str
        # The ID of the task flow.
        self.id = id  # type: long
        # The status of the last execution of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.latest_instance_status = latest_instance_status  # type: int
        # The time when the last execution record was created.
        self.latest_instance_time = latest_instance_time  # type: str
        # The ID of the application scenario.
        self.scenario_id = scenario_id  # type: str
        # Event scheduling configuration, JSON string format.
        self.schedule_param = schedule_param  # type: str
        # The status of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.status = status  # type: int
        # Time zone setting. Default value: East 8(Asia/Shanghai).
        self.time_zone_id = time_zone_id  # type: str
        # The trigger type. Valid values:
        # - **0**: Periodic scheduling
        # - **1**: Run manually
        self.trigger_type = trigger_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.cron_switch is not None:
            result['CronSwitch'] = self.cron_switch
        if self.cron_type is not None:
            result['CronType'] = self.cron_type
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.schedule_param is not None:
            result['ScheduleParam'] = self.schedule_param
        if self.status is not None:
            result['Status'] = self.status
        if self.time_zone_id is not None:
            result['TimeZoneId'] = self.time_zone_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('CronSwitch') is not None:
            self.cron_switch = m.get('CronSwitch')
        if m.get('CronType') is not None:
            self.cron_type = m.get('CronType')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('ScheduleParam') is not None:
            self.schedule_param = m.get('ScheduleParam')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimeZoneId') is not None:
            self.time_zone_id = m.get('TimeZoneId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowList(TeaModel):
    def __init__(self, task_flow=None):
        self.task_flow = task_flow  # type: list[ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow]

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTaskFlowsByPageResponseBodyTaskFlowList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowsByPageResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, task_flow_list=None,
                 total_count=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The details of the returned task flows.
        self.task_flow_list = task_flow_list  # type: ListTaskFlowsByPageResponseBodyTaskFlowList
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super(ListTaskFlowsByPageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowsByPageResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowsByPageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTaskFlowsByPageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTaskFlowsByPageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowsByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTasksInTaskFlowRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTasksInTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTasksInTaskFlowResponseBodyTasksTask(TeaModel):
    def __init__(self, graph_param=None, node_config=None, node_content=None, node_id=None, node_name=None,
                 node_output=None, node_type=None, time_variables=None):
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param  # type: str
        # The advanced configuration for the node.
        self.node_config = node_config  # type: str
        # The configuration for the node.
        self.node_content = node_content  # type: str
        # The ID of the node.
        self.node_id = node_id  # type: str
        # The name of the node.
        self.node_name = node_name  # type: str
        # The output variables for the task.
        self.node_output = node_output  # type: str
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type  # type: str
        # The time variables configured for the node.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTasksInTaskFlowResponseBodyTasksTask, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class ListTasksInTaskFlowResponseBodyTasks(TeaModel):
    def __init__(self, task=None):
        self.task = task  # type: list[ListTasksInTaskFlowResponseBodyTasksTask]

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTasksInTaskFlowResponseBodyTasks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = ListTasksInTaskFlowResponseBodyTasksTask()
                self.task.append(temp_model.from_map(k))
        return self


class ListTasksInTaskFlowResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, tasks=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The tasks in the task flow.
        self.tasks = tasks  # type: ListTasksInTaskFlowResponseBodyTasks

    def validate(self):
        if self.tasks:
            self.tasks.validate()

    def to_map(self):
        _map = super(ListTasksInTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tasks is not None:
            result['Tasks'] = self.tasks.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tasks') is not None:
            temp_model = ListTasksInTaskFlowResponseBodyTasks()
            self.tasks = temp_model.from_map(m['Tasks'])
        return self


class ListTasksInTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTasksInTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTasksInTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTasksInTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserPermissionsRequest(TeaModel):
    def __init__(self, database_name=None, db_type=None, env_type=None, logic=None, page_number=None, page_size=None,
                 perm_type=None, search_key=None, tid=None, user_id=None):
        # The name of the database.
        self.database_name = database_name  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: staging environment
        # *   test: test environment
        # *   sit: SIT environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: STAG environment
        self.env_type = env_type  # type: str
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic  # type: bool
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The permissions on a specific type of resources that you want to query. Valid values:
        # 
        # *   DATABASE: permissions on databases
        # *   TABLE: permissions on tables
        # *   COLUMN: permissions on fields
        # *   INSTANCE: permissions on instances
        self.perm_type = perm_type  # type: str
        # The keyword used in the query. For example, if you want to query permissions on an instance, you can specify the endpoint of the instance, such as rm-bp144d5ky4l4r****.
        self.search_key = search_key  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserPermissionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(self, create_date=None, expire_date=None, extra_data=None, origin_from=None, perm_type=None,
                 user_access_id=None):
        # The time when the permissions were granted.
        self.create_date = create_date  # type: str
        # The time when the permissions expire.
        self.expire_date = expire_date  # type: str
        # This parameter is reserved.
        self.extra_data = extra_data  # type: str
        # The user who grants the permissions.
        self.origin_from = origin_from  # type: str
        # The type of the permissions. Valid values:
        # 
        # *   QUERY: the query permissions
        # *   EXPORT: the export permissions
        # *   CORRECT: the change permissions
        self.perm_type = perm_type  # type: str
        # The ID of the authorization record.
        self.user_access_id = user_access_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(self, perm_detail=None):
        self.perm_detail = perm_detail  # type: list[ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail]

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(self, alias=None, column_name=None, db_id=None, db_type=None, ds_type=None, env_type=None, host=None,
                 instance_id=None, logic=None, perm_details=None, port=None, schema_name=None, search_name=None, table_id=None,
                 table_name=None, user_id=None, user_nick_name=None):
        # The alias of the instance.
        self.alias = alias  # type: str
        # The name of the field.
        self.column_name = column_name  # type: str
        # The ID of the database.
        self.db_id = db_id  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type  # type: str
        # The permissions on a specific type of objects that are granted to the user. Valid values: 
        # 
        # - DATABASE: permissions on physical databases
        # - LOGIC_DATABASE: permissions on logical databases
        # - TABLE: permissions on physical tables
        # - LOGIC_TABLE: permissions on logical tables
        self.ds_type = ds_type  # type: str
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: SIT environment
        # - uat: UAT environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type  # type: str
        # The endpoint that is used to connect the database.
        self.host = host  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic  # type: bool
        # The details of permissions.
        self.perm_details = perm_details  # type: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails
        # The port that is used to connect to the instance.
        self.port = port  # type: long
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: str
        # The nickname of the user.
        self.user_nick_name = user_nick_name  # type: str

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super(ListUserPermissionsResponseBodyUserPermissionsUserPermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(self, user_permission=None):
        self.user_permission = user_permission  # type: list[ListUserPermissionsResponseBodyUserPermissionsUserPermission]

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUserPermissionsResponseBodyUserPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, total_count=None,
                 user_permissions=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success  # type: bool
        # The total number of entries that meet the query conditions.
        self.total_count = total_count  # type: long
        # The details of the permissions that the user has.
        self.user_permissions = user_permissions  # type: ListUserPermissionsResponseBodyUserPermissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super(ListUserPermissionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListUserPermissionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUserPermissionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUserPermissionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserTenantsRequest(TeaModel):
    def __init__(self, tid=None):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserTenantsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBodyTenantList(TeaModel):
    def __init__(self, status=None, tenant_name=None, tid=None):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status  # type: str
        # The name of the tenant.
        self.tenant_name = tenant_name  # type: str
        # The ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserTenantsResponseBodyTenantList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, tenant_list=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The details of the tenants that were returned.
        self.tenant_list = tenant_list  # type: list[ListUserTenantsResponseBodyTenantList]

    def validate(self):
        if self.tenant_list:
            for k in self.tenant_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUserTenantsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TenantList'] = []
        if self.tenant_list is not None:
            for k in self.tenant_list:
                result['TenantList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.tenant_list = []
        if m.get('TenantList') is not None:
            for k in m.get('TenantList'):
                temp_model = ListUserTenantsResponseBodyTenantList()
                self.tenant_list.append(temp_model.from_map(k))
        return self


class ListUserTenantsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUserTenantsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUserTenantsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserTenantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUsersRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, role=None, search_key=None, tid=None, user_state=None):
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # **\
        # 
        # Valid values: 10, 20, 50, and 100.**** Default value: 10.
        self.page_size = page_size  # type: int
        # The role that is assigned to the user. Valid values:
        # 
        # *   **USER**: a regular user.
        # *   **DBA** : a database administrator (DBA).
        # *   **ADMIN**: a Data Management (DMS) administrator.
        # *   **SECURITY_ADMIN**: a security administrator.
        # *   **STRUCT_READ_ONLY**: a schema read-only user.
        # 
        # >  To check your role, move the pointer over the profile picture in the upper-right corner of the DMS console.
        self.role = role  # type: str
        # The search keyword. Fuzzy match is supported.
        self.search_key = search_key  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.user_state = user_state  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.role is not None:
            result['Role'] = self.role
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_state is not None:
            result['UserState'] = self.user_state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        return self


class ListUsersResponseBodyUserListUserRoleIdList(TeaModel):
    def __init__(self, role_ids=None):
        self.role_ids = role_ids  # type: list[int]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUsersResponseBodyUserListUserRoleIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class ListUsersResponseBodyUserListUserRoleNameList(TeaModel):
    def __init__(self, role_names=None):
        self.role_names = role_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUsersResponseBodyUserListUserRoleNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class ListUsersResponseBodyUserListUser(TeaModel):
    def __init__(self, cur_execute_count=None, cur_result_count=None, ding_robot=None, email=None,
                 last_login_time=None, max_execute_count=None, max_result_count=None, mobile=None, nick_name=None,
                 notification_mode=None, parent_uid=None, role_id_list=None, role_name_list=None, signature_method=None, state=None,
                 uid=None, user_id=None, webhook=None):
        # The number of queries that were performed on the current day.
        self.cur_execute_count = cur_execute_count  # type: long
        # The number of rows that were queried on the current day.
        self.cur_result_count = cur_result_count  # type: long
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot  # type: str
        # The email address that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set an email address.
        self.email = email  # type: str
        # The time when the user last logged on to the console.
        self.last_login_time = last_login_time  # type: str
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count  # type: long
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count  # type: long
        # The mobile phone number of the user.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set a mobile phone number.
        self.mobile = mobile  # type: str
        # The nickname of the user.
        self.nick_name = nick_name  # type: str
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message
        # *   **EMAIL**: email.
        # *   **DINGDING**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode  # type: str
        # The ID of the Alibaba Cloud account of the user.
        self.parent_uid = parent_uid  # type: str
        # The IDs of the roles.
        self.role_id_list = role_id_list  # type: ListUsersResponseBodyUserListUserRoleIdList
        # The names of roles.
        self.role_name_list = role_name_list  # type: ListUsersResponseBodyUserListUserRoleNameList
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC_SHA1.
        self.signature_method = signature_method  # type: str
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state  # type: str
        # The ID of the Alibaba Cloud account.
        self.uid = uid  # type: str
        # The ID of the user.
        self.user_id = user_id  # type: str
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   If you have set a webhook URL, DMS sends notifications to the specified URL.
        # 
        # *   The system does not return this parameter if you have not set a webhook URL.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super(ListUsersResponseBodyUserListUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ListUsersResponseBodyUserList(TeaModel):
    def __init__(self, user=None):
        self.user = user  # type: list[ListUsersResponseBodyUserListUser]

    def validate(self):
        if self.user:
            for k in self.user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUsersResponseBodyUserList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['User'] = []
        if self.user is not None:
            for k in self.user:
                result['User'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.user = []
        if m.get('User') is not None:
            for k in m.get('User'):
                temp_model = ListUsersResponseBodyUserListUser()
                self.user.append(temp_model.from_map(k))
        return self


class ListUsersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, total_count=None,
                 user_list=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total_count = total_count  # type: long
        # The details of users.
        self.user_list = user_list  # type: ListUsersResponseBodyUserList

    def validate(self):
        if self.user_list:
            self.user_list.validate()

    def to_map(self):
        _map = super(ListUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_list is not None:
            result['UserList'] = self.user_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserList') is not None:
            temp_model = ListUsersResponseBodyUserList()
            self.user_list = temp_model.from_map(m['UserList'])
        return self


class ListUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowNodesRequest(TeaModel):
    def __init__(self, search_name=None, tid=None):
        # The name that is used to search for approval nodes.
        self.search_name = search_name  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkFlowNodesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser(TeaModel):
    def __init__(self, nick_name=None, real_name=None, user_id=None):
        # The nickname of the approver.
        self.nick_name = nick_name  # type: str
        # The real name of the approver.
        self.real_name = real_name  # type: str
        # The ID of the approver. The ID is different from the ID of the Alibaba Cloud account of the approver.
        self.user_id = user_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.real_name is not None:
            result['RealName'] = self.real_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('RealName') is not None:
            self.real_name = m.get('RealName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers(TeaModel):
    def __init__(self, audit_user=None):
        self.audit_user = audit_user  # type: list[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser]

    def validate(self):
        if self.audit_user:
            for k in self.audit_user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuditUser'] = []
        if self.audit_user is not None:
            for k in self.audit_user:
                result['AuditUser'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audit_user = []
        if m.get('AuditUser') is not None:
            for k in m.get('AuditUser'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser()
                self.audit_user.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode(TeaModel):
    def __init__(self, audit_users=None, comment=None, create_user_id=None, create_user_nick_name=None,
                 node_id=None, node_name=None, node_type=None):
        # The details about approvers.
        self.audit_users = audit_users  # type: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers
        # The description of the approval template.
        self.comment = comment  # type: str
        # The ID of the creator. This ID is different from the ID of the Alibaba Cloud account of the creator.
        self.create_user_id = create_user_id  # type: long
        # The name of the user who creates the approval node.
        self.create_user_nick_name = create_user_nick_name  # type: str
        # The ID of the approval node.
        self.node_id = node_id  # type: long
        # The name of the approval node.
        self.node_name = node_name  # type: str
        # The type of the approval node. Valid values:
        # 
        # *   SYS: The approval node is predefined by the system.
        # *   USER_LIST: The approval node is created by a user.
        self.node_type = node_type  # type: str

    def validate(self):
        if self.audit_users:
            self.audit_users.validate()

    def to_map(self):
        _map = super(ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_users is not None:
            result['AuditUsers'] = self.audit_users.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.create_user_nick_name is not None:
            result['CreateUserNickName'] = self.create_user_nick_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditUsers') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers()
            self.audit_users = temp_model.from_map(m['AuditUsers'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('CreateUserNickName') is not None:
            self.create_user_nick_name = m.get('CreateUserNickName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodes(TeaModel):
    def __init__(self, workflow_node=None):
        self.workflow_node = workflow_node  # type: list[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode]

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListWorkFlowNodesResponseBodyWorkflowNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, workflow_nodes=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes  # type: ListWorkFlowNodesResponseBodyWorkflowNodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super(ListWorkFlowNodesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowNodesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListWorkFlowNodesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListWorkFlowNodesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowTemplatesRequest(TeaModel):
    def __init__(self, search_name=None, tid=None):
        # The name that is used to query approval templates.
        self.search_name = search_name  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkFlowTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode(TeaModel):
    def __init__(self, comment=None, create_user_id=None, node_id=None, node_name=None, node_type=None,
                 position=None, template_id=None):
        # The description of the approval node.
        self.comment = comment  # type: str
        # The ID of the creator.
        self.create_user_id = create_user_id  # type: long
        # The ID of the approval node.
        self.node_id = node_id  # type: long
        # The name of the approval node.
        self.node_name = node_name  # type: str
        # The type of the approval node. Valid values:
        # 
        # *   SYS: The approval node is predefined by the system.
        # *   USER_LIST: The approval node is created by a user.
        self.node_type = node_type  # type: str
        # The position of the approval node.
        self.position = position  # type: int
        # The ID of the template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.position is not None:
            result['Position'] = self.position
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes(TeaModel):
    def __init__(self, workflow_node=None):
        self.workflow_node = workflow_node  # type: list[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode]

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate(TeaModel):
    def __init__(self, comment=None, create_user_id=None, enabled=None, is_system=None, template_id=None,
                 template_name=None, workflow_nodes=None):
        # The description of the approval template.
        self.comment = comment  # type: str
        # The ID of the creator.
        self.create_user_id = create_user_id  # type: long
        # Indicates whether the approval template is enabled. Valid values:
        # 
        # *   Y: The approval template is enabled.
        # *   N: The approval template is disabled.
        self.enabled = enabled  # type: str
        # Indicates whether the approval template is predefined by the system. Valid values:
        # 
        # *   1: The approval template is predefined by the system.
        # *   0: The approval template is not predefined by the system.
        self.is_system = is_system  # type: int
        # The ID of the approval template.
        self.template_id = template_id  # type: long
        # The name of the approval template.
        self.template_name = template_name  # type: str
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes  # type: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.is_system is not None:
            result['IsSystem'] = self.is_system
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('IsSystem') is not None:
            self.is_system = m.get('IsSystem')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates(TeaModel):
    def __init__(self, work_flow_template=None):
        self.work_flow_template = work_flow_template  # type: list[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate]

    def validate(self):
        if self.work_flow_template:
            for k in self.work_flow_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponseBodyWorkFlowTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkFlowTemplate'] = []
        if self.work_flow_template is not None:
            for k in self.work_flow_template:
                result['WorkFlowTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.work_flow_template = []
        if m.get('WorkFlowTemplate') is not None:
            for k in m.get('WorkFlowTemplate'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate()
                self.work_flow_template.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, work_flow_templates=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The approval templates.
        self.work_flow_templates = work_flow_templates  # type: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates

    def validate(self):
        if self.work_flow_templates:
            self.work_flow_templates.validate()

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.work_flow_templates is not None:
            result['WorkFlowTemplates'] = self.work_flow_templates.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkFlowTemplates') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplates()
            self.work_flow_templates = temp_model.from_map(m['WorkFlowTemplates'])
        return self


class ListWorkFlowTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListWorkFlowTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListWorkFlowTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MakeTaskFlowInstanceSuccessRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(MakeTaskFlowInstanceSuccessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MakeTaskFlowInstanceSuccessResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(MakeTaskFlowInstanceSuccessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MakeTaskFlowInstanceSuccessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: MakeTaskFlowInstanceSuccessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(MakeTaskFlowInstanceSuccessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MakeTaskFlowInstanceSuccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDataCorrectExecSQLRequest(TeaModel):
    def __init__(self, exec_sql=None, order_id=None, tid=None):
        # The new SQL script.
        self.exec_sql = exec_sql  # type: str
        # The ID of the data change ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDataCorrectExecSQLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDataCorrectExecSQLResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDataCorrectExecSQLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDataCorrectExecSQLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDataCorrectExecSQLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDataCorrectExecSQLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDataCorrectExecSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesensitizationStrategyRequest(TeaModel):
    def __init__(self, column_name=None, db_id=None, is_default=None, is_logic=None, is_reset=None, rule_id=None,
                 schema_name=None, table_name=None, tid=None):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to query the field name.
        # 
        # >  You can also call the [ListColumns](~~141870~~) operation to query the field name.
        self.column_name = column_name  # type: str
        # The ID of the database. You can call the [ListDatabases](~~141873~~) operation to query the ID.
        self.db_id = db_id  # type: int
        self.is_default = is_default  # type: bool
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true:** The database is a physical database.
        # *   **false:** The database is a logical database.
        self.is_logic = is_logic  # type: bool
        # Specifies whether to reset the masking rule. Valid values:
        # 
        # *   **true**: resets the masking rule.
        # *   **false**: does not reset the masking rule. This is the default value.
        self.is_reset = is_reset  # type: bool
        # The ID of the masking rule.
        self.rule_id = rule_id  # type: int
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to query the database name.
        # 
        # > * If the database is a physical database, you can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to query the database name.
        # > * If the database is a logical database, you can call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to query the database name.
        self.schema_name = schema_name  # type: str
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to query the table name.
        # 
        # >  You can also call the [ListTables](~~141878~~) operation to query the table name.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesensitizationStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.is_reset is not None:
            result['IsReset'] = self.is_reset
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('IsReset') is not None:
            self.is_reset = m.get('IsReset')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDesensitizationStrategyResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, result=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The returned result.
        self.result = result  # type: bool
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesensitizationStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDesensitizationStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesensitizationStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesensitizationStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesensitizationStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveTaskFlowToScenarioRequest(TeaModel):
    def __init__(self, dag_id=None, scenario_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the business scenario to which you want to migrate your task flow. If this parameter is set to the default value or a value that is less than or equal to 0, the task flow is migrated to the default business scenario.
        self.scenario_id = scenario_id  # type: long
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(MoveTaskFlowToScenarioRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MoveTaskFlowToScenarioResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(MoveTaskFlowToScenarioResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveTaskFlowToScenarioResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: MoveTaskFlowToScenarioResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(MoveTaskFlowToScenarioResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveTaskFlowToScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OfflineTaskFlowRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(OfflineTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class OfflineTaskFlowResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(OfflineTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OfflineTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OfflineTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OfflineTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OfflineTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseDataCorrectSQLJobRequest(TeaModel):
    def __init__(self, job_id=None, order_id=None, tid=None, type=None):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
        # 
        # >  If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
        self.job_id = job_id  # type: long
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The type of the pause operation. Valid values:
        # 
        # *   ALL: pauses all SQL tasks.
        # *   SINGLE: pauses a single SQL task.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PauseDataCorrectSQLJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class PauseDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PauseDataCorrectSQLJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PauseDataCorrectSQLJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PauseDataCorrectSQLJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PauseDataCorrectSQLJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishAndDeployTaskFlowRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None, version_comments=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long
        # The description of the version.
        self.version_comments = version_comments  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublishAndDeployTaskFlowRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        return self


class PublishAndDeployTaskFlowResponseBody(TeaModel):
    def __init__(self, deploy_id=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the deployment record.
        self.deploy_id = deploy_id  # type: long
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublishAndDeployTaskFlowResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishAndDeployTaskFlowResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PublishAndDeployTaskFlowResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PublishAndDeployTaskFlowResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishAndDeployTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDataTrackResultDownloadStatusRequest(TeaModel):
    def __init__(self, download_key_id=None, order_id=None, tid=None):
        # The ID of the download key, which is used to identify the parsing progress of data tracking logs. You can call the DownloadDataTrackResult operation to query the ID of the key.
        self.download_key_id = download_key_id  # type: str
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryDataTrackResultDownloadStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_key_id is not None:
            result['DownloadKeyId'] = self.download_key_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadKeyId') is not None:
            self.download_key_id = m.get('DownloadKeyId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class QueryDataTrackResultDownloadStatusResponseBodyStatusResult(TeaModel):
    def __init__(self, download_status=None, download_url=None, status_desc=None, total_count=None):
        # The status of the download task. Valid values:
        # 
        # *   **INIT**: The download task is being initialized.
        # *   **LISTING**: The download task is in a transient intermediate state during the initialization.
        # *   **DOWNLOADING**: The download task is being processed.
        # *   **DOWNLOAD_SUCCESS**: The download task was successfully processed.
        # *   **DOWNLOAD_FAIL**: The download task failed.
        self.download_status = download_status  # type: str
        # The URL that is used to download data tracking logs. This parameter is returned only when the value of DownloadStatus is DOWNLOAD_SUCCESS.
        self.download_url = download_url  # type: str
        # The description of the state.
        self.status_desc = status_desc  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryDataTrackResultDownloadStatusResponseBodyStatusResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_status is not None:
            result['DownloadStatus'] = self.download_status
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadStatus') is not None:
            self.download_status = m.get('DownloadStatus')
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryDataTrackResultDownloadStatusResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, status_result=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the download progress.
        self.status_result = status_result  # type: QueryDataTrackResultDownloadStatusResponseBodyStatusResult
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.status_result:
            self.status_result.validate()

    def to_map(self):
        _map = super(QueryDataTrackResultDownloadStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_result is not None:
            result['StatusResult'] = self.status_result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusResult') is not None:
            temp_model = QueryDataTrackResultDownloadStatusResponseBodyStatusResult()
            self.status_result = temp_model.from_map(m['StatusResult'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDataTrackResultDownloadStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryDataTrackResultDownloadStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryDataTrackResultDownloadStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDataTrackResultDownloadStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReDeployLhDagVersionRequest(TeaModel):
    def __init__(self, dag_id=None, dag_version=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The ID of the task flow version. You can call the [ListDAGVersions](~~424682~~) operation to obtain the ID of the task flow version.
        self.dag_version = dag_version  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the ID of the tenant.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReDeployLhDagVersionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReDeployLhDagVersionResponseBody(TeaModel):
    def __init__(self, deploy_id=None, error_code=None, error_message=None, request_id=None, success=None):
        # The ID of the deployment record.
        self.deploy_id = deploy_id  # type: long
        # The error code returned if the request fails.
        self.error_code = error_code  # type: str
        # The error message returned if the request fails.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReDeployLhDagVersionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReDeployLhDagVersionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReDeployLhDagVersionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReDeployLhDagVersionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReDeployLhDagVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReRunTaskFlowInstanceRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, dag_version=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The version number of the task flow. You can call the ListTaskFlowVersions operation to query the version number of the task flow.
        self.dag_version = dag_version  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReRunTaskFlowInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReRunTaskFlowInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReRunTaskFlowInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReRunTaskFlowInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReRunTaskFlowInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReRunTaskFlowInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReRunTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefundPayAsYouGoOrderRequest(TeaModel):
    def __init__(self, instance_id=None, order_id=None, tid=None):
        # The ID of the sales order instance.
        self.instance_id = instance_id  # type: str
        # The order ID of the order for the pay-as-you-go resource. You can call the ListEffectiveOrders operation to query the order ID.
        self.order_id = order_id  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefundPayAsYouGoOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RefundPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefundPayAsYouGoOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RefundPayAsYouGoOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RefundPayAsYouGoOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RefundPayAsYouGoOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefundPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterInstanceRequest(TeaModel):
    def __init__(self, data_link_name=None, database_password=None, database_user=None, dba_uid=None,
                 ddl_online=None, ecs_instance_id=None, ecs_region=None, enable_sell_sitd=None, env_type=None,
                 export_timeout=None, host=None, instance_alias=None, instance_source=None, instance_type=None, network_type=None,
                 port=None, query_timeout=None, safe_rule=None, sid=None, skip_test=None, template_id=None,
                 template_type=None, tid=None, use_dsql=None, vpc_id=None):
        # The name of the database link for cross-database queries.
        # 
        # > 
        # 
        # *   This parameter is required if UseDsql is set to 1.
        # 
        # *   The name can contain only lowercase letters and underscores (\_).
        # 
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name  # type: str
        # The password that is used to log on to the database.
        self.database_password = database_password  # type: str
        # The account that is used to log on to the database.
        self.database_user = database_user  # type: str
        # The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to query the user ID.
        self.dba_uid = dba_uid  # type: long
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   **0**: disables the lock-free schema change feature.
        # *   **1**: uses the online DDL of MySQL first.
        # *   **2**: uses the lock-free schema change feature of DMS first.
        # 
        # > Supported database types: ApsaraDB RDS for MySQL, PolarDB for MySQL, ApsaraDB MyBase for MySQL, and third-party MySQL databases.
        self.ddl_online = ddl_online  # type: int
        # The ID of the ECS instance on which the database instance is deployed.
        # 
        # > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id  # type: str
        # The ID of the region in which the database instance resides.
        # 
        # > This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
        self.ecs_region = ecs_region  # type: str
        # *   **Y:** enables the sensitive data protection feature
        # *   **NULL or other:** disables the sensitive data protection feature
        self.enable_sell_sitd = enable_sell_sitd  # type: str
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: pre-release environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: staging environment
        self.env_type = env_type  # type: str
        # The timeout period for exporting data from the database instance. Unit: seconds.
        self.export_timeout = export_timeout  # type: int
        # The host address that is used to connect to the database instance.
        self.host = host  # type: str
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        self.instance_alias = instance_alias  # type: str
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
        # *   **RDS:** an ApsaraDB RDS instance
        # *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.instance_type = instance_type  # type: str
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC:** classic network
        # *   **VPC:** VPC
        self.network_type = network_type  # type: str
        # The port that is used to connect to the database instance.
        self.port = port  # type: int
        # The timeout period for querying data in the database instance. Unit: seconds.
        self.query_timeout = query_timeout  # type: int
        # The name of the security rule set (GroupName) for the database instance. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to query the name of the security rule set.
        self.safe_rule = safe_rule  # type: str
        # The system ID (SID) of the database.
        # 
        # > This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid  # type: str
        # Specifies whether to skip the connectivity test. Valid values:
        # 
        # *   **true:** skips the connectivity test
        # *   **false:** does not skip the connectivity test
        self.skip_test = skip_test  # type: bool
        # The ID of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template ID.
        self.template_id = template_id  # type: long
        # The type of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template type.
        self.template_type = template_type  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   **0**: disables the cross-database query feature.
        # *   **1**: enables the cross-database query feature.
        # 
        # > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
        self.use_dsql = use_dsql  # type: int
        # The ID of the VPC to which the database instance belongs.
        # 
        # > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_uid is not None:
            result['DbaUid'] = self.dba_uid
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule is not None:
            result['SafeRule'] = self.safe_rule
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaUid') is not None:
            self.dba_uid = m.get('DbaUid')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRule') is not None:
            self.safe_rule = m.get('SafeRule')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class RegisterInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true:** The request was successful.
        # *   **false:** The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RegisterInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RegisterInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterUserRequest(TeaModel):
    def __init__(self, mobile=None, role_names=None, tid=None, uid=None, user_nick=None):
        # The mobile number of the user.
        self.mobile = mobile  # type: str
        # The role that you want to assign to the user. Valid values:
        # 
        # *   **USER**: a regular user role
        # *   **DBA**: a database administrator (DBA) role
        # *   **ADMIN**: a DMS administrator role
        # *   **SECURITY_ADMIN**: a security administrator role
        # 
        # >  If you do not specify this parameter, the regular user role is assigned to the user by default. You can assign one or more roles to the user. Separate multiple roles with commas (,).
        self.role_names = role_names  # type: str
        # The ID of the tenant.
        # 
        # >  To query ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long
        # The UID of the Alibaba Cloud account of the user that you want to register.
        self.uid = uid  # type: str
        # The nickname of the user.
        self.user_nick = user_nick  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class RegisterUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RegisterUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RegisterUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartDataCorrectSQLJobRequest(TeaModel):
    def __init__(self, job_id=None, order_id=None, tid=None, type=None):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
        # 
        # If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
        self.job_id = job_id  # type: long
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The type of the rerun operation. Valid values:
        # 
        # *   **ALL**: reruns all SQL tasks.
        # *   **SINGLE**: reruns a single SQL task.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RestartDataCorrectSQLJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RestartDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RestartDataCorrectSQLJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RestartDataCorrectSQLJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RestartDataCorrectSQLJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RestartDataCorrectSQLJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeTaskFlowInstanceRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, dag_version=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The version number of the task flow. You can call the [ListDAGVersions](~~424682~~) operation to query the version number.
        self.dag_version = dag_version  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeTaskFlowInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ResumeTaskFlowInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeTaskFlowInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResumeTaskFlowInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResumeTaskFlowInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResumeTaskFlowInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryDataCorrectPreCheckRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RetryDataCorrectPreCheckRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RetryDataCorrectPreCheckResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RetryDataCorrectPreCheckResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RetryDataCorrectPreCheckResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RetryDataCorrectPreCheckResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RetryDataCorrectPreCheckResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryDataCorrectPreCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeTemplateAuthorityRequest(TeaModel):
    def __init__(self, template_id=None, tid=None, user_ids=None):
        # The ID of the permission template.
        self.template_id = template_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The IDs of users from whom you want to revoke permissions by using a permission template.
        self.user_ids = user_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeTemplateAuthorityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class RevokeTemplateAuthorityResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, result=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the permissions were revoked from the users.
        self.result = result  # type: bool
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeTemplateAuthorityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RevokeTemplateAuthorityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RevokeTemplateAuthorityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RevokeTemplateAuthorityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeTemplateAuthorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeUserPermissionRequest(TeaModel):
    def __init__(self, db_id=None, ds_type=None, instance_id=None, logic=None, perm_types=None, table_id=None,
                 table_name=None, tid=None, user_access_id=None, user_id=None):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id  # type: str
        # The object type on which the permission you want to revoke from the user. Valid values:
        # 
        # *   **INSTANCE**: database instances
        # *   **DATABASE**: physical databases
        # *   **LOGIC_DATABASE**: logical databases
        # *   **TABLE**: physical tables
        # *   **LOGIC_TABLE**: logical tables
        self.ds_type = ds_type  # type: str
        # The ID of the database instance. You must specify this parameter when you revoke a permission from the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the database instance ID.
        self.instance_id = instance_id  # type: long
        # Specifies whether the database is a logical database. Valid values:
        # 
        # * **true**: The database is a logical database.
        # * **false**: The database is a physical database.
        # 
        # > * If the database is a logical database, set this parameter to **true**.
        # > * If the database is a physical database, set this parameter to **false**.
        self.logic = logic  # type: bool
        # The type of the permission. Valid values:
        # 
        # *   **QUERY**: the data query permission
        # *   **EXPORT**: the data export permission
        # *   **CORRECT**: the data change permission
        self.perm_types = perm_types  # type: str
        # The ID of the table. You must specify this parameter when you revoke a permission from the table. You can call the [ListTables](~~141878~~) operation to query the table ID.
        self.table_id = table_id  # type: str
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the table name.
        self.table_name = table_name  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # The ID of the permission. You can call the [ListUserPermission](~~146957~~) operation to query the permission ID.
        self.user_access_id = user_access_id  # type: str
        # The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the user ID.
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeUserPermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeUserPermissionResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned.
        self.error_code = error_code  # type: str
        # The error message returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeUserPermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RevokeUserPermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RevokeUserPermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RevokeUserPermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDataTrackResultRequestColumnFilter(TeaModel):
    def __init__(self, between_end=None, between_start=None, column_name=None, in_list=None, operator=None,
                 value=None):
        # The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_end = between_end  # type: str
        # The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_start = between_start  # type: str
        # The name of the column.
        self.column_name = column_name  # type: str
        # The IN list used in the filter condition. This parameter takes effect only when Operator is set to IN or NOT_IN.
        self.in_list = in_list  # type: list[str]
        # The type of the operator used to configure the filter condition. Valid values:
        # 
        # *   **EQUAL**: retrieves the column whose value is equal to the specified value.
        # *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
        # *   **IN**: retrieves the column whose value is in the IN list.
        # *   **BETWEEN**: retrieves the column whose value is in the specified range.
        # *   **LESS**: retrieves the column whose value is less than the specified value.
        # *   **MORE**: retrieves the column whose value is greater than the specified value.
        # *   **NOT_IN**: retrieves the column whose value is not in the IN list.
        self.operator = operator  # type: str
        # The value used in the filter condition.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDataTrackResultRequestColumnFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.between_end is not None:
            result['BetweenEnd'] = self.between_end
        if self.between_start is not None:
            result['BetweenStart'] = self.between_start
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.in_list is not None:
            result['InList'] = self.in_list
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BetweenEnd') is not None:
            self.between_end = m.get('BetweenEnd')
        if m.get('BetweenStart') is not None:
            self.between_start = m.get('BetweenStart')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('InList') is not None:
            self.in_list = m.get('InList')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchDataTrackResultRequest(TeaModel):
    def __init__(self, column_filter=None, filter_end_time=None, filter_start_time=None, filter_table_list=None,
                 filter_type_list=None, order_id=None, tid=None):
        # The condition to filter columns.
        self.column_filter = column_filter  # type: SearchDataTrackResultRequestColumnFilter
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time  # type: str
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time  # type: str
        # The names of the tables for which you want to track data operations.
        self.filter_table_list = filter_table_list  # type: list[str]
        # The types of data operations that you want to track.
        self.filter_type_list = filter_type_list  # type: list[str]
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.column_filter:
            self.column_filter.validate()

    def to_map(self):
        _map = super(SearchDataTrackResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter is not None:
            result['ColumnFilter'] = self.column_filter.to_map()
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list is not None:
            result['FilterTableList'] = self.filter_table_list
        if self.filter_type_list is not None:
            result['FilterTypeList'] = self.filter_type_list
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            temp_model = SearchDataTrackResultRequestColumnFilter()
            self.column_filter = temp_model.from_map(m['ColumnFilter'])
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDataTrackResultShrinkRequest(TeaModel):
    def __init__(self, column_filter_shrink=None, filter_end_time=None, filter_start_time=None,
                 filter_table_list_shrink=None, filter_type_list_shrink=None, order_id=None, tid=None):
        # The condition to filter columns.
        self.column_filter_shrink = column_filter_shrink  # type: str
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time  # type: str
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time  # type: str
        # The names of the tables for which you want to track data operations.
        self.filter_table_list_shrink = filter_table_list_shrink  # type: str
        # The types of data operations that you want to track.
        self.filter_type_list_shrink = filter_type_list_shrink  # type: str
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
        self.order_id = order_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDataTrackResultShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter_shrink is not None:
            result['ColumnFilter'] = self.column_filter_shrink
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list_shrink is not None:
            result['FilterTableList'] = self.filter_table_list_shrink
        if self.filter_type_list_shrink is not None:
            result['FilterTypeList'] = self.filter_type_list_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            self.column_filter_shrink = m.get('ColumnFilter')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list_shrink = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list_shrink = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDataTrackResultResponseBodyTrackResultEventList(TeaModel):
    def __init__(self, data_after=None, data_before=None, event_id=None, event_length=None, event_timestamp=None,
                 event_type=None, roll_sql=None):
        # The data records after you perform data operations in the database.
        self.data_after = data_after  # type: list[str]
        # The data records before you perform data operations in the database.
        self.data_before = data_before  # type: list[str]
        # The ID of the event.
        self.event_id = event_id  # type: long
        # The length of the event content. Unit: bytes.
        self.event_length = event_length  # type: long
        # The event time.
        self.event_timestamp = event_timestamp  # type: str
        # The type of the event. Valid values:
        # 
        # *   **WRITE_ROWS**: indicates an INSERT operation.
        # *   **UPDATE_ROWS**: indicates an UPDATE operation.
        # *   **DELETE_ROWS**: indicates a DELETE operation.
        # *   **EXT_WRITE_ROWS**: indicates an INSERT operation, which is equivalent to WRITE_ROWS.
        # *   **EXT_UPDATE_ROWS**: indicates an UPDATE operation, which is equivalent to UPDATE_ROWS.
        # *   **EXT_DELETE_ROWS**: indicates a DELETE operation, which is equivalent to DELETE_ROWS.
        self.event_type = event_type  # type: str
        # The SQL statements used to roll back the data change.
        self.roll_sql = roll_sql  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDataTrackResultResponseBodyTrackResultEventList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_after is not None:
            result['DataAfter'] = self.data_after
        if self.data_before is not None:
            result['DataBefore'] = self.data_before
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_length is not None:
            result['EventLength'] = self.event_length
        if self.event_timestamp is not None:
            result['EventTimestamp'] = self.event_timestamp
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.roll_sql is not None:
            result['RollSQL'] = self.roll_sql
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataAfter') is not None:
            self.data_after = m.get('DataAfter')
        if m.get('DataBefore') is not None:
            self.data_before = m.get('DataBefore')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventLength') is not None:
            self.event_length = m.get('EventLength')
        if m.get('EventTimestamp') is not None:
            self.event_timestamp = m.get('EventTimestamp')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('RollSQL') is not None:
            self.roll_sql = m.get('RollSQL')
        return self


class SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns(TeaModel):
    def __init__(self, column_name=None, column_position=None, column_type=None, fictive=None):
        # The name of the column.
        self.column_name = column_name  # type: str
        # The position of the column.
        self.column_position = column_position  # type: int
        # The data type of the column. Examples: BIGINT, INT, and VARCHAR.
        self.column_type = column_type  # type: str
        # Indicates whether the column is a virtual column. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.fictive = fictive  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_position is not None:
            result['ColumnPosition'] = self.column_position
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.fictive is not None:
            result['Fictive'] = self.fictive
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPosition') is not None:
            self.column_position = m.get('ColumnPosition')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Fictive') is not None:
            self.fictive = m.get('Fictive')
        return self


class SearchDataTrackResultResponseBodyTrackResultTableInfoList(TeaModel):
    def __init__(self, columns=None, description=None, schema_name=None, table_name=None):
        # The information about columns.
        self.columns = columns  # type: list[SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns]
        # The description of the column.
        self.description = description  # type: str
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchDataTrackResultResponseBodyTrackResultTableInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class SearchDataTrackResultResponseBodyTrackResult(TeaModel):
    def __init__(self, event_list=None, table_info_list=None, total_count=None):
        # The details of the event logs.
        self.event_list = event_list  # type: list[SearchDataTrackResultResponseBodyTrackResultEventList]
        # The metadata of tables for which you track data operations.
        self.table_info_list = table_info_list  # type: list[SearchDataTrackResultResponseBodyTrackResultTableInfoList]
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchDataTrackResultResponseBodyTrackResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['EventList'].append(k.to_map() if k else None)
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_list = []
        if m.get('EventList') is not None:
            for k in m.get('EventList'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultEventList()
                self.event_list.append(temp_model.from_map(k))
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchDataTrackResultResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None, track_result=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The parsing result of the data tracking task.
        self.track_result = track_result  # type: SearchDataTrackResultResponseBodyTrackResult

    def validate(self):
        if self.track_result:
            self.track_result.validate()

    def to_map(self):
        _map = super(SearchDataTrackResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.track_result is not None:
            result['TrackResult'] = self.track_result.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TrackResult') is not None:
            temp_model = SearchDataTrackResultResponseBodyTrackResult()
            self.track_result = temp_model.from_map(m['TrackResult'])
        return self


class SearchDataTrackResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchDataTrackResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchDataTrackResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDataTrackResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDatabaseRequest(TeaModel):
    def __init__(self, db_type=None, env_type=None, page_number=None, page_size=None, search_key=None,
                 search_range=None, search_target=None, tid=None):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type  # type: str
        # The environment type of the database. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The keyword that is used to search for databases.
        self.search_key = search_key  # type: str
        # The query range based on permissions. Valid values:
        # 
        # *   **HAS_PERMSSION**: searches for databases on which the current user has permissions.
        # *   **OWNER**: searches for databases owned by the current user.
        # *   **MY_FOCUS**: searches for databases that the current user follows.
        # *   **UNKNOWN**: searches for all databases.
        self.search_range = search_range  # type: str
        # The category of the database. Valid values:
        # 
        # *   **DB**: single database or logical database.
        # *   **SINGLE_DB**: single database.
        # *   **LOGIC_DB**: logical database.
        self.search_target = search_target  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase(TeaModel):
    def __init__(self, alias=None, catalog_name=None, database_id=None, datalink_name=None, db_type=None,
                 dba_id=None, encoding=None, env_type=None, host=None, logic=None, owner_id_list=None, owner_name_list=None,
                 port=None, schema_name=None, search_name=None, sid=None):
        # The alias of the database.
        self.alias = alias  # type: str
        # The name of the catalog to which the database belongs.
        # 
        # > If the type of the database engine is PostgreSQL, the name of the database is displayed.
        self.catalog_name = catalog_name  # type: str
        # The ID of the database.
        self.database_id = database_id  # type: str
        # The name of the data link for cross-database queries.
        self.datalink_name = datalink_name  # type: str
        # The type of the database engine.
        self.db_type = db_type  # type: str
        # The ID of the user who assumes the database administrator (DBA) role.
        self.dba_id = dba_id  # type: str
        # The encoding method of the database.
        self.encoding = encoding  # type: str
        # The environment type of the database. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The endpoint of the instance in which the database resides.
        self.host = host  # type: str
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic  # type: bool
        # The IDs of the owners of the databases.
        self.owner_id_list = owner_id_list  # type: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list  # type: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList
        # The port of the instance in which the database resides.
        self.port = port  # type: int
        # The name of the database.
        self.schema_name = schema_name  # type: str
        # The name that is used to search for the database.
        self.search_name = search_name  # type: str
        # The system ID (SID) of the instance in which the database resides.
        self.sid = sid  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(SearchDatabaseResponseBodySearchDatabaseListSearchDatabase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.datalink_name is not None:
            result['DatalinkName'] = self.datalink_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatalinkName') is not None:
            self.datalink_name = m.get('DatalinkName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class SearchDatabaseResponseBodySearchDatabaseList(TeaModel):
    def __init__(self, search_database=None):
        self.search_database = search_database  # type: list[SearchDatabaseResponseBodySearchDatabaseListSearchDatabase]

    def validate(self):
        if self.search_database:
            for k in self.search_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchDatabaseResponseBodySearchDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchDatabase'] = []
        if self.search_database is not None:
            for k in self.search_database:
                result['SearchDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.search_database = []
        if m.get('SearchDatabase') is not None:
            for k in m.get('SearchDatabase'):
                temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabase()
                self.search_database.append(temp_model.from_map(k))
        return self


class SearchDatabaseResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, search_database_list=None,
                 success=None, total_count=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the databases.
        self.search_database_list = search_database_list  # type: SearchDatabaseResponseBodySearchDatabaseList
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.search_database_list:
            self.search_database_list.validate()

    def to_map(self):
        _map = super(SearchDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_database_list is not None:
            result['SearchDatabaseList'] = self.search_database_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchDatabaseList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseList()
            self.search_database_list = temp_model.from_map(m['SearchDatabaseList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTableRequest(TeaModel):
    def __init__(self, db_type=None, env_type=None, page_number=None, page_size=None, return_guid=None,
                 search_key=None, search_range=None, search_target=None, tid=None):
        # The type of database. Valid values:
        # 
        # *   **MySQL**\
        # *   **SQLServer**\
        # *   **PostgreSQL**\
        # *   **Oracle**\
        # *   **DRDS**\
        # *   **OceanBase**\
        # *   **Mongo**\
        # *   **Redis**\
        self.db_type = db_type  # type: str
        # The type of the environment to which databases belong. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # Specifies whether to return the GUID of each table.
        self.return_guid = return_guid  # type: bool
        # The keyword that is used to query tables.
        self.search_key = search_key  # type: str
        # The scope of tables that you want to query. Valid values:
        # 
        # *   **HAS_PERMSSION**: the tables on which the current account has permissions.
        # *   **OWNER**: the tables owned by the current account.
        # *   **MY_FOCUS**: the tables that the current account follows.
        # *   **UNKNOWN**: all tables.
        self.search_range = search_range  # type: str
        # The type of table that you want to query. Valid values:
        # 
        # *   **TABLE**: physical and logical tables
        # *   **SINGLE_TABLE**: physical tables
        # *   **LOGIC_TABLE**: logical tables
        self.search_target = search_target  # type: str
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchTableRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerIdList(TeaModel):
    def __init__(self, owner_ids=None):
        self.owner_ids = owner_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchTableResponseBodySearchTableListSearchTableOwnerIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerNameList(TeaModel):
    def __init__(self, owner_names=None):
        self.owner_names = owner_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchTableResponseBodySearchTableListSearchTableOwnerNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchTableResponseBodySearchTableListSearchTable(TeaModel):
    def __init__(self, dbsearch_name=None, database_id=None, db_name=None, db_type=None, description=None,
                 encoding=None, engine=None, env_type=None, logic=None, owner_id_list=None, owner_name_list=None,
                 table_guid=None, table_id=None, table_name=None, table_schema_name=None):
        # The name that is used to search for the database to which the table belongs.
        self.dbsearch_name = dbsearch_name  # type: str
        # The ID of the database to which the table belongs.
        self.database_id = database_id  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        # The type of the database. Valid values:
        # 
        # *   **MySQL**\
        # *   **SQLServer**\
        # *   **PostgreSQL**\
        # *   **Oracle**\
        # *   **DRDS**\
        # *   **OceanBase**\
        # *   **Mongo**\
        # *   **Redis**\
        self.db_type = db_type  # type: str
        # The description of the table.
        self.description = description  # type: str
        # The encoding format of the table.
        self.encoding = encoding  # type: str
        # The engine of the table.
        self.engine = engine  # type: str
        # The type of the environment to which the database belongs.
        self.env_type = env_type  # type: str
        # Indicates whether the table is a logical table. Valid values:
        # 
        # *   **true**: The table is a logical table.
        # *   **false**: The table is not a logical table.
        self.logic = logic  # type: bool
        # The IDs of the table owners.
        self.owner_id_list = owner_id_list  # type: SearchTableResponseBodySearchTableListSearchTableOwnerIdList
        # The nicknames of the table owners.
        self.owner_name_list = owner_name_list  # type: SearchTableResponseBodySearchTableListSearchTableOwnerNameList
        # The GUID of the table.
        self.table_guid = table_guid  # type: str
        # The ID of the table.
        self.table_id = table_id  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # The name of the database to which the table belongs.
        self.table_schema_name = table_schema_name  # type: str

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super(SearchTableResponseBodySearchTableListSearchTable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbsearch_name is not None:
            result['DBSearchName'] = self.dbsearch_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DBSearchName') is not None:
            self.dbsearch_name = m.get('DBSearchName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class SearchTableResponseBodySearchTableList(TeaModel):
    def __init__(self, search_table=None):
        self.search_table = search_table  # type: list[SearchTableResponseBodySearchTableListSearchTable]

    def validate(self):
        if self.search_table:
            for k in self.search_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchTableResponseBodySearchTableList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchTable'] = []
        if self.search_table is not None:
            for k in self.search_table:
                result['SearchTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.search_table = []
        if m.get('SearchTable') is not None:
            for k in m.get('SearchTable'):
                temp_model = SearchTableResponseBodySearchTableListSearchTable()
                self.search_table.append(temp_model.from_map(k))
        return self


class SearchTableResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, search_table_list=None, success=None,
                 total_count=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the tables.
        self.search_table_list = search_table_list  # type: SearchTableResponseBodySearchTableList
        # Indicates whether the request was successful.
        self.success = success  # type: bool
        # The total number of entries that are returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.search_table_list:
            self.search_table_list.validate()

    def to_map(self):
        _map = super(SearchTableResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_table_list is not None:
            result['SearchTableList'] = self.search_table_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchTableList') is not None:
            temp_model = SearchTableResponseBodySearchTableList()
            self.search_table_list = temp_model.from_map(m['SearchTableList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchTableResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchTableResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchTableResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetOwnersRequest(TeaModel):
    def __init__(self, owner_ids=None, owner_type=None, resource_id=None, tid=None):
        # The ID of the user whom you want to specify as an owner. Separate multiple IDs with commas (,). You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The value of the OwnerIds parameter is that of the UserId parameter.
        self.owner_ids = owner_ids  # type: str
        # The type of the owner. Valid values:
        # 
        # *   INSTANCE: an owner of an instance.
        # *   DATABASE: an owner of a physical database.
        # *   LOGIC_DATABASE: an owner of a logical database.
        # *   TABLE: an owner of a physical table.
        # *   LOGIC_TABLE: an owner of a logical table.
        self.owner_type = owner_type  # type: str
        # The ID of the resource. The ID of the resource varies with the owner type. The owner types and resource IDs have the following mappings:
        # 
        # *   INSTANCE: the ID of an instance. You can call the [ListInstances](~~141936~~) operation to query the ID of the instance.
        # *   DATABASE: the ID of a physical database. You can call the [ListDatabases](~~141873~~) operation to query the ID of the physical database.
        # *   LOGIC_DATABASE: the ID of a logical database. You can call the [ListLogicDatabases](~~141874~~) operation to query the ID of the logical database.
        # *   TABLE: the ID of a physical table. You can call the [ListTables](~~141878~~) operation to query the ID of the physical table.
        # *   LOGIC_DATABASE: the ID of a logical table. You can call the [ListLogicTables](~~141875~~) operation to query the ID of the logical table.
        self.resource_id = resource_id  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetOwnersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SetOwnersResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetOwnersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetOwnersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetOwnersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetOwnersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetOwnersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SkipDataCorrectRowCheckRequest(TeaModel):
    def __init__(self, order_id=None, reason=None, tid=None):
        self.order_id = order_id  # type: long
        self.reason = reason  # type: str
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SkipDataCorrectRowCheckRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SkipDataCorrectRowCheckResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SkipDataCorrectRowCheckResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SkipDataCorrectRowCheckResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SkipDataCorrectRowCheckResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SkipDataCorrectRowCheckResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SkipDataCorrectRowCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTaskFlowInstanceRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopTaskFlowInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class StopTaskFlowInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopTaskFlowInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopTaskFlowInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopTaskFlowInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopTaskFlowInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitOrderApprovalRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitOrderApprovalRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitOrderApprovalResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitOrderApprovalResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitOrderApprovalResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitOrderApprovalResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitOrderApprovalResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitStructSyncOrderApprovalRequest(TeaModel):
    def __init__(self, order_id=None, tid=None):
        # The ID of the ticket.
        self.order_id = order_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitStructSyncOrderApprovalRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitStructSyncOrderApprovalResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None,
                 workflow_instance_id=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitStructSyncOrderApprovalResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class SubmitStructSyncOrderApprovalResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitStructSyncOrderApprovalResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitStructSyncOrderApprovalResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitStructSyncOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendTaskFlowInstanceRequest(TeaModel):
    def __init__(self, dag_id=None, dag_instance_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id  # type: long
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SuspendTaskFlowInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SuspendTaskFlowInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SuspendTaskFlowInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SuspendTaskFlowInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SuspendTaskFlowInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SuspendTaskFlowInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncDatabaseMetaRequest(TeaModel):
    def __init__(self, db_id=None, logic=None, tid=None):
        # The ID of the database.
        self.db_id = db_id  # type: str
        # Specifies whether the database is a logical database.
        self.logic = logic  # type: bool
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SyncDatabaseMetaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncDatabaseMetaResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SyncDatabaseMetaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncDatabaseMetaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SyncDatabaseMetaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SyncDatabaseMetaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncDatabaseMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncInstanceMetaRequest(TeaModel):
    def __init__(self, ignore_table=None, instance_id=None, tid=None):
        # Specifies whether to skip synchronization for the metadata of table dictionaries. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.ignore_table = ignore_table  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SyncInstanceMetaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_table is not None:
            result['IgnoreTable'] = self.ignore_table
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoreTable') is not None:
            self.ignore_table = m.get('IgnoreTable')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncInstanceMetaResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # Details about the topology of the data table.
        self.error_code = error_code  # type: str
        # The error code returned.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SyncInstanceMetaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncInstanceMetaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SyncInstanceMetaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SyncInstanceMetaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncInstanceMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAuthorityTemplateRequest(TeaModel):
    def __init__(self, description=None, name=None, template_id=None, tid=None):
        # The description of the permission template.
        # 
        # >  You must specify the Name or Description parameter. Otherwise, the API call fails.
        self.description = description  # type: str
        # The name of the permission template.
        # 
        # >  You must specify the Name or Description parameter. Otherwise, the API call fails.
        self.name = name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateAuthorityTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(self, creator_id=None, description=None, name=None, template_id=None):
        # The ID of the user who created the permission template.
        self.creator_id = creator_id  # type: long
        # The description of the permission template.
        self.description = description  # type: str
        # The name of the permission template.
        self.name = name  # type: str
        # The ID of the permission template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateAuthorityTemplateResponseBodyAuthorityTemplateView, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateAuthorityTemplateResponseBody(TeaModel):
    def __init__(self, authority_template_view=None, error_code=None, error_message=None, request_id=None,
                 success=None):
        # The details of the permission template.
        self.authority_template_view = authority_template_view  # type: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super(UpdateAuthorityTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = UpdateAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateAuthorityTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateAuthorityTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateAuthorityTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateInstanceRequest(TeaModel):
    def __init__(self, data_link_name=None, database_password=None, database_user=None, dba_id=None,
                 ddl_online=None, ecs_instance_id=None, ecs_region=None, enable_sell_sitd=None, env_type=None,
                 export_timeout=None, host=None, instance_alias=None, instance_id=None, instance_source=None, instance_type=None,
                 port=None, query_timeout=None, safe_rule_id=None, sid=None, skip_test=None, template_id=None,
                 template_type=None, tid=None, use_dsql=None, vpc_id=None):
        # The name of the database link for cross-database queries.
        # 
        # > 
        # 
        # *   This parameter is required if UseDsql is set to 1.
        # 
        # *   The name can contain only lowercase letters and underscores (\_).
        # 
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name  # type: str
        # The password that is used to log on to the database.
        self.database_password = database_password  # type: str
        # The account that is used to log on to the database.
        self.database_user = database_user  # type: str
        # The ID of the user who assumes the database administrator (DBA) role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to query the user ID.
        self.dba_id = dba_id  # type: str
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   **0:** disables the lock-free schema change feature.
        # *   **1**: uses the online DDL of MySQL first.
        # *   **2**: uses the lock-free schema change feature of DMS first.
        self.ddl_online = ddl_online  # type: int
        # The ID of the ECS instance on which the database instance is deployed.
        # 
        # > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id  # type: str
        # The ID of the region in which the database instance resides.
        # 
        # > This parameter is required if InstanceSource is set to RDS, ECS_OWN, and VPC_IDC.
        self.ecs_region = ecs_region  # type: str
        # *   **Y:** enables the sensitive data protection feature
        # *   **N:** disables the sensitive data protection feature
        # *   **NULL or other:** does not update the status of the sensitive data protection feature
        self.enable_sell_sitd = enable_sell_sitd  # type: str
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   **product:** production environment
        # *   **dev:** development environment
        # *   **pre:** pre-release environment
        # *   **test:** test environment
        # *   **sit:** system integration testing (SIT) environment
        # *   **uat:** user acceptance testing (UAT) environment
        # *   **pet:** stress testing environment
        # *   **stag:** staging environment
        self.env_type = env_type  # type: str
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout  # type: int
        # The host address that is used to connect to the database instance.
        self.host = host  # type: str
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        self.instance_alias = instance_alias  # type: str
        # The ID of the database instance. You can call the [GetInstance](~~141567~~) operation to query the instance ID.
        self.instance_id = instance_id  # type: str
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
        # *   **RDS:** an ApsaraDB RDS instance
        # *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source  # type: str
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.instance_type = instance_type  # type: str
        # The port that is used to connect to the database instance.
        self.port = port  # type: int
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout  # type: int
        # The name of the security rule set (GroupName) for the instance. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to query the name of the security rule set.
        self.safe_rule_id = safe_rule_id  # type: str
        # The system ID (SID) of the database instance.
        # 
        # > This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid  # type: str
        # Specifies whether to skip the connectivity test. Valid values:
        # 
        # *   **true:** skips the connectivity test
        # *   **false:** does not skip the connectivity test
        self.skip_test = skip_test  # type: bool
        # The ID of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template ID.
        self.template_id = template_id  # type: long
        # The type of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template type.
        self.template_type = template_type  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid  # type: long
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   **0**: disables the cross-database query feature.
        # *   **1**: enables the cross-database query feature.
        # 
        # > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
        self.use_dsql = use_dsql  # type: int
        # The ID of the VPC to which the database instance belongs.
        # 
        # > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateInstanceResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true:** The request was successful.
        # *   **false:** The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSLARulesRequestSlaRuleList(TeaModel):
    def __init__(self, dag_id=None, interval_minutes=None, node_id=None, type=None):
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes  # type: int
        # The ID of the task node.
        self.node_id = node_id  # type: long
        # The rule type. Valid values:
        # 
        # *   **0**: SLA rules for task flows
        # *   **1**: SLA rules for nodes
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateSLARulesRequestSlaRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateSLARulesRequest(TeaModel):
    def __init__(self, dag_id=None, sla_rule_list=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of SLA rules.
        self.sla_rule_list = sla_rule_list  # type: list[UpdateSLARulesRequestSlaRuleList]
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        if self.sla_rule_list:
            for k in self.sla_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(UpdateSLARulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['SlaRuleList'] = []
        if self.sla_rule_list is not None:
            for k in self.sla_rule_list:
                result['SlaRuleList'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.sla_rule_list = []
        if m.get('SlaRuleList') is not None:
            for k in m.get('SlaRuleList'):
                temp_model = UpdateSLARulesRequestSlaRuleList()
                self.sla_rule_list.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesShrinkRequest(TeaModel):
    def __init__(self, dag_id=None, sla_rule_list_shrink=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of SLA rules.
        self.sla_rule_list_shrink = sla_rule_list_shrink  # type: str
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateSLARulesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.sla_rule_list_shrink is not None:
            result['SlaRuleList'] = self.sla_rule_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('SlaRuleList') is not None:
            self.sla_rule_list_shrink = m.get('SlaRuleList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateSLARulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSLARulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateSLARulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateSLARulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScenarioRequest(TeaModel):
    def __init__(self, description=None, scenario_id=None, scenario_name=None, tid=None):
        # The description of the business scenario.
        self.description = description  # type: str
        # The ID of the business scenario.
        self.scenario_id = scenario_id  # type: str
        # The name of the business scenario.
        self.scenario_name = scenario_name  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateScenarioRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateScenarioResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateScenarioResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateScenarioResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateScenarioResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateScenarioResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskConfigRequest(TeaModel):
    def __init__(self, node_config=None, node_id=None, tid=None):
        # The advanced configuration for the node. The value of this parameter must be a JSON string.
        self.node_config = node_config  # type: str
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: str
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskConfigResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskContentRequest(TeaModel):
    def __init__(self, node_content=None, node_id=None, tid=None):
        # The node configurations after modification.
        self.node_content = node_content  # type: str
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: str
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the ["View information about the current tenant"](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskContentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskContentResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskContentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskContentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskContentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskContentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowConstantsRequestDagConstants(TeaModel):
    def __init__(self, key=None, value=None):
        # The key name of a constant for the task flow.
        self.key = key  # type: str
        # The key value of a constant for the task flow.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowConstantsRequestDagConstants, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskFlowConstantsRequest(TeaModel):
    def __init__(self, dag_constants=None, dag_id=None, tid=None):
        # The constants for the task flow.
        self.dag_constants = dag_constants  # type: list[UpdateTaskFlowConstantsRequestDagConstants]
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        if self.dag_constants:
            for k in self.dag_constants:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowConstantsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstants'] = []
        if self.dag_constants is not None:
            for k in self.dag_constants:
                result['DagConstants'].append(k.to_map() if k else None)
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dag_constants = []
        if m.get('DagConstants') is not None:
            for k in m.get('DagConstants'):
                temp_model = UpdateTaskFlowConstantsRequestDagConstants()
                self.dag_constants.append(temp_model.from_map(k))
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsShrinkRequest(TeaModel):
    def __init__(self, dag_constants_shrink=None, dag_id=None, tid=None):
        # The constants for the task flow.
        self.dag_constants_shrink = dag_constants_shrink  # type: str
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowConstantsShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants_shrink is not None:
            result['DagConstants'] = self.dag_constants_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            self.dag_constants_shrink = m.get('DagConstants')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowConstantsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowConstantsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowConstantsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowConstantsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowCooperatorsRequest(TeaModel):
    def __init__(self, cooperator_ids=None, dag_id=None, tid=None):
        # The IDs of the users who are involved in the task flow to be updated.
        self.cooperator_ids = cooperator_ids  # type: list[str]
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowCooperatorsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids is not None:
            result['CooperatorIds'] = self.cooperator_ids
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsShrinkRequest(TeaModel):
    def __init__(self, cooperator_ids_shrink=None, dag_id=None, tid=None):
        # The IDs of the users who are involved in the task flow to be updated.
        self.cooperator_ids_shrink = cooperator_ids_shrink  # type: str
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowCooperatorsShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids_shrink is not None:
            result['CooperatorIds'] = self.cooperator_ids_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids_shrink = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowCooperatorsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowCooperatorsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowCooperatorsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowCooperatorsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(self, id=None, node_end=None, node_from=None):
        # The ID of the task flow edge.
        self.id = id  # type: long
        # The ID of the end node of the edge.
        self.node_end = node_end  # type: long
        # The ID of the start node of the edge.
        self.node_from = node_from  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowEdgesRequestEdges, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowEdgesRequest(TeaModel):
    def __init__(self, dag_id=None, edges=None, tid=None):
        # The task flow ID. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of updated task flow edges.
        self.edges = edges  # type: list[UpdateTaskFlowEdgesRequestEdges]
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowEdgesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(self, dag_id=None, edges_shrink=None, tid=None):
        # The task flow ID. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of updated task flow edges.
        self.edges_shrink = edges_shrink  # type: str
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowEdgesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowEdgesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowEdgesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowEdgesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowEdgesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNameAndDescRequest(TeaModel):
    def __init__(self, dag_id=None, dag_name=None, description=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The new name that you want to specify for the task flow.
        self.dag_name = dag_name  # type: str
        # The description that you want to specify for the task flow.
        self.description = description  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowNameAndDescRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNameAndDescResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowNameAndDescResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNameAndDescResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowNameAndDescResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowNameAndDescResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNameAndDescResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNotificationRequest(TeaModel):
    def __init__(self, dag_id=None, dag_notification_fail=None, dag_notification_sla=None,
                 dag_notification_success=None, tid=None):
        # The unique ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # Specifies whether to enable notifications for failed task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_fail = dag_notification_fail  # type: bool
        # Specifies whether to enable SLA global notifications for task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_sla = dag_notification_sla  # type: bool
        # Specifies whether to enable notifications for successful task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_success = dag_notification_success  # type: bool
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowNotificationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNotificationResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowNotificationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNotificationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowNotificationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowNotificationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowOwnerRequest(TeaModel):
    def __init__(self, dag_id=None, new_owner_id=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The user ID of the new owner. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the user ID.
        self.new_owner_id = new_owner_id  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowOwnerRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.new_owner_id is not None:
            result['NewOwnerId'] = self.new_owner_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('NewOwnerId') is not None:
            self.new_owner_id = m.get('NewOwnerId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowOwnerResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowOwnerResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowOwnerResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowOwnerResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowOwnerResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowRelationsRequestEdges(TeaModel):
    def __init__(self, id=None, node_end=None, node_from=None):
        # The ID of the task flow edge.
        self.id = id  # type: long
        # The ID of the end node on the edge.
        self.node_end = node_end  # type: long
        # The ID of the start node on the edge.
        self.node_from = node_from  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowRelationsRequestEdges, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowRelationsRequest(TeaModel):
    def __init__(self, dag_id=None, edges=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of task flow edges to be updated.
        self.edges = edges  # type: list[UpdateTaskFlowRelationsRequestEdges]
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowRelationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowRelationsRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsShrinkRequest(TeaModel):
    def __init__(self, dag_id=None, edges_shrink=None, tid=None):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id  # type: long
        # The list of task flow edges to be updated.
        self.edges_shrink = edges_shrink  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowRelationsShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowRelationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowRelationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowRelationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowRelationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowScheduleRequest(TeaModel):
    def __init__(self, cron_begin_date=None, cron_end_date=None, cron_str=None, cron_type=None, dag_id=None,
                 schedule_param=None, schedule_switch=None, tid=None, time_zone_id=None, trigger_type=None):
        # The start of the time range for scheduling.
        self.cron_begin_date = cron_begin_date  # type: str
        # The end of the time range for scheduling.
        self.cron_end_date = cron_end_date  # type: str
        # The cron expression for timed scheduling.
        self.cron_str = cron_str  # type: str
        # The type of the scheduling cycle. Valid values:
        # 
        # *   **MINUTE**: scheduling by minute
        # *   **HOUR**: scheduling by hour
        # *   **DAY**: scheduling by day
        # *   **WEEK**: scheduling by week
        # *   **MONTH**: scheduling by month
        self.cron_type = cron_type  # type: str
        # The ID of the task flow.
        self.dag_id = dag_id  # type: long
        # The event scheduling configuration. The value of this parameter is a JSON string.
        self.schedule_param = schedule_param  # type: str
        # Specifies whether to enable scheduling. Valid values:
        # 
        # *   **Enable**\
        # *   **Disable**\
        self.schedule_switch = schedule_switch  # type: bool
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long
        # The time zone. The default time zone is UTC+8 (Asia/Shanghai).
        self.time_zone_id = time_zone_id  # type: str
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **Cron**: The task flow is triggered based on timed scheduling.
        # *   **Event**: The task flow is triggered by events.
        self.trigger_type = trigger_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowScheduleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.cron_type is not None:
            result['CronType'] = self.cron_type
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.schedule_param is not None:
            result['ScheduleParam'] = self.schedule_param
        if self.schedule_switch is not None:
            result['ScheduleSwitch'] = self.schedule_switch
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_zone_id is not None:
            result['TimeZoneId'] = self.time_zone_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('CronType') is not None:
            self.cron_type = m.get('CronType')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScheduleParam') is not None:
            self.schedule_param = m.get('ScheduleParam')
        if m.get('ScheduleSwitch') is not None:
            self.schedule_switch = m.get('ScheduleSwitch')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeZoneId') is not None:
            self.time_zone_id = m.get('TimeZoneId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class UpdateTaskFlowScheduleResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowScheduleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowScheduleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowScheduleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowScheduleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(self, dag_id=None, tid=None, time_variables=None):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.dag_id = dag_id  # type: long
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long
        # The time variables for the task flow.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowTimeVariablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskFlowTimeVariablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskFlowTimeVariablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskFlowTimeVariablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskNameRequest(TeaModel):
    def __init__(self, node_id=None, node_name=None, tid=None):
        # The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: str
        # The name of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node name.
        self.node_name = node_name  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskNameResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskOutputRequest(TeaModel):
    def __init__(self, node_id=None, node_output=None, tid=None):
        # The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: str
        # The output variables for the task.
        self.node_output = node_output  # type: str
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskOutputRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskOutputResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskOutputResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskOutputResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskOutputResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskOutputResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskTimeVariablesRequest(TeaModel):
    def __init__(self, node_id=None, tid=None, time_variables=None):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id  # type: str
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid  # type: long
        # The time variables configured for the node. The value of this parameter must be a JSON string.
        self.time_variables = time_variables  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskTimeVariablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskTimeVariablesResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTaskTimeVariablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskTimeVariablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTaskTimeVariablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTaskTimeVariablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserRequest(TeaModel):
    def __init__(self, max_execute_count=None, max_result_count=None, mobile=None, role_names=None, tid=None,
                 uid=None, user_nick=None):
        # The maximum number of queries that can be performed each day.
        self.max_execute_count = max_execute_count  # type: long
        # The maximum number of rows that can be queried each day.
        self.max_result_count = max_result_count  # type: long
        # The DingTalk ID or mobile number of the user.
        self.mobile = mobile  # type: str
        # The roles that the user assumes. For more information about the valid values, see the Request parameters section in the [UpdateUser](~~465812~~) topic.
        self.role_names = role_names  # type: str
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
        self.tid = tid  # type: long
        # The Alibaba Cloud unique ID (UID) of the user to update.
        self.uid = uid  # type: long
        # The nickname of the user.
        self.user_nick = user_nick  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class UpdateUserResponseBody(TeaModel):
    def __init__(self, error_code=None, error_message=None, request_id=None, success=None):
        # The error code returned if the request failed.
        self.error_code = error_code  # type: str
        # The error message returned if the request failed.
        self.error_message = error_message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request succeeded.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


