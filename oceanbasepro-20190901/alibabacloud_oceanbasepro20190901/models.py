# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class DataExtraInfoSubCondsValue(TeaModel):
    def __init__(self, tenant_name=None, database=None, dest_database=None, table_name=None, dest_name=None,
                 where_clause=None, filter_columns=None, shard_columns=None, logic_table_id=None, source_endpoint_id=None,
                 source_client_id=None):
        self.tenant_name = tenant_name  # type: str
        self.database = database  # type: str
        self.dest_database = dest_database  # type: str
        self.table_name = table_name  # type: str
        self.dest_name = dest_name  # type: str
        self.where_clause = where_clause  # type: str
        self.filter_columns = filter_columns  # type: list[str]
        self.shard_columns = shard_columns  # type: list[str]
        self.logic_table_id = logic_table_id  # type: str
        self.source_endpoint_id = source_endpoint_id  # type: str
        self.source_client_id = source_client_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DataExtraInfoSubCondsValue, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.database is not None:
            result['Database'] = self.database
        if self.dest_database is not None:
            result['DestDatabase'] = self.dest_database
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.dest_name is not None:
            result['DestName'] = self.dest_name
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.logic_table_id is not None:
            result['LogicTableId'] = self.logic_table_id
        if self.source_endpoint_id is not None:
            result['SourceEndpointId'] = self.source_endpoint_id
        if self.source_client_id is not None:
            result['SourceClientId'] = self.source_client_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('DestDatabase') is not None:
            self.dest_database = m.get('DestDatabase')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('DestName') is not None:
            self.dest_name = m.get('DestName')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('LogicTableId') is not None:
            self.logic_table_id = m.get('LogicTableId')
        if m.get('SourceEndpointId') is not None:
            self.source_endpoint_id = m.get('SourceEndpointId')
        if m.get('SourceClientId') is not None:
            self.source_client_id = m.get('SourceClientId')
        return self


class DataExtraInfoSubDbsValueTablesColumns(TeaModel):
    def __init__(self, column_name=None, position=None, column_type=None, record_field_type=None,
                 raw_column_type=None, column_key=None, nullable=None, default_value=None, data_length=None, data_precision=None,
                 data_scale=None, encoding=None, column_comment=None, is_generate_field=None):
        self.column_name = column_name  # type: str
        self.position = position  # type: int
        self.column_type = column_type  # type: str
        self.record_field_type = record_field_type  # type: str
        self.raw_column_type = raw_column_type  # type: str
        self.column_key = column_key  # type: str
        self.nullable = nullable  # type: bool
        self.default_value = default_value  # type: str
        self.data_length = data_length  # type: long
        self.data_precision = data_precision  # type: int
        self.data_scale = data_scale  # type: int
        self.encoding = encoding  # type: str
        self.column_comment = column_comment  # type: str
        self.is_generate_field = is_generate_field  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DataExtraInfoSubDbsValueTablesColumns, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.position is not None:
            result['Position'] = self.position
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.record_field_type is not None:
            result['RecordFieldType'] = self.record_field_type
        if self.raw_column_type is not None:
            result['RawColumnType'] = self.raw_column_type
        if self.column_key is not None:
            result['ColumnKey'] = self.column_key
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.column_comment is not None:
            result['ColumnComment'] = self.column_comment
        if self.is_generate_field is not None:
            result['IsGenerateField'] = self.is_generate_field
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('RecordFieldType') is not None:
            self.record_field_type = m.get('RecordFieldType')
        if m.get('RawColumnType') is not None:
            self.raw_column_type = m.get('RawColumnType')
        if m.get('ColumnKey') is not None:
            self.column_key = m.get('ColumnKey')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('ColumnComment') is not None:
            self.column_comment = m.get('ColumnComment')
        if m.get('IsGenerateField') is not None:
            self.is_generate_field = m.get('IsGenerateField')
        return self


class DataExtraInfoSubDbsValueTables(TeaModel):
    def __init__(self, table_id=None, database=None, table_name=None, mapping_table_name=None, instance=None,
                 columns=None):
        self.table_id = table_id  # type: str
        self.database = database  # type: str
        self.table_name = table_name  # type: str
        self.mapping_table_name = mapping_table_name  # type: str
        self.instance = instance  # type: str
        self.columns = columns  # type: list[DataExtraInfoSubDbsValueTablesColumns]

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DataExtraInfoSubDbsValueTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.database is not None:
            result['Database'] = self.database
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.mapping_table_name is not None:
            result['MappingTableName'] = self.mapping_table_name
        if self.instance is not None:
            result['Instance'] = self.instance
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('MappingTableName') is not None:
            self.mapping_table_name = m.get('MappingTableName')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = DataExtraInfoSubDbsValueTablesColumns()
                self.columns.append(temp_model.from_map(k))
        return self


class DataExtraInfoSubDbsValue(TeaModel):
    def __init__(self, cluster_name=None, tenant_name=None, database_id=None, database_name=None,
                 mapping_database_name=None, source_client_id=None, tables=None):
        self.cluster_name = cluster_name  # type: str
        self.tenant_name = tenant_name  # type: str
        self.database_id = database_id  # type: str
        self.database_name = database_name  # type: str
        self.mapping_database_name = mapping_database_name  # type: str
        self.source_client_id = source_client_id  # type: str
        self.tables = tables  # type: list[DataExtraInfoSubDbsValueTables]

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DataExtraInfoSubDbsValue, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.mapping_database_name is not None:
            result['MappingDatabaseName'] = self.mapping_database_name
        if self.source_client_id is not None:
            result['SourceClientId'] = self.source_client_id
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('MappingDatabaseName') is not None:
            self.mapping_database_name = m.get('MappingDatabaseName')
        if m.get('SourceClientId') is not None:
            self.source_client_id = m.get('SourceClientId')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = DataExtraInfoSubDbsValueTables()
                self.tables.append(temp_model.from_map(k))
        return self


class CreateDatabaseRequest(TeaModel):
    def __init__(self, client_token=None, collation=None, database_name=None, description=None, encoding=None,
                 instance_id=None, tenant_id=None):
        # The name of the database.
        self.client_token = client_token  # type: str
        # The encoding standard of the database.
        # For more information, see the Charset field returned by the DescribeCharset operation.
        self.collation = collation  # type: str
        # Alibaba Cloud CLI
        self.database_name = database_name  # type: str
        # The operation that you want to perform.   
        # Set the value to **CreateDatabase**.
        self.description = description  # type: str
        # The ID of the tenant.
        self.encoding = encoding  # type: str
        # The collation.
        self.instance_id = instance_id  # type: str
        # The name of the database.   
        # You cannot use reserved keywords, such as test and mysql.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.collation is not None:
            result['Collation'] = self.collation
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Collation') is not None:
            self.collation = m.get('Collation')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class CreateDatabaseResponseBody(TeaModel):
    def __init__(self, database_name=None, request_id=None):
        # CreateDatabase
        self.database_name = database_name  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstanceRequest(TeaModel):
    def __init__(self, auto_renew=None, auto_renew_period=None, charge_type=None, disk_size=None, disk_type=None,
                 dry_run=None, instance_class=None, instance_name=None, isolation_optimization=None, ob_version=None,
                 period=None, period_unit=None, primary_instance=None, primary_region=None, replica_mode=None,
                 resource_group_id=None, series=None, zones=None):
        # Specifies whether to enable automatic renewal.   
        # This parameter is valid only when the ChargeType parameter is set to PrePaid. Valid values: 
        # - true: enables automatic renewal for the instance.   
        # - false: disables automatic renewal for the instance. This is the default value.
        self.auto_renew = auto_renew  # type: bool
        # The automatic renewal period of the instance. This parameter is required when the AutoRenew parameter is set to true. Valid values:  
        # - If the PeriodUnit parameter is set to Year: "1", "2", and "3".   
        # - If the PeriodUnit parameter is set to Month: "1", "2", "3", "6", and "12".
        self.auto_renew_period = auto_renew_period  # type: long
        # The billing method of the instance. Valid values:  
        # - PrePay: the subscription billing method. You must ensure that the remaining balance or credit balance of your account can cover the cost of the subscription. Otherwise, you will receive an InvalidPayMethod error. 
        # - PostPay: the pay-as-you-go billing method. This is the default value. By default, fees are charged on an hourly basis.
        self.charge_type = charge_type  # type: str
        # The size of the storage space,in GB.    
        # The limits on the storage space vary with the cluster specifications:   
        # - 8C32GB: 100 GB to 10000 GB   
        # - 14C70GB: 200 GB to 10000 GB   
        # - 30C180GB: 400 GB to 10000 GB   
        # - 62C400GB: 800 GB to 10000 GB    
        # The preceding minimum storage space sizes are the default storage space sizes of the corresponding cluster specification plans.
        self.disk_size = disk_size  # type: long
        # The return result of the request.
        self.disk_type = disk_type  # type: str
        self.dry_run = dry_run  # type: bool
        # The specifications of the cluster.     
        # You can specify one of the following four plans:   
        #  - 8C32GB: indicates 8 CPU cores and 32 GB of memory.    
        #  - 14C70GB: indicates 14 CPU cores and 70 GB of memory. This is the default value.
        # - 30C180GB: indicates 30 CPU cores and 180 GB of memory.     
        # - 62C400GB: indicates 62 CPU cores and 400 GB of memory.
        self.instance_class = instance_class  # type: str
        # The name of the OceanBase cluster.    
        # It must be 1 to 20 characters in length.   
        # If this parameter is not specified, the value is the instance ID of the cluster by default.
        self.instance_name = instance_name  # type: str
        self.isolation_optimization = isolation_optimization  # type: str
        # OceanBase Server version number.
        self.ob_version = ob_version  # type: str
        # The valid duration of the purchased resources. The unit is specified by the PeriodUnit parameter.   
        # This parameter is valid and required only when the InstanceChargeType parameter is set to PrePaid.      
        # Valid values:     
        # - When the PeriodUnit parameter is set to Month: "1", "2", "3", "4", "5", "6", "7", "8", "9". 
        # - When the PeriodUnit parameter is set to Year: "1", "2", "3".
        self.period = period  # type: long
        # The unit of the valid duration of the purchased resources.     
        # Valid value for subscription: Month or Year.
        # Default value: Month for subscription, and Hour for pay-as-you-go.
        self.period_unit = period_unit  # type: str
        self.primary_instance = primary_instance  # type: str
        self.primary_region = primary_region  # type: str
        self.replica_mode = replica_mode  # type: str
        # The ID of the resource group to which the instance belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The series of the OceanBase cluster. Valid values:    
        # - normal: Standard Cluster Edition (Cloud Disk). This is the default value.
        # - normal_ssd: Standard Cluster Edition (Local Disk).
        # - history: History Database Cluster Edition.
        self.series = series  # type: str
        # The ID of the zone to which the instance belongs.   
        # For more information about how to obtain the list of zones, see [DescribeZones](~~25610~~).
        self.zones = zones  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.isolation_optimization is not None:
            result['IsolationOptimization'] = self.isolation_optimization
        if self.ob_version is not None:
            result['ObVersion'] = self.ob_version
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.primary_instance is not None:
            result['PrimaryInstance'] = self.primary_instance
        if self.primary_region is not None:
            result['PrimaryRegion'] = self.primary_region
        if self.replica_mode is not None:
            result['ReplicaMode'] = self.replica_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.series is not None:
            result['Series'] = self.series
        if self.zones is not None:
            result['Zones'] = self.zones
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IsolationOptimization') is not None:
            self.isolation_optimization = m.get('IsolationOptimization')
        if m.get('ObVersion') is not None:
            self.ob_version = m.get('ObVersion')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PrimaryInstance') is not None:
            self.primary_instance = m.get('PrimaryInstance')
        if m.get('PrimaryRegion') is not None:
            self.primary_region = m.get('PrimaryRegion')
        if m.get('ReplicaMode') is not None:
            self.replica_mode = m.get('ReplicaMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('Zones') is not None:
            self.zones = m.get('Zones')
        return self


class CreateInstanceResponseBodyData(TeaModel):
    def __init__(self, dry_run_result=None, instance_id=None, order_id=None, resource_group_id=None):
        self.dry_run_result = dry_run_result  # type: bool
        # 订单ID。该参数只有创建包年包月ECS实例（请求参数InstanceChargeType=PrePaid）时有返回值。
        self.instance_id = instance_id  # type: str
        # 资源组ID
        self.order_id = order_id  # type: str
        self.resource_group_id = resource_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run_result is not None:
            result['DryRunResult'] = self.dry_run_result
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRunResult') is not None:
            self.dry_run_result = m.get('DryRunResult')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class CreateInstanceResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # 实例ID
        self.data = data  # type: CreateInstanceResponseBodyData
        # Response parameters
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLabelRequest(TeaModel):
    def __init__(self, name=None):
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLabelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateLabelResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLabelResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class CreateLabelResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: CreateLabelResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(CreateLabelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = CreateLabelResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateLabelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLabelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLabelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMySqlDataSourceRequest(TeaModel):
    def __init__(self, description=None, dg_instance_id=None, instance_id=None, ip=None, name=None, password=None,
                 port=None, schema=None, type=None, user_name=None, vpc_id=None):
        self.description = description  # type: str
        self.dg_instance_id = dg_instance_id  # type: str
        self.instance_id = instance_id  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.password = password  # type: str
        self.port = port  # type: int
        self.schema = schema  # type: str
        self.type = type  # type: str
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMySqlDataSourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dg_instance_id is not None:
            result['DgInstanceId'] = self.dg_instance_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.password is not None:
            result['Password'] = self.password
        if self.port is not None:
            result['Port'] = self.port
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.type is not None:
            result['Type'] = self.type
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DgInstanceId') is not None:
            self.dg_instance_id = m.get('DgInstanceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateMySqlDataSourceResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMySqlDataSourceResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class CreateMySqlDataSourceResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: CreateMySqlDataSourceResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(CreateMySqlDataSourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = CreateMySqlDataSourceResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateMySqlDataSourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMySqlDataSourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMySqlDataSourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMySqlDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOceanBaseDataSourceRequest(TeaModel):
    def __init__(self, cluster=None, config_url=None, description=None, drc_password=None, drc_user_name=None,
                 inner_drc_password=None, ip=None, log_proxy_ip=None, log_proxy_port=None, name=None, password=None, port=None,
                 tenant=None, type=None, user_name=None, vpc_id=None):
        self.cluster = cluster  # type: str
        self.config_url = config_url  # type: str
        self.description = description  # type: str
        self.drc_password = drc_password  # type: str
        self.drc_user_name = drc_user_name  # type: str
        self.inner_drc_password = inner_drc_password  # type: str
        self.ip = ip  # type: str
        # LogProxy IP。
        self.log_proxy_ip = log_proxy_ip  # type: str
        self.log_proxy_port = log_proxy_port  # type: str
        self.name = name  # type: str
        self.password = password  # type: str
        self.port = port  # type: int
        self.tenant = tenant  # type: str
        self.type = type  # type: str
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOceanBaseDataSourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['Cluster'] = self.cluster
        if self.config_url is not None:
            result['ConfigUrl'] = self.config_url
        if self.description is not None:
            result['Description'] = self.description
        if self.drc_password is not None:
            result['DrcPassword'] = self.drc_password
        if self.drc_user_name is not None:
            result['DrcUserName'] = self.drc_user_name
        if self.inner_drc_password is not None:
            result['InnerDrcPassword'] = self.inner_drc_password
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.log_proxy_ip is not None:
            result['LogProxyIp'] = self.log_proxy_ip
        if self.log_proxy_port is not None:
            result['LogProxyPort'] = self.log_proxy_port
        if self.name is not None:
            result['Name'] = self.name
        if self.password is not None:
            result['Password'] = self.password
        if self.port is not None:
            result['Port'] = self.port
        if self.tenant is not None:
            result['Tenant'] = self.tenant
        if self.type is not None:
            result['Type'] = self.type
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cluster') is not None:
            self.cluster = m.get('Cluster')
        if m.get('ConfigUrl') is not None:
            self.config_url = m.get('ConfigUrl')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DrcPassword') is not None:
            self.drc_password = m.get('DrcPassword')
        if m.get('DrcUserName') is not None:
            self.drc_user_name = m.get('DrcUserName')
        if m.get('InnerDrcPassword') is not None:
            self.inner_drc_password = m.get('InnerDrcPassword')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('LogProxyIp') is not None:
            self.log_proxy_ip = m.get('LogProxyIp')
        if m.get('LogProxyPort') is not None:
            self.log_proxy_port = m.get('LogProxyPort')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Tenant') is not None:
            self.tenant = m.get('Tenant')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateOceanBaseDataSourceResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOceanBaseDataSourceResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class CreateOceanBaseDataSourceResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: CreateOceanBaseDataSourceResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(CreateOceanBaseDataSourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = CreateOceanBaseDataSourceResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateOceanBaseDataSourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateOceanBaseDataSourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateOceanBaseDataSourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOceanBaseDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOmsMysqlDataSourceRequest(TeaModel):
    def __init__(self, description=None, dg_database_id=None, instance_id=None, ip=None, name=None, password=None,
                 port=None, schema=None, type=None, username=None, vpc_id=None):
        # The description of the data source.   
        # 
        # It must be 2 to 256 characters in length. The default value is null.
        self.description = description  # type: str
        # The ID of the database gateway instance.   
        # 
        # > <br>If Type is set to DG, this parameter is required.
        self.dg_database_id = dg_database_id  # type: str
        # The ID of the ECS instance of the data source.   
        # 
        # > <br>If Type is set to RDS, PolarDB, or DG, this parameter is required.
        self.instance_id = instance_id  # type: str
        # The IP address of the data source.   
        # 
        # > <br>If Type is set to INTERNET or VPC, this parameter is required.
        self.ip = ip  # type: str
        # The name of the data source.   
        # It must be 2 to 128 characters in length and can contain letters, digits, underscores (_), periods (.), and hyphens (-).   
        # 
        # > <br>Invalid characters, such as slashes (/), are not allowed.
        self.name = name  # type: str
        # The password of the username that is used to access the database. It must be Base64 encoded.   
        # For example, for the password abcd123@!, the Base64-encoded value is YWJjZDEyM0Ah.
        self.password = password  # type: str
        # The port number of the data source.   
        # 
        # > <br>If Type is set to INTERNET or VPC, this parameter is required.
        self.port = port  # type: str
        # The name of the database.   
        # 
        # > <br>If you specify this parameter, subsequent migration or synchronization operations will take effect on this database only.
        self.schema = schema  # type: str
        # The type of the MySQL data source.   
        # Valid values: INTERNET, VPC, RDS, PolarDB, and DG.
        self.type = type  # type: str
        # The username that is used to access the database.
        self.username = username  # type: str
        # The ID of the VPC to which the data source belongs.   
        # 
        # > <br>If Type is set to VPC, this parameter is required.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsMysqlDataSourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dg_database_id is not None:
            result['DgDatabaseId'] = self.dg_database_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.password is not None:
            result['Password'] = self.password
        if self.port is not None:
            result['Port'] = self.port
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.type is not None:
            result['Type'] = self.type
        if self.username is not None:
            result['Username'] = self.username
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DgDatabaseId') is not None:
            self.dg_database_id = m.get('DgDatabaseId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateOmsMysqlDataSourceResponseBodyData(TeaModel):
    def __init__(self, endpoint_id=None):
        # The ID of the data source record.
        self.endpoint_id = endpoint_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsMysqlDataSourceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        return self


class CreateOmsMysqlDataSourceResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The return result of the request.
        self.data = data  # type: CreateOmsMysqlDataSourceResponseBodyData
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateOmsMysqlDataSourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateOmsMysqlDataSourceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOmsMysqlDataSourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateOmsMysqlDataSourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateOmsMysqlDataSourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOmsMysqlDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOmsOpenAPIProjectRequestDestConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        self.enable_msg_trace = enable_msg_trace  # type: bool
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_type = endpoint_type  # type: str
        self.msg_tags = msg_tags  # type: str
        self.partition = partition  # type: int
        self.partition_mode = partition_mode  # type: str
        self.producer_group = producer_group  # type: str
        self.send_msg_timeout = send_msg_timeout  # type: long
        self.sequence_enable = sequence_enable  # type: bool
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        self.serializer_type = serializer_type  # type: str
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestDestConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class CreateOmsOpenAPIProjectRequestSourceConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        self.enable_msg_trace = enable_msg_trace  # type: bool
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_type = endpoint_type  # type: str
        self.msg_tags = msg_tags  # type: str
        self.partition = partition  # type: int
        self.partition_mode = partition_mode  # type: str
        self.producer_group = producer_group  # type: str
        self.send_msg_timeout = send_msg_timeout  # type: long
        self.sequence_enable = sequence_enable  # type: bool
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        self.serializer_type = serializer_type  # type: str
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestSourceConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: int
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, mapped_name=None, shard_columns=None,
                 table_id=None, table_name=None, type=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.mapped_name = mapped_name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.table_id = table_id  # type: str
        self.table_name = table_name  # type: str
        self.type = type  # type: str
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.type is not None:
            result['Type'] = self.type
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateOmsOpenAPIProjectRequestTransferMappingDatabases(TeaModel):
    def __init__(self, database_id=None, database_name=None, mapped_name=None, tables=None, tenant_name=None,
                 type=None):
        self.database_id = database_id  # type: str
        self.database_name = database_name  # type: str
        self.mapped_name = mapped_name  # type: str
        self.tables = tables  # type: list[CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTables]
        self.tenant_name = tenant_name  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferMappingDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = CreateOmsOpenAPIProjectRequestTransferMappingDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateOmsOpenAPIProjectRequestTransferMapping(TeaModel):
    def __init__(self, databases=None, mode=None):
        self.databases = databases  # type: list[CreateOmsOpenAPIProjectRequestTransferMappingDatabases]
        self.mode = mode  # type: str

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = CreateOmsOpenAPIProjectRequestTransferMappingDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class CreateOmsOpenAPIProjectRequestTransferStepConfigIncrSyncStepTransferConfig(TeaModel):
    def __init__(self, record_type_list=None, start_timestamp=None, store_log_kept_hour=None,
                 store_transaction_enabled=None, transfer_step_type=None):
        self.record_type_list = record_type_list  # type: list[str]
        self.start_timestamp = start_timestamp  # type: long
        self.store_log_kept_hour = store_log_kept_hour  # type: long
        self.store_transaction_enabled = store_transaction_enabled  # type: bool
        self.transfer_step_type = transfer_step_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferStepConfigIncrSyncStepTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_type_list is not None:
            result['RecordTypeList'] = self.record_type_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        if self.store_transaction_enabled is not None:
            result['StoreTransactionEnabled'] = self.store_transaction_enabled
        if self.transfer_step_type is not None:
            result['TransferStepType'] = self.transfer_step_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RecordTypeList') is not None:
            self.record_type_list = m.get('RecordTypeList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        if m.get('StoreTransactionEnabled') is not None:
            self.store_transaction_enabled = m.get('StoreTransactionEnabled')
        if m.get('TransferStepType') is not None:
            self.transfer_step_type = m.get('TransferStepType')
        return self


class CreateOmsOpenAPIProjectRequestTransferStepConfig(TeaModel):
    def __init__(self, enable_full_sync=None, enable_incr_sync=None, enable_struct_sync=None,
                 incr_sync_step_transfer_config=None):
        self.enable_full_sync = enable_full_sync  # type: bool
        self.enable_incr_sync = enable_incr_sync  # type: bool
        self.enable_struct_sync = enable_struct_sync  # type: bool
        self.incr_sync_step_transfer_config = incr_sync_step_transfer_config  # type: CreateOmsOpenAPIProjectRequestTransferStepConfigIncrSyncStepTransferConfig

    def validate(self):
        if self.incr_sync_step_transfer_config:
            self.incr_sync_step_transfer_config.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequestTransferStepConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_full_sync is not None:
            result['EnableFullSync'] = self.enable_full_sync
        if self.enable_incr_sync is not None:
            result['EnableIncrSync'] = self.enable_incr_sync
        if self.enable_struct_sync is not None:
            result['EnableStructSync'] = self.enable_struct_sync
        if self.incr_sync_step_transfer_config is not None:
            result['IncrSyncStepTransferConfig'] = self.incr_sync_step_transfer_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableFullSync') is not None:
            self.enable_full_sync = m.get('EnableFullSync')
        if m.get('EnableIncrSync') is not None:
            self.enable_incr_sync = m.get('EnableIncrSync')
        if m.get('EnableStructSync') is not None:
            self.enable_struct_sync = m.get('EnableStructSync')
        if m.get('IncrSyncStepTransferConfig') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestTransferStepConfigIncrSyncStepTransferConfig()
            self.incr_sync_step_transfer_config = temp_model.from_map(m['IncrSyncStepTransferConfig'])
        return self


class CreateOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, business_name=None, dest_config=None, label_ids=None, page_number=None, page_size=None,
                 project_name=None, source_config=None, transfer_mapping=None, transfer_step_config=None, worker_grade_id=None):
        self.business_name = business_name  # type: str
        self.dest_config = dest_config  # type: CreateOmsOpenAPIProjectRequestDestConfig
        self.label_ids = label_ids  # type: list[str]
        # 页序号，分页查询时生效
        self.page_number = page_number  # type: int
        # 页大小，分页查询时生效
        self.page_size = page_size  # type: int
        self.project_name = project_name  # type: str
        self.source_config = source_config  # type: CreateOmsOpenAPIProjectRequestSourceConfig
        self.transfer_mapping = transfer_mapping  # type: CreateOmsOpenAPIProjectRequestTransferMapping
        self.transfer_step_config = transfer_step_config  # type: CreateOmsOpenAPIProjectRequestTransferStepConfig
        # 实例规格 ID，创建项目时生效
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        if self.dest_config:
            self.dest_config.validate()
        if self.source_config:
            self.source_config.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()
        if self.transfer_step_config:
            self.transfer_step_config.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.dest_config is not None:
            result['DestConfig'] = self.dest_config.to_map()
        if self.label_ids is not None:
            result['LabelIds'] = self.label_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config.to_map()
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.transfer_step_config is not None:
            result['TransferStepConfig'] = self.transfer_step_config.to_map()
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('DestConfig') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestDestConfig()
            self.dest_config = temp_model.from_map(m['DestConfig'])
        if m.get('LabelIds') is not None:
            self.label_ids = m.get('LabelIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        if m.get('SourceConfig') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestSourceConfig()
            self.source_config = temp_model.from_map(m['SourceConfig'])
        if m.get('TransferMapping') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('TransferStepConfig') is not None:
            temp_model = CreateOmsOpenAPIProjectRequestTransferStepConfig()
            self.transfer_step_config = temp_model.from_map(m['TransferStepConfig'])
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class CreateOmsOpenAPIProjectShrinkRequest(TeaModel):
    def __init__(self, business_name=None, dest_config_shrink=None, label_ids_shrink=None, page_number=None,
                 page_size=None, project_name=None, source_config_shrink=None, transfer_mapping_shrink=None,
                 transfer_step_config_shrink=None, worker_grade_id=None):
        self.business_name = business_name  # type: str
        self.dest_config_shrink = dest_config_shrink  # type: str
        self.label_ids_shrink = label_ids_shrink  # type: str
        # 页序号，分页查询时生效
        self.page_number = page_number  # type: int
        # 页大小，分页查询时生效
        self.page_size = page_size  # type: int
        self.project_name = project_name  # type: str
        self.source_config_shrink = source_config_shrink  # type: str
        self.transfer_mapping_shrink = transfer_mapping_shrink  # type: str
        self.transfer_step_config_shrink = transfer_step_config_shrink  # type: str
        # 实例规格 ID，创建项目时生效
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.dest_config_shrink is not None:
            result['DestConfig'] = self.dest_config_shrink
        if self.label_ids_shrink is not None:
            result['LabelIds'] = self.label_ids_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        if self.source_config_shrink is not None:
            result['SourceConfig'] = self.source_config_shrink
        if self.transfer_mapping_shrink is not None:
            result['TransferMapping'] = self.transfer_mapping_shrink
        if self.transfer_step_config_shrink is not None:
            result['TransferStepConfig'] = self.transfer_step_config_shrink
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('DestConfig') is not None:
            self.dest_config_shrink = m.get('DestConfig')
        if m.get('LabelIds') is not None:
            self.label_ids_shrink = m.get('LabelIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        if m.get('SourceConfig') is not None:
            self.source_config_shrink = m.get('SourceConfig')
        if m.get('TransferMapping') is not None:
            self.transfer_mapping_shrink = m.get('TransferMapping')
        if m.get('TransferStepConfig') is not None:
            self.transfer_step_config_shrink = m.get('TransferStepConfig')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class CreateOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        self.code = code  # type: str
        self.level = level  # type: str
        self.message = message  # type: str
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class CreateOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: CreateOmsOpenAPIProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = CreateOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectRequestCommonTransferConfig(TeaModel):
    def __init__(self, active_active=None, data_works_business_name=None, datahub_topic_type=None,
                 mq_partition=None, mq_partition_mode=None, mq_serializer_type=None, rocket_mq_enable_msg_trace=None,
                 rocket_mq_msg_tags=None, rocket_mq_producer_group=None, rocket_mq_send_msg_timeout=None, table_category=None):
        self.active_active = active_active  # type: bool
        self.data_works_business_name = data_works_business_name  # type: str
        self.datahub_topic_type = datahub_topic_type  # type: str
        self.mq_partition = mq_partition  # type: int
        self.mq_partition_mode = mq_partition_mode  # type: str
        self.mq_serializer_type = mq_serializer_type  # type: str
        self.rocket_mq_enable_msg_trace = rocket_mq_enable_msg_trace  # type: bool
        self.rocket_mq_msg_tags = rocket_mq_msg_tags  # type: str
        self.rocket_mq_producer_group = rocket_mq_producer_group  # type: str
        self.rocket_mq_send_msg_timeout = rocket_mq_send_msg_timeout  # type: long
        self.table_category = table_category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestCommonTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_active is not None:
            result['ActiveActive'] = self.active_active
        if self.data_works_business_name is not None:
            result['DataWorksBusinessName'] = self.data_works_business_name
        if self.datahub_topic_type is not None:
            result['DatahubTopicType'] = self.datahub_topic_type
        if self.mq_partition is not None:
            result['MqPartition'] = self.mq_partition
        if self.mq_partition_mode is not None:
            result['MqPartitionMode'] = self.mq_partition_mode
        if self.mq_serializer_type is not None:
            result['MqSerializerType'] = self.mq_serializer_type
        if self.rocket_mq_enable_msg_trace is not None:
            result['RocketMqEnableMsgTrace'] = self.rocket_mq_enable_msg_trace
        if self.rocket_mq_msg_tags is not None:
            result['RocketMqMsgTags'] = self.rocket_mq_msg_tags
        if self.rocket_mq_producer_group is not None:
            result['RocketMqProducerGroup'] = self.rocket_mq_producer_group
        if self.rocket_mq_send_msg_timeout is not None:
            result['RocketMqSendMsgTimeout'] = self.rocket_mq_send_msg_timeout
        if self.table_category is not None:
            result['TableCategory'] = self.table_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActiveActive') is not None:
            self.active_active = m.get('ActiveActive')
        if m.get('DataWorksBusinessName') is not None:
            self.data_works_business_name = m.get('DataWorksBusinessName')
        if m.get('DatahubTopicType') is not None:
            self.datahub_topic_type = m.get('DatahubTopicType')
        if m.get('MqPartition') is not None:
            self.mq_partition = m.get('MqPartition')
        if m.get('MqPartitionMode') is not None:
            self.mq_partition_mode = m.get('MqPartitionMode')
        if m.get('MqSerializerType') is not None:
            self.mq_serializer_type = m.get('MqSerializerType')
        if m.get('RocketMqEnableMsgTrace') is not None:
            self.rocket_mq_enable_msg_trace = m.get('RocketMqEnableMsgTrace')
        if m.get('RocketMqMsgTags') is not None:
            self.rocket_mq_msg_tags = m.get('RocketMqMsgTags')
        if m.get('RocketMqProducerGroup') is not None:
            self.rocket_mq_producer_group = m.get('RocketMqProducerGroup')
        if m.get('RocketMqSendMsgTimeout') is not None:
            self.rocket_mq_send_msg_timeout = m.get('RocketMqSendMsgTimeout')
        if m.get('TableCategory') is not None:
            self.table_category = m.get('TableCategory')
        return self


class CreateProjectRequestFullTransferConfig(TeaModel):
    def __init__(self, allow_dest_table_not_empty=None, full_transfer_speed_mode=None,
                 full_verify_speed_mode=None, none_pk_uk_truncate_dst_table=None):
        self.allow_dest_table_not_empty = allow_dest_table_not_empty  # type: bool
        self.full_transfer_speed_mode = full_transfer_speed_mode  # type: str
        self.full_verify_speed_mode = full_verify_speed_mode  # type: str
        self.none_pk_uk_truncate_dst_table = none_pk_uk_truncate_dst_table  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestFullTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_dest_table_not_empty is not None:
            result['AllowDestTableNotEmpty'] = self.allow_dest_table_not_empty
        if self.full_transfer_speed_mode is not None:
            result['FullTransferSpeedMode'] = self.full_transfer_speed_mode
        if self.full_verify_speed_mode is not None:
            result['FullVerifySpeedMode'] = self.full_verify_speed_mode
        if self.none_pk_uk_truncate_dst_table is not None:
            result['NonePkUkTruncateDstTable'] = self.none_pk_uk_truncate_dst_table
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowDestTableNotEmpty') is not None:
            self.allow_dest_table_not_empty = m.get('AllowDestTableNotEmpty')
        if m.get('FullTransferSpeedMode') is not None:
            self.full_transfer_speed_mode = m.get('FullTransferSpeedMode')
        if m.get('FullVerifySpeedMode') is not None:
            self.full_verify_speed_mode = m.get('FullVerifySpeedMode')
        if m.get('NonePkUkTruncateDstTable') is not None:
            self.none_pk_uk_truncate_dst_table = m.get('NonePkUkTruncateDstTable')
        return self


class CreateProjectRequestIncrTransferConfig(TeaModel):
    def __init__(self, enable_incr_sync_statistics=None, enable_sequencing_within_txn=None,
                 incr_sync_concurrency=None, record_type_white_list=None, start_timestamp=None, store_log_kept_hour=None):
        self.enable_incr_sync_statistics = enable_incr_sync_statistics  # type: bool
        self.enable_sequencing_within_txn = enable_sequencing_within_txn  # type: bool
        self.incr_sync_concurrency = incr_sync_concurrency  # type: int
        self.record_type_white_list = record_type_white_list  # type: list[str]
        self.start_timestamp = start_timestamp  # type: str
        self.store_log_kept_hour = store_log_kept_hour  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestIncrTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_incr_sync_statistics is not None:
            result['EnableIncrSyncStatistics'] = self.enable_incr_sync_statistics
        if self.enable_sequencing_within_txn is not None:
            result['EnableSequencingWithinTxn'] = self.enable_sequencing_within_txn
        if self.incr_sync_concurrency is not None:
            result['IncrSyncConcurrency'] = self.incr_sync_concurrency
        if self.record_type_white_list is not None:
            result['RecordTypeWhiteList'] = self.record_type_white_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableIncrSyncStatistics') is not None:
            self.enable_incr_sync_statistics = m.get('EnableIncrSyncStatistics')
        if m.get('EnableSequencingWithinTxn') is not None:
            self.enable_sequencing_within_txn = m.get('EnableSequencingWithinTxn')
        if m.get('IncrSyncConcurrency') is not None:
            self.incr_sync_concurrency = m.get('IncrSyncConcurrency')
        if m.get('RecordTypeWhiteList') is not None:
            self.record_type_white_list = m.get('RecordTypeWhiteList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        return self


class CreateProjectRequestStructTransferConfig(TeaModel):
    def __init__(self, byte_char_convert_strategy=None, defer_index_creation=None):
        self.byte_char_convert_strategy = byte_char_convert_strategy  # type: str
        self.defer_index_creation = defer_index_creation  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestStructTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.byte_char_convert_strategy is not None:
            result['ByteCharConvertStrategy'] = self.byte_char_convert_strategy
        if self.defer_index_creation is not None:
            result['DeferIndexCreation'] = self.defer_index_creation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ByteCharConvertStrategy') is not None:
            self.byte_char_convert_strategy = m.get('ByteCharConvertStrategy')
        if m.get('DeferIndexCreation') is not None:
            self.defer_index_creation = m.get('DeferIndexCreation')
        return self


class CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesSpecificTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesSpecificTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesSpecificViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesSpecificViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabases(TeaModel):
    def __init__(self, cluster_name=None, id=None, mapped_name=None, name=None, specific_tables=None,
                 specific_views=None, tables=None, tenant_name=None, views=None):
        self.cluster_name = cluster_name  # type: str
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.specific_tables = specific_tables  # type: list[CreateProjectRequestTransferMappingDatabasesSpecificTables]
        self.specific_views = specific_views  # type: list[CreateProjectRequestTransferMappingDatabasesSpecificViews]
        self.tables = tables  # type: list[CreateProjectRequestTransferMappingDatabasesTables]
        self.tenant_name = tenant_name  # type: str
        self.views = views  # type: list[CreateProjectRequestTransferMappingDatabasesViews]

    def validate(self):
        if self.specific_tables:
            for k in self.specific_tables:
                if k:
                    k.validate()
        if self.specific_views:
            for k in self.specific_views:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.views:
            for k in self.views:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        result['SpecificTables'] = []
        if self.specific_tables is not None:
            for k in self.specific_tables:
                result['SpecificTables'].append(k.to_map() if k else None)
        result['SpecificViews'] = []
        if self.specific_views is not None:
            for k in self.specific_views:
                result['SpecificViews'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        result['Views'] = []
        if self.views is not None:
            for k in self.views:
                result['Views'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.specific_tables = []
        if m.get('SpecificTables') is not None:
            for k in m.get('SpecificTables'):
                temp_model = CreateProjectRequestTransferMappingDatabasesSpecificTables()
                self.specific_tables.append(temp_model.from_map(k))
        self.specific_views = []
        if m.get('SpecificViews') is not None:
            for k in m.get('SpecificViews'):
                temp_model = CreateProjectRequestTransferMappingDatabasesSpecificViews()
                self.specific_views.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = CreateProjectRequestTransferMappingDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        self.views = []
        if m.get('Views') is not None:
            for k in m.get('Views'):
                temp_model = CreateProjectRequestTransferMappingDatabasesViews()
                self.views.append(temp_model.from_map(k))
        return self


class CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackSpecificTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackSpecificTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackSpecificViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackSpecificViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class CreateProjectRequestTransferMappingDatabasesBlackViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlackViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class CreateProjectRequestTransferMappingDatabasesBlack(TeaModel):
    def __init__(self, cluster_name=None, id=None, mapped_name=None, name=None, specific_tables=None,
                 specific_views=None, tables=None, tenant_name=None, views=None):
        self.cluster_name = cluster_name  # type: str
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.specific_tables = specific_tables  # type: list[CreateProjectRequestTransferMappingDatabasesBlackSpecificTables]
        self.specific_views = specific_views  # type: list[CreateProjectRequestTransferMappingDatabasesBlackSpecificViews]
        self.tables = tables  # type: list[CreateProjectRequestTransferMappingDatabasesBlackTables]
        self.tenant_name = tenant_name  # type: str
        self.views = views  # type: list[CreateProjectRequestTransferMappingDatabasesBlackViews]

    def validate(self):
        if self.specific_tables:
            for k in self.specific_tables:
                if k:
                    k.validate()
        if self.specific_views:
            for k in self.specific_views:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.views:
            for k in self.views:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMappingDatabasesBlack, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        result['SpecificTables'] = []
        if self.specific_tables is not None:
            for k in self.specific_tables:
                result['SpecificTables'].append(k.to_map() if k else None)
        result['SpecificViews'] = []
        if self.specific_views is not None:
            for k in self.specific_views:
                result['SpecificViews'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        result['Views'] = []
        if self.views is not None:
            for k in self.views:
                result['Views'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.specific_tables = []
        if m.get('SpecificTables') is not None:
            for k in m.get('SpecificTables'):
                temp_model = CreateProjectRequestTransferMappingDatabasesBlackSpecificTables()
                self.specific_tables.append(temp_model.from_map(k))
        self.specific_views = []
        if m.get('SpecificViews') is not None:
            for k in m.get('SpecificViews'):
                temp_model = CreateProjectRequestTransferMappingDatabasesBlackSpecificViews()
                self.specific_views.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = CreateProjectRequestTransferMappingDatabasesBlackTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        self.views = []
        if m.get('Views') is not None:
            for k in m.get('Views'):
                temp_model = CreateProjectRequestTransferMappingDatabasesBlackViews()
                self.views.append(temp_model.from_map(k))
        return self


class CreateProjectRequestTransferMapping(TeaModel):
    def __init__(self, databases=None, databases_black=None, mode=None, table_and_view_black_list=None,
                 table_and_view_white_list=None):
        self.databases = databases  # type: list[CreateProjectRequestTransferMappingDatabases]
        self.databases_black = databases_black  # type: list[CreateProjectRequestTransferMappingDatabasesBlack]
        self.mode = mode  # type: str
        self.table_and_view_black_list = table_and_view_black_list  # type: list[str]
        self.table_and_view_white_list = table_and_view_white_list  # type: list[str]

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()
        if self.databases_black:
            for k in self.databases_black:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateProjectRequestTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        result['DatabasesBlack'] = []
        if self.databases_black is not None:
            for k in self.databases_black:
                result['DatabasesBlack'].append(k.to_map() if k else None)
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.table_and_view_black_list is not None:
            result['TableAndViewBlackList'] = self.table_and_view_black_list
        if self.table_and_view_white_list is not None:
            result['TableAndViewWhiteList'] = self.table_and_view_white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = CreateProjectRequestTransferMappingDatabases()
                self.databases.append(temp_model.from_map(k))
        self.databases_black = []
        if m.get('DatabasesBlack') is not None:
            for k in m.get('DatabasesBlack'):
                temp_model = CreateProjectRequestTransferMappingDatabasesBlack()
                self.databases_black.append(temp_model.from_map(k))
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('TableAndViewBlackList') is not None:
            self.table_and_view_black_list = m.get('TableAndViewBlackList')
        if m.get('TableAndViewWhiteList') is not None:
            self.table_and_view_white_list = m.get('TableAndViewWhiteList')
        return self


class CreateProjectRequest(TeaModel):
    def __init__(self, common_transfer_config=None, enable_full_transfer=None, enable_full_verify=None,
                 enable_incr_transfer=None, enable_reverse_incr_transfer=None, enable_struct_transfer=None, full_transfer_config=None,
                 incr_transfer_config=None, label_ids=None, name=None, oss_key=None, sink_endpoint_id=None, source_endpoint_id=None,
                 struct_transfer_config=None, transfer_mapping=None, type=None, use_oss=None, worker_grade_id=None):
        self.common_transfer_config = common_transfer_config  # type: CreateProjectRequestCommonTransferConfig
        self.enable_full_transfer = enable_full_transfer  # type: bool
        self.enable_full_verify = enable_full_verify  # type: bool
        self.enable_incr_transfer = enable_incr_transfer  # type: bool
        self.enable_reverse_incr_transfer = enable_reverse_incr_transfer  # type: bool
        self.enable_struct_transfer = enable_struct_transfer  # type: bool
        self.full_transfer_config = full_transfer_config  # type: CreateProjectRequestFullTransferConfig
        self.incr_transfer_config = incr_transfer_config  # type: CreateProjectRequestIncrTransferConfig
        self.label_ids = label_ids  # type: list[str]
        self.name = name  # type: str
        self.oss_key = oss_key  # type: str
        self.sink_endpoint_id = sink_endpoint_id  # type: str
        self.source_endpoint_id = source_endpoint_id  # type: str
        self.struct_transfer_config = struct_transfer_config  # type: CreateProjectRequestStructTransferConfig
        self.transfer_mapping = transfer_mapping  # type: CreateProjectRequestTransferMapping
        self.type = type  # type: str
        self.use_oss = use_oss  # type: bool
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        if self.common_transfer_config:
            self.common_transfer_config.validate()
        if self.full_transfer_config:
            self.full_transfer_config.validate()
        if self.incr_transfer_config:
            self.incr_transfer_config.validate()
        if self.struct_transfer_config:
            self.struct_transfer_config.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()

    def to_map(self):
        _map = super(CreateProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_transfer_config is not None:
            result['CommonTransferConfig'] = self.common_transfer_config.to_map()
        if self.enable_full_transfer is not None:
            result['EnableFullTransfer'] = self.enable_full_transfer
        if self.enable_full_verify is not None:
            result['EnableFullVerify'] = self.enable_full_verify
        if self.enable_incr_transfer is not None:
            result['EnableIncrTransfer'] = self.enable_incr_transfer
        if self.enable_reverse_incr_transfer is not None:
            result['EnableReverseIncrTransfer'] = self.enable_reverse_incr_transfer
        if self.enable_struct_transfer is not None:
            result['EnableStructTransfer'] = self.enable_struct_transfer
        if self.full_transfer_config is not None:
            result['FullTransferConfig'] = self.full_transfer_config.to_map()
        if self.incr_transfer_config is not None:
            result['IncrTransferConfig'] = self.incr_transfer_config.to_map()
        if self.label_ids is not None:
            result['LabelIds'] = self.label_ids
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.sink_endpoint_id is not None:
            result['SinkEndpointId'] = self.sink_endpoint_id
        if self.source_endpoint_id is not None:
            result['SourceEndpointId'] = self.source_endpoint_id
        if self.struct_transfer_config is not None:
            result['StructTransferConfig'] = self.struct_transfer_config.to_map()
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.use_oss is not None:
            result['UseOss'] = self.use_oss
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommonTransferConfig') is not None:
            temp_model = CreateProjectRequestCommonTransferConfig()
            self.common_transfer_config = temp_model.from_map(m['CommonTransferConfig'])
        if m.get('EnableFullTransfer') is not None:
            self.enable_full_transfer = m.get('EnableFullTransfer')
        if m.get('EnableFullVerify') is not None:
            self.enable_full_verify = m.get('EnableFullVerify')
        if m.get('EnableIncrTransfer') is not None:
            self.enable_incr_transfer = m.get('EnableIncrTransfer')
        if m.get('EnableReverseIncrTransfer') is not None:
            self.enable_reverse_incr_transfer = m.get('EnableReverseIncrTransfer')
        if m.get('EnableStructTransfer') is not None:
            self.enable_struct_transfer = m.get('EnableStructTransfer')
        if m.get('FullTransferConfig') is not None:
            temp_model = CreateProjectRequestFullTransferConfig()
            self.full_transfer_config = temp_model.from_map(m['FullTransferConfig'])
        if m.get('IncrTransferConfig') is not None:
            temp_model = CreateProjectRequestIncrTransferConfig()
            self.incr_transfer_config = temp_model.from_map(m['IncrTransferConfig'])
        if m.get('LabelIds') is not None:
            self.label_ids = m.get('LabelIds')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('SinkEndpointId') is not None:
            self.sink_endpoint_id = m.get('SinkEndpointId')
        if m.get('SourceEndpointId') is not None:
            self.source_endpoint_id = m.get('SourceEndpointId')
        if m.get('StructTransferConfig') is not None:
            temp_model = CreateProjectRequestStructTransferConfig()
            self.struct_transfer_config = temp_model.from_map(m['StructTransferConfig'])
        if m.get('TransferMapping') is not None:
            temp_model = CreateProjectRequestTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UseOss') is not None:
            self.use_oss = m.get('UseOss')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class CreateProjectShrinkRequest(TeaModel):
    def __init__(self, common_transfer_config_shrink=None, enable_full_transfer=None, enable_full_verify=None,
                 enable_incr_transfer=None, enable_reverse_incr_transfer=None, enable_struct_transfer=None,
                 full_transfer_config_shrink=None, incr_transfer_config_shrink=None, label_ids_shrink=None, name=None, oss_key=None,
                 sink_endpoint_id=None, source_endpoint_id=None, struct_transfer_config_shrink=None, transfer_mapping_shrink=None,
                 type=None, use_oss=None, worker_grade_id=None):
        self.common_transfer_config_shrink = common_transfer_config_shrink  # type: str
        self.enable_full_transfer = enable_full_transfer  # type: bool
        self.enable_full_verify = enable_full_verify  # type: bool
        self.enable_incr_transfer = enable_incr_transfer  # type: bool
        self.enable_reverse_incr_transfer = enable_reverse_incr_transfer  # type: bool
        self.enable_struct_transfer = enable_struct_transfer  # type: bool
        self.full_transfer_config_shrink = full_transfer_config_shrink  # type: str
        self.incr_transfer_config_shrink = incr_transfer_config_shrink  # type: str
        self.label_ids_shrink = label_ids_shrink  # type: str
        self.name = name  # type: str
        self.oss_key = oss_key  # type: str
        self.sink_endpoint_id = sink_endpoint_id  # type: str
        self.source_endpoint_id = source_endpoint_id  # type: str
        self.struct_transfer_config_shrink = struct_transfer_config_shrink  # type: str
        self.transfer_mapping_shrink = transfer_mapping_shrink  # type: str
        self.type = type  # type: str
        self.use_oss = use_oss  # type: bool
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_transfer_config_shrink is not None:
            result['CommonTransferConfig'] = self.common_transfer_config_shrink
        if self.enable_full_transfer is not None:
            result['EnableFullTransfer'] = self.enable_full_transfer
        if self.enable_full_verify is not None:
            result['EnableFullVerify'] = self.enable_full_verify
        if self.enable_incr_transfer is not None:
            result['EnableIncrTransfer'] = self.enable_incr_transfer
        if self.enable_reverse_incr_transfer is not None:
            result['EnableReverseIncrTransfer'] = self.enable_reverse_incr_transfer
        if self.enable_struct_transfer is not None:
            result['EnableStructTransfer'] = self.enable_struct_transfer
        if self.full_transfer_config_shrink is not None:
            result['FullTransferConfig'] = self.full_transfer_config_shrink
        if self.incr_transfer_config_shrink is not None:
            result['IncrTransferConfig'] = self.incr_transfer_config_shrink
        if self.label_ids_shrink is not None:
            result['LabelIds'] = self.label_ids_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.sink_endpoint_id is not None:
            result['SinkEndpointId'] = self.sink_endpoint_id
        if self.source_endpoint_id is not None:
            result['SourceEndpointId'] = self.source_endpoint_id
        if self.struct_transfer_config_shrink is not None:
            result['StructTransferConfig'] = self.struct_transfer_config_shrink
        if self.transfer_mapping_shrink is not None:
            result['TransferMapping'] = self.transfer_mapping_shrink
        if self.type is not None:
            result['Type'] = self.type
        if self.use_oss is not None:
            result['UseOss'] = self.use_oss
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommonTransferConfig') is not None:
            self.common_transfer_config_shrink = m.get('CommonTransferConfig')
        if m.get('EnableFullTransfer') is not None:
            self.enable_full_transfer = m.get('EnableFullTransfer')
        if m.get('EnableFullVerify') is not None:
            self.enable_full_verify = m.get('EnableFullVerify')
        if m.get('EnableIncrTransfer') is not None:
            self.enable_incr_transfer = m.get('EnableIncrTransfer')
        if m.get('EnableReverseIncrTransfer') is not None:
            self.enable_reverse_incr_transfer = m.get('EnableReverseIncrTransfer')
        if m.get('EnableStructTransfer') is not None:
            self.enable_struct_transfer = m.get('EnableStructTransfer')
        if m.get('FullTransferConfig') is not None:
            self.full_transfer_config_shrink = m.get('FullTransferConfig')
        if m.get('IncrTransferConfig') is not None:
            self.incr_transfer_config_shrink = m.get('IncrTransferConfig')
        if m.get('LabelIds') is not None:
            self.label_ids_shrink = m.get('LabelIds')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('SinkEndpointId') is not None:
            self.sink_endpoint_id = m.get('SinkEndpointId')
        if m.get('SourceEndpointId') is not None:
            self.source_endpoint_id = m.get('SourceEndpointId')
        if m.get('StructTransferConfig') is not None:
            self.struct_transfer_config_shrink = m.get('StructTransferConfig')
        if m.get('TransferMapping') is not None:
            self.transfer_mapping_shrink = m.get('TransferMapping')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UseOss') is not None:
            self.use_oss = m.get('UseOss')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class CreateProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class CreateProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: CreateProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(CreateProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = CreateProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSecurityIpGroupRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The name of the whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The return result of the request.
        self.security_ips = security_ips  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSecurityIpGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        return self


class CreateSecurityIpGroupResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None):
        # ```
        # http(s)://[Endpoint]/?Action=CreateSecurityIpGroup
        # &InstanceId=ob317v4uif****\
        # &SecurityIps=192.168.1.1,192.168.0.0.1/8
        # &SecurityIpGroupName=pay_online
        # &Common request parameters
        # ```
        self.instance_id = instance_id  # type: str
        # You can call this operation to create an IP address whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        self.security_ips = security_ips  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSecurityIpGroupResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        return self


class CreateSecurityIpGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # The IP addresses or CIDR blocks in the IP address whitelist group.   
        # The return values of SecurityIps are strings that are separated with commas (,).
        self.request_id = request_id  # type: str
        # The operation that you want to perform.   
        # Set the value to **CreateSecurityIpGroup**.
        self.security_ip_group = security_ip_group  # type: CreateSecurityIpGroupResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(CreateSecurityIpGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = CreateSecurityIpGroupResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class CreateSecurityIpGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSecurityIpGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSecurityIpGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSecurityIpGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTenantRequest(TeaModel):
    def __init__(self, charset=None, cpu=None, description=None, instance_id=None, log_disk=None, memory=None,
                 primary_zone=None, read_only_zone_list=None, tenant_mode=None, tenant_name=None, time_zone=None, unit_num=None,
                 user_vswitch_id=None, user_vpc_id=None):
        # The character set.    
        # For more information, see DescribeCharset.
        self.charset = charset  # type: str
        # The number of CPU cores of the tenant.   
        # 
        # > <br>The CPU specification of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the CPU specification of the tenant cannot exceed 14 cores.
        self.cpu = cpu  # type: int
        # The description of the database.
        self.description = description  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        self.log_disk = log_disk  # type: long
        # The memory size of the tenant, in GB.   
        # 
        # > <br>The memory size of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the memory size of the tenant cannot exceed 70 GB.
        self.memory = memory  # type: int
        # The primary zone of the tenant.    
        # It is one of the zones in which the cluster is deployed.
        self.primary_zone = primary_zone  # type: str
        self.read_only_zone_list = read_only_zone_list  # type: str
        # The tenant mode.    
        # Valid values: Oracle and MySQL.   
        # For more information, see [DescribeInstanceTenantModes](~~410354~~).
        self.tenant_mode = tenant_mode  # type: str
        # The name of the tenant.    
        # It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
        self.tenant_name = tenant_name  # type: str
        # The time zone of the tenant. For more information, see [DescribeTimeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describetimezones).
        self.time_zone = time_zone  # type: str
        # The number of resource distribution nodes in the tenant.    
        # The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
        self.unit_num = unit_num  # type: int
        # The ID of the vSwitch.    
        # If no suitable vSwitch is available, create a vSwitch as prompted.   
        # For more information, see Use a vSwitch.
        self.user_vswitch_id = user_vswitch_id  # type: str
        # The ID of the VPC.   
        #  If no suitable VPC is available, create a VPC as prompted.   
        # For more information, see "What is a VPC".
        self.user_vpc_id = user_vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.log_disk is not None:
            result['LogDisk'] = self.log_disk
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.primary_zone is not None:
            result['PrimaryZone'] = self.primary_zone
        if self.read_only_zone_list is not None:
            result['ReadOnlyZoneList'] = self.read_only_zone_list
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        if self.user_vswitch_id is not None:
            result['UserVSwitchId'] = self.user_vswitch_id
        if self.user_vpc_id is not None:
            result['UserVpcId'] = self.user_vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LogDisk') is not None:
            self.log_disk = m.get('LogDisk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('PrimaryZone') is not None:
            self.primary_zone = m.get('PrimaryZone')
        if m.get('ReadOnlyZoneList') is not None:
            self.read_only_zone_list = m.get('ReadOnlyZoneList')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        if m.get('UserVSwitchId') is not None:
            self.user_vswitch_id = m.get('UserVSwitchId')
        if m.get('UserVpcId') is not None:
            self.user_vpc_id = m.get('UserVpcId')
        return self


class CreateTenantResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_id=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class CreateTenantResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTenantResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTenantResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTenantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTenantReadOnlyConnectionRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None, v_switch_id=None, vpc_id=None, zone_id=None):
        self.instance_id = instance_id  # type: str
        self.tenant_id = tenant_id  # type: str
        self.v_switch_id = v_switch_id  # type: str
        self.vpc_id = vpc_id  # type: str
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantReadOnlyConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateTenantReadOnlyConnectionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantReadOnlyConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateTenantReadOnlyConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTenantReadOnlyConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTenantReadOnlyConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTenantReadOnlyConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTenantSecurityIpGroupRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The group name of the whitelist group of IP addresses.
        # 
        # It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The list of IP addresses in the whitelist group.
        # 
        # It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
        self.security_ips = security_ips  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantSecurityIpGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class CreateTenantSecurityIpGroupResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The name of the whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The list of IP addresses in the IP address whitelist group.   
        # 
        # It is a string separated by commas, and each object is an IP address or CIDR block.
        self.security_ips = security_ips  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantSecurityIpGroupResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class CreateTenantSecurityIpGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The information of the whitelist group.
        self.security_ip_group = security_ip_group  # type: CreateTenantSecurityIpGroupResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(CreateTenantSecurityIpGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = CreateTenantSecurityIpGroupResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class CreateTenantSecurityIpGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTenantSecurityIpGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTenantSecurityIpGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTenantSecurityIpGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTenantUserRequest(TeaModel):
    def __init__(self, description=None, encryption_type=None, instance_id=None, roles=None, tenant_id=None,
                 user_name=None, user_password=None, user_type=None):
        # The description of the database.
        self.description = description  # type: str
        # 加密方式。
        self.encryption_type = encryption_type  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The role of the user account.  In Oracle mode, this parameter unspecified is left unspecified.  In MySQL mode, the super administrator account has ALL PRIVILEGES, and you can leave this parameter unspecified.  You need to specify the account information for a general user account. By default, the account information is a JSON array that contains the information of the role and the schema (Oracle mode) or database (MySQL mode).  Valid values: ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES. ReadOnly: a role that has only the read-only privilege SELECT. DDL: a role that has DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW. DML: a role that has DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
        self.roles = roles  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # The name of the database account.  You cannot use reserved keywords, such as SYS and root.
        self.user_name = user_name  # type: str
        # The password of the database account.  It must be 10 to 32 characters in length and contain three types of the following characters: uppercase letters, lowercase letters, digits, and special characters. The special characters are ! @ # $ % \ ^ \ & \ * ( ) _ + - =\
        self.user_password = user_password  # type: str
        # The type of the database account. Valid values: Admin: the super administrator account. Normal: a general account.
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.encryption_type is not None:
            result['EncryptionType'] = self.encryption_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_password is not None:
            result['UserPassword'] = self.user_password
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EncryptionType') is not None:
            self.encryption_type = m.get('EncryptionType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserPassword') is not None:
            self.user_password = m.get('UserPassword')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class CreateTenantUserResponseBodyTenantUserRoles(TeaModel):
    def __init__(self, database=None, role=None):
        self.database = database  # type: str
        self.role = role  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateTenantUserResponseBodyTenantUserRoles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class CreateTenantUserResponseBodyTenantUser(TeaModel):
    def __init__(self, roles=None, user_name=None, user_status=None, user_type=None):
        self.roles = roles  # type: list[CreateTenantUserResponseBodyTenantUserRoles]
        self.user_name = user_name  # type: str
        self.user_status = user_status  # type: str
        self.user_type = user_type  # type: str

    def validate(self):
        if self.roles:
            for k in self.roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateTenantUserResponseBodyTenantUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Roles'] = []
        if self.roles is not None:
            for k in self.roles:
                result['Roles'].append(k.to_map() if k else None)
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.roles = []
        if m.get('Roles') is not None:
            for k in m.get('Roles'):
                temp_model = CreateTenantUserResponseBodyTenantUserRoles()
                self.roles.append(temp_model.from_map(k))
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class CreateTenantUserResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_user=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The list of database accounts in the tenant.
        self.tenant_user = tenant_user  # type: CreateTenantUserResponseBodyTenantUser

    def validate(self):
        if self.tenant_user:
            self.tenant_user.validate()

    def to_map(self):
        _map = super(CreateTenantUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_user is not None:
            result['TenantUser'] = self.tenant_user.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantUser') is not None:
            temp_model = CreateTenantUserResponseBodyTenantUser()
            self.tenant_user = temp_model.from_map(m['TenantUser'])
        return self


class CreateTenantUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateTenantUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateTenantUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTenantUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDatabasesRequest(TeaModel):
    def __init__(self, database_names=None, instance_id=None, tenant_id=None):
        self.database_names = database_names  # type: str
        self.instance_id = instance_id  # type: str
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDatabasesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_names is not None:
            result['DatabaseNames'] = self.database_names
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseNames') is not None:
            self.database_names = m.get('DatabaseNames')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DeleteDatabasesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDatabasesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDatabasesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDatabasesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDatabasesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstancesRequest(TeaModel):
    def __init__(self, backup_retain_mode=None, dry_run=None, instance_ids=None):
        self.backup_retain_mode = backup_retain_mode  # type: str
        self.dry_run = dry_run  # type: bool
        self.instance_ids = instance_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_retain_mode is not None:
            result['BackupRetainMode'] = self.backup_retain_mode
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupRetainMode') is not None:
            self.backup_retain_mode = m.get('BackupRetainMode')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class DeleteInstancesResponseBodyData(TeaModel):
    def __init__(self, dry_run_result=None):
        self.dry_run_result = dry_run_result  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstancesResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run_result is not None:
            result['DryRunResult'] = self.dry_run_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRunResult') is not None:
            self.dry_run_result = m.get('DryRunResult')
        return self


class DeleteInstancesResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: DeleteInstancesResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DeleteInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DeleteInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The total count, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # Contact the administrator.
        self.page_size = page_size  # type: int
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.project_id = project_id  # type: str
        # Indicates whether the call is successful.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class DeleteOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The operation that you want to perform. Set the value to **DeleteOmsOpenAPIProject**.
        self.code = code  # type: str
        # The error description (old).
        self.level = level  # type: str
        # The error code (new).
        self.message = message  # type: str
        # The page number, which takes effect in a pagination query.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class DeleteOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # You can call this operation to delete a data synchronization project.
        self.advice = advice  # type: str
        # Indicates whether the project has been deleted.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # The suggestions (new).
        self.error_detail = error_detail  # type: DeleteOmsOpenAPIProjectResponseBodyErrorDetail
        # A system error occurred.
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        # The page number, which takes effect in a pagination query.
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DeleteOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = DeleteOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DeleteOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DeleteProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: any
        self.error_detail = error_detail  # type: DeleteProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DeleteProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = DeleteProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DeleteProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecurityIpGroupRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None):
        # The name of the IP address whitelist group.    
        # It must be 2 to 32 characters in length, start with a lowercase letter, end with a lowercase letter or digit, and contain only lowercase letters, digits, and underscores (_).
        self.instance_id = instance_id  # type: str
        # The information of the deleted IP whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityIpGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        return self


class DeleteSecurityIpGroupResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None):
        self.instance_id = instance_id  # type: str
        self.security_ip_group_name = security_ip_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityIpGroupResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        return self


class DeleteSecurityIpGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # Example 1
        self.request_id = request_id  # type: str
        self.security_ip_group = security_ip_group  # type: DeleteSecurityIpGroupResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(DeleteSecurityIpGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = DeleteSecurityIpGroupResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class DeleteSecurityIpGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSecurityIpGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSecurityIpGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecurityIpGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTenantSecurityIpGroupRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The group name of the whitelist group of IP addresses.
        # 
        # It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantSecurityIpGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The name of the whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DeleteTenantSecurityIpGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The information of the whitelist group.
        self.security_ip_group = security_ip_group  # type: DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(DeleteTenantSecurityIpGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class DeleteTenantSecurityIpGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTenantSecurityIpGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTenantSecurityIpGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTenantSecurityIpGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTenantUsersRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None, users=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # A list of usernames.
        self.users = users  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class DeleteTenantUsersResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTenantUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTenantUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTenantUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTenantUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTenantsRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_ids=None):
        # You can call this operation to delete one or more tenants from an OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DeleteTenants
        # &TenantIds=["ob2mr3oae0****", "ob2mr3oae1****"]
        # &InstanceId=ob317v4uif****\
        # &Common request parameters
        # ```
        self.tenant_ids = tenant_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_ids is not None:
            result['TenantIds'] = self.tenant_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantIds') is not None:
            self.tenant_ids = m.get('TenantIds')
        return self


class DeleteTenantsResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_ids=None):
        self.request_id = request_id  # type: str
        self.tenant_ids = tenant_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTenantsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_ids is not None:
            result['TenantIds'] = self.tenant_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantIds') is not None:
            self.tenant_ids = m.get('TenantIds')
        return self


class DeleteTenantsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTenantsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTenantsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTenantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAnomalySQLListRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, end_time=None, filter_condition=None, instance_id=None,
                 node_ip=None, page_number=None, page_size=None, sqlid=None, search_key_word=None, search_parameter=None,
                 search_rule=None, search_value=None, sort_column=None, sort_order=None, start_time=None, tenant_id=None):
        # The language of the returned data.   
        # Default value: CN for a China site and EN for an International site.
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        # The end time of the time range for querying suspicious SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The filter condition.   
        # > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
        self.filter_condition = filter_condition  # type: dict[str, any]
        self.instance_id = instance_id  # type: str
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_number = page_number  # type: int
        # The number of rows to return on each page.    
        # - Maximum value: 100   
        # - Default value: 10
        self.page_size = page_size  # type: int
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_parameter = search_parameter  # type: str
        # The search rule.   
        # Valid values: "=", ">", ">=", "<", and "<="
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # The sorted column.
        self.sort_column = sort_column  # type: str
        # The sorting rule.
        self.sort_order = sort_order  # type: str
        # The start time of the time range for querying suspicious SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAnomalySQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeAnomalySQLListShrinkRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, end_time=None, filter_condition_shrink=None,
                 instance_id=None, node_ip=None, page_number=None, page_size=None, sqlid=None, search_key_word=None,
                 search_parameter=None, search_rule=None, search_value=None, sort_column=None, sort_order=None, start_time=None,
                 tenant_id=None):
        # The language of the returned data.   
        # Default value: CN for a China site and EN for an International site.
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        # The end time of the time range for querying suspicious SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The filter condition.   
        # > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
        self.filter_condition_shrink = filter_condition_shrink  # type: str
        self.instance_id = instance_id  # type: str
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_number = page_number  # type: int
        # The number of rows to return on each page.    
        # - Maximum value: 100   
        # - Default value: 10
        self.page_size = page_size  # type: int
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_parameter = search_parameter  # type: str
        # The search rule.   
        # Valid values: "=", ">", ">=", "<", and "<="
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # The sorted column.
        self.sort_column = sort_column  # type: str
        # The sorting rule.
        self.sort_order = sort_order  # type: str
        # The start time of the time range for querying suspicious SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAnomalySQLListShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition_shrink is not None:
            result['FilterCondition'] = self.filter_condition_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition_shrink = m.get('FilterCondition')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeAnomalySQLListResponseBodyAnomalySQLList(TeaModel):
    def __init__(self, cpu_time=None, db_name=None, diagnosis=None, diagnosis_rule=None, executions=None, key=None,
                 request_time=None, request_time_utcstring=None, sqlid=None, sqltext=None, suggestion=None, user_name=None):
        # The average CPU time, in ms.
        self.cpu_time = cpu_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # The diagnosis information.
        self.diagnosis = diagnosis  # type: str
        # The diagnostic rule.
        self.diagnosis_rule = diagnosis_rule  # type: str
        # The number of executions.
        self.executions = executions  # type: long
        # The sequence number of the returned SQL statement.
        self.key = key  # type: long
        # The request time, in ms.
        self.request_time = request_time  # type: float
        # The request time in UTC +0.
        self.request_time_utcstring = request_time_utcstring  # type: str
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The SQL text.
        self.sqltext = sqltext  # type: str
        # The suggestions.
        self.suggestion = suggestion  # type: str
        # The username.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAnomalySQLListResponseBodyAnomalySQLList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.diagnosis is not None:
            result['Diagnosis'] = self.diagnosis
        if self.diagnosis_rule is not None:
            result['DiagnosisRule'] = self.diagnosis_rule
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.key is not None:
            result['Key'] = self.key
        if self.request_time is not None:
            result['RequestTime'] = self.request_time
        if self.request_time_utcstring is not None:
            result['RequestTimeUTCString'] = self.request_time_utcstring
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqltext is not None:
            result['SQLText'] = self.sqltext
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Diagnosis') is not None:
            self.diagnosis = m.get('Diagnosis')
        if m.get('DiagnosisRule') is not None:
            self.diagnosis_rule = m.get('DiagnosisRule')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('RequestTime') is not None:
            self.request_time = m.get('RequestTime')
        if m.get('RequestTimeUTCString') is not None:
            self.request_time_utcstring = m.get('RequestTimeUTCString')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLText') is not None:
            self.sqltext = m.get('SQLText')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeAnomalySQLListResponseBody(TeaModel):
    def __init__(self, anomaly_sqllist=None, request_id=None, total_count=None):
        # The list of suspicious SQL statements.
        self.anomaly_sqllist = anomaly_sqllist  # type: list[DescribeAnomalySQLListResponseBodyAnomalySQLList]
        # The request ID.
        self.request_id = request_id  # type: str
        # The total count.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.anomaly_sqllist:
            for k in self.anomaly_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAnomalySQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnomalySQLList'] = []
        if self.anomaly_sqllist is not None:
            for k in self.anomaly_sqllist:
                result['AnomalySQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.anomaly_sqllist = []
        if m.get('AnomalySQLList') is not None:
            for k in m.get('AnomalySQLList'):
                temp_model = DescribeAnomalySQLListResponseBodyAnomalySQLList()
                self.anomaly_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAnomalySQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAnomalySQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAnomalySQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAnomalySQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableCpuResourceRequest(TeaModel):
    def __init__(self, instance_id=None, modify_type=None, tenant_id=None):
        # The CPU resources available.
        self.instance_id = instance_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DescribeAvailableCpuResource
        # &InstanceId=ob317v4uif****\
        # &TenantId=ob2mr3oae0****\
        # &ModifyType=update
        # &Common request parameters
        # ```
        self.modify_type = modify_type  # type: str
        # The operation that you want to perform.   
        # Set the value to **DescribeAvailableCpuResource**.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableCpuResourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.modify_type is not None:
            result['ModifyType'] = self.modify_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModifyType') is not None:
            self.modify_type = m.get('ModifyType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeAvailableCpuResourceResponseBodyData(TeaModel):
    def __init__(self, max_cpu=None, min_cpu=None, unit_num=None):
        self.max_cpu = max_cpu  # type: long
        self.min_cpu = min_cpu  # type: long
        self.unit_num = unit_num  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableCpuResourceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_cpu is not None:
            result['MaxCpu'] = self.max_cpu
        if self.min_cpu is not None:
            result['MinCpu'] = self.min_cpu
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCpu') is not None:
            self.max_cpu = m.get('MaxCpu')
        if m.get('MinCpu') is not None:
            self.min_cpu = m.get('MinCpu')
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        return self


class DescribeAvailableCpuResourceResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeAvailableCpuResourceResponseBodyData]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableCpuResourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeAvailableCpuResourceResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAvailableCpuResourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAvailableCpuResourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAvailableCpuResourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableCpuResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableMemResourceRequest(TeaModel):
    def __init__(self, cpu_num=None, instance_id=None, tenant_id=None, unit_num=None):
        # The available memory size.
        self.cpu_num = cpu_num  # type: long
        # The ID of the region.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # The number of resource units in the tenant.
        self.unit_num = unit_num  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableMemResourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_num is not None:
            result['CpuNum'] = self.cpu_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuNum') is not None:
            self.cpu_num = m.get('CpuNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        return self


class DescribeAvailableMemResourceResponseBodyData(TeaModel):
    def __init__(self, max_mem=None, min_mem=None, safe_mem=None, used_mem=None):
        self.max_mem = max_mem  # type: long
        # You can call this operation to query the available memory resource of an OceanBase Database tenant.
        self.min_mem = min_mem  # type: long
        self.safe_mem = safe_mem  # type: str
        self.used_mem = used_mem  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableMemResourceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_mem is not None:
            result['MaxMem'] = self.max_mem
        if self.min_mem is not None:
            result['MinMem'] = self.min_mem
        if self.safe_mem is not None:
            result['SafeMem'] = self.safe_mem
        if self.used_mem is not None:
            result['UsedMem'] = self.used_mem
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxMem') is not None:
            self.max_mem = m.get('MaxMem')
        if m.get('MinMem') is not None:
            self.min_mem = m.get('MinMem')
        if m.get('SafeMem') is not None:
            self.safe_mem = m.get('SafeMem')
        if m.get('UsedMem') is not None:
            self.used_mem = m.get('UsedMem')
        return self


class DescribeAvailableMemResourceResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # ```
        # http(s)://[Endpoint]/?Action=DescribeAvailableMemResource
        # &InstanceId=ob317v4uif****\
        # &TenantId=ob2mr3oae0****\
        # &UnitNum=2
        # &CpuNum=14
        # &Common request parameters
        # ```
        self.data = data  # type: DescribeAvailableMemResourceResponseBodyData
        # The number of CPU cores.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeAvailableMemResourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeAvailableMemResourceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAvailableMemResourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAvailableMemResourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAvailableMemResourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableMemResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableSpecRequest(TeaModel):
    def __init__(self, instance_id=None, spec=None, upgrade_type=None):
        self.instance_id = instance_id  # type: str
        self.spec = spec  # type: str
        self.upgrade_type = upgrade_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.upgrade_type is not None:
            result['UpgradeType'] = self.upgrade_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('UpgradeType') is not None:
            self.upgrade_type = m.get('UpgradeType')
        return self


class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange(TeaModel):
    def __init__(self, max=None, min=None, step=None):
        self.max = max  # type: long
        self.min = min  # type: long
        self.step = step  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange(TeaModel):
    def __init__(self, max=None, min=None, step=None):
        self.max = max  # type: long
        self.min = min  # type: long
        self.step = step  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeAvailableSpecResponseBodyDataAvailableSpecifications(TeaModel):
    def __init__(self, disk_size_range=None, disk_types=None, instance_class=None, log_disk_size_range=None,
                 node_num=None, spec=None):
        self.disk_size_range = disk_size_range  # type: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange
        self.disk_types = disk_types  # type: list[str]
        self.instance_class = instance_class  # type: str
        self.log_disk_size_range = log_disk_size_range  # type: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange
        self.node_num = node_num  # type: list[int]
        self.spec = spec  # type: str

    def validate(self):
        if self.disk_size_range:
            self.disk_size_range.validate()
        if self.log_disk_size_range:
            self.log_disk_size_range.validate()

    def to_map(self):
        _map = super(DescribeAvailableSpecResponseBodyDataAvailableSpecifications, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_size_range is not None:
            result['DiskSizeRange'] = self.disk_size_range.to_map()
        if self.disk_types is not None:
            result['DiskTypes'] = self.disk_types
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.log_disk_size_range is not None:
            result['LogDiskSizeRange'] = self.log_disk_size_range.to_map()
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskSizeRange') is not None:
            temp_model = DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange()
            self.disk_size_range = temp_model.from_map(m['DiskSizeRange'])
        if m.get('DiskTypes') is not None:
            self.disk_types = m.get('DiskTypes')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('LogDiskSizeRange') is not None:
            temp_model = DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange()
            self.log_disk_size_range = temp_model.from_map(m['LogDiskSizeRange'])
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class DescribeAvailableSpecResponseBodyData(TeaModel):
    def __init__(self, available_specifications=None):
        self.available_specifications = available_specifications  # type: list[DescribeAvailableSpecResponseBodyDataAvailableSpecifications]

    def validate(self):
        if self.available_specifications:
            for k in self.available_specifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableSpecResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableSpecifications'] = []
        if self.available_specifications is not None:
            for k in self.available_specifications:
                result['AvailableSpecifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_specifications = []
        if m.get('AvailableSpecifications') is not None:
            for k in m.get('AvailableSpecifications'):
                temp_model = DescribeAvailableSpecResponseBodyDataAvailableSpecifications()
                self.available_specifications.append(temp_model.from_map(k))
        return self


class DescribeAvailableSpecResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: DescribeAvailableSpecResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeAvailableSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeAvailableSpecResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAvailableSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAvailableSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAvailableSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableZoneRequest(TeaModel):
    def __init__(self, deploy_type=None, instance_type=None, ob_version=None, series=None, spec=None):
        self.deploy_type = deploy_type  # type: str
        self.instance_type = instance_type  # type: str
        self.ob_version = ob_version  # type: str
        self.series = series  # type: str
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableZoneRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.ob_version is not None:
            result['ObVersion'] = self.ob_version
        if self.series is not None:
            result['Series'] = self.series
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('ObVersion') is not None:
            self.ob_version = m.get('ObVersion')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange(TeaModel):
    def __init__(self, max=None, min=None, step=None):
        self.max = max  # type: long
        self.min = min  # type: long
        self.step = step  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions(TeaModel):
    def __init__(self, ob_version=None, support_isolation_optimization=None, support_replica_modes=None):
        self.ob_version = ob_version  # type: str
        self.support_isolation_optimization = support_isolation_optimization  # type: bool
        self.support_replica_modes = support_replica_modes  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ob_version is not None:
            result['ObVersion'] = self.ob_version
        if self.support_isolation_optimization is not None:
            result['SupportIsolationOptimization'] = self.support_isolation_optimization
        if self.support_replica_modes is not None:
            result['SupportReplicaModes'] = self.support_replica_modes
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ObVersion') is not None:
            self.ob_version = m.get('ObVersion')
        if m.get('SupportIsolationOptimization') is not None:
            self.support_isolation_optimization = m.get('SupportIsolationOptimization')
        if m.get('SupportReplicaModes') is not None:
            self.support_replica_modes = m.get('SupportReplicaModes')
        return self


class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications(TeaModel):
    def __init__(self, disk_size_range=None, disk_types=None, instance_class=None, spec=None,
                 support_engine_versions=None):
        self.disk_size_range = disk_size_range  # type: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange
        self.disk_types = disk_types  # type: list[str]
        self.instance_class = instance_class  # type: str
        self.spec = spec  # type: str
        self.support_engine_versions = support_engine_versions  # type: list[DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions]

    def validate(self):
        if self.disk_size_range:
            self.disk_size_range.validate()
        if self.support_engine_versions:
            for k in self.support_engine_versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_size_range is not None:
            result['DiskSizeRange'] = self.disk_size_range.to_map()
        if self.disk_types is not None:
            result['DiskTypes'] = self.disk_types
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.spec is not None:
            result['Spec'] = self.spec
        result['SupportEngineVersions'] = []
        if self.support_engine_versions is not None:
            for k in self.support_engine_versions:
                result['SupportEngineVersions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskSizeRange') is not None:
            temp_model = DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange()
            self.disk_size_range = temp_model.from_map(m['DiskSizeRange'])
        if m.get('DiskTypes') is not None:
            self.disk_types = m.get('DiskTypes')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        self.support_engine_versions = []
        if m.get('SupportEngineVersions') is not None:
            for k in m.get('SupportEngineVersions'):
                temp_model = DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions()
                self.support_engine_versions.append(temp_model.from_map(k))
        return self


class DescribeAvailableZoneResponseBodyDataAvailableZones(TeaModel):
    def __init__(self, channel=None, deploy_type=None, instance_type=None, region=None, series=None,
                 support_specifications=None, zones=None):
        self.channel = channel  # type: str
        self.deploy_type = deploy_type  # type: str
        self.instance_type = instance_type  # type: str
        self.region = region  # type: str
        self.series = series  # type: str
        self.support_specifications = support_specifications  # type: list[DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications]
        self.zones = zones  # type: str

    def validate(self):
        if self.support_specifications:
            for k in self.support_specifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBodyDataAvailableZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.region is not None:
            result['Region'] = self.region
        if self.series is not None:
            result['Series'] = self.series
        result['SupportSpecifications'] = []
        if self.support_specifications is not None:
            for k in self.support_specifications:
                result['SupportSpecifications'].append(k.to_map() if k else None)
        if self.zones is not None:
            result['Zones'] = self.zones
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channel') is not None:
            self.channel = m.get('Channel')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        self.support_specifications = []
        if m.get('SupportSpecifications') is not None:
            for k in m.get('SupportSpecifications'):
                temp_model = DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications()
                self.support_specifications.append(temp_model.from_map(k))
        if m.get('Zones') is not None:
            self.zones = m.get('Zones')
        return self


class DescribeAvailableZoneResponseBodyData(TeaModel):
    def __init__(self, available_zones=None):
        self.available_zones = available_zones  # type: list[DescribeAvailableZoneResponseBodyDataAvailableZones]

    def validate(self):
        if self.available_zones:
            for k in self.available_zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableZones'] = []
        if self.available_zones is not None:
            for k in self.available_zones:
                result['AvailableZones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_zones = []
        if m.get('AvailableZones') is not None:
            for k in m.get('AvailableZones'):
                temp_model = DescribeAvailableZoneResponseBodyDataAvailableZones()
                self.available_zones.append(temp_model.from_map(k))
        return self


class DescribeAvailableZoneResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: DescribeAvailableZoneResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeAvailableZoneResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeAvailableZoneResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAvailableZoneResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAvailableZoneResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAvailableZoneResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableZoneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCharsetRequest(TeaModel):
    def __init__(self, instance_id=None, series=None, tenant_mode=None):
        self.instance_id = instance_id  # type: str
        # 实例的系列  - normal（默认）：标准集群版（云盘）  - normal_ssd：标准集群版（本地盘） - history：历史库集群版。
        self.series = series  # type: str
        # The return result of the request.
        self.tenant_mode = tenant_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCharsetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.series is not None:
            result['Series'] = self.series
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        return self


class DescribeCharsetResponseBodyCharset(TeaModel):
    def __init__(self, charset=None, collations=None):
        # DescribeCharset
        self.charset = charset  # type: str
        self.collations = collations  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCharsetResponseBodyCharset, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.collations is not None:
            result['Collations'] = self.collations
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('Collations') is not None:
            self.collations = m.get('Collations')
        return self


class DescribeCharsetResponseBody(TeaModel):
    def __init__(self, charset=None, request_id=None):
        # ```
        # http(s)://[Endpoint]/?Action=DescribeCharset
        # &TenantMode=Oracle
        # &Common request parameters
        # ```
        self.charset = charset  # type: list[DescribeCharsetResponseBodyCharset]
        # The operation that you want to perform.   
        # Set the value to **DescribeCharset**.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.charset:
            for k in self.charset:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCharsetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Charset'] = []
        if self.charset is not None:
            for k in self.charset:
                result['Charset'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.charset = []
        if m.get('Charset') is not None:
            for k in m.get('Charset'):
                temp_model = DescribeCharsetResponseBodyCharset()
                self.charset.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCharsetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCharsetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCharsetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCharsetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDatabasesRequest(TeaModel):
    def __init__(self, database_name=None, instance_id=None, page_number=None, page_size=None, search_key=None,
                 tenant_id=None, with_tables=None):
        # It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
        self.database_name = database_name  # type: str
        self.instance_id = instance_id  # type: str
        # The return result of the request.
        self.page_number = page_number  # type: int
        # Alibaba Cloud provides SDKs in different languages to help you quickly integrate Alibaba Cloud products and services by using APIs. We recommend that you use an SDK to call APIs. In this way, you do not need to sign for verification.
        self.page_size = page_size  # type: int
        # The information about the database tables.
        self.search_key = search_key  # type: str
        # The request ID.
        self.tenant_id = tenant_id  # type: str
        # The role of the account.    
        # In MySQL mode, a role is a database-level role. Valid values:  
        # - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.  
        # - ReadOnly: a role that has only the read-only privilege SELECT.   
        # - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
        # - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
        self.with_tables = with_tables  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDatabasesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.with_tables is not None:
            result['WithTables'] = self.with_tables
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('WithTables') is not None:
            self.with_tables = m.get('WithTables')
        return self


class DescribeDatabasesResponseBodyDatabasesTables(TeaModel):
    def __init__(self, table_name=None):
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDatabasesResponseBodyDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class DescribeDatabasesResponseBodyDatabasesUsers(TeaModel):
    def __init__(self, privileges=None, role=None, user_name=None, user_type=None):
        self.privileges = privileges  # type: str
        # The request ID.
        self.role = role  # type: str
        # Example 1
        self.user_name = user_name  # type: str
        # The type of the account. Valid values:  - Admin: the super administrator account. - Normal: a general account.
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDatabasesResponseBodyDatabasesUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.privileges is not None:
            result['Privileges'] = self.privileges
        if self.role is not None:
            result['Role'] = self.role
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Privileges') is not None:
            self.privileges = m.get('Privileges')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeDatabasesResponseBodyDatabases(TeaModel):
    def __init__(self, collation=None, create_time=None, data_size=None, database_name=None, db_type=None,
                 description=None, encoding=None, instance_id=None, required_size=None, status=None, tables=None, tenant_id=None,
                 tenant_name=None, users=None):
        self.collation = collation  # type: str
        # Specifies whether to return the information of tables in the database.   
        # Default value: false.
        self.create_time = create_time  # type: str
        self.data_size = data_size  # type: float
        # The number of the page to return.   
        # - Start value: 1   
        # - Default value: 1
        self.database_name = database_name  # type: str
        # The return result of the request.
        self.db_type = db_type  # type: str
        # The name of the database.
        self.description = description  # type: str
        # The status of the database. Valid values:    
        # - ONLINE: The database is running.  
        # - DELETING: The database is being deleted.
        self.encoding = encoding  # type: str
        self.instance_id = instance_id  # type: str
        self.required_size = required_size  # type: float
        # The list of databases in the tenant.
        self.status = status  # type: str
        self.tables = tables  # type: list[DescribeDatabasesResponseBodyDatabasesTables]
        self.tenant_id = tenant_id  # type: str
        self.tenant_name = tenant_name  # type: str
        # The name of the database table.
        self.users = users  # type: list[DescribeDatabasesResponseBodyDatabasesUsers]

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDatabasesResponseBodyDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.collation is not None:
            result['Collation'] = self.collation
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_size is not None:
            result['DataSize'] = self.data_size
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.required_size is not None:
            result['RequiredSize'] = self.required_size
        if self.status is not None:
            result['Status'] = self.status
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Collation') is not None:
            self.collation = m.get('Collation')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSize') is not None:
            self.data_size = m.get('DataSize')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequiredSize') is not None:
            self.required_size = m.get('RequiredSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = DescribeDatabasesResponseBodyDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = DescribeDatabasesResponseBodyDatabasesUsers()
                self.users.append(temp_model.from_map(k))
        return self


class DescribeDatabasesResponseBody(TeaModel):
    def __init__(self, databases=None, request_id=None, total_count=None):
        # The ID of the tenant.
        self.databases = databases  # type: list[DescribeDatabasesResponseBodyDatabases]
        self.request_id = request_id  # type: str
        # The search keyword.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDatabasesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = DescribeDatabasesResponseBodyDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDatabasesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDatabasesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDatabasesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceRequest(TeaModel):
    def __init__(self, instance_id=None, page_number=None):
        # The size of the data disk, in GB.
        self.instance_id = instance_id  # type: str
        # The information about the storage resources of the cluster.
        self.page_number = page_number  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        return self


class DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig(TeaModel):
    def __init__(self, auto_scale=None, max_disk_size=None, scale_step_in_merge=None, scale_step_in_normal=None,
                 upper_merge_threshold=None, upper_threshold=None, upperbound=None):
        self.auto_scale = auto_scale  # type: bool
        self.max_disk_size = max_disk_size  # type: long
        self.scale_step_in_merge = scale_step_in_merge  # type: long
        self.scale_step_in_normal = scale_step_in_normal  # type: long
        self.upper_merge_threshold = upper_merge_threshold  # type: long
        self.upper_threshold = upper_threshold  # type: long
        self.upperbound = upperbound  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_scale is not None:
            result['AutoScale'] = self.auto_scale
        if self.max_disk_size is not None:
            result['MaxDiskSize'] = self.max_disk_size
        if self.scale_step_in_merge is not None:
            result['ScaleStepInMerge'] = self.scale_step_in_merge
        if self.scale_step_in_normal is not None:
            result['ScaleStepInNormal'] = self.scale_step_in_normal
        if self.upper_merge_threshold is not None:
            result['UpperMergeThreshold'] = self.upper_merge_threshold
        if self.upper_threshold is not None:
            result['UpperThreshold'] = self.upper_threshold
        if self.upperbound is not None:
            result['Upperbound'] = self.upperbound
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoScale') is not None:
            self.auto_scale = m.get('AutoScale')
        if m.get('MaxDiskSize') is not None:
            self.max_disk_size = m.get('MaxDiskSize')
        if m.get('ScaleStepInMerge') is not None:
            self.scale_step_in_merge = m.get('ScaleStepInMerge')
        if m.get('ScaleStepInNormal') is not None:
            self.scale_step_in_normal = m.get('ScaleStepInNormal')
        if m.get('UpperMergeThreshold') is not None:
            self.upper_merge_threshold = m.get('UpperMergeThreshold')
        if m.get('UpperThreshold') is not None:
            self.upper_threshold = m.get('UpperThreshold')
        if m.get('Upperbound') is not None:
            self.upperbound = m.get('Upperbound')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit(TeaModel):
    def __init__(self, max_capacity_unit=None, min_capacity_unit=None, used_capacity_unit=None):
        self.max_capacity_unit = max_capacity_unit  # type: int
        self.min_capacity_unit = min_capacity_unit  # type: int
        self.used_capacity_unit = used_capacity_unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity_unit is not None:
            result['MaxCapacityUnit'] = self.max_capacity_unit
        if self.min_capacity_unit is not None:
            result['MinCapacityUnit'] = self.min_capacity_unit
        if self.used_capacity_unit is not None:
            result['UsedCapacityUnit'] = self.used_capacity_unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCapacityUnit') is not None:
            self.max_capacity_unit = m.get('MaxCapacityUnit')
        if m.get('MinCapacityUnit') is not None:
            self.min_capacity_unit = m.get('MinCapacityUnit')
        if m.get('UsedCapacityUnit') is not None:
            self.used_capacity_unit = m.get('UsedCapacityUnit')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu(TeaModel):
    def __init__(self, original_total_cpu=None, total_cpu=None, unit_cpu=None, used_cpu=None):
        self.original_total_cpu = original_total_cpu  # type: long
        self.total_cpu = total_cpu  # type: long
        self.unit_cpu = unit_cpu  # type: long
        self.used_cpu = used_cpu  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_cpu is not None:
            result['OriginalTotalCpu'] = self.original_total_cpu
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalCpu') is not None:
            self.original_total_cpu = m.get('OriginalTotalCpu')
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize(TeaModel):
    def __init__(self, data_used_size=None, max_disk_size=None, max_disk_used_ob_server=None,
                 max_disk_used_percent=None, original_total_disk_size=None, total_disk_size=None, unit_disk_size=None,
                 used_disk_size=None):
        self.data_used_size = data_used_size  # type: float
        self.max_disk_size = max_disk_size  # type: float
        self.max_disk_used_ob_server = max_disk_used_ob_server  # type: list[str]
        self.max_disk_used_percent = max_disk_used_percent  # type: float
        self.original_total_disk_size = original_total_disk_size  # type: long
        self.total_disk_size = total_disk_size  # type: long
        self.unit_disk_size = unit_disk_size  # type: long
        self.used_disk_size = used_disk_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_used_size is not None:
            result['DataUsedSize'] = self.data_used_size
        if self.max_disk_size is not None:
            result['MaxDiskSize'] = self.max_disk_size
        if self.max_disk_used_ob_server is not None:
            result['MaxDiskUsedObServer'] = self.max_disk_used_ob_server
        if self.max_disk_used_percent is not None:
            result['MaxDiskUsedPercent'] = self.max_disk_used_percent
        if self.original_total_disk_size is not None:
            result['OriginalTotalDiskSize'] = self.original_total_disk_size
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.unit_disk_size is not None:
            result['UnitDiskSize'] = self.unit_disk_size
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataUsedSize') is not None:
            self.data_used_size = m.get('DataUsedSize')
        if m.get('MaxDiskSize') is not None:
            self.max_disk_size = m.get('MaxDiskSize')
        if m.get('MaxDiskUsedObServer') is not None:
            self.max_disk_used_ob_server = m.get('MaxDiskUsedObServer')
        if m.get('MaxDiskUsedPercent') is not None:
            self.max_disk_used_percent = m.get('MaxDiskUsedPercent')
        if m.get('OriginalTotalDiskSize') is not None:
            self.original_total_disk_size = m.get('OriginalTotalDiskSize')
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UnitDiskSize') is not None:
            self.unit_disk_size = m.get('UnitDiskSize')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize(TeaModel):
    def __init__(self, log_assigned_size=None, max_log_assigned_ob_server=None, max_log_assigned_percent=None,
                 total_disk_size=None, unit_disk_size=None):
        self.log_assigned_size = log_assigned_size  # type: str
        self.max_log_assigned_ob_server = max_log_assigned_ob_server  # type: list[str]
        self.max_log_assigned_percent = max_log_assigned_percent  # type: str
        self.total_disk_size = total_disk_size  # type: long
        self.unit_disk_size = unit_disk_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_assigned_size is not None:
            result['LogAssignedSize'] = self.log_assigned_size
        if self.max_log_assigned_ob_server is not None:
            result['MaxLogAssignedObServer'] = self.max_log_assigned_ob_server
        if self.max_log_assigned_percent is not None:
            result['MaxLogAssignedPercent'] = self.max_log_assigned_percent
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.unit_disk_size is not None:
            result['UnitDiskSize'] = self.unit_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogAssignedSize') is not None:
            self.log_assigned_size = m.get('LogAssignedSize')
        if m.get('MaxLogAssignedObServer') is not None:
            self.max_log_assigned_ob_server = m.get('MaxLogAssignedObServer')
        if m.get('MaxLogAssignedPercent') is not None:
            self.max_log_assigned_percent = m.get('MaxLogAssignedPercent')
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UnitDiskSize') is not None:
            self.unit_disk_size = m.get('UnitDiskSize')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory(TeaModel):
    def __init__(self, original_total_memory=None, total_memory=None, unit_memory=None, used_memory=None):
        self.original_total_memory = original_total_memory  # type: long
        self.total_memory = total_memory  # type: long
        self.unit_memory = unit_memory  # type: long
        self.used_memory = used_memory  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_memory is not None:
            result['OriginalTotalMemory'] = self.original_total_memory
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalMemory') is not None:
            self.original_total_memory = m.get('OriginalTotalMemory')
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeInstanceResponseBodyInstanceReadOnlyResource(TeaModel):
    def __init__(self, capacity_unit=None, cpu=None, disk_size=None, log_disk_size=None, memory=None,
                 unit_count=None):
        self.capacity_unit = capacity_unit  # type: DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit
        self.cpu = cpu  # type: DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu
        self.disk_size = disk_size  # type: DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize
        self.log_disk_size = log_disk_size  # type: DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize
        self.memory = memory  # type: DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory
        self.unit_count = unit_count  # type: long

    def validate(self):
        if self.capacity_unit:
            self.capacity_unit.validate()
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.log_disk_size:
            self.log_disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceReadOnlyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_unit is not None:
            result['CapacityUnit'] = self.capacity_unit.to_map()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.log_disk_size is not None:
            result['LogDiskSize'] = self.log_disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.unit_count is not None:
            result['UnitCount'] = self.unit_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityUnit') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit()
            self.capacity_unit = temp_model.from_map(m['CapacityUnit'])
        if m.get('Cpu') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('LogDiskSize') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize()
            self.log_disk_size = temp_model.from_map(m['LogDiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('UnitCount') is not None:
            self.unit_count = m.get('UnitCount')
        return self


class DescribeInstanceResponseBodyInstanceResourceCapacityUnit(TeaModel):
    def __init__(self, max_capacity_unit=None, min_capacity_unit=None, used_capacity_unit=None):
        self.max_capacity_unit = max_capacity_unit  # type: int
        self.min_capacity_unit = min_capacity_unit  # type: int
        self.used_capacity_unit = used_capacity_unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResourceCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity_unit is not None:
            result['MaxCapacityUnit'] = self.max_capacity_unit
        if self.min_capacity_unit is not None:
            result['MinCapacityUnit'] = self.min_capacity_unit
        if self.used_capacity_unit is not None:
            result['UsedCapacityUnit'] = self.used_capacity_unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCapacityUnit') is not None:
            self.max_capacity_unit = m.get('MaxCapacityUnit')
        if m.get('MinCapacityUnit') is not None:
            self.min_capacity_unit = m.get('MinCapacityUnit')
        if m.get('UsedCapacityUnit') is not None:
            self.used_capacity_unit = m.get('UsedCapacityUnit')
        return self


class DescribeInstanceResponseBodyInstanceResourceCpu(TeaModel):
    def __init__(self, original_total_cpu=None, total_cpu=None, unit_cpu=None, used_cpu=None):
        self.original_total_cpu = original_total_cpu  # type: long
        # The series of the OceanBase cluster. Valid values:   
        # - NORMAL: the high availability edition.   
        # - BASIC: the basic edition.
        self.total_cpu = total_cpu  # type: long
        # The type of the storage disk where the cluster is deployed. 
        # 
        # The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
        self.unit_cpu = unit_cpu  # type: long
        # Indicates whether automatic upgrade of the OBServer version is enabled.
        self.used_cpu = used_cpu  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_cpu is not None:
            result['OriginalTotalCpu'] = self.original_total_cpu
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalCpu') is not None:
            self.original_total_cpu = m.get('OriginalTotalCpu')
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeInstanceResponseBodyInstanceResourceDiskSize(TeaModel):
    def __init__(self, data_used_size=None, max_disk_size=None, max_disk_used_ob_server=None,
                 max_disk_used_percent=None, original_total_disk_size=None, total_disk_size=None, unit_disk_size=None,
                 used_disk_size=None):
        # The ID of the OceanBase cluster.
        self.data_used_size = data_used_size  # type: float
        self.max_disk_size = max_disk_size  # type: float
        # The time in UTC when the cluster expires.
        self.max_disk_used_ob_server = max_disk_used_ob_server  # type: list[str]
        # The maximum disk usage, in percentage.
        self.max_disk_used_percent = max_disk_used_percent  # type: float
        self.original_total_disk_size = original_total_disk_size  # type: long
        # The data replica distribution mode of the cluster. Valid values: 
        # - n: indicates the single-IDC mode. 
        # - n-n: indicates the dual-IDC mode. 
        # - n-n-n: indicates the multi-IDC mode. 
        # 
        # > <br>The integer n represents the number of OBServer nodes in each IDC.
        self.total_disk_size = total_disk_size  # type: long
        # The list of zones.
        self.unit_disk_size = unit_disk_size  # type: long
        # The specifications of the cluster.  You can specify one of the following four plans:    
        # - 8C32G: indicates 8 CPU cores and 32 GB of memory. 
        # - 14C70G: indicates 14 CPU cores and 70 GB of memory. 
        # - 30C180G: indicates 30 CPU cores and 180 GB of memory. 
        # - 62C400G: indicates 62 CPU cores and 400 GB of memory.
        self.used_disk_size = used_disk_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_used_size is not None:
            result['DataUsedSize'] = self.data_used_size
        if self.max_disk_size is not None:
            result['MaxDiskSize'] = self.max_disk_size
        if self.max_disk_used_ob_server is not None:
            result['MaxDiskUsedObServer'] = self.max_disk_used_ob_server
        if self.max_disk_used_percent is not None:
            result['MaxDiskUsedPercent'] = self.max_disk_used_percent
        if self.original_total_disk_size is not None:
            result['OriginalTotalDiskSize'] = self.original_total_disk_size
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.unit_disk_size is not None:
            result['UnitDiskSize'] = self.unit_disk_size
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataUsedSize') is not None:
            self.data_used_size = m.get('DataUsedSize')
        if m.get('MaxDiskSize') is not None:
            self.max_disk_size = m.get('MaxDiskSize')
        if m.get('MaxDiskUsedObServer') is not None:
            self.max_disk_used_ob_server = m.get('MaxDiskUsedObServer')
        if m.get('MaxDiskUsedPercent') is not None:
            self.max_disk_used_percent = m.get('MaxDiskUsedPercent')
        if m.get('OriginalTotalDiskSize') is not None:
            self.original_total_disk_size = m.get('OriginalTotalDiskSize')
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UnitDiskSize') is not None:
            self.unit_disk_size = m.get('UnitDiskSize')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeInstanceResponseBodyInstanceResourceLogDiskSize(TeaModel):
    def __init__(self, log_assigned_size=None, max_log_assigned_ob_server=None, max_log_assigned_percent=None,
                 original_total_disk_size=None, total_disk_size=None, unit_disk_size=None):
        self.log_assigned_size = log_assigned_size  # type: str
        self.max_log_assigned_ob_server = max_log_assigned_ob_server  # type: list[str]
        self.max_log_assigned_percent = max_log_assigned_percent  # type: str
        self.original_total_disk_size = original_total_disk_size  # type: int
        # The ID of the region.
        self.total_disk_size = total_disk_size  # type: long
        # The request ID.
        self.unit_disk_size = unit_disk_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResourceLogDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_assigned_size is not None:
            result['LogAssignedSize'] = self.log_assigned_size
        if self.max_log_assigned_ob_server is not None:
            result['MaxLogAssignedObServer'] = self.max_log_assigned_ob_server
        if self.max_log_assigned_percent is not None:
            result['MaxLogAssignedPercent'] = self.max_log_assigned_percent
        if self.original_total_disk_size is not None:
            result['OriginalTotalDiskSize'] = self.original_total_disk_size
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.unit_disk_size is not None:
            result['UnitDiskSize'] = self.unit_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogAssignedSize') is not None:
            self.log_assigned_size = m.get('LogAssignedSize')
        if m.get('MaxLogAssignedObServer') is not None:
            self.max_log_assigned_ob_server = m.get('MaxLogAssignedObServer')
        if m.get('MaxLogAssignedPercent') is not None:
            self.max_log_assigned_percent = m.get('MaxLogAssignedPercent')
        if m.get('OriginalTotalDiskSize') is not None:
            self.original_total_disk_size = m.get('OriginalTotalDiskSize')
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UnitDiskSize') is not None:
            self.unit_disk_size = m.get('UnitDiskSize')
        return self


class DescribeInstanceResponseBodyInstanceResourceMemory(TeaModel):
    def __init__(self, original_total_memory=None, total_memory=None, unit_memory=None, used_memory=None):
        self.original_total_memory = original_total_memory  # type: long
        # Indicates whether trusted ECS instances are used.
        self.total_memory = total_memory  # type: long
        # The log disk space of each replica node in the cluster. Unit: GB.
        self.unit_memory = unit_memory  # type: long
        # The time in UTC when the cluster was created.
        self.used_memory = used_memory  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_memory is not None:
            result['OriginalTotalMemory'] = self.original_total_memory
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalMemory') is not None:
            self.original_total_memory = m.get('OriginalTotalMemory')
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeInstanceResponseBodyInstanceResource(TeaModel):
    def __init__(self, capacity_unit=None, cpu=None, disk_size=None, log_disk_size=None, memory=None,
                 unit_count=None):
        self.capacity_unit = capacity_unit  # type: DescribeInstanceResponseBodyInstanceResourceCapacityUnit
        # The information of the OceanBase cluster.
        self.cpu = cpu  # type: DescribeInstanceResponseBodyInstanceResourceCpu
        # The number of the page to return. 
        # - Start value: 1  
        # - Default value: 1
        self.disk_size = disk_size  # type: DescribeInstanceResponseBodyInstanceResourceDiskSize
        # The server with the highest disk usage.
        self.log_disk_size = log_disk_size  # type: DescribeInstanceResponseBodyInstanceResourceLogDiskSize
        # The name of the OceanBase cluster.
        self.memory = memory  # type: DescribeInstanceResponseBodyInstanceResourceMemory
        # The number of CPU cores used in the cluster.
        self.unit_count = unit_count  # type: long

    def validate(self):
        if self.capacity_unit:
            self.capacity_unit.validate()
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.log_disk_size:
            self.log_disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_unit is not None:
            result['CapacityUnit'] = self.capacity_unit.to_map()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.log_disk_size is not None:
            result['LogDiskSize'] = self.log_disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.unit_count is not None:
            result['UnitCount'] = self.unit_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityUnit') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResourceCapacityUnit()
            self.capacity_unit = temp_model.from_map(m['CapacityUnit'])
        if m.get('Cpu') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('LogDiskSize') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResourceLogDiskSize()
            self.log_disk_size = temp_model.from_map(m['LogDiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('UnitCount') is not None:
            self.unit_count = m.get('UnitCount')
        return self


class DescribeInstanceResponseBodyInstanceTenantCreatable(TeaModel):
    def __init__(self, disable_create_tenant_reason=None, enable_create_tenant=None):
        self.disable_create_tenant_reason = disable_create_tenant_reason  # type: str
        self.enable_create_tenant = enable_create_tenant  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstanceTenantCreatable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_create_tenant_reason is not None:
            result['DisableCreateTenantReason'] = self.disable_create_tenant_reason
        if self.enable_create_tenant is not None:
            result['EnableCreateTenant'] = self.enable_create_tenant
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisableCreateTenantReason') is not None:
            self.disable_create_tenant_reason = m.get('DisableCreateTenantReason')
        if m.get('EnableCreateTenant') is not None:
            self.enable_create_tenant = m.get('EnableCreateTenant')
        return self


class DescribeInstanceResponseBodyInstance(TeaModel):
    def __init__(self, auto_renewal=None, auto_upgrade_ob_version=None, available_zones=None,
                 cpu_architecture=None, create_time=None, data_disk_auto_scale=None, data_disk_auto_scale_config=None,
                 data_merge_time=None, deploy_mode=None, deploy_type=None, disk_type=None, enable_isolation_optimization=None,
                 enable_proxy_service=None, enable_upgrade_log_disk=None, expire_time=None, in_temp_capacity_status=None,
                 instance_class=None, instance_id=None, instance_name=None, instance_role=None, is_latest_ob_version=None,
                 is_trust_ecs=None, isolation_optimization=None, maintain_time=None, node_num=None, ob_rpm_version=None,
                 pay_type=None, proxy_cluster_id=None, proxy_service_status=None, read_only_resource=None,
                 replica_mode=None, resource=None, series=None, status=None, tenant_creatable=None, version=None, zones=None):
        # The operation that you want to perform. <br>Set the value to **DescribeInstance**.
        self.auto_renewal = auto_renewal  # type: bool
        # Example 1
        self.auto_upgrade_ob_version = auto_upgrade_ob_version  # type: bool
        self.available_zones = available_zones  # type: list[str]
        self.cpu_architecture = cpu_architecture  # type: str
        # Indicates whether the log disk specifications can be upgraded.
        self.create_time = create_time  # type: str
        self.data_disk_auto_scale = data_disk_auto_scale  # type: bool
        self.data_disk_auto_scale_config = data_disk_auto_scale_config  # type: DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig
        # The total number of CPU cores of the cluster.
        self.data_merge_time = data_merge_time  # type: str
        # Alibaba Cloud CLI
        self.deploy_mode = deploy_mode  # type: str
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.deploy_type = deploy_type  # type: str
        # The total storage space of the cluster, in GB.
        self.disk_type = disk_type  # type: str
        self.enable_isolation_optimization = enable_isolation_optimization  # type: bool
        self.enable_proxy_service = enable_proxy_service  # type: bool
        self.enable_upgrade_log_disk = enable_upgrade_log_disk  # type: bool
        # The information of the OceanBase cluster.
        self.expire_time = expire_time  # type: str
        self.in_temp_capacity_status = in_temp_capacity_status  # type: bool
        # The detailed information of the OBServer version.
        self.instance_class = instance_class  # type: str
        # The information about the log disk space of the cluster.
        self.instance_id = instance_id  # type: str
        # Indicates whether automatic upgrade of the OBServer version is enabled.
        self.instance_name = instance_name  # type: str
        self.instance_role = instance_role  # type: str
        self.is_latest_ob_version = is_latest_ob_version  # type: bool
        # The information about the CPU resources of the cluster.
        self.is_trust_ecs = is_trust_ecs  # type: bool
        self.isolation_optimization = isolation_optimization  # type: bool
        # The time when the major compaction of cluster data is performed.
        self.maintain_time = maintain_time  # type: str
        self.node_num = node_num  # type: str
        self.ob_rpm_version = ob_rpm_version  # type: str
        # The list of zones.
        self.pay_type = pay_type  # type: str
        self.proxy_cluster_id = proxy_cluster_id  # type: str
        self.proxy_service_status = proxy_service_status  # type: str
        self.read_only_resource = read_only_resource  # type: DescribeInstanceResponseBodyInstanceReadOnlyResource
        self.replica_mode = replica_mode  # type: str
        # The size of used memory in the cluster, in GB.
        self.resource = resource  # type: DescribeInstanceResponseBodyInstanceResource
        # Indicates whether the OBServer version is the latest.
        self.series = series  # type: str
        # The information about cluster resources.
        self.status = status  # type: str
        self.tenant_creatable = tenant_creatable  # type: DescribeInstanceResponseBodyInstanceTenantCreatable
        # You can call this operation to query the detailed information of an OceanBase cluster.
        self.version = version  # type: str
        self.zones = zones  # type: list[str]

    def validate(self):
        if self.data_disk_auto_scale_config:
            self.data_disk_auto_scale_config.validate()
        if self.read_only_resource:
            self.read_only_resource.validate()
        if self.resource:
            self.resource.validate()
        if self.tenant_creatable:
            self.tenant_creatable.validate()

    def to_map(self):
        _map = super(DescribeInstanceResponseBodyInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renewal is not None:
            result['AutoRenewal'] = self.auto_renewal
        if self.auto_upgrade_ob_version is not None:
            result['AutoUpgradeObVersion'] = self.auto_upgrade_ob_version
        if self.available_zones is not None:
            result['AvailableZones'] = self.available_zones
        if self.cpu_architecture is not None:
            result['CpuArchitecture'] = self.cpu_architecture
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_disk_auto_scale is not None:
            result['DataDiskAutoScale'] = self.data_disk_auto_scale
        if self.data_disk_auto_scale_config is not None:
            result['DataDiskAutoScaleConfig'] = self.data_disk_auto_scale_config.to_map()
        if self.data_merge_time is not None:
            result['DataMergeTime'] = self.data_merge_time
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.enable_isolation_optimization is not None:
            result['EnableIsolationOptimization'] = self.enable_isolation_optimization
        if self.enable_proxy_service is not None:
            result['EnableProxyService'] = self.enable_proxy_service
        if self.enable_upgrade_log_disk is not None:
            result['EnableUpgradeLogDisk'] = self.enable_upgrade_log_disk
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.in_temp_capacity_status is not None:
            result['InTempCapacityStatus'] = self.in_temp_capacity_status
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_role is not None:
            result['InstanceRole'] = self.instance_role
        if self.is_latest_ob_version is not None:
            result['IsLatestObVersion'] = self.is_latest_ob_version
        if self.is_trust_ecs is not None:
            result['IsTrustEcs'] = self.is_trust_ecs
        if self.isolation_optimization is not None:
            result['IsolationOptimization'] = self.isolation_optimization
        if self.maintain_time is not None:
            result['MaintainTime'] = self.maintain_time
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.ob_rpm_version is not None:
            result['ObRpmVersion'] = self.ob_rpm_version
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.proxy_cluster_id is not None:
            result['ProxyClusterId'] = self.proxy_cluster_id
        if self.proxy_service_status is not None:
            result['ProxyServiceStatus'] = self.proxy_service_status
        if self.read_only_resource is not None:
            result['ReadOnlyResource'] = self.read_only_resource.to_map()
        if self.replica_mode is not None:
            result['ReplicaMode'] = self.replica_mode
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.series is not None:
            result['Series'] = self.series
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_creatable is not None:
            result['TenantCreatable'] = self.tenant_creatable.to_map()
        if self.version is not None:
            result['Version'] = self.version
        if self.zones is not None:
            result['Zones'] = self.zones
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenewal') is not None:
            self.auto_renewal = m.get('AutoRenewal')
        if m.get('AutoUpgradeObVersion') is not None:
            self.auto_upgrade_ob_version = m.get('AutoUpgradeObVersion')
        if m.get('AvailableZones') is not None:
            self.available_zones = m.get('AvailableZones')
        if m.get('CpuArchitecture') is not None:
            self.cpu_architecture = m.get('CpuArchitecture')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataDiskAutoScale') is not None:
            self.data_disk_auto_scale = m.get('DataDiskAutoScale')
        if m.get('DataDiskAutoScaleConfig') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig()
            self.data_disk_auto_scale_config = temp_model.from_map(m['DataDiskAutoScaleConfig'])
        if m.get('DataMergeTime') is not None:
            self.data_merge_time = m.get('DataMergeTime')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EnableIsolationOptimization') is not None:
            self.enable_isolation_optimization = m.get('EnableIsolationOptimization')
        if m.get('EnableProxyService') is not None:
            self.enable_proxy_service = m.get('EnableProxyService')
        if m.get('EnableUpgradeLogDisk') is not None:
            self.enable_upgrade_log_disk = m.get('EnableUpgradeLogDisk')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('InTempCapacityStatus') is not None:
            self.in_temp_capacity_status = m.get('InTempCapacityStatus')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceRole') is not None:
            self.instance_role = m.get('InstanceRole')
        if m.get('IsLatestObVersion') is not None:
            self.is_latest_ob_version = m.get('IsLatestObVersion')
        if m.get('IsTrustEcs') is not None:
            self.is_trust_ecs = m.get('IsTrustEcs')
        if m.get('IsolationOptimization') is not None:
            self.isolation_optimization = m.get('IsolationOptimization')
        if m.get('MaintainTime') is not None:
            self.maintain_time = m.get('MaintainTime')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('ObRpmVersion') is not None:
            self.ob_rpm_version = m.get('ObRpmVersion')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('ProxyClusterId') is not None:
            self.proxy_cluster_id = m.get('ProxyClusterId')
        if m.get('ProxyServiceStatus') is not None:
            self.proxy_service_status = m.get('ProxyServiceStatus')
        if m.get('ReadOnlyResource') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceReadOnlyResource()
            self.read_only_resource = temp_model.from_map(m['ReadOnlyResource'])
        if m.get('ReplicaMode') is not None:
            self.replica_mode = m.get('ReplicaMode')
        if m.get('Resource') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantCreatable') is not None:
            temp_model = DescribeInstanceResponseBodyInstanceTenantCreatable()
            self.tenant_creatable = temp_model.from_map(m['TenantCreatable'])
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('Zones') is not None:
            self.zones = m.get('Zones')
        return self


class DescribeInstanceResponseBody(TeaModel):
    def __init__(self, instance=None, request_id=None):
        # The log disk space of each replica node in the cluster. Unit: GB.
        self.instance = instance  # type: DescribeInstanceResponseBodyInstance
        # The total log disk space of the cluster, in GB.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super(DescribeInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instance') is not None:
            temp_model = DescribeInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceCreatableZoneRequest(TeaModel):
    def __init__(self, instance_id=None):
        # The ID of the zone.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceCreatableZoneRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceCreatableZoneResponseBodyZoneList(TeaModel):
    def __init__(self, is_in_cluster=None, zone=None):
        self.is_in_cluster = is_in_cluster  # type: bool
        # DescribeInstanceCreatableZone
        self.zone = zone  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceCreatableZoneResponseBodyZoneList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_in_cluster is not None:
            result['IsInCluster'] = self.is_in_cluster
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsInCluster') is not None:
            self.is_in_cluster = m.get('IsInCluster')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class DescribeInstanceCreatableZoneResponseBody(TeaModel):
    def __init__(self, request_id=None, zone_list=None):
        # Indicates whether the cluster is deployed in the zone.
        self.request_id = request_id  # type: str
        # The operation that you want to perform.   
        # Set the value to **DescribeInstanceCreatableZone**.
        self.zone_list = zone_list  # type: list[DescribeInstanceCreatableZoneResponseBodyZoneList]

    def validate(self):
        if self.zone_list:
            for k in self.zone_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceCreatableZoneResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ZoneList'] = []
        if self.zone_list is not None:
            for k in self.zone_list:
                result['ZoneList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.zone_list = []
        if m.get('ZoneList') is not None:
            for k in m.get('ZoneList'):
                temp_model = DescribeInstanceCreatableZoneResponseBodyZoneList()
                self.zone_list.append(temp_model.from_map(k))
        return self


class DescribeInstanceCreatableZoneResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceCreatableZoneResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceCreatableZoneResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceCreatableZoneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSSLRequest(TeaModel):
    def __init__(self, instance_id=None):
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceSSLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceSSLResponseBodyInstanceSSL(TeaModel):
    def __init__(self, ca_url=None, enable_ssl=None, force_ssl=None, force_sslsupport=None, instance_id=None,
                 status=None, valid_period=None):
        self.ca_url = ca_url  # type: str
        self.enable_ssl = enable_ssl  # type: str
        self.force_ssl = force_ssl  # type: str
        self.force_sslsupport = force_sslsupport  # type: bool
        self.instance_id = instance_id  # type: str
        self.status = status  # type: str
        self.valid_period = valid_period  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceSSLResponseBodyInstanceSSL, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ca_url is not None:
            result['CaUrl'] = self.ca_url
        if self.enable_ssl is not None:
            result['EnableSSL'] = self.enable_ssl
        if self.force_ssl is not None:
            result['ForceSSL'] = self.force_ssl
        if self.force_sslsupport is not None:
            result['ForceSSLSupport'] = self.force_sslsupport
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.valid_period is not None:
            result['ValidPeriod'] = self.valid_period
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CaUrl') is not None:
            self.ca_url = m.get('CaUrl')
        if m.get('EnableSSL') is not None:
            self.enable_ssl = m.get('EnableSSL')
        if m.get('ForceSSL') is not None:
            self.force_ssl = m.get('ForceSSL')
        if m.get('ForceSSLSupport') is not None:
            self.force_sslsupport = m.get('ForceSSLSupport')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('ValidPeriod') is not None:
            self.valid_period = m.get('ValidPeriod')
        return self


class DescribeInstanceSSLResponseBody(TeaModel):
    def __init__(self, instance_ssl=None, request_id=None):
        self.instance_ssl = instance_ssl  # type: DescribeInstanceSSLResponseBodyInstanceSSL
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_ssl:
            self.instance_ssl.validate()

    def to_map(self):
        _map = super(DescribeInstanceSSLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ssl is not None:
            result['InstanceSSL'] = self.instance_ssl.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceSSL') is not None:
            temp_model = DescribeInstanceSSLResponseBodyInstanceSSL()
            self.instance_ssl = temp_model.from_map(m['InstanceSSL'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceSSLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceSSLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceSSLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSSLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSecurityConfigsRequest(TeaModel):
    def __init__(self, check_id=None, instance_id=None):
        self.check_id = check_id  # type: str
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceSecurityConfigsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs(TeaModel):
    def __init__(self, config_description=None, config_group=None, config_name=None, risk=None,
                 risk_description=None):
        self.config_description = config_description  # type: str
        self.config_group = config_group  # type: str
        self.config_name = config_name  # type: str
        self.risk = risk  # type: bool
        self.risk_description = risk_description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_description is not None:
            result['ConfigDescription'] = self.config_description
        if self.config_group is not None:
            result['ConfigGroup'] = self.config_group
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        if self.risk is not None:
            result['Risk'] = self.risk
        if self.risk_description is not None:
            result['RiskDescription'] = self.risk_description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigDescription') is not None:
            self.config_description = m.get('ConfigDescription')
        if m.get('ConfigGroup') is not None:
            self.config_group = m.get('ConfigGroup')
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        if m.get('Risk') is not None:
            self.risk = m.get('Risk')
        if m.get('RiskDescription') is not None:
            self.risk_description = m.get('RiskDescription')
        return self


class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs(TeaModel):
    def __init__(self, check_id=None, check_time=None, instance_id=None, security_configs=None,
                 total_check_count=None, total_risk_count=None):
        self.check_id = check_id  # type: str
        self.check_time = check_time  # type: str
        self.instance_id = instance_id  # type: str
        self.security_configs = security_configs  # type: list[DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs]
        self.total_check_count = total_check_count  # type: int
        self.total_risk_count = total_risk_count  # type: int

    def validate(self):
        if self.security_configs:
            for k in self.security_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_time is not None:
            result['CheckTime'] = self.check_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['SecurityConfigs'] = []
        if self.security_configs is not None:
            for k in self.security_configs:
                result['SecurityConfigs'].append(k.to_map() if k else None)
        if self.total_check_count is not None:
            result['TotalCheckCount'] = self.total_check_count
        if self.total_risk_count is not None:
            result['TotalRiskCount'] = self.total_risk_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckTime') is not None:
            self.check_time = m.get('CheckTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.security_configs = []
        if m.get('SecurityConfigs') is not None:
            for k in m.get('SecurityConfigs'):
                temp_model = DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs()
                self.security_configs.append(temp_model.from_map(k))
        if m.get('TotalCheckCount') is not None:
            self.total_check_count = m.get('TotalCheckCount')
        if m.get('TotalRiskCount') is not None:
            self.total_risk_count = m.get('TotalRiskCount')
        return self


class DescribeInstanceSecurityConfigsResponseBody(TeaModel):
    def __init__(self, instance_security_configs=None, request_id=None):
        self.instance_security_configs = instance_security_configs  # type: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_security_configs:
            self.instance_security_configs.validate()

    def to_map(self):
        _map = super(DescribeInstanceSecurityConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_security_configs is not None:
            result['InstanceSecurityConfigs'] = self.instance_security_configs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceSecurityConfigs') is not None:
            temp_model = DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs()
            self.instance_security_configs = temp_model.from_map(m['InstanceSecurityConfigs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceSecurityConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceSecurityConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceSecurityConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSecurityConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTagsRequest(TeaModel):
    def __init__(self, instance_ids=None, tags=None):
        # The list of tags.
        self.instance_ids = instance_ids  # type: str
        # The returned response.
        self.tags = tags  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeInstanceTagsResponseBodyTagResources(TeaModel):
    def __init__(self, resource_id=None, resource_type=None, tag=None):
        # You can call this operation to view the tag value of a cluster.
        self.resource_id = resource_id  # type: str
        self.resource_type = resource_type  # type: str
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTagsResponseBodyTagResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeInstanceTagsResponseBody(TeaModel):
    def __init__(self, request_id=None, tag_resources=None):
        # The resource ID.
        self.request_id = request_id  # type: str
        # The request ID.
        self.tag_resources = tag_resources  # type: list[DescribeInstanceTagsResponseBodyTagResources]

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = DescribeInstanceTagsResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class DescribeInstanceTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTenantModesRequest(TeaModel):
    def __init__(self, instance_id=None):
        # The operation that you want to perform.   
        # Set the value to **DescribeInstanceTenantModes**.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTenantModesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceTenantModesResponseBody(TeaModel):
    def __init__(self, instance_modes=None, request_id=None):
        self.instance_modes = instance_modes  # type: list[str]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTenantModesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_modes is not None:
            result['InstanceModes'] = self.instance_modes
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceModes') is not None:
            self.instance_modes = m.get('InstanceModes')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceTenantModesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTenantModesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTenantModesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTenantModesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTopologyRequest(TeaModel):
    def __init__(self, instance_id=None):
        # The status of the node.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits(TeaModel):
    def __init__(self, enable_cancel_migrate_unit=None, enable_migrate_unit=None, manual_migrate=None,
                 node_id=None, replica_type=None, unit_cpu=None, unit_data_size=None, unit_id=None, unit_memory=None,
                 unit_status=None):
        # Indicates whether the migration can be canceled.   
        # This field is valid only for units that are being manually immigrated or emigrated.
        self.enable_cancel_migrate_unit = enable_cancel_migrate_unit  # type: bool
        # The return result of the request.
        self.enable_migrate_unit = enable_migrate_unit  # type: bool
        # The return result of the request.
        self.manual_migrate = manual_migrate  # type: bool
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.node_id = node_id  # type: str
        self.replica_type = replica_type  # type: str
        # Alibaba Cloud CLI
        self.unit_cpu = unit_cpu  # type: float
        # The operation that you want to perform.   
        # Set the value to **DescribeInstanceTopology**.
        self.unit_data_size = unit_data_size  # type: long
        # The topology of the cluster.
        self.unit_id = unit_id  # type: str
        # The ID of the tenant.
        self.unit_memory = unit_memory  # type: float
        # You can call this operation to query the topology of an OceanBase cluster.
        self.unit_status = unit_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cancel_migrate_unit is not None:
            result['EnableCancelMigrateUnit'] = self.enable_cancel_migrate_unit
        if self.enable_migrate_unit is not None:
            result['EnableMigrateUnit'] = self.enable_migrate_unit
        if self.manual_migrate is not None:
            result['ManualMigrate'] = self.manual_migrate
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.replica_type is not None:
            result['ReplicaType'] = self.replica_type
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.unit_data_size is not None:
            result['UnitDataSize'] = self.unit_data_size
        if self.unit_id is not None:
            result['UnitId'] = self.unit_id
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.unit_status is not None:
            result['UnitStatus'] = self.unit_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableCancelMigrateUnit') is not None:
            self.enable_cancel_migrate_unit = m.get('EnableCancelMigrateUnit')
        if m.get('EnableMigrateUnit') is not None:
            self.enable_migrate_unit = m.get('EnableMigrateUnit')
        if m.get('ManualMigrate') is not None:
            self.manual_migrate = m.get('ManualMigrate')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('ReplicaType') is not None:
            self.replica_type = m.get('ReplicaType')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UnitDataSize') is not None:
            self.unit_data_size = m.get('UnitDataSize')
        if m.get('UnitId') is not None:
            self.unit_id = m.get('UnitId')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UnitStatus') is not None:
            self.unit_status = m.get('UnitStatus')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones(TeaModel):
    def __init__(self, is_primary_tenant_zone=None, tenant_zone_id=None, tenant_zone_role=None, units=None):
        # The maximum disk usage, in percentage.
        self.is_primary_tenant_zone = is_primary_tenant_zone  # type: str
        # The server with the highest disk usage.
        self.tenant_zone_id = tenant_zone_id  # type: str
        # The information of zones.
        self.tenant_zone_role = tenant_zone_role  # type: str
        # The information about the storage resources.
        self.units = units  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits]

    def validate(self):
        if self.units:
            for k in self.units:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_primary_tenant_zone is not None:
            result['IsPrimaryTenantZone'] = self.is_primary_tenant_zone
        if self.tenant_zone_id is not None:
            result['TenantZoneId'] = self.tenant_zone_id
        if self.tenant_zone_role is not None:
            result['TenantZoneRole'] = self.tenant_zone_role
        result['Units'] = []
        if self.units is not None:
            for k in self.units:
                result['Units'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsPrimaryTenantZone') is not None:
            self.is_primary_tenant_zone = m.get('IsPrimaryTenantZone')
        if m.get('TenantZoneId') is not None:
            self.tenant_zone_id = m.get('TenantZoneId')
        if m.get('TenantZoneRole') is not None:
            self.tenant_zone_role = m.get('TenantZoneRole')
        self.units = []
        if m.get('Units') is not None:
            for k in m.get('Units'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits()
                self.units.append(temp_model.from_map(k))
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyTenants(TeaModel):
    def __init__(self, primary_zone_deploy_type=None, tenant_cpu=None, tenant_deploy_type=None, tenant_id=None,
                 tenant_memory=None, tenant_mode=None, tenant_name=None, tenant_status=None, tenant_unit_num=None,
                 tenant_zones=None):
        # The server with the highest disk usage.
        self.primary_zone_deploy_type = primary_zone_deploy_type  # type: str
        # The information about the memory resources of the node.
        self.tenant_cpu = tenant_cpu  # type: float
        # The name of the tenant.
        self.tenant_deploy_type = tenant_deploy_type  # type: str
        # The size of used memory of the node, in GB.
        self.tenant_id = tenant_id  # type: str
        # The total storage space of the node, in GB.
        self.tenant_memory = tenant_memory  # type: float
        # The size of used storage space of the node, in GB.
        self.tenant_mode = tenant_mode  # type: str
        # The total memory size of the node, in GB.
        self.tenant_name = tenant_name  # type: str
        # The size of used memory of the node, in GB.
        self.tenant_status = tenant_status  # type: str
        # The number of CPU cores of the tenant.
        self.tenant_unit_num = tenant_unit_num  # type: int
        # The information about the storage resources of the node.
        self.tenant_zones = tenant_zones  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones]

    def validate(self):
        if self.tenant_zones:
            for k in self.tenant_zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyTenants, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary_zone_deploy_type is not None:
            result['PrimaryZoneDeployType'] = self.primary_zone_deploy_type
        if self.tenant_cpu is not None:
            result['TenantCpu'] = self.tenant_cpu
        if self.tenant_deploy_type is not None:
            result['TenantDeployType'] = self.tenant_deploy_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_memory is not None:
            result['TenantMemory'] = self.tenant_memory
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tenant_status is not None:
            result['TenantStatus'] = self.tenant_status
        if self.tenant_unit_num is not None:
            result['TenantUnitNum'] = self.tenant_unit_num
        result['TenantZones'] = []
        if self.tenant_zones is not None:
            for k in self.tenant_zones:
                result['TenantZones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrimaryZoneDeployType') is not None:
            self.primary_zone_deploy_type = m.get('PrimaryZoneDeployType')
        if m.get('TenantCpu') is not None:
            self.tenant_cpu = m.get('TenantCpu')
        if m.get('TenantDeployType') is not None:
            self.tenant_deploy_type = m.get('TenantDeployType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantMemory') is not None:
            self.tenant_memory = m.get('TenantMemory')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('TenantStatus') is not None:
            self.tenant_status = m.get('TenantStatus')
        if m.get('TenantUnitNum') is not None:
            self.tenant_unit_num = m.get('TenantUnitNum')
        self.tenant_zones = []
        if m.get('TenantZones') is not None:
            for k in m.get('TenantZones'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones()
                self.tenant_zones.append(temp_model.from_map(k))
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu(TeaModel):
    def __init__(self, total_cpu=None, used_cpu=None):
        # The size of used storage space of the node, in GB.
        self.total_cpu = total_cpu  # type: int
        # Indicates whether migration can be performed.
        self.used_cpu = used_cpu  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize(TeaModel):
    def __init__(self, total_disk_size=None, used_disk_size=None):
        # The deployment type of the primary zone.
        self.total_disk_size = total_disk_size  # type: float
        # The status of the tenant.   
        # - PENDING_CREATE: The tenant is being created.   
        # - RESTORE: The tenant is being recovered.   
        # - ONLINE: The tenant is running.   
        # - SPEC_MODIFYING: The specification of the tenant is being modified.   
        # - ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.   
        # - PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.   
        # - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.   
        # - PARAMETER_MODIFYING: Parameters are being modified.   
        # - WHITE_LIST_MODIFYING: The whitelist is being modified.
        self.used_disk_size = used_disk_size  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory(TeaModel):
    def __init__(self, total_memory=None, used_memory=None):
        # The ID of the replica node.
        self.total_memory = total_memory  # type: long
        # The information of node resources.
        self.used_memory = used_memory  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource(TeaModel):
    def __init__(self, cpu=None, disk_size=None, memory=None):
        # The memory size of the tenant, in GB.
        self.cpu = cpu  # type: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu
        # The information about the CPU resources of the node.
        self.disk_size = disk_size  # type: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize
        # The role to access the zone. Valid values:   
        #  - ReadWrite: a role that has the read and write privileges.
        #  - ReadOnly: a role that has only the read-only privilege.
        self.memory = memory  # type: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory

    def validate(self):
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cpu') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes(TeaModel):
    def __init__(self, full_copy_id=None, node_copy_id=None, node_id=None, node_resource=None, node_status=None,
                 read_only_copy_id=None, replica_type=None):
        self.full_copy_id = full_copy_id  # type: long
        # The information of zones.
        self.node_copy_id = node_copy_id  # type: long
        # The ID of the resource unit.
        self.node_id = node_id  # type: str
        # The ID of the node.
        self.node_resource = node_resource  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource]
        # The ID of the OBServer where the resource unit resides.
        self.node_status = node_status  # type: str
        self.read_only_copy_id = read_only_copy_id  # type: long
        self.replica_type = replica_type  # type: str

    def validate(self):
        if self.node_resource:
            for k in self.node_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_copy_id is not None:
            result['FullCopyId'] = self.full_copy_id
        if self.node_copy_id is not None:
            result['NodeCopyId'] = self.node_copy_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        result['NodeResource'] = []
        if self.node_resource is not None:
            for k in self.node_resource:
                result['NodeResource'].append(k.to_map() if k else None)
        if self.node_status is not None:
            result['NodeStatus'] = self.node_status
        if self.read_only_copy_id is not None:
            result['ReadOnlyCopyId'] = self.read_only_copy_id
        if self.replica_type is not None:
            result['ReplicaType'] = self.replica_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FullCopyId') is not None:
            self.full_copy_id = m.get('FullCopyId')
        if m.get('NodeCopyId') is not None:
            self.node_copy_id = m.get('NodeCopyId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        self.node_resource = []
        if m.get('NodeResource') is not None:
            for k in m.get('NodeResource'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource()
                self.node_resource.append(temp_model.from_map(k))
        if m.get('NodeStatus') is not None:
            self.node_status = m.get('NodeStatus')
        if m.get('ReadOnlyCopyId') is not None:
            self.read_only_copy_id = m.get('ReadOnlyCopyId')
        if m.get('ReplicaType') is not None:
            self.replica_type = m.get('ReplicaType')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize(TeaModel):
    def __init__(self, max_disk_used_ob_server=None, max_disk_used_percent=None):
        self.max_disk_used_ob_server = max_disk_used_ob_server  # type: list[str]
        # DescribeInstanceTopology
        self.max_disk_used_percent = max_disk_used_percent  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_disk_used_ob_server is not None:
            result['MaxDiskUsedObServer'] = self.max_disk_used_ob_server
        if self.max_disk_used_percent is not None:
            result['MaxDiskUsedPercent'] = self.max_disk_used_percent
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxDiskUsedObServer') is not None:
            self.max_disk_used_ob_server = m.get('MaxDiskUsedObServer')
        if m.get('MaxDiskUsedPercent') is not None:
            self.max_disk_used_percent = m.get('MaxDiskUsedPercent')
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource(TeaModel):
    def __init__(self, disk_size=None):
        self.disk_size = disk_size  # type: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize

    def validate(self):
        if self.disk_size:
            self.disk_size.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskSize') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopologyZones(TeaModel):
    def __init__(self, nodes=None, region=None, zone_disk=None, zone_id=None, zone_resource=None):
        # The ID of the region.
        self.nodes = nodes  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes]
        # The zone information of the cluster.
        self.region = region  # type: str
        # The information about the memory resources of the node.
        self.zone_disk = zone_disk  # type: str
        # The information of the tenant.
        self.zone_id = zone_id  # type: str
        # Example 1
        self.zone_resource = zone_resource  # type: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()
        if self.zone_resource:
            self.zone_resource.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopologyZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.region is not None:
            result['Region'] = self.region
        if self.zone_disk is not None:
            result['ZoneDisk'] = self.zone_disk
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        if self.zone_resource is not None:
            result['ZoneResource'] = self.zone_resource.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ZoneDisk') is not None:
            self.zone_disk = m.get('ZoneDisk')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        if m.get('ZoneResource') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource()
            self.zone_resource = temp_model.from_map(m['ZoneResource'])
        return self


class DescribeInstanceTopologyResponseBodyInstanceTopology(TeaModel):
    def __init__(self, tenants=None, zones=None):
        # The total number of CPU cores for the node.
        self.tenants = tenants  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyTenants]
        # The information about resource units.
        self.zones = zones  # type: list[DescribeInstanceTopologyResponseBodyInstanceTopologyZones]

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyInstanceTopology, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['Tenants'].append(k.to_map() if k else None)
        result['Zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['Zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tenants = []
        if m.get('Tenants') is not None:
            for k in m.get('Tenants'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyTenants()
                self.tenants.append(temp_model.from_map(k))
        self.zones = []
        if m.get('Zones') is not None:
            for k in m.get('Zones'):
                temp_model = DescribeInstanceTopologyResponseBodyInstanceTopologyZones()
                self.zones.append(temp_model.from_map(k))
        return self


class DescribeInstanceTopologyResponseBody(TeaModel):
    def __init__(self, instance_topology=None, request_id=None):
        # The number of CPU cores used by the node.
        self.instance_topology = instance_topology  # type: DescribeInstanceTopologyResponseBodyInstanceTopology
        # The information about the CPU resources of the node.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_topology:
            self.instance_topology.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_topology is not None:
            result['InstanceTopology'] = self.instance_topology.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceTopology') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyInstanceTopology()
            self.instance_topology = temp_model.from_map(m['InstanceTopology'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceTopologyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTopologyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstancesRequest(TeaModel):
    def __init__(self, instance_id=None, instance_name=None, page_number=None, page_size=None,
                 resource_group_id=None, search_key=None):
        # The number of CPU cores used in the cluster.
        self.instance_id = instance_id  # type: str
        # The size of used memory in the cluster, in GB.
        self.instance_name = instance_name  # type: str
        # The total memory size of the cluster, in GB.
        self.page_number = page_number  # type: int
        # The information about the memory resources of the cluster.
        self.page_size = page_size  # type: int
        # The number of CPU cores of each replica node in the cluster.
        self.resource_group_id = resource_group_id  # type: str
        # The memory size of each replica node in the cluster, in GB.
        self.search_key = search_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        return self


class DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig(TeaModel):
    def __init__(self, auto_scale=None, max_disk_size=None, scale_step_in_merge=None, scale_step_in_normal=None,
                 upper_merge_threshold=None, upper_threshold=None, upperbound=None):
        self.auto_scale = auto_scale  # type: bool
        self.max_disk_size = max_disk_size  # type: long
        self.scale_step_in_merge = scale_step_in_merge  # type: long
        self.scale_step_in_normal = scale_step_in_normal  # type: long
        self.upper_merge_threshold = upper_merge_threshold  # type: long
        self.upper_threshold = upper_threshold  # type: long
        self.upperbound = upperbound  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_scale is not None:
            result['AutoScale'] = self.auto_scale
        if self.max_disk_size is not None:
            result['MaxDiskSize'] = self.max_disk_size
        if self.scale_step_in_merge is not None:
            result['ScaleStepInMerge'] = self.scale_step_in_merge
        if self.scale_step_in_normal is not None:
            result['ScaleStepInNormal'] = self.scale_step_in_normal
        if self.upper_merge_threshold is not None:
            result['UpperMergeThreshold'] = self.upper_merge_threshold
        if self.upper_threshold is not None:
            result['UpperThreshold'] = self.upper_threshold
        if self.upperbound is not None:
            result['Upperbound'] = self.upperbound
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoScale') is not None:
            self.auto_scale = m.get('AutoScale')
        if m.get('MaxDiskSize') is not None:
            self.max_disk_size = m.get('MaxDiskSize')
        if m.get('ScaleStepInMerge') is not None:
            self.scale_step_in_merge = m.get('ScaleStepInMerge')
        if m.get('ScaleStepInNormal') is not None:
            self.scale_step_in_normal = m.get('ScaleStepInNormal')
        if m.get('UpperMergeThreshold') is not None:
            self.upper_merge_threshold = m.get('UpperMergeThreshold')
        if m.get('UpperThreshold') is not None:
            self.upper_threshold = m.get('UpperThreshold')
        if m.get('Upperbound') is not None:
            self.upperbound = m.get('Upperbound')
        return self


class DescribeInstancesResponseBodyInstancesResourceCapacityUnit(TeaModel):
    def __init__(self, max_capacity_unit=None, min_capacity_unit=None, used_capacity_unit=None):
        self.max_capacity_unit = max_capacity_unit  # type: int
        self.min_capacity_unit = min_capacity_unit  # type: int
        self.used_capacity_unit = used_capacity_unit  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesResourceCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity_unit is not None:
            result['MaxCapacityUnit'] = self.max_capacity_unit
        if self.min_capacity_unit is not None:
            result['MinCapacityUnit'] = self.min_capacity_unit
        if self.used_capacity_unit is not None:
            result['UsedCapacityUnit'] = self.used_capacity_unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCapacityUnit') is not None:
            self.max_capacity_unit = m.get('MaxCapacityUnit')
        if m.get('MinCapacityUnit') is not None:
            self.min_capacity_unit = m.get('MinCapacityUnit')
        if m.get('UsedCapacityUnit') is not None:
            self.used_capacity_unit = m.get('UsedCapacityUnit')
        return self


class DescribeInstancesResponseBodyInstancesResourceCpu(TeaModel):
    def __init__(self, original_total_cpu=None, total_cpu=None, unit_cpu=None, used_cpu=None):
        self.original_total_cpu = original_total_cpu  # type: long
        # The name of the OceanBase cluster.    
        # It must be 1 to 20 characters in length.   
        # If this parameter is not specified, the value is the instance ID of the cluster by default.
        self.total_cpu = total_cpu  # type: long
        # The data replica distribution mode of the cluster. Valid values:    
        # 
        # - n: indicates the single-IDC mode.  
        # - n-n: indicates the dual-IDC mode.  
        # - n-n-n: indicates the multi-IDC mode. The integer n represents the number of OBServer nodes in each IDC.
        self.unit_cpu = unit_cpu  # type: long
        # The search keyword.
        self.used_cpu = used_cpu  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_cpu is not None:
            result['OriginalTotalCpu'] = self.original_total_cpu
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalCpu') is not None:
            self.original_total_cpu = m.get('OriginalTotalCpu')
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeInstancesResponseBodyInstancesResourceDiskSize(TeaModel):
    def __init__(self, original_total_disk_size=None, total_disk_size=None, unit_disk_size=None,
                 used_disk_size=None):
        self.original_total_disk_size = original_total_disk_size  # type: long
        # The request ID.
        self.total_disk_size = total_disk_size  # type: long
        # Example 1
        self.unit_disk_size = unit_disk_size  # type: long
        # $.parameters[7].schema.example
        self.used_disk_size = used_disk_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_disk_size is not None:
            result['OriginalTotalDiskSize'] = self.original_total_disk_size
        if self.total_disk_size is not None:
            result['TotalDiskSize'] = self.total_disk_size
        if self.unit_disk_size is not None:
            result['UnitDiskSize'] = self.unit_disk_size
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalDiskSize') is not None:
            self.original_total_disk_size = m.get('OriginalTotalDiskSize')
        if m.get('TotalDiskSize') is not None:
            self.total_disk_size = m.get('TotalDiskSize')
        if m.get('UnitDiskSize') is not None:
            self.unit_disk_size = m.get('UnitDiskSize')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeInstancesResponseBodyInstancesResourceMemory(TeaModel):
    def __init__(self, original_total_memory=None, total_memory=None, unit_memory=None, used_memory=None):
        self.original_total_memory = original_total_memory  # type: long
        # The number of CPU cores of the cluster.
        self.total_memory = total_memory  # type: long
        # The size of used storage space of the cluster, in GB.
        self.unit_memory = unit_memory  # type: long
        # The size of used memory in the cluster, in GB.
        self.used_memory = used_memory  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_total_memory is not None:
            result['OriginalTotalMemory'] = self.original_total_memory
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OriginalTotalMemory') is not None:
            self.original_total_memory = m.get('OriginalTotalMemory')
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeInstancesResponseBodyInstancesResource(TeaModel):
    def __init__(self, capacity_unit=None, cpu=None, disk_size=None, memory=None, unit_count=None):
        self.capacity_unit = capacity_unit  # type: DescribeInstancesResponseBodyInstancesResourceCapacityUnit
        # Indicates whether new nodes can be added.
        self.cpu = cpu  # type: DescribeInstancesResponseBodyInstancesResourceCpu
        # The time elapsed since the expiration of the cluster, in seconds.
        self.disk_size = disk_size  # type: DescribeInstancesResponseBodyInstancesResourceDiskSize
        # The status of the cluster. Valid values:   
        # - PENDING_CREATE: The cluster is being created.  
        # - ONLINE: The cluster is running.  
        # - TENANT_CREATING: The tenant is being created.  
        # - TENANT_SPEC_MODIFYING: The tenant specifications are being modified.  
        # - EXPANDING: Nodes are being added to the cluster to increase its capacity.  
        # - REDUCING: Nodes are being removed from the cluster to reduce its capacity.  
        # - SPEC_UPGRADING: The service plan is being upgraded.  
        # - DISK_UPGRADING: The storage space is being expanded.  
        # - WHITE_LIST_MODIFYING: The whitelist is being modified.  
        # - PARAMETER_MODIFYING: Parameters are being modified.  
        # - SSL_MODIFYING: The SSL certificate is being changed.  
        # - PREPAID_EXPIRE_CLOSED: The payment is overdue. This parameter is valid for a cluster whose billing method is set to PREPAY.  
        # - ARREARS_CLOSED: The payment is overdue. This parameter is valid for a cluster whose billing method is set to POSTPAY.  
        # - PENDING_DELETE: The cluster is being deleted.   
        # Generally, the cluster is in the ONLINE state.
        self.memory = memory  # type: DescribeInstancesResponseBodyInstancesResourceMemory
        self.unit_count = unit_count  # type: long

    def validate(self):
        if self.capacity_unit:
            self.capacity_unit.validate()
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_unit is not None:
            result['CapacityUnit'] = self.capacity_unit.to_map()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.unit_count is not None:
            result['UnitCount'] = self.unit_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityUnit') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesResourceCapacityUnit()
            self.capacity_unit = temp_model.from_map(m['CapacityUnit'])
        if m.get('Cpu') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('UnitCount') is not None:
            self.unit_count = m.get('UnitCount')
        return self


class DescribeInstancesResponseBodyInstances(TeaModel):
    def __init__(self, available_zones=None, commodity_code=None, cpu=None, cpu_architecture=None, create_time=None,
                 data_disk_auto_scale_config=None, deploy_mode=None, deploy_type=None, disk_size=None, disk_type=None,
                 enable_upgrade_nodes=None, expire_seconds=None, expire_time=None, in_temp_capacity_status=None, instance_class=None,
                 instance_id=None, instance_name=None, instance_role=None, instance_type=None, maintain_time=None, mem=None,
                 pay_type=None, resource=None, resource_group_id=None, series=None, state=None, used_disk_size=None,
                 version=None, vpc_id=None):
        # The time in UTC when the cluster expires.
        self.available_zones = available_zones  # type: list[str]
        # The storage space of each replica node in the cluster, in GB.
        self.commodity_code = commodity_code  # type: str
        # The product code of the OceanBase cluster.   
        # - oceanbase_oceanbasepre_public_cn: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in a China site.  
        # - oceanbase_oceanbasepost_public_cn: indicates an OceanBase cluster that is billed based on the pay-as-you-go plan and that is deployed in a China site.  
        # - oceanbase_obpre_public_intl: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in an international site.
        self.cpu = cpu  # type: int
        self.cpu_architecture = cpu_architecture  # type: str
        # The number of OceanBase clusters queried.
        self.create_time = create_time  # type: str
        self.data_disk_auto_scale_config = data_disk_auto_scale_config  # type: DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig
        # The request ID.
        self.deploy_mode = deploy_mode  # type: str
        # Alibaba Cloud provides SDKs in different languages to help you quickly integrate Alibaba Cloud products and services by using APIs. We recommend that you use an SDK to call APIs. In this way, you do not need to sign for verification.
        self.deploy_type = deploy_type  # type: str
        # The information about the memory resources of the cluster.
        self.disk_size = disk_size  # type: str
        # The number of CPU cores used in the cluster.
        self.disk_type = disk_type  # type: str
        # The ID of the OceanBase cluster.
        self.enable_upgrade_nodes = enable_upgrade_nodes  # type: bool
        # The whitelist information of the cluster.
        self.expire_seconds = expire_seconds  # type: int
        # The information about the storage resources of the cluster.
        self.expire_time = expire_time  # type: str
        self.in_temp_capacity_status = in_temp_capacity_status  # type: bool
        # The instance type.
        self.instance_class = instance_class  # type: str
        # The total storage space of the cluster, in GB.
        self.instance_id = instance_id  # type: str
        # The return result of the request.
        self.instance_name = instance_name  # type: str
        self.instance_role = instance_role  # type: str
        # You can call this operation to obtain the list of OceanBase clusters.
        self.instance_type = instance_type  # type: str
        # The return result of the request.
        self.maintain_time = maintain_time  # type: str
        # The information about the CPU resources of the cluster.
        self.mem = mem  # type: long
        # It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
        self.pay_type = pay_type  # type: str
        # The type of the storage disk where the cluster is deployed.   
        # The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
        self.resource = resource  # type: DescribeInstancesResponseBodyInstancesResource
        # The number of OceanBase clusters queried.
        self.resource_group_id = resource_group_id  # type: str
        # The billing method for the OceanBase cluster. Valid values:  
        # - PREPAY: the subscription billing method.  
        # - POSTPAY: the pay-as-you-go billing method.
        self.series = series  # type: str
        # The number of resource units in the cluster.
        self.state = state  # type: str
        # The number of resource units in the cluster.
        self.used_disk_size = used_disk_size  # type: long
        # The total number of CPU cores of the cluster.
        self.version = version  # type: str
        # vpcId
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.data_disk_auto_scale_config:
            self.data_disk_auto_scale_config.validate()
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_zones is not None:
            result['AvailableZones'] = self.available_zones
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_architecture is not None:
            result['CpuArchitecture'] = self.cpu_architecture
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_disk_auto_scale_config is not None:
            result['DataDiskAutoScaleConfig'] = self.data_disk_auto_scale_config.to_map()
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.enable_upgrade_nodes is not None:
            result['EnableUpgradeNodes'] = self.enable_upgrade_nodes
        if self.expire_seconds is not None:
            result['ExpireSeconds'] = self.expire_seconds
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.in_temp_capacity_status is not None:
            result['InTempCapacityStatus'] = self.in_temp_capacity_status
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_role is not None:
            result['InstanceRole'] = self.instance_role
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.maintain_time is not None:
            result['MaintainTime'] = self.maintain_time
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.series is not None:
            result['Series'] = self.series
        if self.state is not None:
            result['State'] = self.state
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        if self.version is not None:
            result['Version'] = self.version
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableZones') is not None:
            self.available_zones = m.get('AvailableZones')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuArchitecture') is not None:
            self.cpu_architecture = m.get('CpuArchitecture')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataDiskAutoScaleConfig') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig()
            self.data_disk_auto_scale_config = temp_model.from_map(m['DataDiskAutoScaleConfig'])
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EnableUpgradeNodes') is not None:
            self.enable_upgrade_nodes = m.get('EnableUpgradeNodes')
        if m.get('ExpireSeconds') is not None:
            self.expire_seconds = m.get('ExpireSeconds')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('InTempCapacityStatus') is not None:
            self.in_temp_capacity_status = m.get('InTempCapacityStatus')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceRole') is not None:
            self.instance_role = m.get('InstanceRole')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaintainTime') is not None:
            self.maintain_time = m.get('MaintainTime')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('Resource') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, request_id=None, total_count=None):
        # The total storage space of the cluster, in GB.
        self.instances = instances  # type: list[DescribeInstancesResponseBodyInstances]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricsDataRequest(TeaModel):
    def __init__(self, end_time=None, group_by_labels=None, instance_id=None, labels=None, limit=None, metrics=None,
                 replica_type=None, sort_metric_key=None, sort_order=None, start_time=None):
        self.end_time = end_time  # type: str
        self.group_by_labels = group_by_labels  # type: str
        self.instance_id = instance_id  # type: str
        self.labels = labels  # type: str
        self.limit = limit  # type: str
        self.metrics = metrics  # type: str
        self.replica_type = replica_type  # type: str
        self.sort_metric_key = sort_metric_key  # type: str
        self.sort_order = sort_order  # type: str
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricsDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_by_labels is not None:
            result['GroupByLabels'] = self.group_by_labels
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.metrics is not None:
            result['Metrics'] = self.metrics
        if self.replica_type is not None:
            result['ReplicaType'] = self.replica_type
        if self.sort_metric_key is not None:
            result['SortMetricKey'] = self.sort_metric_key
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupByLabels') is not None:
            self.group_by_labels = m.get('GroupByLabels')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('Metrics') is not None:
            self.metrics = m.get('Metrics')
        if m.get('ReplicaType') is not None:
            self.replica_type = m.get('ReplicaType')
        if m.get('SortMetricKey') is not None:
            self.sort_metric_key = m.get('SortMetricKey')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMetricsDataResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricsDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMetricsDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricsDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricsDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNodeMetricsRequest(TeaModel):
    def __init__(self, end_time=None, instance_id=None, metrics=None, node_id_list=None, node_name=None,
                 page_number=None, page_size=None, start_time=None, tenant_id=None):
        # $.parameters[7].schema.description
        self.end_time = end_time  # type: str
        # The list of nodes.
        self.instance_id = instance_id  # type: str
        # $.parameters[7].schema.enumValueTitles
        self.metrics = metrics  # type: str
        # $.parameters[10].schema.description
        self.node_id_list = node_id_list  # type: str
        # $.parameters[8].schema.example
        self.node_name = node_name  # type: str
        # $.parameters[6].schema.description
        self.page_number = page_number  # type: int
        # The ID of the tenant.
        self.page_size = page_size  # type: int
        # $.parameters[9].schema.example
        self.start_time = start_time  # type: str
        # $.parameters[6].schema.enumValueTitles
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNodeMetricsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.metrics is not None:
            result['Metrics'] = self.metrics
        if self.node_id_list is not None:
            result['NodeIdList'] = self.node_id_list
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Metrics') is not None:
            self.metrics = m.get('Metrics')
        if m.get('NodeIdList') is not None:
            self.node_id_list = m.get('NodeIdList')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeNodeMetricsResponseBody(TeaModel):
    def __init__(self, node_metrics=None, request_id=None, total_count=None):
        self.node_metrics = node_metrics  # type: str
        # You can call this operation to query the detailed metrics information of an OceanBase Database node.
        self.request_id = request_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DescribeNodeMetrics
        # &InstanceId=ob317v4uif****\
        # &PageSize=10
        # &PageNumber=1
        # &TenantId=ob2mr3oae0****\
        # &StartTime=2021-06-13 15:40:43
        # &EndTime=2021-09-13 15:40:43
        # &Metrics=tps
        # &NodeName=i-bp16niirq4zdmgvm****\
        # &NodeIdList=["i-bp19y05uq6xpacyqnlrc","i-bp1blcr3htr3g3u2vqvu","i-bp1392ikhayhr3hi4fli"]
        # &Common request parameters
        # ```
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNodeMetricsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_metrics is not None:
            result['NodeMetrics'] = self.node_metrics
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeMetrics') is not None:
            self.node_metrics = m.get('NodeMetrics')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNodeMetricsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNodeMetricsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNodeMetricsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNodeMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasAnomalySQLListRequest(TeaModel):
    def __init__(self, accept_language=None, current=None, db_name=None, dynamic_sql=None, end_time=None,
                 filter_condition=None, instance_id=None, merge_dynamic_sql=None, node_ip=None, page_size=None, search_key_word=None,
                 search_param=None, search_rule=None, search_value=None, sql_id=None, sql_text_length=None, start_time=None,
                 tenant_id=None):
        # The language of the response. Valid values:
        # - zh: Chinese
        # - en: English
        self.accept_language = accept_language  # type: str
        # The current page.
        self.current = current  # type: long
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of the monitoring data.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
        self.filter_condition = filter_condition  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        self.merge_dynamic_sql = merge_dynamic_sql  # type: bool
        # The node IP.
        self.node_ip = node_ip  # type: str
        # Page size.
        # - Start value: 1
        # - Default value: 1
        self.page_size = page_size  # type: long
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_param = search_param  # type: str
        # The search rule.   
        # Valid values: "=", ">", ">=", "<", and "<="
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        # Max length of the returned SQL text.
        self.sql_text_length = sql_text_length  # type: long
        # The start time of the monitoring data.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasAnomalySQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.current is not None:
            result['Current'] = self.current
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.merge_dynamic_sql is not None:
            result['MergeDynamicSql'] = self.merge_dynamic_sql
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_param is not None:
            result['SearchParam'] = self.search_param
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_length is not None:
            result['SqlTextLength'] = self.sql_text_length
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MergeDynamicSql') is not None:
            self.merge_dynamic_sql = m.get('MergeDynamicSql')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParam') is not None:
            self.search_param = m.get('SearchParam')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextLength') is not None:
            self.sql_text_length = m.get('SqlTextLength')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasAnomalySQLListResponseBodyDataSqlList(TeaModel):
    def __init__(self, avg_cpu_time=None, avg_db_time=None, avg_elapsed_time=None, avg_get_plan_time=None,
                 cpu_time=None, db_name=None, diag_types=None, diagnosis=None, executions=None, last_executed_time=None,
                 risk_level=None, sql_id=None, sql_text_short=None, suggestion=None, sum_db_time=None, sum_elapsed_time=None,
                 user_name=None):
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        self.cpu_time = cpu_time  # type: float
        self.db_name = db_name  # type: str
        self.diag_types = diag_types  # type: list[str]
        self.diagnosis = diagnosis  # type: str
        self.executions = executions  # type: float
        self.last_executed_time = last_executed_time  # type: float
        self.risk_level = risk_level  # type: str
        self.sql_id = sql_id  # type: str
        self.sql_text_short = sql_text_short  # type: str
        self.suggestion = suggestion  # type: str
        self.sum_db_time = sum_db_time  # type: float
        self.sum_elapsed_time = sum_elapsed_time  # type: str
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasAnomalySQLListResponseBodyDataSqlList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.diag_types is not None:
            result['DiagTypes'] = self.diag_types
        if self.diagnosis is not None:
            result['Diagnosis'] = self.diagnosis
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.last_executed_time is not None:
            result['LastExecutedTime'] = self.last_executed_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DiagTypes') is not None:
            self.diag_types = m.get('DiagTypes')
        if m.get('Diagnosis') is not None:
            self.diagnosis = m.get('Diagnosis')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('LastExecutedTime') is not None:
            self.last_executed_time = m.get('LastExecutedTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeOasAnomalySQLListResponseBodyData(TeaModel):
    def __init__(self, avg_cpu_time=None, avg_db_time=None, avg_elapsed_time=None, avg_get_plan_time=None,
                 cpu_time=None, db_name=None, diag_types=None, diagnosis=None, dynamic_sql=None, executions=None,
                 last_executed_time=None, risk_level=None, sql_id=None, sql_list=None, sql_text_short=None, suggestion=None,
                 sum_db_time=None, sum_elapsed_time=None, user_name=None):
        # Average CPU time of the suspicious SQL.
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        # Average response time of the suspicious SQL.
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        # Average time to obtain the execution plan of the suspicious SQL.
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        # CPU time of the suspicious SQL.
        self.cpu_time = cpu_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # The type of the diagnosis.
        self.diag_types = diag_types  # type: list[str]
        # The details of diagnosis.
        self.diagnosis = diagnosis  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # Total execution count of the suspicious SQL.
        self.executions = executions  # type: float
        # Last execution time of the suspicious SQL.
        self.last_executed_time = last_executed_time  # type: float
        # Risk level.
        self.risk_level = risk_level  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        self.sql_list = sql_list  # type: list[DescribeOasAnomalySQLListResponseBodyDataSqlList]
        # Prefix of the SQL text.
        self.sql_text_short = sql_text_short  # type: str
        # Suggestion for the suspicious SQL.
        self.suggestion = suggestion  # type: str
        self.sum_db_time = sum_db_time  # type: float
        # Total response time of the suspicious SQL.
        self.sum_elapsed_time = sum_elapsed_time  # type: str
        # Username.
        self.user_name = user_name  # type: str

    def validate(self):
        if self.sql_list:
            for k in self.sql_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasAnomalySQLListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.diag_types is not None:
            result['DiagTypes'] = self.diag_types
        if self.diagnosis is not None:
            result['Diagnosis'] = self.diagnosis
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.last_executed_time is not None:
            result['LastExecutedTime'] = self.last_executed_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        result['SqlList'] = []
        if self.sql_list is not None:
            for k in self.sql_list:
                result['SqlList'].append(k.to_map() if k else None)
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DiagTypes') is not None:
            self.diag_types = m.get('DiagTypes')
        if m.get('Diagnosis') is not None:
            self.diagnosis = m.get('Diagnosis')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('LastExecutedTime') is not None:
            self.last_executed_time = m.get('LastExecutedTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        self.sql_list = []
        if m.get('SqlList') is not None:
            for k in m.get('SqlList'):
                temp_model = DescribeOasAnomalySQLListResponseBodyDataSqlList()
                self.sql_list.append(temp_model.from_map(k))
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeOasAnomalySQLListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None, total_count=None):
        # The list of suspicious SQLs.
        self.data = data  # type: list[DescribeOasAnomalySQLListResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str
        # The total count.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasAnomalySQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOasAnomalySQLListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOasAnomalySQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasAnomalySQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasAnomalySQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasAnomalySQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasSQLDetailsRequest(TeaModel):
    def __init__(self, db_name=None, dynamic_sql=None, end_time=None, instance_id=None, sql_id=None, start_time=None,
                 tenant_id=None):
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of querying the SQL execution plan.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        # The start time of querying the SQL execution plan.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasSQLDetailsResponseBodyData(TeaModel):
    def __init__(self, db_name=None, fulltext=None, statement=None, tables=None, user_name=None):
        # The name of the database.
        self.db_name = db_name  # type: str
        # SQL text.
        self.fulltext = fulltext  # type: str
        # Parameterized text.
        self.statement = statement  # type: str
        # The table name related to the SQL.
        self.tables = tables  # type: list[str]
        # The username.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLDetailsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.fulltext is not None:
            result['Fulltext'] = self.fulltext
        if self.statement is not None:
            result['Statement'] = self.statement
        if self.tables is not None:
            result['Tables'] = self.tables
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Fulltext') is not None:
            self.fulltext = m.get('Fulltext')
        if m.get('Statement') is not None:
            self.statement = m.get('Statement')
        if m.get('Tables') is not None:
            self.tables = m.get('Tables')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeOasSQLDetailsResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of the SQL execution plan.
        self.data = data  # type: DescribeOasSQLDetailsResponseBodyData
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeOasSQLDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeOasSQLDetailsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOasSQLDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasSQLDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasSQLDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasSQLDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasSQLHistoryListRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, dynamic_sql=None, end_time=None, instance_id=None,
                 node_ip=None, sql_id=None, start_time=None, tenant_id=None):
        # The language of the response. Valid values:
        # - zh: Chinese
        # - en: English
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of querying the execution history of the SQL statement.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        # The start time of querying the execution history of the SQL statement.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLHistoryListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasSQLHistoryListResponseBodyData(TeaModel):
    def __init__(self, avg_affected_rows=None, avg_application_wait_time=None, avg_block_cache_hit=None,
                 avg_block_index_cache_hit=None, avg_bloom_filter_cache_hit=None, avg_concurrency_wait_time=None, avg_cpu_time=None,
                 avg_decode_time=None, avg_disk_reads=None, avg_elapsed_time=None, avg_execute_time=None,
                 avg_executor_rpc_count=None, avg_expected_worker_count=None, avg_get_plan_time=None, avg_logical_reads=None,
                 avg_memstore_read_rows=None, avg_net_time=None, avg_net_wait_time=None, avg_partition_count=None, avg_queue_time=None,
                 avg_return_rows=None, avg_row_cache_hit=None, avg_rpc_count=None, avg_schedule_time=None,
                 avg_ssstore_read_rows=None, avg_used_worker_count=None, avg_user_io_wait_time=None, avg_wait_count=None,
                 avg_wait_time=None, db_name=None, dist_plan_percentage=None, exec_ps=None, executions=None, fail_count=None,
                 fail_percentage=None, local_plan_percentage=None, max_affected_rows=None, max_application_wait_time=None,
                 max_concurrency_wait_time=None, max_cpu_time=None, max_disk_reads=None, max_elapsed_time=None, max_return_rows=None,
                 max_user_io_wait_time=None, max_wait_time=None, miss_plan_percentage=None, miss_plans=None, remote_plan_percentage=None,
                 remote_plans=None, ret_code_4012count=None, ret_code_4013count=None, ret_code_5001count=None,
                 ret_code_5024count=None, ret_code_5167count=None, ret_code_5217count=None, ret_code_6002count=None, retry_count=None,
                 sqlid=None, server=None, strong_consistency_percentage=None, sum_elapsed_time=None,
                 sum_logical_reads=None, sum_wait_time=None, table_scan_percentage=None, timestamp=None, user_name=None,
                 weak_consistency_percentage=None):
        # Average updated rows during the execution period.
        self.avg_affected_rows = avg_affected_rows  # type: long
        # Average Application event wait time (in milliseconds) during the client waiting period.
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        # Average BlockCache hit count during the execution period.
        self.avg_block_cache_hit = avg_block_cache_hit  # type: long
        # Average BlockIndexCache hit count during the execution period.
        self.avg_block_index_cache_hit = avg_block_index_cache_hit  # type: long
        # Average BloomFilterCache hit count during the execution period.
        self.avg_bloom_filter_cache_hit = avg_bloom_filter_cache_hit  # type: long
        # Average Concurrency event wait time (in milliseconds) during the execution period.
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        # Average CPU time (in milliseconds) during the execution period.
        self.avg_cpu_time = avg_cpu_time  # type: float
        # Average syntax parsing time (in milliseconds) during the execution period.
        self.avg_decode_time = avg_decode_time  # type: float
        # Average physical read count during the execution period.
        self.avg_disk_reads = avg_disk_reads  # type: long
        # Average response time (in milliseconds) during the execution period.
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        # Average plan execution time (in milliseconds) during the execution period.
        self.avg_execute_time = avg_execute_time  # type: float
        # Average number of RPC requests executed during the execution period.
        self.avg_executor_rpc_count = avg_executor_rpc_count  # type: float
        # Average degree of parallelism during the execution period.
        self.avg_expected_worker_count = avg_expected_worker_count  # type: float
        # Average plan generation time (in milliseconds) during the execution period.
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        # Average logical reads during the execution period.
        self.avg_logical_reads = avg_logical_reads  # type: long
        # Average Memstore read rows during the execution period.
        self.avg_memstore_read_rows = avg_memstore_read_rows  # type: long
        # Average network transmission time (in milliseconds) during the execution period.
        self.avg_net_time = avg_net_time  # type: float
        # Average network enqueue time (in milliseconds) during the network waiting period.
        self.avg_net_wait_time = avg_net_wait_time  # type: float
        # Average number of partition accessed during the execution period.
        self.avg_partition_count = avg_partition_count  # type: float
        # Average queueing time (in milliseconds) during the execution period.
        self.avg_queue_time = avg_queue_time  # type: float
        # Average number of rows returned during the execution period.
        self.avg_return_rows = avg_return_rows  # type: long
        # Average RowCache hit count during the execution period.
        self.avg_row_cache_hit = avg_row_cache_hit  # type: long
        # Average number of RPC sent during the execution.
        self.avg_rpc_count = avg_rpc_count  # type: long
        # Average Schedule event wait time (in milliseconds) during the scheduling period.
        self.avg_schedule_time = avg_schedule_time  # type: float
        # Average Ssstore read rows during the execution period.
        self.avg_ssstore_read_rows = avg_ssstore_read_rows  # type: long
        # Average number of threads used of the SQL during the execution period.
        self.avg_used_worker_count = avg_used_worker_count  # type: float
        # Average UserIO event wait time (in milliseconds) during the execution period.
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        # Average number of waits during the execution period.
        self.avg_wait_count = avg_wait_count  # type: float
        # Average wait time (in milliseconds) during the execution period.
        self.avg_wait_time = avg_wait_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # Distributed plan percentage during the execution period.
        self.dist_plan_percentage = dist_plan_percentage  # type: float
        # Average execution count per second during the execution period.
        self.exec_ps = exec_ps  # type: float
        # Total number of executions during the execution period.
        self.executions = executions  # type: long
        # The total number of errors during the execution period.
        self.fail_count = fail_count  # type: long
        # Error percentage during the execution period.
        self.fail_percentage = fail_percentage  # type: float
        # Local plan percentage during the execution period.
        self.local_plan_percentage = local_plan_percentage  # type: float
        # Max updated rows during the execution period.
        self.max_affected_rows = max_affected_rows  # type: float
        # Max Application event wait time (in milliseconds) during the execution period
        self.max_application_wait_time = max_application_wait_time  # type: float
        # Max Concurrency event wait time (in milliseconds) during the execution period
        self.max_concurrency_wait_time = max_concurrency_wait_time  # type: float
        # Max CPU time.
        self.max_cpu_time = max_cpu_time  # type: float
        # Max physical read count during the execution period.
        self.max_disk_reads = max_disk_reads  # type: float
        # Max response time.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # Max returned rows during the execution period.
        self.max_return_rows = max_return_rows  # type: float
        # Max UserIO event wait time (in milliseconds) during the execution period
        self.max_user_io_wait_time = max_user_io_wait_time  # type: float
        # Max wait time (in milliseconds) during the execution period.
        self.max_wait_time = max_wait_time  # type: float
        # Plan hit rage during the execution period.
        self.miss_plan_percentage = miss_plan_percentage  # type: float
        # Missed plan count.
        self.miss_plans = miss_plans  # type: long
        # Remote plan percentage during the execution period.
        self.remote_plan_percentage = remote_plan_percentage  # type: float
        # Remote plan count.
        self.remote_plans = remote_plans  # type: long
        # Number of occurrences of code 4012 during the execution period.
        self.ret_code_4012count = ret_code_4012count  # type: float
        # Number of occurrences of code 4013 during the execution period.
        self.ret_code_4013count = ret_code_4013count  # type: float
        # Number of occurrences of code 5001 during the execution period.
        self.ret_code_5001count = ret_code_5001count  # type: float
        # Number of occurrences of code 5024 during the execution period.
        self.ret_code_5024count = ret_code_5024count  # type: float
        # Number of occurrences of code 5167 during the execution period.
        self.ret_code_5167count = ret_code_5167count  # type: float
        # Number of occurrences of code 5217 during the execution period.
        self.ret_code_5217count = ret_code_5217count  # type: float
        # Number of occurrences of code 6002 during the execution period.
        self.ret_code_6002count = ret_code_6002count  # type: float
        # Total number of retries during the execution period.
        self.retry_count = retry_count  # type: long
        # SQL ID.
        self.sqlid = sqlid  # type: str
        # The server where the SQL is executed.
        self.server = server  # type: str
        # Strong consistent transaction percentage during the execution period.
        self.strong_consistency_percentage = strong_consistency_percentage  # type: float
        # Total response time (in milliseconds) during the execution period.
        self.sum_elapsed_time = sum_elapsed_time  # type: float
        # Total logical reads.
        self.sum_logical_reads = sum_logical_reads  # type: float
        # The total wait time (in milliseconds) during the internal waiting period.
        self.sum_wait_time = sum_wait_time  # type: float
        # Table scan percentage during the execution period.
        self.table_scan_percentage = table_scan_percentage  # type: float
        # Timestamp for the sample.
        self.timestamp = timestamp  # type: str
        # Username.
        self.user_name = user_name  # type: str
        # Eventually consistent transaction percentage during the execution period.
        self.weak_consistency_percentage = weak_consistency_percentage  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLHistoryListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_affected_rows is not None:
            result['AvgAffectedRows'] = self.avg_affected_rows
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_block_cache_hit is not None:
            result['AvgBlockCacheHit'] = self.avg_block_cache_hit
        if self.avg_block_index_cache_hit is not None:
            result['AvgBlockIndexCacheHit'] = self.avg_block_index_cache_hit
        if self.avg_bloom_filter_cache_hit is not None:
            result['AvgBloomFilterCacheHit'] = self.avg_bloom_filter_cache_hit
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_decode_time is not None:
            result['AvgDecodeTime'] = self.avg_decode_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_execute_time is not None:
            result['AvgExecuteTime'] = self.avg_execute_time
        if self.avg_executor_rpc_count is not None:
            result['AvgExecutorRpcCount'] = self.avg_executor_rpc_count
        if self.avg_expected_worker_count is not None:
            result['AvgExpectedWorkerCount'] = self.avg_expected_worker_count
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.avg_logical_reads is not None:
            result['AvgLogicalReads'] = self.avg_logical_reads
        if self.avg_memstore_read_rows is not None:
            result['AvgMemstoreReadRows'] = self.avg_memstore_read_rows
        if self.avg_net_time is not None:
            result['AvgNetTime'] = self.avg_net_time
        if self.avg_net_wait_time is not None:
            result['AvgNetWaitTime'] = self.avg_net_wait_time
        if self.avg_partition_count is not None:
            result['AvgPartitionCount'] = self.avg_partition_count
        if self.avg_queue_time is not None:
            result['AvgQueueTime'] = self.avg_queue_time
        if self.avg_return_rows is not None:
            result['AvgReturnRows'] = self.avg_return_rows
        if self.avg_row_cache_hit is not None:
            result['AvgRowCacheHit'] = self.avg_row_cache_hit
        if self.avg_rpc_count is not None:
            result['AvgRpcCount'] = self.avg_rpc_count
        if self.avg_schedule_time is not None:
            result['AvgScheduleTime'] = self.avg_schedule_time
        if self.avg_ssstore_read_rows is not None:
            result['AvgSsstoreReadRows'] = self.avg_ssstore_read_rows
        if self.avg_used_worker_count is not None:
            result['AvgUsedWorkerCount'] = self.avg_used_worker_count
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.avg_wait_count is not None:
            result['AvgWaitCount'] = self.avg_wait_count
        if self.avg_wait_time is not None:
            result['AvgWaitTime'] = self.avg_wait_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dist_plan_percentage is not None:
            result['DistPlanPercentage'] = self.dist_plan_percentage
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.fail_percentage is not None:
            result['FailPercentage'] = self.fail_percentage
        if self.local_plan_percentage is not None:
            result['LocalPlanPercentage'] = self.local_plan_percentage
        if self.max_affected_rows is not None:
            result['MaxAffectedRows'] = self.max_affected_rows
        if self.max_application_wait_time is not None:
            result['MaxApplicationWaitTime'] = self.max_application_wait_time
        if self.max_concurrency_wait_time is not None:
            result['MaxConcurrencyWaitTime'] = self.max_concurrency_wait_time
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_disk_reads is not None:
            result['MaxDiskReads'] = self.max_disk_reads
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.max_return_rows is not None:
            result['MaxReturnRows'] = self.max_return_rows
        if self.max_user_io_wait_time is not None:
            result['MaxUserIoWaitTime'] = self.max_user_io_wait_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.miss_plan_percentage is not None:
            result['MissPlanPercentage'] = self.miss_plan_percentage
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.remote_plan_percentage is not None:
            result['RemotePlanPercentage'] = self.remote_plan_percentage
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.ret_code_4012count is not None:
            result['RetCode4012Count'] = self.ret_code_4012count
        if self.ret_code_4013count is not None:
            result['RetCode4013Count'] = self.ret_code_4013count
        if self.ret_code_5001count is not None:
            result['RetCode5001Count'] = self.ret_code_5001count
        if self.ret_code_5024count is not None:
            result['RetCode5024Count'] = self.ret_code_5024count
        if self.ret_code_5167count is not None:
            result['RetCode5167Count'] = self.ret_code_5167count
        if self.ret_code_5217count is not None:
            result['RetCode5217Count'] = self.ret_code_5217count
        if self.ret_code_6002count is not None:
            result['RetCode6002Count'] = self.ret_code_6002count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.server is not None:
            result['Server'] = self.server
        if self.strong_consistency_percentage is not None:
            result['StrongConsistencyPercentage'] = self.strong_consistency_percentage
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.sum_logical_reads is not None:
            result['SumLogicalReads'] = self.sum_logical_reads
        if self.sum_wait_time is not None:
            result['SumWaitTime'] = self.sum_wait_time
        if self.table_scan_percentage is not None:
            result['TableScanPercentage'] = self.table_scan_percentage
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.weak_consistency_percentage is not None:
            result['WeakConsistencyPercentage'] = self.weak_consistency_percentage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgAffectedRows') is not None:
            self.avg_affected_rows = m.get('AvgAffectedRows')
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBlockCacheHit') is not None:
            self.avg_block_cache_hit = m.get('AvgBlockCacheHit')
        if m.get('AvgBlockIndexCacheHit') is not None:
            self.avg_block_index_cache_hit = m.get('AvgBlockIndexCacheHit')
        if m.get('AvgBloomFilterCacheHit') is not None:
            self.avg_bloom_filter_cache_hit = m.get('AvgBloomFilterCacheHit')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDecodeTime') is not None:
            self.avg_decode_time = m.get('AvgDecodeTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgExecuteTime') is not None:
            self.avg_execute_time = m.get('AvgExecuteTime')
        if m.get('AvgExecutorRpcCount') is not None:
            self.avg_executor_rpc_count = m.get('AvgExecutorRpcCount')
        if m.get('AvgExpectedWorkerCount') is not None:
            self.avg_expected_worker_count = m.get('AvgExpectedWorkerCount')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('AvgLogicalReads') is not None:
            self.avg_logical_reads = m.get('AvgLogicalReads')
        if m.get('AvgMemstoreReadRows') is not None:
            self.avg_memstore_read_rows = m.get('AvgMemstoreReadRows')
        if m.get('AvgNetTime') is not None:
            self.avg_net_time = m.get('AvgNetTime')
        if m.get('AvgNetWaitTime') is not None:
            self.avg_net_wait_time = m.get('AvgNetWaitTime')
        if m.get('AvgPartitionCount') is not None:
            self.avg_partition_count = m.get('AvgPartitionCount')
        if m.get('AvgQueueTime') is not None:
            self.avg_queue_time = m.get('AvgQueueTime')
        if m.get('AvgReturnRows') is not None:
            self.avg_return_rows = m.get('AvgReturnRows')
        if m.get('AvgRowCacheHit') is not None:
            self.avg_row_cache_hit = m.get('AvgRowCacheHit')
        if m.get('AvgRpcCount') is not None:
            self.avg_rpc_count = m.get('AvgRpcCount')
        if m.get('AvgScheduleTime') is not None:
            self.avg_schedule_time = m.get('AvgScheduleTime')
        if m.get('AvgSsstoreReadRows') is not None:
            self.avg_ssstore_read_rows = m.get('AvgSsstoreReadRows')
        if m.get('AvgUsedWorkerCount') is not None:
            self.avg_used_worker_count = m.get('AvgUsedWorkerCount')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('AvgWaitCount') is not None:
            self.avg_wait_count = m.get('AvgWaitCount')
        if m.get('AvgWaitTime') is not None:
            self.avg_wait_time = m.get('AvgWaitTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DistPlanPercentage') is not None:
            self.dist_plan_percentage = m.get('DistPlanPercentage')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('FailPercentage') is not None:
            self.fail_percentage = m.get('FailPercentage')
        if m.get('LocalPlanPercentage') is not None:
            self.local_plan_percentage = m.get('LocalPlanPercentage')
        if m.get('MaxAffectedRows') is not None:
            self.max_affected_rows = m.get('MaxAffectedRows')
        if m.get('MaxApplicationWaitTime') is not None:
            self.max_application_wait_time = m.get('MaxApplicationWaitTime')
        if m.get('MaxConcurrencyWaitTime') is not None:
            self.max_concurrency_wait_time = m.get('MaxConcurrencyWaitTime')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxDiskReads') is not None:
            self.max_disk_reads = m.get('MaxDiskReads')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MaxReturnRows') is not None:
            self.max_return_rows = m.get('MaxReturnRows')
        if m.get('MaxUserIoWaitTime') is not None:
            self.max_user_io_wait_time = m.get('MaxUserIoWaitTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MissPlanPercentage') is not None:
            self.miss_plan_percentage = m.get('MissPlanPercentage')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('RemotePlanPercentage') is not None:
            self.remote_plan_percentage = m.get('RemotePlanPercentage')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetCode4012Count') is not None:
            self.ret_code_4012count = m.get('RetCode4012Count')
        if m.get('RetCode4013Count') is not None:
            self.ret_code_4013count = m.get('RetCode4013Count')
        if m.get('RetCode5001Count') is not None:
            self.ret_code_5001count = m.get('RetCode5001Count')
        if m.get('RetCode5024Count') is not None:
            self.ret_code_5024count = m.get('RetCode5024Count')
        if m.get('RetCode5167Count') is not None:
            self.ret_code_5167count = m.get('RetCode5167Count')
        if m.get('RetCode5217Count') is not None:
            self.ret_code_5217count = m.get('RetCode5217Count')
        if m.get('RetCode6002Count') is not None:
            self.ret_code_6002count = m.get('RetCode6002Count')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('StrongConsistencyPercentage') is not None:
            self.strong_consistency_percentage = m.get('StrongConsistencyPercentage')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('SumLogicalReads') is not None:
            self.sum_logical_reads = m.get('SumLogicalReads')
        if m.get('SumWaitTime') is not None:
            self.sum_wait_time = m.get('SumWaitTime')
        if m.get('TableScanPercentage') is not None:
            self.table_scan_percentage = m.get('TableScanPercentage')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WeakConsistencyPercentage') is not None:
            self.weak_consistency_percentage = m.get('WeakConsistencyPercentage')
        return self


class DescribeOasSQLHistoryListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of SQL execution history.
        self.data = data  # type: list[DescribeOasSQLHistoryListResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasSQLHistoryListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOasSQLHistoryListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOasSQLHistoryListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasSQLHistoryListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasSQLHistoryListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasSQLHistoryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasSQLPlansRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, dynamic_sql=None, end_time=None, instance_id=None,
                 sql_id=None, start_time=None, tenant_id=None):
        # Supported language. Valid values:
        # - zh-CN: Chinese
        # - en-US: English
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of querying the SQL execution plan.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        # The start time of querying the SQL execution plan.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLPlansRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasSQLPlansResponseBodyDataPlanExplain(TeaModel):
    def __init__(self, plan_json_string=None):
        # JSON string of the SQL execution plan.
        self.plan_json_string = plan_json_string  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLPlansResponseBodyDataPlanExplain, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.plan_json_string is not None:
            result['PlanJsonString'] = self.plan_json_string
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PlanJsonString') is not None:
            self.plan_json_string = m.get('PlanJsonString')
        return self


class DescribeOasSQLPlansResponseBodyDataPlans(TeaModel):
    def __init__(self, avg_application_wait_time=None, avg_buffer_gets=None, avg_concurrency_wait_time=None,
                 avg_cpu_time=None, avg_disk_reads=None, avg_disk_writes=None, avg_elapsed_time=None, avg_row_processed=None,
                 avg_user_io_wait_time=None, collect_time_us=None, delayed_large_query_percentage=None, exec_ps=None, executions=None,
                 first_load_time=None, first_load_time_us=None, hit_diagnosis=None, hit_percentage=None,
                 large_query_percentage=None, merged_version=None, ob_db_id=None, ob_server_id=None, outline_data=None, outline_id=None,
                 plan_hash=None, plan_id=None, plan_size=None, plan_type=None, plan_union_hash=None, schema_version=None,
                 server=None, server_id=None, sql_id=None, table_scan=None, timeout_percentage=None, uid=None):
        # Average Application event waiting time (in milliseconds) during the execution period.
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        # Average cache read count during the execution period.
        self.avg_buffer_gets = avg_buffer_gets  # type: float
        # Average Concurrency event waiting time (in milliseconds) during the execution period.
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        # Average CPU time (in milliseconds) during the execution period.
        self.avg_cpu_time = avg_cpu_time  # type: float
        # The average physical read count during the execution period.
        self.avg_disk_reads = avg_disk_reads  # type: float
        # The average physical write count during the execution period.
        self.avg_disk_writes = avg_disk_writes  # type: float
        # Average interval waiting time (in milliseconds) during the execution period.
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        # Average row processing waiting time (in milliseconds) during the execution period.
        self.avg_row_processed = avg_row_processed  # type: float
        # Average UserIo event waiting time (in milliseconds) during the execution period.
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        # Collection time.
        self.collect_time_us = collect_time_us  # type: long
        # Percentage of delayed long-running queries.
        self.delayed_large_query_percentage = delayed_large_query_percentage  # type: float
        # The average execution count per second during the execution period.
        self.exec_ps = exec_ps  # type: float
        # The total number of executions during the execution period.
        self.executions = executions  # type: long
        # First time to load the plan.
        self.first_load_time = first_load_time  # type: str
        # First loading time.
        self.first_load_time_us = first_load_time_us  # type: long
        # Whether to hit the diagnosis.
        self.hit_diagnosis = hit_diagnosis  # type: bool
        # Hit rate.
        self.hit_percentage = hit_percentage  # type: float
        # Percentage of completed long-running queries.
        self.large_query_percentage = large_query_percentage  # type: float
        # Merge version.
        self.merged_version = merged_version  # type: long
        # Database ID.
        self.ob_db_id = ob_db_id  # type: long
        # Server ID.
        self.ob_server_id = ob_server_id  # type: long
        # The outline_data parameter of the SQL execution plan.
        self.outline_data = outline_data  # type: str
        # Outline ID.
        self.outline_id = outline_id  # type: long
        # The internal identifier of the SQL execution plan in the diagnostic system.
        self.plan_hash = plan_hash  # type: str
        # The ID of the plan.
        self.plan_id = plan_id  # type: long
        # Plan size.
        self.plan_size = plan_size  # type: long
        # Plan type, including LOCAL, REMOTE, DIST.
        self.plan_type = plan_type  # type: str
        # The internal unique identifier of the SQL execution plan in the diagnostic system.
        self.plan_union_hash = plan_union_hash  # type: str
        # Schema version.
        self.schema_version = schema_version  # type: long
        # The server where the SQL is executed.
        self.server = server  # type: str
        # The ID of the backend server instance.
        self.server_id = server_id  # type: long
        self.sql_id = sql_id  # type: str
        # Whether a full table scan is performed.
        self.table_scan = table_scan  # type: bool
        # Percentage of timeouts.
        self.timeout_percentage = timeout_percentage  # type: float
        # The unique identifier of the plan.
        self.uid = uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSQLPlansResponseBodyDataPlans, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_buffer_gets is not None:
            result['AvgBufferGets'] = self.avg_buffer_gets
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_disk_writes is not None:
            result['AvgDiskWrites'] = self.avg_disk_writes
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_row_processed is not None:
            result['AvgRowProcessed'] = self.avg_row_processed
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.collect_time_us is not None:
            result['CollectTimeUs'] = self.collect_time_us
        if self.delayed_large_query_percentage is not None:
            result['DelayedLargeQueryPercentage'] = self.delayed_large_query_percentage
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.first_load_time is not None:
            result['FirstLoadTime'] = self.first_load_time
        if self.first_load_time_us is not None:
            result['FirstLoadTimeUs'] = self.first_load_time_us
        if self.hit_diagnosis is not None:
            result['HitDiagnosis'] = self.hit_diagnosis
        if self.hit_percentage is not None:
            result['HitPercentage'] = self.hit_percentage
        if self.large_query_percentage is not None:
            result['LargeQueryPercentage'] = self.large_query_percentage
        if self.merged_version is not None:
            result['MergedVersion'] = self.merged_version
        if self.ob_db_id is not None:
            result['ObDbId'] = self.ob_db_id
        if self.ob_server_id is not None:
            result['ObServerId'] = self.ob_server_id
        if self.outline_data is not None:
            result['OutlineData'] = self.outline_data
        if self.outline_id is not None:
            result['OutlineId'] = self.outline_id
        if self.plan_hash is not None:
            result['PlanHash'] = self.plan_hash
        if self.plan_id is not None:
            result['PlanId'] = self.plan_id
        if self.plan_size is not None:
            result['PlanSize'] = self.plan_size
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.plan_union_hash is not None:
            result['PlanUnionHash'] = self.plan_union_hash
        if self.schema_version is not None:
            result['SchemaVersion'] = self.schema_version
        if self.server is not None:
            result['Server'] = self.server
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.table_scan is not None:
            result['TableScan'] = self.table_scan
        if self.timeout_percentage is not None:
            result['TimeoutPercentage'] = self.timeout_percentage
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBufferGets') is not None:
            self.avg_buffer_gets = m.get('AvgBufferGets')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgDiskWrites') is not None:
            self.avg_disk_writes = m.get('AvgDiskWrites')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgRowProcessed') is not None:
            self.avg_row_processed = m.get('AvgRowProcessed')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('CollectTimeUs') is not None:
            self.collect_time_us = m.get('CollectTimeUs')
        if m.get('DelayedLargeQueryPercentage') is not None:
            self.delayed_large_query_percentage = m.get('DelayedLargeQueryPercentage')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FirstLoadTime') is not None:
            self.first_load_time = m.get('FirstLoadTime')
        if m.get('FirstLoadTimeUs') is not None:
            self.first_load_time_us = m.get('FirstLoadTimeUs')
        if m.get('HitDiagnosis') is not None:
            self.hit_diagnosis = m.get('HitDiagnosis')
        if m.get('HitPercentage') is not None:
            self.hit_percentage = m.get('HitPercentage')
        if m.get('LargeQueryPercentage') is not None:
            self.large_query_percentage = m.get('LargeQueryPercentage')
        if m.get('MergedVersion') is not None:
            self.merged_version = m.get('MergedVersion')
        if m.get('ObDbId') is not None:
            self.ob_db_id = m.get('ObDbId')
        if m.get('ObServerId') is not None:
            self.ob_server_id = m.get('ObServerId')
        if m.get('OutlineData') is not None:
            self.outline_data = m.get('OutlineData')
        if m.get('OutlineId') is not None:
            self.outline_id = m.get('OutlineId')
        if m.get('PlanHash') is not None:
            self.plan_hash = m.get('PlanHash')
        if m.get('PlanId') is not None:
            self.plan_id = m.get('PlanId')
        if m.get('PlanSize') is not None:
            self.plan_size = m.get('PlanSize')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('PlanUnionHash') is not None:
            self.plan_union_hash = m.get('PlanUnionHash')
        if m.get('SchemaVersion') is not None:
            self.schema_version = m.get('SchemaVersion')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('TableScan') is not None:
            self.table_scan = m.get('TableScan')
        if m.get('TimeoutPercentage') is not None:
            self.timeout_percentage = m.get('TimeoutPercentage')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DescribeOasSQLPlansResponseBodyData(TeaModel):
    def __init__(self, avg_cpu_time=None, bounded=None, executions=None, first_load_time=None, hit_diagnosis=None,
                 hit_percentage=None, merged_version=None, plan_explain=None, plan_hash=None, plan_type=None, plan_union_hash=None,
                 plans=None, query_sql=None):
        # Average CPU time (in milliseconds) during the execution period.
        self.avg_cpu_time = avg_cpu_time  # type: float
        # Whether to bind the execution plan.
        self.bounded = bounded  # type: bool
        # Execution count.
        self.executions = executions  # type: long
        # First loading time.
        self.first_load_time = first_load_time  # type: str
        # Whether to hit the diagnosis.
        self.hit_diagnosis = hit_diagnosis  # type: bool
        # Hit rate.
        self.hit_percentage = hit_percentage  # type: float
        # Merge version.
        self.merged_version = merged_version  # type: long
        # Execution plan.
        self.plan_explain = plan_explain  # type: DescribeOasSQLPlansResponseBodyDataPlanExplain
        # The internal identifier of the SQL execution plan in the diagnostic system.
        self.plan_hash = plan_hash  # type: str
        # Execution plan type.
        self.plan_type = plan_type  # type: str
        # The internal unique identifier of the SQL execution plan in the diagnostic system.
        self.plan_union_hash = plan_union_hash  # type: str
        # The list of the execution plan.
        self.plans = plans  # type: list[DescribeOasSQLPlansResponseBodyDataPlans]
        # The SQL for the query.
        self.query_sql = query_sql  # type: str

    def validate(self):
        if self.plan_explain:
            self.plan_explain.validate()
        if self.plans:
            for k in self.plans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasSQLPlansResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.bounded is not None:
            result['Bounded'] = self.bounded
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.first_load_time is not None:
            result['FirstLoadTime'] = self.first_load_time
        if self.hit_diagnosis is not None:
            result['HitDiagnosis'] = self.hit_diagnosis
        if self.hit_percentage is not None:
            result['HitPercentage'] = self.hit_percentage
        if self.merged_version is not None:
            result['MergedVersion'] = self.merged_version
        if self.plan_explain is not None:
            result['PlanExplain'] = self.plan_explain.to_map()
        if self.plan_hash is not None:
            result['PlanHash'] = self.plan_hash
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.plan_union_hash is not None:
            result['PlanUnionHash'] = self.plan_union_hash
        result['Plans'] = []
        if self.plans is not None:
            for k in self.plans:
                result['Plans'].append(k.to_map() if k else None)
        if self.query_sql is not None:
            result['QuerySql'] = self.query_sql
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('Bounded') is not None:
            self.bounded = m.get('Bounded')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FirstLoadTime') is not None:
            self.first_load_time = m.get('FirstLoadTime')
        if m.get('HitDiagnosis') is not None:
            self.hit_diagnosis = m.get('HitDiagnosis')
        if m.get('HitPercentage') is not None:
            self.hit_percentage = m.get('HitPercentage')
        if m.get('MergedVersion') is not None:
            self.merged_version = m.get('MergedVersion')
        if m.get('PlanExplain') is not None:
            temp_model = DescribeOasSQLPlansResponseBodyDataPlanExplain()
            self.plan_explain = temp_model.from_map(m['PlanExplain'])
        if m.get('PlanHash') is not None:
            self.plan_hash = m.get('PlanHash')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('PlanUnionHash') is not None:
            self.plan_union_hash = m.get('PlanUnionHash')
        self.plans = []
        if m.get('Plans') is not None:
            for k in m.get('Plans'):
                temp_model = DescribeOasSQLPlansResponseBodyDataPlans()
                self.plans.append(temp_model.from_map(k))
        if m.get('QuerySql') is not None:
            self.query_sql = m.get('QuerySql')
        return self


class DescribeOasSQLPlansResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of SQL execution plan.
        self.data = data  # type: list[DescribeOasSQLPlansResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasSQLPlansResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOasSQLPlansResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOasSQLPlansResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasSQLPlansResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasSQLPlansResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasSQLPlansResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasSlowSQLListRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, dynamic_sql=None, end_time=None, filter_condition=None,
                 instance_id=None, merge_dynamic_sql=None, node_ip=None, search_key_word=None, search_param=None,
                 search_rule=None, search_value=None, sql_id=None, sql_text_length=None, start_time=None, tenant_id=None):
        # The language of the response.
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of querying slow SQL historical parameters.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
        self.filter_condition = filter_condition  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        self.merge_dynamic_sql = merge_dynamic_sql  # type: bool
        # The IP of the database node.
        self.node_ip = node_ip  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_param = search_param  # type: str
        # The search rule.
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # SQL ID, the unique identifier of the SQL.
        self.sql_id = sql_id  # type: str
        # Max length of the returned SQL text.
        self.sql_text_length = sql_text_length  # type: long
        # The start time of querying slow SQL historical parameters.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSlowSQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.merge_dynamic_sql is not None:
            result['MergeDynamicSql'] = self.merge_dynamic_sql
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_param is not None:
            result['SearchParam'] = self.search_param
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_length is not None:
            result['SqlTextLength'] = self.sql_text_length
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MergeDynamicSql') is not None:
            self.merge_dynamic_sql = m.get('MergeDynamicSql')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParam') is not None:
            self.search_param = m.get('SearchParam')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextLength') is not None:
            self.sql_text_length = m.get('SqlTextLength')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasSlowSQLListResponseBodyDataSqlList(TeaModel):
    def __init__(self, avg_affected_rows=None, avg_application_wait_time=None, avg_block_cache_hit=None,
                 avg_block_index_cache_hit=None, avg_bloom_filter_cache_hit=None, avg_concurrency_wait_time=None, avg_cpu_time=None,
                 avg_db_time=None, avg_decode_time=None, avg_disk_reads=None, avg_elapsed_time=None, avg_execute_time=None,
                 avg_executor_rpc_count=None, avg_expected_worker_count=None, avg_get_plan_time=None, avg_logical_reads=None,
                 avg_memstore_read_rows=None, avg_net_time=None, avg_net_wait_time=None, avg_partition_count=None, avg_queue_time=None,
                 avg_return_rows=None, avg_row_cache_hit=None, avg_rpc_count=None, avg_schedule_time=None,
                 avg_ssstore_read_rows=None, avg_used_worker_count=None, avg_user_io_wait_time=None, avg_wait_count=None,
                 avg_wait_time=None, client_ip=None, db_name=None, dist_plan_percentage=None, exec_ps=None, executions=None,
                 fail_count=None, fail_percentage=None, inner=None, local_plan_percentage=None, max_affected_rows=None,
                 max_application_wait_time=None, max_concurrency_wait_time=None, max_cpu_time=None, max_disk_reads=None,
                 max_elapsed_time=None, max_return_rows=None, max_user_io_wait_time=None, max_wait_time=None,
                 miss_plan_percentage=None, miss_plans=None, remote_plan_percentage=None, remote_plans=None, ret_code_4012count=None,
                 ret_code_4013count=None, ret_code_5001count=None, ret_code_5024count=None, ret_code_5167count=None,
                 ret_code_5217count=None, ret_code_6002count=None, retry_count=None, rpc_count=None, server=None, server_ip=None,
                 server_port=None, sql_id=None, sql_text_short=None, sql_type=None, strong_consistency_percentage=None,
                 sum_db_time=None, sum_elapsed_time=None, sum_logical_reads=None, sum_wait_time=None,
                 table_scan_percentage=None, total_wait_time=None, user_name=None, wait_event=None, weak_consistency_percentage=None):
        self.avg_affected_rows = avg_affected_rows  # type: float
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        self.avg_block_cache_hit = avg_block_cache_hit  # type: float
        self.avg_block_index_cache_hit = avg_block_index_cache_hit  # type: float
        self.avg_bloom_filter_cache_hit = avg_bloom_filter_cache_hit  # type: float
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        self.avg_decode_time = avg_decode_time  # type: float
        self.avg_disk_reads = avg_disk_reads  # type: float
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        self.avg_execute_time = avg_execute_time  # type: float
        self.avg_executor_rpc_count = avg_executor_rpc_count  # type: float
        self.avg_expected_worker_count = avg_expected_worker_count  # type: float
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        self.avg_logical_reads = avg_logical_reads  # type: float
        self.avg_memstore_read_rows = avg_memstore_read_rows  # type: float
        self.avg_net_time = avg_net_time  # type: float
        self.avg_net_wait_time = avg_net_wait_time  # type: float
        self.avg_partition_count = avg_partition_count  # type: float
        self.avg_queue_time = avg_queue_time  # type: float
        self.avg_return_rows = avg_return_rows  # type: float
        self.avg_row_cache_hit = avg_row_cache_hit  # type: float
        self.avg_rpc_count = avg_rpc_count  # type: float
        self.avg_schedule_time = avg_schedule_time  # type: float
        self.avg_ssstore_read_rows = avg_ssstore_read_rows  # type: float
        self.avg_used_worker_count = avg_used_worker_count  # type: float
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        self.avg_wait_count = avg_wait_count  # type: float
        self.avg_wait_time = avg_wait_time  # type: float
        self.client_ip = client_ip  # type: str
        self.db_name = db_name  # type: str
        self.dist_plan_percentage = dist_plan_percentage  # type: float
        self.exec_ps = exec_ps  # type: float
        self.executions = executions  # type: float
        self.fail_count = fail_count  # type: float
        self.fail_percentage = fail_percentage  # type: float
        self.inner = inner  # type: bool
        self.local_plan_percentage = local_plan_percentage  # type: float
        self.max_affected_rows = max_affected_rows  # type: float
        self.max_application_wait_time = max_application_wait_time  # type: float
        self.max_concurrency_wait_time = max_concurrency_wait_time  # type: float
        self.max_cpu_time = max_cpu_time  # type: float
        self.max_disk_reads = max_disk_reads  # type: float
        self.max_elapsed_time = max_elapsed_time  # type: float
        self.max_return_rows = max_return_rows  # type: float
        self.max_user_io_wait_time = max_user_io_wait_time  # type: float
        self.max_wait_time = max_wait_time  # type: float
        self.miss_plan_percentage = miss_plan_percentage  # type: float
        self.miss_plans = miss_plans  # type: float
        self.remote_plan_percentage = remote_plan_percentage  # type: float
        self.remote_plans = remote_plans  # type: float
        self.ret_code_4012count = ret_code_4012count  # type: long
        self.ret_code_4013count = ret_code_4013count  # type: long
        self.ret_code_5001count = ret_code_5001count  # type: long
        self.ret_code_5024count = ret_code_5024count  # type: long
        self.ret_code_5167count = ret_code_5167count  # type: long
        self.ret_code_5217count = ret_code_5217count  # type: long
        self.ret_code_6002count = ret_code_6002count  # type: long
        self.retry_count = retry_count  # type: float
        self.rpc_count = rpc_count  # type: float
        self.server = server  # type: str
        self.server_ip = server_ip  # type: str
        self.server_port = server_port  # type: long
        self.sql_id = sql_id  # type: str
        self.sql_text_short = sql_text_short  # type: str
        self.sql_type = sql_type  # type: str
        self.strong_consistency_percentage = strong_consistency_percentage  # type: float
        self.sum_db_time = sum_db_time  # type: float
        self.sum_elapsed_time = sum_elapsed_time  # type: float
        self.sum_logical_reads = sum_logical_reads  # type: float
        self.sum_wait_time = sum_wait_time  # type: float
        self.table_scan_percentage = table_scan_percentage  # type: float
        self.total_wait_time = total_wait_time  # type: float
        self.user_name = user_name  # type: str
        self.wait_event = wait_event  # type: str
        self.weak_consistency_percentage = weak_consistency_percentage  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasSlowSQLListResponseBodyDataSqlList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_affected_rows is not None:
            result['AvgAffectedRows'] = self.avg_affected_rows
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_block_cache_hit is not None:
            result['AvgBlockCacheHit'] = self.avg_block_cache_hit
        if self.avg_block_index_cache_hit is not None:
            result['AvgBlockIndexCacheHit'] = self.avg_block_index_cache_hit
        if self.avg_bloom_filter_cache_hit is not None:
            result['AvgBloomFilterCacheHit'] = self.avg_bloom_filter_cache_hit
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_decode_time is not None:
            result['AvgDecodeTime'] = self.avg_decode_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_execute_time is not None:
            result['AvgExecuteTime'] = self.avg_execute_time
        if self.avg_executor_rpc_count is not None:
            result['AvgExecutorRpcCount'] = self.avg_executor_rpc_count
        if self.avg_expected_worker_count is not None:
            result['AvgExpectedWorkerCount'] = self.avg_expected_worker_count
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.avg_logical_reads is not None:
            result['AvgLogicalReads'] = self.avg_logical_reads
        if self.avg_memstore_read_rows is not None:
            result['AvgMemstoreReadRows'] = self.avg_memstore_read_rows
        if self.avg_net_time is not None:
            result['AvgNetTime'] = self.avg_net_time
        if self.avg_net_wait_time is not None:
            result['AvgNetWaitTime'] = self.avg_net_wait_time
        if self.avg_partition_count is not None:
            result['AvgPartitionCount'] = self.avg_partition_count
        if self.avg_queue_time is not None:
            result['AvgQueueTime'] = self.avg_queue_time
        if self.avg_return_rows is not None:
            result['AvgReturnRows'] = self.avg_return_rows
        if self.avg_row_cache_hit is not None:
            result['AvgRowCacheHit'] = self.avg_row_cache_hit
        if self.avg_rpc_count is not None:
            result['AvgRpcCount'] = self.avg_rpc_count
        if self.avg_schedule_time is not None:
            result['AvgScheduleTime'] = self.avg_schedule_time
        if self.avg_ssstore_read_rows is not None:
            result['AvgSsstoreReadRows'] = self.avg_ssstore_read_rows
        if self.avg_used_worker_count is not None:
            result['AvgUsedWorkerCount'] = self.avg_used_worker_count
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.avg_wait_count is not None:
            result['AvgWaitCount'] = self.avg_wait_count
        if self.avg_wait_time is not None:
            result['AvgWaitTime'] = self.avg_wait_time
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dist_plan_percentage is not None:
            result['DistPlanPercentage'] = self.dist_plan_percentage
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.fail_percentage is not None:
            result['FailPercentage'] = self.fail_percentage
        if self.inner is not None:
            result['Inner'] = self.inner
        if self.local_plan_percentage is not None:
            result['LocalPlanPercentage'] = self.local_plan_percentage
        if self.max_affected_rows is not None:
            result['MaxAffectedRows'] = self.max_affected_rows
        if self.max_application_wait_time is not None:
            result['MaxApplicationWaitTime'] = self.max_application_wait_time
        if self.max_concurrency_wait_time is not None:
            result['MaxConcurrencyWaitTime'] = self.max_concurrency_wait_time
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_disk_reads is not None:
            result['MaxDiskReads'] = self.max_disk_reads
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.max_return_rows is not None:
            result['MaxReturnRows'] = self.max_return_rows
        if self.max_user_io_wait_time is not None:
            result['MaxUserIoWaitTime'] = self.max_user_io_wait_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.miss_plan_percentage is not None:
            result['MissPlanPercentage'] = self.miss_plan_percentage
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.remote_plan_percentage is not None:
            result['RemotePlanPercentage'] = self.remote_plan_percentage
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.ret_code_4012count is not None:
            result['RetCode4012Count'] = self.ret_code_4012count
        if self.ret_code_4013count is not None:
            result['RetCode4013Count'] = self.ret_code_4013count
        if self.ret_code_5001count is not None:
            result['RetCode5001Count'] = self.ret_code_5001count
        if self.ret_code_5024count is not None:
            result['RetCode5024Count'] = self.ret_code_5024count
        if self.ret_code_5167count is not None:
            result['RetCode5167Count'] = self.ret_code_5167count
        if self.ret_code_5217count is not None:
            result['RetCode5217Count'] = self.ret_code_5217count
        if self.ret_code_6002count is not None:
            result['RetCode6002Count'] = self.ret_code_6002count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.rpc_count is not None:
            result['RpcCount'] = self.rpc_count
        if self.server is not None:
            result['Server'] = self.server
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.server_port is not None:
            result['ServerPort'] = self.server_port
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.strong_consistency_percentage is not None:
            result['StrongConsistencyPercentage'] = self.strong_consistency_percentage
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.sum_logical_reads is not None:
            result['SumLogicalReads'] = self.sum_logical_reads
        if self.sum_wait_time is not None:
            result['SumWaitTime'] = self.sum_wait_time
        if self.table_scan_percentage is not None:
            result['TableScanPercentage'] = self.table_scan_percentage
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.wait_event is not None:
            result['WaitEvent'] = self.wait_event
        if self.weak_consistency_percentage is not None:
            result['WeakConsistencyPercentage'] = self.weak_consistency_percentage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgAffectedRows') is not None:
            self.avg_affected_rows = m.get('AvgAffectedRows')
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBlockCacheHit') is not None:
            self.avg_block_cache_hit = m.get('AvgBlockCacheHit')
        if m.get('AvgBlockIndexCacheHit') is not None:
            self.avg_block_index_cache_hit = m.get('AvgBlockIndexCacheHit')
        if m.get('AvgBloomFilterCacheHit') is not None:
            self.avg_bloom_filter_cache_hit = m.get('AvgBloomFilterCacheHit')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgDecodeTime') is not None:
            self.avg_decode_time = m.get('AvgDecodeTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgExecuteTime') is not None:
            self.avg_execute_time = m.get('AvgExecuteTime')
        if m.get('AvgExecutorRpcCount') is not None:
            self.avg_executor_rpc_count = m.get('AvgExecutorRpcCount')
        if m.get('AvgExpectedWorkerCount') is not None:
            self.avg_expected_worker_count = m.get('AvgExpectedWorkerCount')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('AvgLogicalReads') is not None:
            self.avg_logical_reads = m.get('AvgLogicalReads')
        if m.get('AvgMemstoreReadRows') is not None:
            self.avg_memstore_read_rows = m.get('AvgMemstoreReadRows')
        if m.get('AvgNetTime') is not None:
            self.avg_net_time = m.get('AvgNetTime')
        if m.get('AvgNetWaitTime') is not None:
            self.avg_net_wait_time = m.get('AvgNetWaitTime')
        if m.get('AvgPartitionCount') is not None:
            self.avg_partition_count = m.get('AvgPartitionCount')
        if m.get('AvgQueueTime') is not None:
            self.avg_queue_time = m.get('AvgQueueTime')
        if m.get('AvgReturnRows') is not None:
            self.avg_return_rows = m.get('AvgReturnRows')
        if m.get('AvgRowCacheHit') is not None:
            self.avg_row_cache_hit = m.get('AvgRowCacheHit')
        if m.get('AvgRpcCount') is not None:
            self.avg_rpc_count = m.get('AvgRpcCount')
        if m.get('AvgScheduleTime') is not None:
            self.avg_schedule_time = m.get('AvgScheduleTime')
        if m.get('AvgSsstoreReadRows') is not None:
            self.avg_ssstore_read_rows = m.get('AvgSsstoreReadRows')
        if m.get('AvgUsedWorkerCount') is not None:
            self.avg_used_worker_count = m.get('AvgUsedWorkerCount')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('AvgWaitCount') is not None:
            self.avg_wait_count = m.get('AvgWaitCount')
        if m.get('AvgWaitTime') is not None:
            self.avg_wait_time = m.get('AvgWaitTime')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DistPlanPercentage') is not None:
            self.dist_plan_percentage = m.get('DistPlanPercentage')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('FailPercentage') is not None:
            self.fail_percentage = m.get('FailPercentage')
        if m.get('Inner') is not None:
            self.inner = m.get('Inner')
        if m.get('LocalPlanPercentage') is not None:
            self.local_plan_percentage = m.get('LocalPlanPercentage')
        if m.get('MaxAffectedRows') is not None:
            self.max_affected_rows = m.get('MaxAffectedRows')
        if m.get('MaxApplicationWaitTime') is not None:
            self.max_application_wait_time = m.get('MaxApplicationWaitTime')
        if m.get('MaxConcurrencyWaitTime') is not None:
            self.max_concurrency_wait_time = m.get('MaxConcurrencyWaitTime')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxDiskReads') is not None:
            self.max_disk_reads = m.get('MaxDiskReads')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MaxReturnRows') is not None:
            self.max_return_rows = m.get('MaxReturnRows')
        if m.get('MaxUserIoWaitTime') is not None:
            self.max_user_io_wait_time = m.get('MaxUserIoWaitTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MissPlanPercentage') is not None:
            self.miss_plan_percentage = m.get('MissPlanPercentage')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('RemotePlanPercentage') is not None:
            self.remote_plan_percentage = m.get('RemotePlanPercentage')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetCode4012Count') is not None:
            self.ret_code_4012count = m.get('RetCode4012Count')
        if m.get('RetCode4013Count') is not None:
            self.ret_code_4013count = m.get('RetCode4013Count')
        if m.get('RetCode5001Count') is not None:
            self.ret_code_5001count = m.get('RetCode5001Count')
        if m.get('RetCode5024Count') is not None:
            self.ret_code_5024count = m.get('RetCode5024Count')
        if m.get('RetCode5167Count') is not None:
            self.ret_code_5167count = m.get('RetCode5167Count')
        if m.get('RetCode5217Count') is not None:
            self.ret_code_5217count = m.get('RetCode5217Count')
        if m.get('RetCode6002Count') is not None:
            self.ret_code_6002count = m.get('RetCode6002Count')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RpcCount') is not None:
            self.rpc_count = m.get('RpcCount')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('ServerPort') is not None:
            self.server_port = m.get('ServerPort')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StrongConsistencyPercentage') is not None:
            self.strong_consistency_percentage = m.get('StrongConsistencyPercentage')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('SumLogicalReads') is not None:
            self.sum_logical_reads = m.get('SumLogicalReads')
        if m.get('SumWaitTime') is not None:
            self.sum_wait_time = m.get('SumWaitTime')
        if m.get('TableScanPercentage') is not None:
            self.table_scan_percentage = m.get('TableScanPercentage')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WaitEvent') is not None:
            self.wait_event = m.get('WaitEvent')
        if m.get('WeakConsistencyPercentage') is not None:
            self.weak_consistency_percentage = m.get('WeakConsistencyPercentage')
        return self


class DescribeOasSlowSQLListResponseBodyData(TeaModel):
    def __init__(self, avg_affected_rows=None, avg_application_wait_time=None, avg_block_cache_hit=None,
                 avg_block_index_cache_hit=None, avg_bloom_filter_cache_hit=None, avg_concurrency_wait_time=None, avg_cpu_time=None,
                 avg_db_time=None, avg_decode_time=None, avg_disk_reads=None, avg_elapsed_time=None, avg_execute_time=None,
                 avg_executor_rpc_count=None, avg_expected_worker_count=None, avg_get_plan_time=None, avg_logical_reads=None,
                 avg_memstore_read_rows=None, avg_net_time=None, avg_net_wait_time=None, avg_partition_count=None, avg_queue_time=None,
                 avg_return_rows=None, avg_row_cache_hit=None, avg_rpc_count=None, avg_schedule_time=None,
                 avg_ssstore_read_rows=None, avg_used_worker_count=None, avg_user_io_wait_time=None, avg_wait_count=None,
                 avg_wait_time=None, client_ip=None, db_name=None, dist_plan_percentage=None, dynamic_sql=None, exec_ps=None,
                 executions=None, fail_count=None, fail_percentage=None, inner=None, local_plan_percentage=None,
                 max_affected_rows=None, max_application_wait_time=None, max_concurrency_wait_time=None, max_cpu_time=None,
                 max_disk_reads=None, max_elapsed_time=None, max_return_rows=None, max_user_io_wait_time=None, max_wait_time=None,
                 miss_plan_percentage=None, miss_plans=None, remote_plan_percentage=None, remote_plans=None, ret_code_4012count=None,
                 ret_code_4013count=None, ret_code_5001count=None, ret_code_5024count=None, ret_code_5167count=None,
                 ret_code_5217count=None, ret_code_6002count=None, retry_count=None, rpc_count=None, server=None, server_ip=None,
                 server_port=None, sql_id=None, sql_list=None, sql_text_short=None, sql_type=None,
                 strong_consistency_percentage=None, sum_db_time=None, sum_elapsed_time=None, sum_logical_reads=None, sum_wait_time=None,
                 table_scan_percentage=None, total_wait_time=None, user_name=None, wait_event=None, weak_consistency_percentage=None):
        # Average updated rows during the execution period.
        self.avg_affected_rows = avg_affected_rows  # type: float
        # Average Application event wait time (in milliseconds) during the client waiting period.
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        # Average BlockCache hit count during the execution period.
        self.avg_block_cache_hit = avg_block_cache_hit  # type: float
        # Average BlockIndexCache hit count during the execution period.
        self.avg_block_index_cache_hit = avg_block_index_cache_hit  # type: float
        # Average BloomFilterCache hit count during the execution period.
        self.avg_bloom_filter_cache_hit = avg_bloom_filter_cache_hit  # type: float
        # Average Concurrency event wait time (in milliseconds) during the execution period.
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        # Average CPU time (in milliseconds) during the execution period.
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        # Average syntax parsing time (in milliseconds) during the execution period.
        self.avg_decode_time = avg_decode_time  # type: float
        # Average physical read count during the execution period.
        self.avg_disk_reads = avg_disk_reads  # type: float
        # Average response time (in milliseconds) during the execution period.
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        # Average plan execution time (in milliseconds) during the execution period.
        self.avg_execute_time = avg_execute_time  # type: float
        # Average number of RPC requests executed during the execution period.
        self.avg_executor_rpc_count = avg_executor_rpc_count  # type: float
        # Average degree of parallelism during the execution period.
        self.avg_expected_worker_count = avg_expected_worker_count  # type: float
        # Average plan generation time (in milliseconds) during the execution period.
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        # Average logical reads of the SQL during the execution period.
        self.avg_logical_reads = avg_logical_reads  # type: float
        # Strong consistent transaction percentage during the execution period.
        self.avg_memstore_read_rows = avg_memstore_read_rows  # type: float
        # Average network transmission time (in milliseconds) during the execution period.
        self.avg_net_time = avg_net_time  # type: float
        # Average network enqueue time (in milliseconds) during the network waiting period.
        self.avg_net_wait_time = avg_net_wait_time  # type: float
        # Average number of partition accessed during the execution period.
        self.avg_partition_count = avg_partition_count  # type: float
        # Average queueing time (in milliseconds) during the execution period.
        self.avg_queue_time = avg_queue_time  # type: float
        # Average number of rows returned during the execution period.
        self.avg_return_rows = avg_return_rows  # type: float
        # Average RowCache hit count during the execution period.
        self.avg_row_cache_hit = avg_row_cache_hit  # type: float
        # Average number of RPC sent during the execution.
        self.avg_rpc_count = avg_rpc_count  # type: float
        # Average Schedule event wait time (in milliseconds) during the scheduling period.
        self.avg_schedule_time = avg_schedule_time  # type: float
        # Eventually consistent transaction percentage during the execution period.
        self.avg_ssstore_read_rows = avg_ssstore_read_rows  # type: float
        # Average number of threads used of the SQL during the execution period.
        self.avg_used_worker_count = avg_used_worker_count  # type: float
        # Average UserIO event wait time (in milliseconds) during the execution period.
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        # Average number of waits during the execution period.
        self.avg_wait_count = avg_wait_count  # type: float
        # Average wait time (in milliseconds) during the execution period.
        self.avg_wait_time = avg_wait_time  # type: float
        # Client IP.
        self.client_ip = client_ip  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        # Distributed plan percentage during the execution period.
        self.dist_plan_percentage = dist_plan_percentage  # type: float
        self.dynamic_sql = dynamic_sql  # type: bool
        # Average execution count per second during the execution period.
        self.exec_ps = exec_ps  # type: float
        # Total number of executions during the execution period.
        self.executions = executions  # type: float
        # Average number of partition accessed during the execution period.
        self.fail_count = fail_count  # type: float
        # Error percentage during the execution period.
        self.fail_percentage = fail_percentage  # type: float
        # Whether an internal SQL.
        self.inner = inner  # type: bool
        # Local plan percentage during the execution period.
        self.local_plan_percentage = local_plan_percentage  # type: float
        # Max affected rows during the execution period.
        self.max_affected_rows = max_affected_rows  # type: float
        # Max Application event wait time (in milliseconds) during the execution period
        self.max_application_wait_time = max_application_wait_time  # type: float
        # Max Concurrency event wait time (in milliseconds) during the execution period
        self.max_concurrency_wait_time = max_concurrency_wait_time  # type: float
        # Max CPU time.
        self.max_cpu_time = max_cpu_time  # type: float
        # Max physical read count during the execution period.
        self.max_disk_reads = max_disk_reads  # type: float
        # Max response time during the execution period.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # Max returned rows during the execution period.
        self.max_return_rows = max_return_rows  # type: float
        # Max UserIO event wait time (in milliseconds) during the execution period.
        self.max_user_io_wait_time = max_user_io_wait_time  # type: float
        # Max wait time (in milliseconds) during the execution period.
        self.max_wait_time = max_wait_time  # type: float
        # Plan hit rage during the execution period.
        self.miss_plan_percentage = miss_plan_percentage  # type: float
        # Missed hit count of the execution plan during the execution period.
        self.miss_plans = miss_plans  # type: float
        # Remote plan percentage during the execution period.
        self.remote_plan_percentage = remote_plan_percentage  # type: float
        # Remote execution count during the execution period.
        self.remote_plans = remote_plans  # type: float
        # Number of occurrences of code 4012 during the execution period.
        self.ret_code_4012count = ret_code_4012count  # type: long
        # Number of occurrences of code 4013 during the execution period.
        self.ret_code_4013count = ret_code_4013count  # type: long
        # Number of occurrences of code 5001 during the execution period.
        self.ret_code_5001count = ret_code_5001count  # type: long
        # Number of occurrences of code 5024 during the execution period.
        self.ret_code_5024count = ret_code_5024count  # type: long
        # Number of occurrences of code 5167 during the execution period.
        self.ret_code_5167count = ret_code_5167count  # type: long
        # Number of occurrences of code 5217 during the execution period.
        self.ret_code_5217count = ret_code_5217count  # type: long
        # Number of occurrences of code 6002 during the execution period.
        self.ret_code_6002count = ret_code_6002count  # type: long
        # Total number of retries during the execution period.
        self.retry_count = retry_count  # type: float
        # RPC count during the execution period.
        self.rpc_count = rpc_count  # type: float
        # The server where the SQL is executed.
        self.server = server  # type: str
        # The IP address of the server.
        self.server_ip = server_ip  # type: str
        # The server port where the SQL is executed.
        self.server_port = server_port  # type: long
        # SQL ID.
        self.sql_id = sql_id  # type: str
        self.sql_list = sql_list  # type: list[DescribeOasSlowSQLListResponseBodyDataSqlList]
        # SQL text (the first 100 characters).
        self.sql_text_short = sql_text_short  # type: str
        # SQL type.
        self.sql_type = sql_type  # type: str
        # Strong consistent transaction percentage during the execution period.
        self.strong_consistency_percentage = strong_consistency_percentage  # type: float
        self.sum_db_time = sum_db_time  # type: float
        # Total response time (in milliseconds) during the execution period.
        self.sum_elapsed_time = sum_elapsed_time  # type: float
        # Total logical reads of the SQL during the execution period.
        self.sum_logical_reads = sum_logical_reads  # type: float
        # The total wait time (in milliseconds) during the internal waiting period.
        self.sum_wait_time = sum_wait_time  # type: float
        # Table scan percentage during the execution period.
        self.table_scan_percentage = table_scan_percentage  # type: float
        # Total wait time during the execution period.
        self.total_wait_time = total_wait_time  # type: float
        # Username.
        self.user_name = user_name  # type: str
        # Longest wait event during the execution period.
        self.wait_event = wait_event  # type: str
        # Eventually consistent transaction percentage during the execution period.
        self.weak_consistency_percentage = weak_consistency_percentage  # type: float

    def validate(self):
        if self.sql_list:
            for k in self.sql_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasSlowSQLListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_affected_rows is not None:
            result['AvgAffectedRows'] = self.avg_affected_rows
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_block_cache_hit is not None:
            result['AvgBlockCacheHit'] = self.avg_block_cache_hit
        if self.avg_block_index_cache_hit is not None:
            result['AvgBlockIndexCacheHit'] = self.avg_block_index_cache_hit
        if self.avg_bloom_filter_cache_hit is not None:
            result['AvgBloomFilterCacheHit'] = self.avg_bloom_filter_cache_hit
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_decode_time is not None:
            result['AvgDecodeTime'] = self.avg_decode_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_execute_time is not None:
            result['AvgExecuteTime'] = self.avg_execute_time
        if self.avg_executor_rpc_count is not None:
            result['AvgExecutorRpcCount'] = self.avg_executor_rpc_count
        if self.avg_expected_worker_count is not None:
            result['AvgExpectedWorkerCount'] = self.avg_expected_worker_count
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.avg_logical_reads is not None:
            result['AvgLogicalReads'] = self.avg_logical_reads
        if self.avg_memstore_read_rows is not None:
            result['AvgMemstoreReadRows'] = self.avg_memstore_read_rows
        if self.avg_net_time is not None:
            result['AvgNetTime'] = self.avg_net_time
        if self.avg_net_wait_time is not None:
            result['AvgNetWaitTime'] = self.avg_net_wait_time
        if self.avg_partition_count is not None:
            result['AvgPartitionCount'] = self.avg_partition_count
        if self.avg_queue_time is not None:
            result['AvgQueueTime'] = self.avg_queue_time
        if self.avg_return_rows is not None:
            result['AvgReturnRows'] = self.avg_return_rows
        if self.avg_row_cache_hit is not None:
            result['AvgRowCacheHit'] = self.avg_row_cache_hit
        if self.avg_rpc_count is not None:
            result['AvgRpcCount'] = self.avg_rpc_count
        if self.avg_schedule_time is not None:
            result['AvgScheduleTime'] = self.avg_schedule_time
        if self.avg_ssstore_read_rows is not None:
            result['AvgSsstoreReadRows'] = self.avg_ssstore_read_rows
        if self.avg_used_worker_count is not None:
            result['AvgUsedWorkerCount'] = self.avg_used_worker_count
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.avg_wait_count is not None:
            result['AvgWaitCount'] = self.avg_wait_count
        if self.avg_wait_time is not None:
            result['AvgWaitTime'] = self.avg_wait_time
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dist_plan_percentage is not None:
            result['DistPlanPercentage'] = self.dist_plan_percentage
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.fail_percentage is not None:
            result['FailPercentage'] = self.fail_percentage
        if self.inner is not None:
            result['Inner'] = self.inner
        if self.local_plan_percentage is not None:
            result['LocalPlanPercentage'] = self.local_plan_percentage
        if self.max_affected_rows is not None:
            result['MaxAffectedRows'] = self.max_affected_rows
        if self.max_application_wait_time is not None:
            result['MaxApplicationWaitTime'] = self.max_application_wait_time
        if self.max_concurrency_wait_time is not None:
            result['MaxConcurrencyWaitTime'] = self.max_concurrency_wait_time
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_disk_reads is not None:
            result['MaxDiskReads'] = self.max_disk_reads
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.max_return_rows is not None:
            result['MaxReturnRows'] = self.max_return_rows
        if self.max_user_io_wait_time is not None:
            result['MaxUserIoWaitTime'] = self.max_user_io_wait_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.miss_plan_percentage is not None:
            result['MissPlanPercentage'] = self.miss_plan_percentage
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.remote_plan_percentage is not None:
            result['RemotePlanPercentage'] = self.remote_plan_percentage
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.ret_code_4012count is not None:
            result['RetCode4012Count'] = self.ret_code_4012count
        if self.ret_code_4013count is not None:
            result['RetCode4013Count'] = self.ret_code_4013count
        if self.ret_code_5001count is not None:
            result['RetCode5001Count'] = self.ret_code_5001count
        if self.ret_code_5024count is not None:
            result['RetCode5024Count'] = self.ret_code_5024count
        if self.ret_code_5167count is not None:
            result['RetCode5167Count'] = self.ret_code_5167count
        if self.ret_code_5217count is not None:
            result['RetCode5217Count'] = self.ret_code_5217count
        if self.ret_code_6002count is not None:
            result['RetCode6002Count'] = self.ret_code_6002count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.rpc_count is not None:
            result['RpcCount'] = self.rpc_count
        if self.server is not None:
            result['Server'] = self.server
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.server_port is not None:
            result['ServerPort'] = self.server_port
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        result['SqlList'] = []
        if self.sql_list is not None:
            for k in self.sql_list:
                result['SqlList'].append(k.to_map() if k else None)
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.strong_consistency_percentage is not None:
            result['StrongConsistencyPercentage'] = self.strong_consistency_percentage
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.sum_logical_reads is not None:
            result['SumLogicalReads'] = self.sum_logical_reads
        if self.sum_wait_time is not None:
            result['SumWaitTime'] = self.sum_wait_time
        if self.table_scan_percentage is not None:
            result['TableScanPercentage'] = self.table_scan_percentage
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.wait_event is not None:
            result['WaitEvent'] = self.wait_event
        if self.weak_consistency_percentage is not None:
            result['WeakConsistencyPercentage'] = self.weak_consistency_percentage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgAffectedRows') is not None:
            self.avg_affected_rows = m.get('AvgAffectedRows')
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBlockCacheHit') is not None:
            self.avg_block_cache_hit = m.get('AvgBlockCacheHit')
        if m.get('AvgBlockIndexCacheHit') is not None:
            self.avg_block_index_cache_hit = m.get('AvgBlockIndexCacheHit')
        if m.get('AvgBloomFilterCacheHit') is not None:
            self.avg_bloom_filter_cache_hit = m.get('AvgBloomFilterCacheHit')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgDecodeTime') is not None:
            self.avg_decode_time = m.get('AvgDecodeTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgExecuteTime') is not None:
            self.avg_execute_time = m.get('AvgExecuteTime')
        if m.get('AvgExecutorRpcCount') is not None:
            self.avg_executor_rpc_count = m.get('AvgExecutorRpcCount')
        if m.get('AvgExpectedWorkerCount') is not None:
            self.avg_expected_worker_count = m.get('AvgExpectedWorkerCount')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('AvgLogicalReads') is not None:
            self.avg_logical_reads = m.get('AvgLogicalReads')
        if m.get('AvgMemstoreReadRows') is not None:
            self.avg_memstore_read_rows = m.get('AvgMemstoreReadRows')
        if m.get('AvgNetTime') is not None:
            self.avg_net_time = m.get('AvgNetTime')
        if m.get('AvgNetWaitTime') is not None:
            self.avg_net_wait_time = m.get('AvgNetWaitTime')
        if m.get('AvgPartitionCount') is not None:
            self.avg_partition_count = m.get('AvgPartitionCount')
        if m.get('AvgQueueTime') is not None:
            self.avg_queue_time = m.get('AvgQueueTime')
        if m.get('AvgReturnRows') is not None:
            self.avg_return_rows = m.get('AvgReturnRows')
        if m.get('AvgRowCacheHit') is not None:
            self.avg_row_cache_hit = m.get('AvgRowCacheHit')
        if m.get('AvgRpcCount') is not None:
            self.avg_rpc_count = m.get('AvgRpcCount')
        if m.get('AvgScheduleTime') is not None:
            self.avg_schedule_time = m.get('AvgScheduleTime')
        if m.get('AvgSsstoreReadRows') is not None:
            self.avg_ssstore_read_rows = m.get('AvgSsstoreReadRows')
        if m.get('AvgUsedWorkerCount') is not None:
            self.avg_used_worker_count = m.get('AvgUsedWorkerCount')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('AvgWaitCount') is not None:
            self.avg_wait_count = m.get('AvgWaitCount')
        if m.get('AvgWaitTime') is not None:
            self.avg_wait_time = m.get('AvgWaitTime')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DistPlanPercentage') is not None:
            self.dist_plan_percentage = m.get('DistPlanPercentage')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('FailPercentage') is not None:
            self.fail_percentage = m.get('FailPercentage')
        if m.get('Inner') is not None:
            self.inner = m.get('Inner')
        if m.get('LocalPlanPercentage') is not None:
            self.local_plan_percentage = m.get('LocalPlanPercentage')
        if m.get('MaxAffectedRows') is not None:
            self.max_affected_rows = m.get('MaxAffectedRows')
        if m.get('MaxApplicationWaitTime') is not None:
            self.max_application_wait_time = m.get('MaxApplicationWaitTime')
        if m.get('MaxConcurrencyWaitTime') is not None:
            self.max_concurrency_wait_time = m.get('MaxConcurrencyWaitTime')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxDiskReads') is not None:
            self.max_disk_reads = m.get('MaxDiskReads')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MaxReturnRows') is not None:
            self.max_return_rows = m.get('MaxReturnRows')
        if m.get('MaxUserIoWaitTime') is not None:
            self.max_user_io_wait_time = m.get('MaxUserIoWaitTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MissPlanPercentage') is not None:
            self.miss_plan_percentage = m.get('MissPlanPercentage')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('RemotePlanPercentage') is not None:
            self.remote_plan_percentage = m.get('RemotePlanPercentage')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetCode4012Count') is not None:
            self.ret_code_4012count = m.get('RetCode4012Count')
        if m.get('RetCode4013Count') is not None:
            self.ret_code_4013count = m.get('RetCode4013Count')
        if m.get('RetCode5001Count') is not None:
            self.ret_code_5001count = m.get('RetCode5001Count')
        if m.get('RetCode5024Count') is not None:
            self.ret_code_5024count = m.get('RetCode5024Count')
        if m.get('RetCode5167Count') is not None:
            self.ret_code_5167count = m.get('RetCode5167Count')
        if m.get('RetCode5217Count') is not None:
            self.ret_code_5217count = m.get('RetCode5217Count')
        if m.get('RetCode6002Count') is not None:
            self.ret_code_6002count = m.get('RetCode6002Count')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RpcCount') is not None:
            self.rpc_count = m.get('RpcCount')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('ServerPort') is not None:
            self.server_port = m.get('ServerPort')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        self.sql_list = []
        if m.get('SqlList') is not None:
            for k in m.get('SqlList'):
                temp_model = DescribeOasSlowSQLListResponseBodyDataSqlList()
                self.sql_list.append(temp_model.from_map(k))
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StrongConsistencyPercentage') is not None:
            self.strong_consistency_percentage = m.get('StrongConsistencyPercentage')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('SumLogicalReads') is not None:
            self.sum_logical_reads = m.get('SumLogicalReads')
        if m.get('SumWaitTime') is not None:
            self.sum_wait_time = m.get('SumWaitTime')
        if m.get('TableScanPercentage') is not None:
            self.table_scan_percentage = m.get('TableScanPercentage')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WaitEvent') is not None:
            self.wait_event = m.get('WaitEvent')
        if m.get('WeakConsistencyPercentage') is not None:
            self.weak_consistency_percentage = m.get('WeakConsistencyPercentage')
        return self


class DescribeOasSlowSQLListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of slow queries.
        self.data = data  # type: list[DescribeOasSlowSQLListResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasSlowSQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOasSlowSQLListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOasSlowSQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasSlowSQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasSlowSQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasSlowSQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOasTopSQLListRequest(TeaModel):
    def __init__(self, accept_language=None, db_name=None, dynamic_sql=None, end_time=None, filter_condition=None,
                 instance_id=None, merge_dynamic_sql=None, node_ip=None, search_key_word=None, search_param=None,
                 search_rule=None, search_value=None, sql_id=None, sql_text_length=None, start_time=None, tenant_id=None):
        # The language of the response. Valid values:
        # 
        # - zh: Chinese
        # - en: English
        self.accept_language = accept_language  # type: str
        # The name of the database.
        self.db_name = db_name  # type: str
        self.dynamic_sql = dynamic_sql  # type: bool
        # The end time of querying the TOPSQL parameter.
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
        self.filter_condition = filter_condition  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        self.merge_dynamic_sql = merge_dynamic_sql  # type: bool
        # The node IP.
        self.node_ip = node_ip  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_param = search_param  # type: str
        # The search rule.
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # SQL ID.
        # > When the SQL ID is provided, the system collects all the request data for the target SQL ID. When the SQL ID is empty, the system collects all the request data for the entire database instance.
        self.sql_id = sql_id  # type: str
        # Max length of the returned SQL text.
        self.sql_text_length = sql_text_length  # type: long
        # The start time of querying the TOPSQL parameter.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasTopSQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.merge_dynamic_sql is not None:
            result['MergeDynamicSql'] = self.merge_dynamic_sql
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_param is not None:
            result['SearchParam'] = self.search_param
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_length is not None:
            result['SqlTextLength'] = self.sql_text_length
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MergeDynamicSql') is not None:
            self.merge_dynamic_sql = m.get('MergeDynamicSql')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParam') is not None:
            self.search_param = m.get('SearchParam')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextLength') is not None:
            self.sql_text_length = m.get('SqlTextLength')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOasTopSQLListResponseBodyDataSqlList(TeaModel):
    def __init__(self, avg_affected_rows=None, avg_application_wait_time=None, avg_block_cache_hit=None,
                 avg_block_index_cache_hit=None, avg_bloom_filter_cache_hit=None, avg_concurrency_wait_time=None, avg_cpu_time=None,
                 avg_db_time=None, avg_decode_time=None, avg_disk_reads=None, avg_elapsed_time=None, avg_execute_time=None,
                 avg_executor_rpc_count=None, avg_expected_worker_count=None, avg_get_plan_time=None, avg_logical_reads=None,
                 avg_memstore_read_rows=None, avg_net_time=None, avg_net_wait_time=None, avg_partition_count=None, avg_queue_time=None,
                 avg_return_rows=None, avg_row_cache_hit=None, avg_rpc_count=None, avg_schedule_time=None,
                 avg_ssstore_read_rows=None, avg_used_worker_count=None, avg_user_io_wait_time=None, avg_wait_count=None,
                 avg_wait_time=None, client_ip=None, cpu_percentage=None, db_name=None, dist_plan_percentage=None, exec_ps=None,
                 executions=None, fail_count=None, fail_percentage=None, inner=None, local_plan_percentage=None,
                 max_affected_rows=None, max_application_wait_time=None, max_concurrency_wait_time=None, max_cpu_time=None,
                 max_disk_reads=None, max_elapsed_time=None, max_return_rows=None, max_user_io_wait_time=None, max_wait_time=None,
                 miss_plan_percentage=None, miss_plans=None, remote_plan_percentage=None, remote_plans=None, ret_code_4012count=None,
                 ret_code_4013count=None, ret_code_5001count=None, ret_code_5024count=None, ret_code_5167count=None,
                 ret_code_5217count=None, ret_code_6002count=None, retry_count=None, rpc_count=None, server=None, server_ip=None,
                 server_port=None, sql_id=None, sql_text_short=None, sql_type=None, strong_consistency_percentage=None,
                 sum_db_time=None, sum_elapsed_time=None, sum_logical_reads=None, sum_wait_time=None,
                 table_scan_percentage=None, total_wait_time=None, user_name=None, wait_event=None, weak_consistency_percentage=None):
        self.avg_affected_rows = avg_affected_rows  # type: float
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        self.avg_block_cache_hit = avg_block_cache_hit  # type: float
        self.avg_block_index_cache_hit = avg_block_index_cache_hit  # type: float
        self.avg_bloom_filter_cache_hit = avg_bloom_filter_cache_hit  # type: float
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        self.avg_decode_time = avg_decode_time  # type: float
        self.avg_disk_reads = avg_disk_reads  # type: float
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        self.avg_execute_time = avg_execute_time  # type: float
        self.avg_executor_rpc_count = avg_executor_rpc_count  # type: float
        self.avg_expected_worker_count = avg_expected_worker_count  # type: float
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        self.avg_logical_reads = avg_logical_reads  # type: float
        self.avg_memstore_read_rows = avg_memstore_read_rows  # type: float
        self.avg_net_time = avg_net_time  # type: float
        self.avg_net_wait_time = avg_net_wait_time  # type: float
        self.avg_partition_count = avg_partition_count  # type: float
        self.avg_queue_time = avg_queue_time  # type: float
        self.avg_return_rows = avg_return_rows  # type: float
        self.avg_row_cache_hit = avg_row_cache_hit  # type: float
        self.avg_rpc_count = avg_rpc_count  # type: float
        self.avg_schedule_time = avg_schedule_time  # type: float
        self.avg_ssstore_read_rows = avg_ssstore_read_rows  # type: float
        self.avg_used_worker_count = avg_used_worker_count  # type: float
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        self.avg_wait_count = avg_wait_count  # type: float
        self.avg_wait_time = avg_wait_time  # type: float
        self.client_ip = client_ip  # type: str
        self.cpu_percentage = cpu_percentage  # type: float
        self.db_name = db_name  # type: str
        self.dist_plan_percentage = dist_plan_percentage  # type: float
        self.exec_ps = exec_ps  # type: float
        self.executions = executions  # type: float
        self.fail_count = fail_count  # type: float
        self.fail_percentage = fail_percentage  # type: float
        self.inner = inner  # type: bool
        self.local_plan_percentage = local_plan_percentage  # type: float
        self.max_affected_rows = max_affected_rows  # type: float
        self.max_application_wait_time = max_application_wait_time  # type: float
        self.max_concurrency_wait_time = max_concurrency_wait_time  # type: float
        self.max_cpu_time = max_cpu_time  # type: float
        self.max_disk_reads = max_disk_reads  # type: float
        self.max_elapsed_time = max_elapsed_time  # type: float
        self.max_return_rows = max_return_rows  # type: float
        self.max_user_io_wait_time = max_user_io_wait_time  # type: float
        self.max_wait_time = max_wait_time  # type: float
        self.miss_plan_percentage = miss_plan_percentage  # type: float
        self.miss_plans = miss_plans  # type: float
        self.remote_plan_percentage = remote_plan_percentage  # type: float
        self.remote_plans = remote_plans  # type: float
        self.ret_code_4012count = ret_code_4012count  # type: long
        self.ret_code_4013count = ret_code_4013count  # type: long
        self.ret_code_5001count = ret_code_5001count  # type: long
        self.ret_code_5024count = ret_code_5024count  # type: long
        self.ret_code_5167count = ret_code_5167count  # type: long
        self.ret_code_5217count = ret_code_5217count  # type: long
        self.ret_code_6002count = ret_code_6002count  # type: long
        self.retry_count = retry_count  # type: float
        self.rpc_count = rpc_count  # type: float
        self.server = server  # type: str
        self.server_ip = server_ip  # type: str
        self.server_port = server_port  # type: long
        self.sql_id = sql_id  # type: str
        self.sql_text_short = sql_text_short  # type: str
        self.sql_type = sql_type  # type: str
        self.strong_consistency_percentage = strong_consistency_percentage  # type: float
        self.sum_db_time = sum_db_time  # type: float
        self.sum_elapsed_time = sum_elapsed_time  # type: float
        self.sum_logical_reads = sum_logical_reads  # type: float
        self.sum_wait_time = sum_wait_time  # type: float
        self.table_scan_percentage = table_scan_percentage  # type: float
        self.total_wait_time = total_wait_time  # type: float
        self.user_name = user_name  # type: str
        self.wait_event = wait_event  # type: str
        self.weak_consistency_percentage = weak_consistency_percentage  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOasTopSQLListResponseBodyDataSqlList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_affected_rows is not None:
            result['AvgAffectedRows'] = self.avg_affected_rows
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_block_cache_hit is not None:
            result['AvgBlockCacheHit'] = self.avg_block_cache_hit
        if self.avg_block_index_cache_hit is not None:
            result['AvgBlockIndexCacheHit'] = self.avg_block_index_cache_hit
        if self.avg_bloom_filter_cache_hit is not None:
            result['AvgBloomFilterCacheHit'] = self.avg_bloom_filter_cache_hit
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_decode_time is not None:
            result['AvgDecodeTime'] = self.avg_decode_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_execute_time is not None:
            result['AvgExecuteTime'] = self.avg_execute_time
        if self.avg_executor_rpc_count is not None:
            result['AvgExecutorRpcCount'] = self.avg_executor_rpc_count
        if self.avg_expected_worker_count is not None:
            result['AvgExpectedWorkerCount'] = self.avg_expected_worker_count
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.avg_logical_reads is not None:
            result['AvgLogicalReads'] = self.avg_logical_reads
        if self.avg_memstore_read_rows is not None:
            result['AvgMemstoreReadRows'] = self.avg_memstore_read_rows
        if self.avg_net_time is not None:
            result['AvgNetTime'] = self.avg_net_time
        if self.avg_net_wait_time is not None:
            result['AvgNetWaitTime'] = self.avg_net_wait_time
        if self.avg_partition_count is not None:
            result['AvgPartitionCount'] = self.avg_partition_count
        if self.avg_queue_time is not None:
            result['AvgQueueTime'] = self.avg_queue_time
        if self.avg_return_rows is not None:
            result['AvgReturnRows'] = self.avg_return_rows
        if self.avg_row_cache_hit is not None:
            result['AvgRowCacheHit'] = self.avg_row_cache_hit
        if self.avg_rpc_count is not None:
            result['AvgRpcCount'] = self.avg_rpc_count
        if self.avg_schedule_time is not None:
            result['AvgScheduleTime'] = self.avg_schedule_time
        if self.avg_ssstore_read_rows is not None:
            result['AvgSsstoreReadRows'] = self.avg_ssstore_read_rows
        if self.avg_used_worker_count is not None:
            result['AvgUsedWorkerCount'] = self.avg_used_worker_count
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.avg_wait_count is not None:
            result['AvgWaitCount'] = self.avg_wait_count
        if self.avg_wait_time is not None:
            result['AvgWaitTime'] = self.avg_wait_time
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.cpu_percentage is not None:
            result['CpuPercentage'] = self.cpu_percentage
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dist_plan_percentage is not None:
            result['DistPlanPercentage'] = self.dist_plan_percentage
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.fail_percentage is not None:
            result['FailPercentage'] = self.fail_percentage
        if self.inner is not None:
            result['Inner'] = self.inner
        if self.local_plan_percentage is not None:
            result['LocalPlanPercentage'] = self.local_plan_percentage
        if self.max_affected_rows is not None:
            result['MaxAffectedRows'] = self.max_affected_rows
        if self.max_application_wait_time is not None:
            result['MaxApplicationWaitTime'] = self.max_application_wait_time
        if self.max_concurrency_wait_time is not None:
            result['MaxConcurrencyWaitTime'] = self.max_concurrency_wait_time
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_disk_reads is not None:
            result['MaxDiskReads'] = self.max_disk_reads
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.max_return_rows is not None:
            result['MaxReturnRows'] = self.max_return_rows
        if self.max_user_io_wait_time is not None:
            result['MaxUserIoWaitTime'] = self.max_user_io_wait_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.miss_plan_percentage is not None:
            result['MissPlanPercentage'] = self.miss_plan_percentage
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.remote_plan_percentage is not None:
            result['RemotePlanPercentage'] = self.remote_plan_percentage
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.ret_code_4012count is not None:
            result['RetCode4012Count'] = self.ret_code_4012count
        if self.ret_code_4013count is not None:
            result['RetCode4013Count'] = self.ret_code_4013count
        if self.ret_code_5001count is not None:
            result['RetCode5001Count'] = self.ret_code_5001count
        if self.ret_code_5024count is not None:
            result['RetCode5024Count'] = self.ret_code_5024count
        if self.ret_code_5167count is not None:
            result['RetCode5167Count'] = self.ret_code_5167count
        if self.ret_code_5217count is not None:
            result['RetCode5217Count'] = self.ret_code_5217count
        if self.ret_code_6002count is not None:
            result['RetCode6002Count'] = self.ret_code_6002count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.rpc_count is not None:
            result['RpcCount'] = self.rpc_count
        if self.server is not None:
            result['Server'] = self.server
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.server_port is not None:
            result['ServerPort'] = self.server_port
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.strong_consistency_percentage is not None:
            result['StrongConsistencyPercentage'] = self.strong_consistency_percentage
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.sum_logical_reads is not None:
            result['SumLogicalReads'] = self.sum_logical_reads
        if self.sum_wait_time is not None:
            result['SumWaitTime'] = self.sum_wait_time
        if self.table_scan_percentage is not None:
            result['TableScanPercentage'] = self.table_scan_percentage
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.wait_event is not None:
            result['WaitEvent'] = self.wait_event
        if self.weak_consistency_percentage is not None:
            result['WeakConsistencyPercentage'] = self.weak_consistency_percentage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgAffectedRows') is not None:
            self.avg_affected_rows = m.get('AvgAffectedRows')
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBlockCacheHit') is not None:
            self.avg_block_cache_hit = m.get('AvgBlockCacheHit')
        if m.get('AvgBlockIndexCacheHit') is not None:
            self.avg_block_index_cache_hit = m.get('AvgBlockIndexCacheHit')
        if m.get('AvgBloomFilterCacheHit') is not None:
            self.avg_bloom_filter_cache_hit = m.get('AvgBloomFilterCacheHit')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgDecodeTime') is not None:
            self.avg_decode_time = m.get('AvgDecodeTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgExecuteTime') is not None:
            self.avg_execute_time = m.get('AvgExecuteTime')
        if m.get('AvgExecutorRpcCount') is not None:
            self.avg_executor_rpc_count = m.get('AvgExecutorRpcCount')
        if m.get('AvgExpectedWorkerCount') is not None:
            self.avg_expected_worker_count = m.get('AvgExpectedWorkerCount')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('AvgLogicalReads') is not None:
            self.avg_logical_reads = m.get('AvgLogicalReads')
        if m.get('AvgMemstoreReadRows') is not None:
            self.avg_memstore_read_rows = m.get('AvgMemstoreReadRows')
        if m.get('AvgNetTime') is not None:
            self.avg_net_time = m.get('AvgNetTime')
        if m.get('AvgNetWaitTime') is not None:
            self.avg_net_wait_time = m.get('AvgNetWaitTime')
        if m.get('AvgPartitionCount') is not None:
            self.avg_partition_count = m.get('AvgPartitionCount')
        if m.get('AvgQueueTime') is not None:
            self.avg_queue_time = m.get('AvgQueueTime')
        if m.get('AvgReturnRows') is not None:
            self.avg_return_rows = m.get('AvgReturnRows')
        if m.get('AvgRowCacheHit') is not None:
            self.avg_row_cache_hit = m.get('AvgRowCacheHit')
        if m.get('AvgRpcCount') is not None:
            self.avg_rpc_count = m.get('AvgRpcCount')
        if m.get('AvgScheduleTime') is not None:
            self.avg_schedule_time = m.get('AvgScheduleTime')
        if m.get('AvgSsstoreReadRows') is not None:
            self.avg_ssstore_read_rows = m.get('AvgSsstoreReadRows')
        if m.get('AvgUsedWorkerCount') is not None:
            self.avg_used_worker_count = m.get('AvgUsedWorkerCount')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('AvgWaitCount') is not None:
            self.avg_wait_count = m.get('AvgWaitCount')
        if m.get('AvgWaitTime') is not None:
            self.avg_wait_time = m.get('AvgWaitTime')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('CpuPercentage') is not None:
            self.cpu_percentage = m.get('CpuPercentage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DistPlanPercentage') is not None:
            self.dist_plan_percentage = m.get('DistPlanPercentage')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('FailPercentage') is not None:
            self.fail_percentage = m.get('FailPercentage')
        if m.get('Inner') is not None:
            self.inner = m.get('Inner')
        if m.get('LocalPlanPercentage') is not None:
            self.local_plan_percentage = m.get('LocalPlanPercentage')
        if m.get('MaxAffectedRows') is not None:
            self.max_affected_rows = m.get('MaxAffectedRows')
        if m.get('MaxApplicationWaitTime') is not None:
            self.max_application_wait_time = m.get('MaxApplicationWaitTime')
        if m.get('MaxConcurrencyWaitTime') is not None:
            self.max_concurrency_wait_time = m.get('MaxConcurrencyWaitTime')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxDiskReads') is not None:
            self.max_disk_reads = m.get('MaxDiskReads')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MaxReturnRows') is not None:
            self.max_return_rows = m.get('MaxReturnRows')
        if m.get('MaxUserIoWaitTime') is not None:
            self.max_user_io_wait_time = m.get('MaxUserIoWaitTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MissPlanPercentage') is not None:
            self.miss_plan_percentage = m.get('MissPlanPercentage')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('RemotePlanPercentage') is not None:
            self.remote_plan_percentage = m.get('RemotePlanPercentage')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetCode4012Count') is not None:
            self.ret_code_4012count = m.get('RetCode4012Count')
        if m.get('RetCode4013Count') is not None:
            self.ret_code_4013count = m.get('RetCode4013Count')
        if m.get('RetCode5001Count') is not None:
            self.ret_code_5001count = m.get('RetCode5001Count')
        if m.get('RetCode5024Count') is not None:
            self.ret_code_5024count = m.get('RetCode5024Count')
        if m.get('RetCode5167Count') is not None:
            self.ret_code_5167count = m.get('RetCode5167Count')
        if m.get('RetCode5217Count') is not None:
            self.ret_code_5217count = m.get('RetCode5217Count')
        if m.get('RetCode6002Count') is not None:
            self.ret_code_6002count = m.get('RetCode6002Count')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RpcCount') is not None:
            self.rpc_count = m.get('RpcCount')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('ServerPort') is not None:
            self.server_port = m.get('ServerPort')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StrongConsistencyPercentage') is not None:
            self.strong_consistency_percentage = m.get('StrongConsistencyPercentage')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('SumLogicalReads') is not None:
            self.sum_logical_reads = m.get('SumLogicalReads')
        if m.get('SumWaitTime') is not None:
            self.sum_wait_time = m.get('SumWaitTime')
        if m.get('TableScanPercentage') is not None:
            self.table_scan_percentage = m.get('TableScanPercentage')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WaitEvent') is not None:
            self.wait_event = m.get('WaitEvent')
        if m.get('WeakConsistencyPercentage') is not None:
            self.weak_consistency_percentage = m.get('WeakConsistencyPercentage')
        return self


class DescribeOasTopSQLListResponseBodyData(TeaModel):
    def __init__(self, avg_affected_rows=None, avg_application_wait_time=None, avg_block_cache_hit=None,
                 avg_block_index_cache_hit=None, avg_bloom_filter_cache_hit=None, avg_concurrency_wait_time=None, avg_cpu_time=None,
                 avg_db_time=None, avg_decode_time=None, avg_disk_reads=None, avg_elapsed_time=None, avg_execute_time=None,
                 avg_executor_rpc_count=None, avg_expected_worker_count=None, avg_get_plan_time=None, avg_logical_reads=None,
                 avg_memstore_read_rows=None, avg_net_time=None, avg_net_wait_time=None, avg_partition_count=None, avg_queue_time=None,
                 avg_return_rows=None, avg_row_cache_hit=None, avg_rpc_count=None, avg_schedule_time=None,
                 avg_ssstore_read_rows=None, avg_used_worker_count=None, avg_user_io_wait_time=None, avg_wait_count=None,
                 avg_wait_time=None, client_ip=None, cpu_percentage=None, db_name=None, dist_plan_percentage=None,
                 dynamic_sql=None, exec_ps=None, executions=None, fail_count=None, fail_percentage=None, inner=None,
                 last_fail_code=None, local_plan_percentage=None, max_affected_rows=None, max_application_wait_time=None,
                 max_concurrency_wait_time=None, max_cpu_time=None, max_disk_reads=None, max_elapsed_time=None, max_return_rows=None,
                 max_user_io_wait_time=None, max_wait_time=None, miss_plan_percentage=None, miss_plans=None, remote_plan_percentage=None,
                 remote_plans=None, ret_code_4012count=None, ret_code_4013count=None, ret_code_5001count=None,
                 ret_code_5024count=None, ret_code_5167count=None, ret_code_5217count=None, ret_code_6002count=None, retry_count=None,
                 rpc_count=None, server=None, server_ip=None, server_port=None, sql_id=None, sql_list=None,
                 sql_text_short=None, sql_type=None, strong_consistency_percentage=None, sum_db_time=None, sum_elapsed_time=None,
                 sum_logical_reads=None, sum_wait_time=None, table_scan_percentage=None, total_wait_time=None, user_name=None,
                 wait_event=None, weak_consistency_percentage=None):
        # Average updated rows during the execution period.
        self.avg_affected_rows = avg_affected_rows  # type: float
        # Average Application event wait time (in milliseconds) during the execution period.
        self.avg_application_wait_time = avg_application_wait_time  # type: float
        # Average BlockCache hit count during the execution period.
        self.avg_block_cache_hit = avg_block_cache_hit  # type: float
        # Average BlockIndexCache hit count during the execution period.
        self.avg_block_index_cache_hit = avg_block_index_cache_hit  # type: float
        # Average BloomFilterCache hit count during the execution period.
        self.avg_bloom_filter_cache_hit = avg_bloom_filter_cache_hit  # type: float
        # Average Concurrency event wait time (in milliseconds) during the execution period.
        self.avg_concurrency_wait_time = avg_concurrency_wait_time  # type: float
        # Average CPU time (in milliseconds) during the execution period.
        self.avg_cpu_time = avg_cpu_time  # type: float
        self.avg_db_time = avg_db_time  # type: float
        # Average syntax parsing time (in milliseconds) during the execution period.
        self.avg_decode_time = avg_decode_time  # type: float
        # Average physical read count during the execution period.
        self.avg_disk_reads = avg_disk_reads  # type: float
        # Average response time (in milliseconds) during the execution period.
        self.avg_elapsed_time = avg_elapsed_time  # type: float
        # Average plan execution time (in milliseconds) during the execution period.
        self.avg_execute_time = avg_execute_time  # type: float
        # Average number of RPC requests executed during the execution period.
        self.avg_executor_rpc_count = avg_executor_rpc_count  # type: float
        # Average degree of parallelism during the execution period.
        self.avg_expected_worker_count = avg_expected_worker_count  # type: float
        # Average plan generation time (in milliseconds) during the execution period.
        self.avg_get_plan_time = avg_get_plan_time  # type: float
        # Average logical reads of the SQL during the execution period.
        self.avg_logical_reads = avg_logical_reads  # type: float
        # Strong consistent transaction percentage during the execution period.
        self.avg_memstore_read_rows = avg_memstore_read_rows  # type: float
        # Average network transmission time (in milliseconds) during the execution period.
        self.avg_net_time = avg_net_time  # type: float
        # Average network enqueue time (in milliseconds) during the execution period.
        self.avg_net_wait_time = avg_net_wait_time  # type: float
        # Average number of partition accessed during the execution period.
        self.avg_partition_count = avg_partition_count  # type: float
        # Average queueing time (in milliseconds) during the execution period.
        self.avg_queue_time = avg_queue_time  # type: float
        # Average returned rows during the execution period.
        self.avg_return_rows = avg_return_rows  # type: float
        # Average RowCache hit count during the execution period.
        self.avg_row_cache_hit = avg_row_cache_hit  # type: float
        # Average count of RPC sent during the execution period.
        self.avg_rpc_count = avg_rpc_count  # type: float
        # Average Schedule event wait time (in milliseconds) during the execution period.
        self.avg_schedule_time = avg_schedule_time  # type: float
        # Eventually consistent transaction percentage during the execution period.
        self.avg_ssstore_read_rows = avg_ssstore_read_rows  # type: float
        # Average number of threads used of the SQL during the execution period.
        self.avg_used_worker_count = avg_used_worker_count  # type: float
        # Average UserIO event wait time (in milliseconds) during the execution period.
        self.avg_user_io_wait_time = avg_user_io_wait_time  # type: float
        # Average wait count during the execution period.
        self.avg_wait_count = avg_wait_count  # type: float
        # Average wait time (in milliseconds) during the execution period.
        self.avg_wait_time = avg_wait_time  # type: float
        # Client IP.
        self.client_ip = client_ip  # type: str
        # CPU percentage.
        self.cpu_percentage = cpu_percentage  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # Distributed plan percentage during the execution period.
        self.dist_plan_percentage = dist_plan_percentage  # type: float
        self.dynamic_sql = dynamic_sql  # type: bool
        # Average execution count per second during the execution period.
        self.exec_ps = exec_ps  # type: float
        # Total number of executions during the execution period.
        self.executions = executions  # type: float
        # Average number of partition accessed during the execution period.
        self.fail_count = fail_count  # type: float
        # Error percentage during the execution period.
        self.fail_percentage = fail_percentage  # type: float
        # Whether a internal SQL.
        self.inner = inner  # type: bool
        self.last_fail_code = last_fail_code  # type: long
        # Local plan percentage during the execution period.
        self.local_plan_percentage = local_plan_percentage  # type: float
        # Max affected rows during the execution period.
        self.max_affected_rows = max_affected_rows  # type: float
        # Max Application event wait time (in milliseconds) during the execution period.
        self.max_application_wait_time = max_application_wait_time  # type: float
        # Max Concurrency event wait time (in milliseconds) during the execution period.
        self.max_concurrency_wait_time = max_concurrency_wait_time  # type: float
        # Max CPU time (in milliseconds).
        self.max_cpu_time = max_cpu_time  # type: float
        # Max physical read count during the execution period.
        self.max_disk_reads = max_disk_reads  # type: float
        # Max response time during the execution period.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # Max returned rows during the execution period.
        self.max_return_rows = max_return_rows  # type: float
        # Max UserIO event wait time (in milliseconds) during the execution period.
        self.max_user_io_wait_time = max_user_io_wait_time  # type: float
        # Max wait time (in milliseconds) during the execution period.
        self.max_wait_time = max_wait_time  # type: float
        # Plan hit rage during the execution period.
        self.miss_plan_percentage = miss_plan_percentage  # type: float
        # Missed hit count of the execution plan during the execution period.
        self.miss_plans = miss_plans  # type: float
        # Remote plan percentage during the execution period.
        self.remote_plan_percentage = remote_plan_percentage  # type: float
        # Remote execution count during the execution period.
        self.remote_plans = remote_plans  # type: float
        # Number of occurrences of the code 4012 during the execution period.
        self.ret_code_4012count = ret_code_4012count  # type: long
        # Number of occurrences of the code 4013 during the execution period.
        self.ret_code_4013count = ret_code_4013count  # type: long
        # Number of occurrences of the code 5001 during the execution period.
        self.ret_code_5001count = ret_code_5001count  # type: long
        # Number of occurrences of the code 5024 during the execution period.
        self.ret_code_5024count = ret_code_5024count  # type: long
        # Number of occurrences of the code 5167 during the execution period.
        self.ret_code_5167count = ret_code_5167count  # type: long
        # Number of occurrences of the code 5217 during the execution period.
        self.ret_code_5217count = ret_code_5217count  # type: long
        # Number of occurrences of the code 6002 during the execution period.
        self.ret_code_6002count = ret_code_6002count  # type: long
        # Total retry count during the execution period.
        self.retry_count = retry_count  # type: float
        # RPC count during the execution period.
        self.rpc_count = rpc_count  # type: float
        # The server where the SQL is executed.
        self.server = server  # type: str
        # The server IP where the SQL is executed.
        self.server_ip = server_ip  # type: str
        # The server port where the SQL is executed.
        self.server_port = server_port  # type: long
        # SQL ID.
        self.sql_id = sql_id  # type: str
        self.sql_list = sql_list  # type: list[DescribeOasTopSQLListResponseBodyDataSqlList]
        # SQL text (the first 100 characters).
        self.sql_text_short = sql_text_short  # type: str
        # SQL type.
        self.sql_type = sql_type  # type: str
        # Strong consistent transaction percentage during the execution period.
        self.strong_consistency_percentage = strong_consistency_percentage  # type: float
        self.sum_db_time = sum_db_time  # type: float
        # Total response time (in milliseconds) during the execution period.
        self.sum_elapsed_time = sum_elapsed_time  # type: float
        # Total logical reads.
        self.sum_logical_reads = sum_logical_reads  # type: float
        # Total wait time (in milliseconds) during the execution period.
        self.sum_wait_time = sum_wait_time  # type: float
        # Table scan percentage during the execution period.
        self.table_scan_percentage = table_scan_percentage  # type: float
        # Total wait time (in milliseconds) during the execution period.
        self.total_wait_time = total_wait_time  # type: float
        # Username.
        self.user_name = user_name  # type: str
        # Longest wait event during the execution period.
        self.wait_event = wait_event  # type: str
        # Eventually consistent transaction percentage during the execution period.
        self.weak_consistency_percentage = weak_consistency_percentage  # type: float

    def validate(self):
        if self.sql_list:
            for k in self.sql_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasTopSQLListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_affected_rows is not None:
            result['AvgAffectedRows'] = self.avg_affected_rows
        if self.avg_application_wait_time is not None:
            result['AvgApplicationWaitTime'] = self.avg_application_wait_time
        if self.avg_block_cache_hit is not None:
            result['AvgBlockCacheHit'] = self.avg_block_cache_hit
        if self.avg_block_index_cache_hit is not None:
            result['AvgBlockIndexCacheHit'] = self.avg_block_index_cache_hit
        if self.avg_bloom_filter_cache_hit is not None:
            result['AvgBloomFilterCacheHit'] = self.avg_bloom_filter_cache_hit
        if self.avg_concurrency_wait_time is not None:
            result['AvgConcurrencyWaitTime'] = self.avg_concurrency_wait_time
        if self.avg_cpu_time is not None:
            result['AvgCpuTime'] = self.avg_cpu_time
        if self.avg_db_time is not None:
            result['AvgDbTime'] = self.avg_db_time
        if self.avg_decode_time is not None:
            result['AvgDecodeTime'] = self.avg_decode_time
        if self.avg_disk_reads is not None:
            result['AvgDiskReads'] = self.avg_disk_reads
        if self.avg_elapsed_time is not None:
            result['AvgElapsedTime'] = self.avg_elapsed_time
        if self.avg_execute_time is not None:
            result['AvgExecuteTime'] = self.avg_execute_time
        if self.avg_executor_rpc_count is not None:
            result['AvgExecutorRpcCount'] = self.avg_executor_rpc_count
        if self.avg_expected_worker_count is not None:
            result['AvgExpectedWorkerCount'] = self.avg_expected_worker_count
        if self.avg_get_plan_time is not None:
            result['AvgGetPlanTime'] = self.avg_get_plan_time
        if self.avg_logical_reads is not None:
            result['AvgLogicalReads'] = self.avg_logical_reads
        if self.avg_memstore_read_rows is not None:
            result['AvgMemstoreReadRows'] = self.avg_memstore_read_rows
        if self.avg_net_time is not None:
            result['AvgNetTime'] = self.avg_net_time
        if self.avg_net_wait_time is not None:
            result['AvgNetWaitTime'] = self.avg_net_wait_time
        if self.avg_partition_count is not None:
            result['AvgPartitionCount'] = self.avg_partition_count
        if self.avg_queue_time is not None:
            result['AvgQueueTime'] = self.avg_queue_time
        if self.avg_return_rows is not None:
            result['AvgReturnRows'] = self.avg_return_rows
        if self.avg_row_cache_hit is not None:
            result['AvgRowCacheHit'] = self.avg_row_cache_hit
        if self.avg_rpc_count is not None:
            result['AvgRpcCount'] = self.avg_rpc_count
        if self.avg_schedule_time is not None:
            result['AvgScheduleTime'] = self.avg_schedule_time
        if self.avg_ssstore_read_rows is not None:
            result['AvgSsstoreReadRows'] = self.avg_ssstore_read_rows
        if self.avg_used_worker_count is not None:
            result['AvgUsedWorkerCount'] = self.avg_used_worker_count
        if self.avg_user_io_wait_time is not None:
            result['AvgUserIoWaitTime'] = self.avg_user_io_wait_time
        if self.avg_wait_count is not None:
            result['AvgWaitCount'] = self.avg_wait_count
        if self.avg_wait_time is not None:
            result['AvgWaitTime'] = self.avg_wait_time
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.cpu_percentage is not None:
            result['CpuPercentage'] = self.cpu_percentage
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.dist_plan_percentage is not None:
            result['DistPlanPercentage'] = self.dist_plan_percentage
        if self.dynamic_sql is not None:
            result['DynamicSql'] = self.dynamic_sql
        if self.exec_ps is not None:
            result['ExecPs'] = self.exec_ps
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.fail_percentage is not None:
            result['FailPercentage'] = self.fail_percentage
        if self.inner is not None:
            result['Inner'] = self.inner
        if self.last_fail_code is not None:
            result['LastFailCode'] = self.last_fail_code
        if self.local_plan_percentage is not None:
            result['LocalPlanPercentage'] = self.local_plan_percentage
        if self.max_affected_rows is not None:
            result['MaxAffectedRows'] = self.max_affected_rows
        if self.max_application_wait_time is not None:
            result['MaxApplicationWaitTime'] = self.max_application_wait_time
        if self.max_concurrency_wait_time is not None:
            result['MaxConcurrencyWaitTime'] = self.max_concurrency_wait_time
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_disk_reads is not None:
            result['MaxDiskReads'] = self.max_disk_reads
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.max_return_rows is not None:
            result['MaxReturnRows'] = self.max_return_rows
        if self.max_user_io_wait_time is not None:
            result['MaxUserIoWaitTime'] = self.max_user_io_wait_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.miss_plan_percentage is not None:
            result['MissPlanPercentage'] = self.miss_plan_percentage
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.remote_plan_percentage is not None:
            result['RemotePlanPercentage'] = self.remote_plan_percentage
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.ret_code_4012count is not None:
            result['RetCode4012Count'] = self.ret_code_4012count
        if self.ret_code_4013count is not None:
            result['RetCode4013Count'] = self.ret_code_4013count
        if self.ret_code_5001count is not None:
            result['RetCode5001Count'] = self.ret_code_5001count
        if self.ret_code_5024count is not None:
            result['RetCode5024Count'] = self.ret_code_5024count
        if self.ret_code_5167count is not None:
            result['RetCode5167Count'] = self.ret_code_5167count
        if self.ret_code_5217count is not None:
            result['RetCode5217Count'] = self.ret_code_5217count
        if self.ret_code_6002count is not None:
            result['RetCode6002Count'] = self.ret_code_6002count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.rpc_count is not None:
            result['RpcCount'] = self.rpc_count
        if self.server is not None:
            result['Server'] = self.server
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.server_port is not None:
            result['ServerPort'] = self.server_port
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        result['SqlList'] = []
        if self.sql_list is not None:
            for k in self.sql_list:
                result['SqlList'].append(k.to_map() if k else None)
        if self.sql_text_short is not None:
            result['SqlTextShort'] = self.sql_text_short
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.strong_consistency_percentage is not None:
            result['StrongConsistencyPercentage'] = self.strong_consistency_percentage
        if self.sum_db_time is not None:
            result['SumDbTime'] = self.sum_db_time
        if self.sum_elapsed_time is not None:
            result['SumElapsedTime'] = self.sum_elapsed_time
        if self.sum_logical_reads is not None:
            result['SumLogicalReads'] = self.sum_logical_reads
        if self.sum_wait_time is not None:
            result['SumWaitTime'] = self.sum_wait_time
        if self.table_scan_percentage is not None:
            result['TableScanPercentage'] = self.table_scan_percentage
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.wait_event is not None:
            result['WaitEvent'] = self.wait_event
        if self.weak_consistency_percentage is not None:
            result['WeakConsistencyPercentage'] = self.weak_consistency_percentage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgAffectedRows') is not None:
            self.avg_affected_rows = m.get('AvgAffectedRows')
        if m.get('AvgApplicationWaitTime') is not None:
            self.avg_application_wait_time = m.get('AvgApplicationWaitTime')
        if m.get('AvgBlockCacheHit') is not None:
            self.avg_block_cache_hit = m.get('AvgBlockCacheHit')
        if m.get('AvgBlockIndexCacheHit') is not None:
            self.avg_block_index_cache_hit = m.get('AvgBlockIndexCacheHit')
        if m.get('AvgBloomFilterCacheHit') is not None:
            self.avg_bloom_filter_cache_hit = m.get('AvgBloomFilterCacheHit')
        if m.get('AvgConcurrencyWaitTime') is not None:
            self.avg_concurrency_wait_time = m.get('AvgConcurrencyWaitTime')
        if m.get('AvgCpuTime') is not None:
            self.avg_cpu_time = m.get('AvgCpuTime')
        if m.get('AvgDbTime') is not None:
            self.avg_db_time = m.get('AvgDbTime')
        if m.get('AvgDecodeTime') is not None:
            self.avg_decode_time = m.get('AvgDecodeTime')
        if m.get('AvgDiskReads') is not None:
            self.avg_disk_reads = m.get('AvgDiskReads')
        if m.get('AvgElapsedTime') is not None:
            self.avg_elapsed_time = m.get('AvgElapsedTime')
        if m.get('AvgExecuteTime') is not None:
            self.avg_execute_time = m.get('AvgExecuteTime')
        if m.get('AvgExecutorRpcCount') is not None:
            self.avg_executor_rpc_count = m.get('AvgExecutorRpcCount')
        if m.get('AvgExpectedWorkerCount') is not None:
            self.avg_expected_worker_count = m.get('AvgExpectedWorkerCount')
        if m.get('AvgGetPlanTime') is not None:
            self.avg_get_plan_time = m.get('AvgGetPlanTime')
        if m.get('AvgLogicalReads') is not None:
            self.avg_logical_reads = m.get('AvgLogicalReads')
        if m.get('AvgMemstoreReadRows') is not None:
            self.avg_memstore_read_rows = m.get('AvgMemstoreReadRows')
        if m.get('AvgNetTime') is not None:
            self.avg_net_time = m.get('AvgNetTime')
        if m.get('AvgNetWaitTime') is not None:
            self.avg_net_wait_time = m.get('AvgNetWaitTime')
        if m.get('AvgPartitionCount') is not None:
            self.avg_partition_count = m.get('AvgPartitionCount')
        if m.get('AvgQueueTime') is not None:
            self.avg_queue_time = m.get('AvgQueueTime')
        if m.get('AvgReturnRows') is not None:
            self.avg_return_rows = m.get('AvgReturnRows')
        if m.get('AvgRowCacheHit') is not None:
            self.avg_row_cache_hit = m.get('AvgRowCacheHit')
        if m.get('AvgRpcCount') is not None:
            self.avg_rpc_count = m.get('AvgRpcCount')
        if m.get('AvgScheduleTime') is not None:
            self.avg_schedule_time = m.get('AvgScheduleTime')
        if m.get('AvgSsstoreReadRows') is not None:
            self.avg_ssstore_read_rows = m.get('AvgSsstoreReadRows')
        if m.get('AvgUsedWorkerCount') is not None:
            self.avg_used_worker_count = m.get('AvgUsedWorkerCount')
        if m.get('AvgUserIoWaitTime') is not None:
            self.avg_user_io_wait_time = m.get('AvgUserIoWaitTime')
        if m.get('AvgWaitCount') is not None:
            self.avg_wait_count = m.get('AvgWaitCount')
        if m.get('AvgWaitTime') is not None:
            self.avg_wait_time = m.get('AvgWaitTime')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('CpuPercentage') is not None:
            self.cpu_percentage = m.get('CpuPercentage')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DistPlanPercentage') is not None:
            self.dist_plan_percentage = m.get('DistPlanPercentage')
        if m.get('DynamicSql') is not None:
            self.dynamic_sql = m.get('DynamicSql')
        if m.get('ExecPs') is not None:
            self.exec_ps = m.get('ExecPs')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('FailPercentage') is not None:
            self.fail_percentage = m.get('FailPercentage')
        if m.get('Inner') is not None:
            self.inner = m.get('Inner')
        if m.get('LastFailCode') is not None:
            self.last_fail_code = m.get('LastFailCode')
        if m.get('LocalPlanPercentage') is not None:
            self.local_plan_percentage = m.get('LocalPlanPercentage')
        if m.get('MaxAffectedRows') is not None:
            self.max_affected_rows = m.get('MaxAffectedRows')
        if m.get('MaxApplicationWaitTime') is not None:
            self.max_application_wait_time = m.get('MaxApplicationWaitTime')
        if m.get('MaxConcurrencyWaitTime') is not None:
            self.max_concurrency_wait_time = m.get('MaxConcurrencyWaitTime')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxDiskReads') is not None:
            self.max_disk_reads = m.get('MaxDiskReads')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MaxReturnRows') is not None:
            self.max_return_rows = m.get('MaxReturnRows')
        if m.get('MaxUserIoWaitTime') is not None:
            self.max_user_io_wait_time = m.get('MaxUserIoWaitTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MissPlanPercentage') is not None:
            self.miss_plan_percentage = m.get('MissPlanPercentage')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('RemotePlanPercentage') is not None:
            self.remote_plan_percentage = m.get('RemotePlanPercentage')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetCode4012Count') is not None:
            self.ret_code_4012count = m.get('RetCode4012Count')
        if m.get('RetCode4013Count') is not None:
            self.ret_code_4013count = m.get('RetCode4013Count')
        if m.get('RetCode5001Count') is not None:
            self.ret_code_5001count = m.get('RetCode5001Count')
        if m.get('RetCode5024Count') is not None:
            self.ret_code_5024count = m.get('RetCode5024Count')
        if m.get('RetCode5167Count') is not None:
            self.ret_code_5167count = m.get('RetCode5167Count')
        if m.get('RetCode5217Count') is not None:
            self.ret_code_5217count = m.get('RetCode5217Count')
        if m.get('RetCode6002Count') is not None:
            self.ret_code_6002count = m.get('RetCode6002Count')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RpcCount') is not None:
            self.rpc_count = m.get('RpcCount')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('ServerPort') is not None:
            self.server_port = m.get('ServerPort')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        self.sql_list = []
        if m.get('SqlList') is not None:
            for k in m.get('SqlList'):
                temp_model = DescribeOasTopSQLListResponseBodyDataSqlList()
                self.sql_list.append(temp_model.from_map(k))
        if m.get('SqlTextShort') is not None:
            self.sql_text_short = m.get('SqlTextShort')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StrongConsistencyPercentage') is not None:
            self.strong_consistency_percentage = m.get('StrongConsistencyPercentage')
        if m.get('SumDbTime') is not None:
            self.sum_db_time = m.get('SumDbTime')
        if m.get('SumElapsedTime') is not None:
            self.sum_elapsed_time = m.get('SumElapsedTime')
        if m.get('SumLogicalReads') is not None:
            self.sum_logical_reads = m.get('SumLogicalReads')
        if m.get('SumWaitTime') is not None:
            self.sum_wait_time = m.get('SumWaitTime')
        if m.get('TableScanPercentage') is not None:
            self.table_scan_percentage = m.get('TableScanPercentage')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WaitEvent') is not None:
            self.wait_event = m.get('WaitEvent')
        if m.get('WeakConsistencyPercentage') is not None:
            self.weak_consistency_percentage = m.get('WeakConsistencyPercentage')
        return self


class DescribeOasTopSQLListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of Top SQL.
        self.data = data  # type: list[DescribeOasTopSQLListResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOasTopSQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOasTopSQLListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOasTopSQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOasTopSQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOasTopSQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOasTopSQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The page number, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # The page size, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The project ID.
        self.project_id = project_id  # type: str
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataDestConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        # Indicates whether message tracing is enabled when the destination data source is RocketMQ.
        self.enable_msg_trace = enable_msg_trace  # type: bool
        # The ID of the data source.
        self.endpoint_id = endpoint_id  # type: str
        # The type of the data source. Valid values: `MYSQL`, `MARIADB`, `OB_MYSQL`, `OB_MYSQL_CE`, `OB_ORACLE`, `ORACLE`, `DB2_LUW`, `KAFKA`, `ROCKETMQ`, `DATAHUB`, `SYBASE`, `LOGPROXY`, `ADB`, `DBP_OP_ROUTE`, `DMS`, `IDB`, and `TIDB`.
        self.endpoint_type = endpoint_type  # type: str
        # The tag of the Post message when the destination data source is RocketMQ.
        self.msg_tags = msg_tags  # type: str
        # The partitioned index, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ, and the partitioning mode is set to ONE.
        self.partition = partition  # type: int
        # The partitioning mode, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: ONE, HASH, and TABLE.
        self.partition_mode = partition_mode  # type: str
        # The producer group of the Post message when the destination data source is RocketMQ.
        self.producer_group = producer_group  # type: str
        # The timeout period in seconds for a single Post message when the destination data source is RocketMQ.
        self.send_msg_timeout = send_msg_timeout  # type: long
        # Indicates whether message sequencing is enabled when the destination data source is DataHub.
        self.sequence_enable = sequence_enable  # type: bool
        # The start time of the sequence, which must be specified if the destination data source is DataHub and message sequencing is enabled. The value is a timestamp in seconds.
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        # The text serialization type, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: Default, DefaultExtendColumnType, Canal, Dataworks, and SharePlex.
        self.serializer_type = serializer_type  # type: str
        # The type of the topic to which the Post message belongs when the destination data source is DataHub. Valid values: Tuple and Blob.
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataDestConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataLabels(TeaModel):
    def __init__(self, count=None, creator=None, id=None, name=None):
        # The number of projects that use this label.
        self.count = count  # type: int
        # The creator. This parameter value is returned only when you log on as the administrator.
        self.creator = creator  # type: str
        # The ID of a label.
        self.id = id  # type: str
        # The name of the label.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataSourceConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        # Indicates whether message tracing is enabled when the destination data source is RocketMQ.
        self.enable_msg_trace = enable_msg_trace  # type: bool
        # The ID of the data source.
        self.endpoint_id = endpoint_id  # type: str
        # The type of the data source. Valid values: `MYSQL`, `MARIADB`, `OB_MYSQL`, `OB_MYSQL_CE`, `OB_ORACLE`, `ORACLE`, `DB2_LUW`, `KAFKA`, `ROCKETMQ`, `DATAHUB`, `SYBASE`, `LOGPROXY`, `ADB`, `DBP_OP_ROUTE`, `DMS`, `IDB`, and `TIDB`.
        self.endpoint_type = endpoint_type  # type: str
        # The tag of the Post message when the destination data source is RocketMQ.
        self.msg_tags = msg_tags  # type: str
        # The partitioned index, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ, and the partitioning mode is set to ONE.
        self.partition = partition  # type: int
        # The partitioning mode, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: ONE, HASH, and TABLE.
        self.partition_mode = partition_mode  # type: str
        # The producer group of the Post message when the destination data source is RocketMQ.
        self.producer_group = producer_group  # type: str
        # The timeout period in seconds for a single Post message when the destination data source is RocketMQ.
        self.send_msg_timeout = send_msg_timeout  # type: long
        # Indicates whether message sequencing is enabled when the destination data source is DataHub.
        self.sequence_enable = sequence_enable  # type: bool
        # The start time of the sequence, which must be specified if the destination data source is DataHub and message sequencing is enabled. The value is a timestamp in seconds.
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        # The text serialization type, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: Default, DefaultExtendColumnType, Canal, Dataworks, and SharePlex.
        self.serializer_type = serializer_type  # type: str
        # The type of the topic to which the Post message belongs when the destination data source is DataHub. Valid values: Tuple and Blob.
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataSourceConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error code.
        self.code = code  # type: str
        # Valid values: CRITICAL, ERROR, and WARN.
        self.level = level  # type: str
        # The error message.
        self.message = message  # type: str
        # The suggestions (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        # The error code, such as AUTHENTICATION_ERROR, PARAM_ERROR, PARAM_ERROR_MESSAGE, NOT_IMPLEMENTED_ERROR, SHARD_COLUMNS_CONFLICT_MESSAGE, FAILED_PARSE_TOKEN_MESSAGE, CONNECT_CHECK_ERROR, NOT_SUPPORT_ERROR, CE_NOT_SUPPORT_ERROR, NOT_FOUND_ERROR, SHARDING_COLUMN_NOT_INCLUDED_ERROR, INNER_ERROR, DB_QUERY_ERROR, DATAHUB_QUERY_ERROR, USER_LACK_SYS_PRIV_ERROR, USER_LACK_TABLE_PRIV_ERROR, RM_API_ERROR, RM_TASK_ERROR, CM_API_ERROR, CM_API_NOT_SUCCESS, BAGUALU_API_ERROR, IDB_API_ERROR, SUPERVISOR_API_ERROR, OCP_API_ERROR, OCP_SERVICE_ERROR, OCP_QUERY_VERSION_FAILED, OCP_VERSION_INCORRECT_ERROR, OCP_VERSION_NOT_SUPPORTED_ERROR, OCP_API_USER_PASSWORD_INCORRECT_ERROR, OBSCHEMA_ERROR, EXECUTOR_THREAD_POOL_BUSY, NO_TABLE_SELECTED, NO_VIEW_SELECTED, SOURCE_CRAWLER_START_FAILED, SOURCE_CRAWLER_START_FAILED_DATA_EXPIRED, SOURCE_CRAWLER_START_TIMEOUT, DEST_WRITER_START_FAILED, WRITER_UNKNOWN_STATUS, DRC_TOPIC_EXISTS_ERROR, TOPIC_EMPTY_ERROR, REACH_WRITER_LIMIT_ERROR, FOUND_NO_FEASIBLE_STORE_ERROR, TOO_MANY_STORES_FOR_SUBTOPIC, TIMEOUT_EXCEPTION, KIPP_API_ERROR, KIPP_API_RESOURCE_NOT_FOUND, KIPP_API_INVALID_PARAM, KIPP_API_UNKNOWN_ERROR, KIPP_API_INTERNAL_ERROR, KIPP_API_SERVICE_UNAVAILABLE, OMS_AGENT_API_ERROR, KMS_API_ERROR, OMS_ENCRYPT_API_ERROR, OMS_DECRYPT_API_ERROR, ALIYUN_SDK_ERROR, YAOCHI_API_ERROR, RESOURCE_WITHOUT_STOCK_ERROR, RESOURCE_NO_AVAILABLE_ZONE, CM_SDK_ERROR, MIGRATION_PROJECT_STEP_PRECHECK_FAILED, PRE_CHECK_ERROR, FAILURES_CORRECT_ERROR, EXECUTE_DDL_FAILURE, EXECUTE_DDL_UNSUPPORTED_OR_FAILURE, STRUCT_RECORD_DDL_NOT_FOUND, STRUCT_RECORD_INDEX_NOT_FOUND, STRUCT_RECORD_NOT_FOUND, STRUCT_RECORD_NOT_FOUND_IN_DBCAT, SCHEMA_OBJECT_TYPE_NOT_SUPPORT_ERROR, POLAR_MYSQL_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_VPC_NETWORK_NOT_SUPPORT_ERROR, DB_TYPE_NOT_SUPPORT_ERROR, SYNC_TYPE_NOT_SUPPORT_ERROR, SLAVE_OPERATION_STEP_NOT_SUPPORT_ERROR, BYTE_USED_TYPE_NOT_SUPPORT_ERROR, MANY_TO_ONE_SCHEMA_TABLE_REVERSE_INCR_NOT_SUPPORT_ERROR, DUPLICATE_SCHEMA_TABLE_ERROR, OMS_STEP_NOT_SUPPORT_ERROR, ORACLE_DATABASE_ROLE_NOT_SUPPORT_ERROR, OLD_PRE_CHECK_NOT_SUPPORT_ERROR, SCHEMA_ONE_TO_MANY_NOT_SUPPORT_ERROR, PROJECT_NOT_FOUND_ERROR, ENDPOINT_NOT_FOUND_ERROR, ENDPOINT_NAME_ALREADY_EXIST_ERROR, ENDPOINT_QUERY_ERROR, ENDPOINT_SQL_QUERY_ERROR, PROJECT_NAME_ALREADY_EXIST_ERROR, CHECKER_NOT_FOUND_ERROR, CHECKER_FAILED_ERROR, CHECKER_STATUS_UNEXPECTED_ERROR, CHECKER_NO_TASK_TYPE_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR, WORKER_INSTANCE_ALLOCATING_ERROR, LOG_SERVICE_TOPIC_NOT_FOUND_ERROR, CLUSTER_NOT_FOUND_ERROR, TENANT_NOT_FOUND_ERROR, DATABASE_NOT_FOUND_ERROR, TABLE_NOT_FOUND_ERROR, COLUMN_NOT_FOUND_ERROR, TABLE_META_NOT_FOUND_ERROR, SYBASE_CHARSET_NOT_FOUND_ERROR, OCP_NOT_FOUND_ERROR, REGION_NOT_FOUND_ERROR, OCP_ALREADY_EXIST_ERROR, ALARM_CHANNEL_NAME_ALREADY_EXIST_ERROR, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_RESPONSE, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_STATUS, LABEL_ALREADY_EXIST_ERROR, LABEL_NOT_EXIST_ERROR, OCP_ALREADY_USED_ERROR, REGION_INFO_INCONSISTENT_ERROR, OCP_NAME_EMPTY_ERROR, MASTER_SLAVE_ENDPOINT_NAME_INCONSISTENT_ERROR, LOG_FILE_NOT_FOUND_ERROR, OPERATION_NOT_ALLOWED_ERROR, PROJECT_OPERATION_NOT_ALLOWED_ERROR, PROJECT_RELEASE_FAILED, STRUCT_MIGRATION_RETRY_NOT_ALLOWED_ERROR, WORKER_INSTANCE_OPERATION_NOT_ALLOWED_ERROR, USER_OPERATION_NOT_ALLOWED_ERROR, OCP_NAME_OR_REGION_NOT_ALLOWED_UPDATE, UPDATE_CONFIG_WITH_NEWLINE_NOT_ALLOWED, EXIST_UNRELEASED_PROJECT_ERROR, EXIST_UNRELEASED_TOPIC_ERROR, LABEL_CREATE_NOT_ALLOWED_ERROR, LABEL_UPDATE_NOT_ALLOWED_ERROR, LABEL_DELETE_NOT_ALLOWED_ERROR, TOPIC_NAME_INVALID_ERROR, INVALID_STATUS_ERROR, INVALID_CSV_HEAD_ERROR, INVALID_CSV_BODY_ERROR, DUPLICATE_SCHEMA_TABLE_SETTING_ERROR, PROJECT_INVALID_STATUS_ERROR, PROJECT_INVALID_CONNECTOR_COUNT_ERROR, WORKER_INSTANCE_INVALID_STATUS_ERROR, LOG_SERVICE_INVALID_STATUS_ERROR, STEP_INVALID_STATUS_ERROR, UPDATE_ALLOW_DEST_TABLE_NOT_EMPTY_NOT_ALLOWED_ERROR, EXIST_INCONSISTENCY_ERROR, OMS_SWITCH_SUBSTEP_FAILED_ERROR, ENDPOINT_ID_INVALID_ERROR, DB_QUERY_VERSION_EMPTY_ERROR, ENDPOINT_NAME_INVALID_ERROR, ENDPOINT_SCHEMA_NOT_ALLOWED_ERROR, ENDPOINT_SCHEMA_CHAR_NOT_ALLOWED_ERROR, NAME_HAS_SPACE_EXCEPTION, CONFIG_CONVERT_VALUE_ERROR, CONFIG_VALUE_EXCEEDS_LIMIT_ERROR, CONFIG_KEY_NOT_FOUND_KEY_ERROR, CONFIG_VALUE_NOT_EMPTY_ERROR, SCHEMA_HAS_CONVERT_INFO, TIME_SERIES_QUERY_SERVICE_ERROR, ETL_VERIFY_ERROR, ETL_SYNTAX_UNSUPPORTED, ETL_FIELD_NOTFOUND, ETL_FAILED_PARSE_SQL, ETL_VAL_TYPE_ERROR, NOT_SUPPORT_GENERATE_COLUMNS, NOT_SUPPORT_UPDATE_ETL, LOCK_FAILED, OMS_USER_EXIST_ERROR, OMS_USER_NOT_FOUND_ERROR, OMS_USER_NAME_LENGTH_CONSTRAINT, OMS_USER_PASSWORD_ERROR, USER_NAME_OR_PASSWORD_ERROR, OMS_USER_PASSWORD_VALIDATION_ERROR, OMS_USER_PASSWORD_DEFAULT_ERROR, OMS_USER_PERMISSION_DENIED_ERROR, OMS_USER_EDIT_ADMIN_ROLE_INFO_PERMISSION_DENIED_ERROR, OMS_USER_ILLEGAL_DELETED_ERROR, CONNECTOR_TASK_NOT_FOUND_ERROR, CONNECTOR_TASK_NUM_LIMIT_ERROR, CONNECTOR_TASK_DELETE_ERROR, METRIC_SERVICE_ERROR, SYNC_PROJECT_TYPE_INVALID_ERROR, SYNC_SHARDING_COLUMNS_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_LIMIT_EXCEEDS_ERROR, SYNC_PROJECT_COMPLEMENT_CONFIG_ERROR, META_SCHEMA_CREATE_FAILED, RESUME_STEP_FAILED, SCHEMA_INCONSISTENCY, SCHEMA_CASCADE_MAPPING_NOT_SUPPORT_ERROR, SCHEMA_NOT_EXISTED, SCHEMA_EXISTED, SCHEMA_NOT_EXIST, BLACK_LIST_MATCH_ALL, BLACK_LIST_CONTAIN_NON_WHITE_SCHEMA, BLACK_WHITE_LIST_PARAM_INVALID_ERROR, OPERATOR_ERROR, OPERATOR_DIMENSION_NOT_SUPPORT, OPERATOR_PULL_LOG_ERROR, OPERATOR_UPDATE_CONFIG_NOT_SUPPORT, KAFKA_CREATE_TOPIC_ERROR, KAFKA_QUERY_TOPIC_ERROR, KAFKA_BUILD_PROPERTIES_ERROR, ROCKETMQ_CREATE_TOPIC_ERROR, ROCKETMQ_QUERY_TOPIC_ERROR, SYNC_OBJECT_EMPTY_ERROR, WRITER_NUMBER_NOT_UNIQUE, WRITER_NOT_ACTIVE, PROJECT_NAME_DUPLICATE_ERROR, EMPTY_FAILED_STRUCT_MIGRATION_TABLES_ERROR, LOGIC_TABLE_NOT_SUPPORT_UPDATE_OBJECT_ERROR, LOGIC_REQUEST_ERROR, LOGIC_DTO_BUILD_ERROR, UNEXPECTED_REMOTE_API_RESULT, OCEANBASE_USER_UNEXPECTED, STORE_CREATE_FAILED_ERROR, STORE_START_FAILED, STORE_NOT_PULL_LOG_ERROR, ALL_HOSTS_STATUS_ERROR, WORKER_ECS_NOT_FOUND_ERROR, WORKER_ECS_NOT_FOUND_FOR_USER_ERROR, WORKER_POD_NOT_FOUND_ERROR, WORKER_POD_NOT_FOUND_FOR_USER_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR_V2, and WORKER_INSTANCE_NOT_FOUND_FOR_USER_ERROR.
        self.error_code = error_code  # type: str
        # The error details.
        self.error_details = error_details  # type: list[DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfoErrorDetails]
        # The error message.
        self.error_msg = error_msg  # type: str
        # The error related parameters.
        self.error_param = error_param  # type: dict[str, str]
        # The time when the error occurred.
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfoConnectorFullProgressOverview(TeaModel):
    def __init__(self, estimated_remaining_time_of_sec=None, estimated_total_count=None, finished_count=None,
                 progress=None):
        # The estimated maximum time remained, in seconds.
        self.estimated_remaining_time_of_sec = estimated_remaining_time_of_sec  # type: long
        # The estimated amount of data to migrate.
        self.estimated_total_count = estimated_total_count  # type: long
        # The amount of data migrated.
        self.finished_count = finished_count  # type: long
        # finishedCount / estimatedTotalCount
        self.progress = progress  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfoConnectorFullProgressOverview, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_time_of_sec is not None:
            result['EstimatedRemainingTimeOfSec'] = self.estimated_remaining_time_of_sec
        if self.estimated_total_count is not None:
            result['EstimatedTotalCount'] = self.estimated_total_count
        if self.finished_count is not None:
            result['FinishedCount'] = self.finished_count
        if self.progress is not None:
            result['Progress'] = self.progress
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingTimeOfSec') is not None:
            self.estimated_remaining_time_of_sec = m.get('EstimatedRemainingTimeOfSec')
        if m.get('EstimatedTotalCount') is not None:
            self.estimated_total_count = m.get('EstimatedTotalCount')
        if m.get('FinishedCount') is not None:
            self.finished_count = m.get('FinishedCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfo(TeaModel):
    def __init__(self, capacity=None, checkpoint=None, connector_full_progress_overview=None, deploy_id=None,
                 dst_iops=None, dst_rps=None, dst_rps_ref=None, dst_rt=None, dst_rt_ref=None, gmt=None, inconsistencies=None,
                 incr_timestamp_checkpoint=None, job_id=None, processed_records=None, skipped=None, src_iops=None, src_iops_ref=None,
                 src_rps=None, src_rps_ref=None, src_rt=None, src_rt_ref=None, validated=None):
        # The estimated total number of rows.
        self.capacity = capacity  # type: long
        # The checkpoint. The value is a unix timestamp in seconds.
        self.checkpoint = checkpoint  # type: str
        # The full synchronization progress.
        self.connector_full_progress_overview = connector_full_progress_overview  # type: DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfoConnectorFullProgressOverview
        # The resource deployment ID.
        self.deploy_id = deploy_id  # type: str
        # The read/write throughput of the destination data source, in bytes per second.
        self.dst_iops = dst_iops  # type: long
        # The read/write RPS of the destination data source.
        self.dst_rps = dst_rps  # type: long
        # The read/write RPS baseline of the destination data source.
        self.dst_rps_ref = dst_rps_ref  # type: long
        # The read/write RT per record of the destination data source, in ms.
        self.dst_rt = dst_rt  # type: long
        # The read/write RT baseline of the destination data source.
        self.dst_rt_ref = dst_rt_ref  # type: long
        # The checkpoint collection time. The value is a unix timestamp in seconds.
        self.gmt = gmt  # type: long
        # The amount of inconsistent data found during full verification.
        self.inconsistencies = inconsistencies  # type: long
        # The checkpoint in incremental synchronization. The value is a unix timestamp in seconds.
        self.incr_timestamp_checkpoint = incr_timestamp_checkpoint  # type: long
        # The job ID.
        self.job_id = job_id  # type: str
        # The number of migrated rows.
        self.processed_records = processed_records  # type: long
        # A sub-status that indicates whether this step is skipped.
        self.skipped = skipped  # type: bool
        # The read throughput of the source data source, in bytes per second.
        self.src_iops = src_iops  # type: long
        # The read throughput baseline of the source data source.
        self.src_iops_ref = src_iops_ref  # type: long
        # The read requests per second (RPS) of the source data source.
        self.src_rps = src_rps  # type: long
        # The read RPS baseline of the source data source.
        self.src_rps_ref = src_rps_ref  # type: long
        # The read response time (RT) per record of the source data source, in ms.
        self.src_rt = src_rt  # type: long
        # The read RT baseline of the source data source.
        self.src_rt_ref = src_rt_ref  # type: long
        # A sub-status that indicates whether the checker has completed full verification.
        self.validated = validated  # type: bool

    def validate(self):
        if self.connector_full_progress_overview:
            self.connector_full_progress_overview.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.checkpoint is not None:
            result['Checkpoint'] = self.checkpoint
        if self.connector_full_progress_overview is not None:
            result['ConnectorFullProgressOverview'] = self.connector_full_progress_overview.to_map()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.dst_iops is not None:
            result['DstIops'] = self.dst_iops
        if self.dst_rps is not None:
            result['DstRps'] = self.dst_rps
        if self.dst_rps_ref is not None:
            result['DstRpsRef'] = self.dst_rps_ref
        if self.dst_rt is not None:
            result['DstRt'] = self.dst_rt
        if self.dst_rt_ref is not None:
            result['DstRtRef'] = self.dst_rt_ref
        if self.gmt is not None:
            result['Gmt'] = self.gmt
        if self.inconsistencies is not None:
            result['Inconsistencies'] = self.inconsistencies
        if self.incr_timestamp_checkpoint is not None:
            result['IncrTimestampCheckpoint'] = self.incr_timestamp_checkpoint
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.processed_records is not None:
            result['ProcessedRecords'] = self.processed_records
        if self.skipped is not None:
            result['Skipped'] = self.skipped
        if self.src_iops is not None:
            result['SrcIops'] = self.src_iops
        if self.src_iops_ref is not None:
            result['SrcIopsRef'] = self.src_iops_ref
        if self.src_rps is not None:
            result['SrcRps'] = self.src_rps
        if self.src_rps_ref is not None:
            result['SrcRpsRef'] = self.src_rps_ref
        if self.src_rt is not None:
            result['SrcRt'] = self.src_rt
        if self.src_rt_ref is not None:
            result['SrcRtRef'] = self.src_rt_ref
        if self.validated is not None:
            result['Validated'] = self.validated
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('Checkpoint') is not None:
            self.checkpoint = m.get('Checkpoint')
        if m.get('ConnectorFullProgressOverview') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfoConnectorFullProgressOverview()
            self.connector_full_progress_overview = temp_model.from_map(m['ConnectorFullProgressOverview'])
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('DstIops') is not None:
            self.dst_iops = m.get('DstIops')
        if m.get('DstRps') is not None:
            self.dst_rps = m.get('DstRps')
        if m.get('DstRpsRef') is not None:
            self.dst_rps_ref = m.get('DstRpsRef')
        if m.get('DstRt') is not None:
            self.dst_rt = m.get('DstRt')
        if m.get('DstRtRef') is not None:
            self.dst_rt_ref = m.get('DstRtRef')
        if m.get('Gmt') is not None:
            self.gmt = m.get('Gmt')
        if m.get('Inconsistencies') is not None:
            self.inconsistencies = m.get('Inconsistencies')
        if m.get('IncrTimestampCheckpoint') is not None:
            self.incr_timestamp_checkpoint = m.get('IncrTimestampCheckpoint')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProcessedRecords') is not None:
            self.processed_records = m.get('ProcessedRecords')
        if m.get('Skipped') is not None:
            self.skipped = m.get('Skipped')
        if m.get('SrcIops') is not None:
            self.src_iops = m.get('SrcIops')
        if m.get('SrcIopsRef') is not None:
            self.src_iops_ref = m.get('SrcIopsRef')
        if m.get('SrcRps') is not None:
            self.src_rps = m.get('SrcRps')
        if m.get('SrcRpsRef') is not None:
            self.src_rps_ref = m.get('SrcRpsRef')
        if m.get('SrcRt') is not None:
            self.src_rt = m.get('SrcRt')
        if m.get('SrcRtRef') is not None:
            self.src_rt_ref = m.get('SrcRtRef')
        if m.get('Validated') is not None:
            self.validated = m.get('Validated')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataSteps(TeaModel):
    def __init__(self, estimated_remaining_seconds=None, extra_info=None, finish_time=None, interactive=None,
                 start_time=None, step_description=None, step_info=None, step_name=None, step_order=None, step_progress=None,
                 step_status=None):
        # The estimated time remained.
        self.estimated_remaining_seconds = estimated_remaining_seconds  # type: long
        # The additional information. The value is a JSON string.
        self.extra_info = extra_info  # type: DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfo
        # The end time, in the format of "2020-05-22T17:04:18".
        self.finish_time = finish_time  # type: str
        # Indicates whether the current step must be confirmed by the user, rather than scheduled in the backend.
        self.interactive = interactive  # type: bool
        # The start time, in the format of "2020-05-22T17:04:18".
        self.start_time = start_time  # type: str
        # The description of the step, for example, schema migration, full migration, full verification, incremental log pull, incremental synchronization, or incremental verification.
        self.step_description = step_description  # type: str
        # The step details. The value is a JSON string.
        self.step_info = step_info  # type: DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfo
        # The step name. Valid values: struct_migration, full_migration, full_validation, incr_log_pull, incr_sync/incr_validation, PRE_CHECK, PREPARE, STRUCT_MIGRATION, INDEX_MIGRATION, STRUCT_SYNC, FULL_MIGRATION, APP_SWITCH, REVERSE_INCR_SYNC, FULL_VALIDATION, INCR_LOG_PULL, INCR_SYNC, INCR_VALIDATION, SYNC_PREPARE, SYNC_INCR_LOG_PULL, CONNECTOR_FULL_SYNC, or CONNECTOR_INCR_SYNC.
        self.step_name = step_name  # type: str
        # The sequence of steps.
        self.step_order = step_order  # type: int
        # The step progress.
        self.step_progress = step_progress  # type: int
        # The step status. Valid values: INIT, RUNNING, FAILED, FINISHED, SUSPEND, and MONITORING. The value MONITORING indicates the continuous monitoring of incremental synchronization and incremental verification.
        self.step_status = step_status  # type: str

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()
        if self.step_info:
            self.step_info.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataSteps, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_seconds is not None:
            result['EstimatedRemainingSeconds'] = self.estimated_remaining_seconds
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.interactive is not None:
            result['Interactive'] = self.interactive
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.step_description is not None:
            result['StepDescription'] = self.step_description
        if self.step_info is not None:
            result['StepInfo'] = self.step_info.to_map()
        if self.step_name is not None:
            result['StepName'] = self.step_name
        if self.step_order is not None:
            result['StepOrder'] = self.step_order
        if self.step_progress is not None:
            result['StepProgress'] = self.step_progress
        if self.step_status is not None:
            result['StepStatus'] = self.step_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingSeconds') is not None:
            self.estimated_remaining_seconds = m.get('EstimatedRemainingSeconds')
        if m.get('ExtraInfo') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataStepsExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Interactive') is not None:
            self.interactive = m.get('Interactive')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StepDescription') is not None:
            self.step_description = m.get('StepDescription')
        if m.get('StepInfo') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataStepsStepInfo()
            self.step_info = temp_model.from_map(m['StepInfo'])
        if m.get('StepName') is not None:
            self.step_name = m.get('StepName')
        if m.get('StepOrder') is not None:
            self.step_order = m.get('StepOrder')
        if m.get('StepProgress') is not None:
            self.step_progress = m.get('StepProgress')
        if m.get('StepStatus') is not None:
            self.step_status = m.get('StepStatus')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        # The list of distribution key columns.
        self.distributed_keys = distributed_keys  # type: list[str]
        # The lifecycle of the table.
        self.partition_life_cycle = partition_life_cycle  # type: int
        # The partitioning expression.
        self.partition_statement = partition_statement  # type: str
        # The list of primary key columns.
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, mapped_name=None, shard_columns=None,
                 table_id=None, table_name=None, type=None, where_clause=None):
        # The schema of the ADB table. If the destination data source is ADB, you need to configure additional information for schema synchronization.
        self.adb_table_schema = adb_table_schema  # type: DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema
        # The list of filter columns, which are the columns to be synchronized.
        self.filter_columns = filter_columns  # type: list[str]
        # The name of the mapped-to table or topic. If the destination data source is a database, this parameter specifies the name of the mapped-to table. If the destination data source is a message queue system, this parameter specifies the name of the mapped-to topic.
        self.mapped_name = mapped_name  # type: str
        # The list of sharding key columns. This parameter applies to scenarios where the destination data source is a message queue system.
        self.shard_columns = shard_columns  # type: list[str]
        # The ID of the table. This parameter takes effect when the source data source is IDB.
        self.table_id = table_id  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # Valid values: DATABASE and TABLE.
        self.type = type  # type: str
        # The row filter conditions.
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.type is not None:
            result['Type'] = self.type
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabases(TeaModel):
    def __init__(self, database_id=None, database_name=None, mapped_name=None, tables=None, tenant_name=None,
                 type=None):
        # The ID of the database. This parameter takes effect when the source data source is IDB.
        self.database_id = database_id  # type: str
        # The name of the database.
        self.database_name = database_name  # type: str
        # The mapped-to database. This parameter takes effect when the destination data source is a database.
        self.mapped_name = mapped_name  # type: str
        # The settings for the target table objects in the current database.
        self.tables = tables  # type: list[DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTables]
        # The mapped-to tenant. This parameter takes effect when the source data source is OceanBase Database.
        self.tenant_name = tenant_name  # type: str
        # Valid values: DATABASE and TABLE.
        self.type = type  # type: str

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferMapping(TeaModel):
    def __init__(self, databases=None, mode=None):
        # The table mapping in the source data source, which is a conventional mapping scheme and takes effect only when Mode is set to NORMAL.
        self.databases = databases  # type: list[DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabases]
        # The mapping type. Valid values: \"NORMAL\" and \"WHITE_AND_BLACK_LIST\".
        self.mode = mode  # type: str

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferMappingDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig(TeaModel):
    def __init__(self, record_type_list=None, start_timestamp=None, store_log_kept_hour=None,
                 store_transaction_enabled=None, transfer_step_type=None):
        # The list of data types of incremental data synchronized in incremental synchronization.
        self.record_type_list = record_type_list  # type: list[str]
        # The start time for incremental synchronization. The value is a timestamp in seconds.
        self.start_timestamp = start_timestamp  # type: long
        # The retention time of logs when incremental synchronization is enabled and the incremental log pull component is Store.
        self.store_log_kept_hour = store_log_kept_hour  # type: long
        # Indicates whether intra-transaction sequencing is enabled when incremental synchronization is enabled and the incremental log pull component is Store.
        self.store_transaction_enabled = store_transaction_enabled  # type: bool
        # Valid values: STRUCT, FULL, and INCR.
        self.transfer_step_type = transfer_step_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_type_list is not None:
            result['RecordTypeList'] = self.record_type_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        if self.store_transaction_enabled is not None:
            result['StoreTransactionEnabled'] = self.store_transaction_enabled
        if self.transfer_step_type is not None:
            result['TransferStepType'] = self.transfer_step_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RecordTypeList') is not None:
            self.record_type_list = m.get('RecordTypeList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        if m.get('StoreTransactionEnabled') is not None:
            self.store_transaction_enabled = m.get('StoreTransactionEnabled')
        if m.get('TransferStepType') is not None:
            self.transfer_step_type = m.get('TransferStepType')
        return self


class DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfig(TeaModel):
    def __init__(self, enable_full_sync=None, enable_incr_sync=None, enable_struct_sync=None,
                 incr_sync_step_transfer_config=None):
        # Indicates whether full migration is enabled.
        self.enable_full_sync = enable_full_sync  # type: bool
        # Indicates whether incremental synchronization is enabled.
        self.enable_incr_sync = enable_incr_sync  # type: bool
        # Indicates whether schema synchronization is enabled.
        self.enable_struct_sync = enable_struct_sync  # type: bool
        # The settings of incremental synchronization steps.
        self.incr_sync_step_transfer_config = incr_sync_step_transfer_config  # type: DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig

    def validate(self):
        if self.incr_sync_step_transfer_config:
            self.incr_sync_step_transfer_config.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_full_sync is not None:
            result['EnableFullSync'] = self.enable_full_sync
        if self.enable_incr_sync is not None:
            result['EnableIncrSync'] = self.enable_incr_sync
        if self.enable_struct_sync is not None:
            result['EnableStructSync'] = self.enable_struct_sync
        if self.incr_sync_step_transfer_config is not None:
            result['IncrSyncStepTransferConfig'] = self.incr_sync_step_transfer_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableFullSync') is not None:
            self.enable_full_sync = m.get('EnableFullSync')
        if m.get('EnableIncrSync') is not None:
            self.enable_incr_sync = m.get('EnableIncrSync')
        if m.get('EnableStructSync') is not None:
            self.enable_struct_sync = m.get('EnableStructSync')
        if m.get('IncrSyncStepTransferConfig') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig()
            self.incr_sync_step_transfer_config = temp_model.from_map(m['IncrSyncStepTransferConfig'])
        return self


class DescribeOmsOpenAPIProjectResponseBodyData(TeaModel):
    def __init__(self, business_name=None, dest_config=None, labels=None, project_id=None, project_name=None,
                 project_owner=None, source_config=None, steps=None, transfer_mapping=None, transfer_step_config=None):
        # The business system identifier, which is optional and is a specific field of the Post message.
        self.business_name = business_name  # type: str
        # The settings of the destination data source.
        self.dest_config = dest_config  # type: DescribeOmsOpenAPIProjectResponseBodyDataDestConfig
        # A collection of label IDs.
        self.labels = labels  # type: list[DescribeOmsOpenAPIProjectResponseBodyDataLabels]
        # The project ID.
        self.project_id = project_id  # type: str
        # The name of the project.
        self.project_name = project_name  # type: str
        # The project owner.
        self.project_owner = project_owner  # type: str
        # The settings of the source data source.
        self.source_config = source_config  # type: DescribeOmsOpenAPIProjectResponseBodyDataSourceConfig
        # The detailed project steps.
        self.steps = steps  # type: list[DescribeOmsOpenAPIProjectResponseBodyDataSteps]
        # The mappings for the synchronization objects.
        self.transfer_mapping = transfer_mapping  # type: DescribeOmsOpenAPIProjectResponseBodyDataTransferMapping
        # The settings of synchronization steps
        self.transfer_step_config = transfer_step_config  # type: DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfig

    def validate(self):
        if self.dest_config:
            self.dest_config.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.source_config:
            self.source_config.validate()
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()
        if self.transfer_step_config:
            self.transfer_step_config.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.dest_config is not None:
            result['DestConfig'] = self.dest_config.to_map()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        if self.project_owner is not None:
            result['ProjectOwner'] = self.project_owner
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config.to_map()
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.transfer_step_config is not None:
            result['TransferStepConfig'] = self.transfer_step_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('DestConfig') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataDestConfig()
            self.dest_config = temp_model.from_map(m['DestConfig'])
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeOmsOpenAPIProjectResponseBodyDataLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        if m.get('ProjectOwner') is not None:
            self.project_owner = m.get('ProjectOwner')
        if m.get('SourceConfig') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataSourceConfig()
            self.source_config = temp_model.from_map(m['SourceConfig'])
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = DescribeOmsOpenAPIProjectResponseBodyDataSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('TransferMapping') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('TransferStepConfig') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyDataTransferStepConfig()
            self.transfer_step_config = temp_model.from_map(m['TransferStepConfig'])
        return self


class DescribeOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error code (new).
        self.code = code  # type: str
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.level = level  # type: str
        # The error description (new).
        self.message = message  # type: str
        # The suggestions (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class DescribeOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # The suggestions (old).
        self.advice = advice  # type: str
        # The error code (old).
        self.code = code  # type: str
        # The time spent in processing the request, in seconds.
        self.cost = cost  # type: str
        # The business data returned.
        self.data = data  # type: DescribeOmsOpenAPIProjectResponseBodyData
        # The error details.
        self.error_detail = error_detail  # type: DescribeOmsOpenAPIProjectResponseBodyErrorDetail
        # The error description (old).
        self.message = message  # type: str
        # The page number, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # The page size, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful.
        self.success = success  # type: bool
        # The total count, which takes effect in a pagination query.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOmsOpenAPIProjectStepsRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The read RT baseline of the source data source.
        self.page_number = page_number  # type: int
        # The read/write RPS baseline of the destination data source.
        self.page_size = page_size  # type: int
        # The read/write RT baseline of the destination data source.
        self.project_id = project_id  # type: str
        # The read RT baseline of the source data source.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The suggestions (old).
        self.code = code  # type: str
        # Contact the administrator.
        self.level = level  # type: str
        # A sub-status that indicates whether the checker has completed full verification.
        self.message = message  # type: str
        # The amount of data migrated.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        # The job ID.
        self.error_code = error_code  # type: str
        # Schema migration
        self.error_details = error_details  # type: list[DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfoErrorDetails]
        # The resource deployment ID.
        self.error_msg = error_msg  # type: str
        # The error code (new).
        self.error_param = error_param  # type: dict[str, str]
        # The additional information. The value is a JSON string.
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfoConnectorFullProgressOverview(TeaModel):
    def __init__(self, estimated_remaining_time_of_sec=None, estimated_total_count=None, finished_count=None,
                 progress=None):
        # A sub-status that indicates whether this step is skipped.
        self.estimated_remaining_time_of_sec = estimated_remaining_time_of_sec  # type: long
        # The read RPS baseline of the source data source.
        self.estimated_total_count = estimated_total_count  # type: long
        # The read/write RT per record of the destination data source, in ms.
        self.finished_count = finished_count  # type: long
        # The business data returned.
        self.progress = progress  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfoConnectorFullProgressOverview, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_time_of_sec is not None:
            result['EstimatedRemainingTimeOfSec'] = self.estimated_remaining_time_of_sec
        if self.estimated_total_count is not None:
            result['EstimatedTotalCount'] = self.estimated_total_count
        if self.finished_count is not None:
            result['FinishedCount'] = self.finished_count
        if self.progress is not None:
            result['Progress'] = self.progress
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingTimeOfSec') is not None:
            self.estimated_remaining_time_of_sec = m.get('EstimatedRemainingTimeOfSec')
        if m.get('EstimatedTotalCount') is not None:
            self.estimated_total_count = m.get('EstimatedTotalCount')
        if m.get('FinishedCount') is not None:
            self.finished_count = m.get('FinishedCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfo(TeaModel):
    def __init__(self, capacity=None, checkpoint=None, connector_full_progress_overview=None, deploy_id=None,
                 dst_iops=None, dst_rps=None, dst_rps_ref=None, dst_rt=None, dst_rt_ref=None, gmt=None, inconsistencies=None,
                 incr_timestamp_checkpoint=None, job_id=None, processed_records=None, skipped=None, src_iops=None, src_iops_ref=None,
                 src_rps=None, src_rps_ref=None, src_rt=None, src_rt_ref=None, validated=None):
        # The total count, which takes effect in a pagination query.
        self.capacity = capacity  # type: long
        # The operation that you want to perform. Set the value to **DescribeOmsOpenAPIProjectSteps**.
        self.checkpoint = checkpoint  # type: str
        # The error code, such as AUTHENTICATION_ERROR, PARAM_ERROR, PARAM_ERROR_MESSAGE, NOT_IMPLEMENTED_ERROR, SHARD_COLUMNS_CONFLICT_MESSAGE, FAILED_PARSE_TOKEN_MESSAGE, CONNECT_CHECK_ERROR, NOT_SUPPORT_ERROR, CE_NOT_SUPPORT_ERROR, NOT_FOUND_ERROR, SHARDING_COLUMN_NOT_INCLUDED_ERROR, INNER_ERROR, DB_QUERY_ERROR, DATAHUB_QUERY_ERROR, USER_LACK_SYS_PRIV_ERROR, USER_LACK_TABLE_PRIV_ERROR, RM_API_ERROR, RM_TASK_ERROR, CM_API_ERROR, CM_API_NOT_SUCCESS, BAGUALU_API_ERROR, IDB_API_ERROR, SUPERVISOR_API_ERROR, OCP_API_ERROR, OCP_SERVICE_ERROR, OCP_QUERY_VERSION_FAILED, OCP_VERSION_INCORRECT_ERROR, OCP_VERSION_NOT_SUPPORTED_ERROR, OCP_API_USER_PASSWORD_INCORRECT_ERROR, OBSCHEMA_ERROR, EXECUTOR_THREAD_POOL_BUSY, NO_TABLE_SELECTED, NO_VIEW_SELECTED, SOURCE_CRAWLER_START_FAILED, SOURCE_CRAWLER_START_FAILED_DATA_EXPIRED, SOURCE_CRAWLER_START_TIMEOUT, DEST_WRITER_START_FAILED, WRITER_UNKNOWN_STATUS, DRC_TOPIC_EXISTS_ERROR, TOPIC_EMPTY_ERROR, REACH_WRITER_LIMIT_ERROR, FOUND_NO_FEASIBLE_STORE_ERROR, TOO_MANY_STORES_FOR_SUBTOPIC, TIMEOUT_EXCEPTION, KIPP_API_ERROR, KIPP_API_RESOURCE_NOT_FOUND, KIPP_API_INVALID_PARAM, KIPP_API_UNKNOWN_ERROR, KIPP_API_INTERNAL_ERROR, KIPP_API_SERVICE_UNAVAILABLE, OMS_AGENT_API_ERROR, KMS_API_ERROR, OMS_ENCRYPT_API_ERROR, OMS_DECRYPT_API_ERROR, ALIYUN_SDK_ERROR, YAOCHI_API_ERROR, RESOURCE_WITHOUT_STOCK_ERROR, RESOURCE_NO_AVAILABLE_ZONE, CM_SDK_ERROR, MIGRATION_PROJECT_STEP_PRECHECK_FAILED, PRE_CHECK_ERROR, FAILURES_CORRECT_ERROR, EXECUTE_DDL_FAILURE, EXECUTE_DDL_UNSUPPORTED_OR_FAILURE, STRUCT_RECORD_DDL_NOT_FOUND, STRUCT_RECORD_INDEX_NOT_FOUND, STRUCT_RECORD_NOT_FOUND, STRUCT_RECORD_NOT_FOUND_IN_DBCAT, SCHEMA_OBJECT_TYPE_NOT_SUPPORT_ERROR, POLAR_MYSQL_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_VPC_NETWORK_NOT_SUPPORT_ERROR, DB_TYPE_NOT_SUPPORT_ERROR, SYNC_TYPE_NOT_SUPPORT_ERROR, SLAVE_OPERATION_STEP_NOT_SUPPORT_ERROR, BYTE_USED_TYPE_NOT_SUPPORT_ERROR, MANY_TO_ONE_SCHEMA_TABLE_REVERSE_INCR_NOT_SUPPORT_ERROR, DUPLICATE_SCHEMA_TABLE_ERROR, OMS_STEP_NOT_SUPPORT_ERROR, ORACLE_DATABASE_ROLE_NOT_SUPPORT_ERROR, OLD_PRE_CHECK_NOT_SUPPORT_ERROR, SCHEMA_ONE_TO_MANY_NOT_SUPPORT_ERROR, PROJECT_NOT_FOUND_ERROR, ENDPOINT_NOT_FOUND_ERROR, ENDPOINT_NAME_ALREADY_EXIST_ERROR, ENDPOINT_QUERY_ERROR, ENDPOINT_SQL_QUERY_ERROR, PROJECT_NAME_ALREADY_EXIST_ERROR, CHECKER_NOT_FOUND_ERROR, CHECKER_FAILED_ERROR, CHECKER_STATUS_UNEXPECTED_ERROR, CHECKER_NO_TASK_TYPE_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR, WORKER_INSTANCE_ALLOCATING_ERROR, LOG_SERVICE_TOPIC_NOT_FOUND_ERROR, CLUSTER_NOT_FOUND_ERROR, TENANT_NOT_FOUND_ERROR, DATABASE_NOT_FOUND_ERROR, TABLE_NOT_FOUND_ERROR, COLUMN_NOT_FOUND_ERROR, TABLE_META_NOT_FOUND_ERROR, SYBASE_CHARSET_NOT_FOUND_ERROR, OCP_NOT_FOUND_ERROR, REGION_NOT_FOUND_ERROR, OCP_ALREADY_EXIST_ERROR, ALARM_CHANNEL_NAME_ALREADY_EXIST_ERROR, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_RESPONSE, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_STATUS, LABEL_ALREADY_EXIST_ERROR, LABEL_NOT_EXIST_ERROR, OCP_ALREADY_USED_ERROR, REGION_INFO_INCONSISTENT_ERROR, OCP_NAME_EMPTY_ERROR, MASTER_SLAVE_ENDPOINT_NAME_INCONSISTENT_ERROR, LOG_FILE_NOT_FOUND_ERROR, OPERATION_NOT_ALLOWED_ERROR, PROJECT_OPERATION_NOT_ALLOWED_ERROR, PROJECT_RELEASE_FAILED, STRUCT_MIGRATION_RETRY_NOT_ALLOWED_ERROR, WORKER_INSTANCE_OPERATION_NOT_ALLOWED_ERROR, USER_OPERATION_NOT_ALLOWED_ERROR, OCP_NAME_OR_REGION_NOT_ALLOWED_UPDATE, UPDATE_CONFIG_WITH_NEWLINE_NOT_ALLOWED, EXIST_UNRELEASED_PROJECT_ERROR, EXIST_UNRELEASED_TOPIC_ERROR, LABEL_CREATE_NOT_ALLOWED_ERROR, LABEL_UPDATE_NOT_ALLOWED_ERROR, LABEL_DELETE_NOT_ALLOWED_ERROR, TOPIC_NAME_INVALID_ERROR, INVALID_STATUS_ERROR, INVALID_CSV_HEAD_ERROR, INVALID_CSV_BODY_ERROR, DUPLICATE_SCHEMA_TABLE_SETTING_ERROR, PROJECT_INVALID_STATUS_ERROR, PROJECT_INVALID_CONNECTOR_COUNT_ERROR, WORKER_INSTANCE_INVALID_STATUS_ERROR, LOG_SERVICE_INVALID_STATUS_ERROR, STEP_INVALID_STATUS_ERROR, UPDATE_ALLOW_DEST_TABLE_NOT_EMPTY_NOT_ALLOWED_ERROR, EXIST_INCONSISTENCY_ERROR, OMS_SWITCH_SUBSTEP_FAILED_ERROR, ENDPOINT_ID_INVALID_ERROR, DB_QUERY_VERSION_EMPTY_ERROR, ENDPOINT_NAME_INVALID_ERROR, ENDPOINT_SCHEMA_NOT_ALLOWED_ERROR, ENDPOINT_SCHEMA_CHAR_NOT_ALLOWED_ERROR, NAME_HAS_SPACE_EXCEPTION, CONFIG_CONVERT_VALUE_ERROR, CONFIG_VALUE_EXCEEDS_LIMIT_ERROR, CONFIG_KEY_NOT_FOUND_KEY_ERROR, CONFIG_VALUE_NOT_EMPTY_ERROR, SCHEMA_HAS_CONVERT_INFO, TIME_SERIES_QUERY_SERVICE_ERROR, ETL_VERIFY_ERROR, ETL_SYNTAX_UNSUPPORTED, ETL_FIELD_NOTFOUND, ETL_FAILED_PARSE_SQL, ETL_VAL_TYPE_ERROR, NOT_SUPPORT_GENERATE_COLUMNS, NOT_SUPPORT_UPDATE_ETL, LOCK_FAILED, OMS_USER_EXIST_ERROR, OMS_USER_NOT_FOUND_ERROR, OMS_USER_NAME_LENGTH_CONSTRAINT, OMS_USER_PASSWORD_ERROR, USER_NAME_OR_PASSWORD_ERROR, OMS_USER_PASSWORD_VALIDATION_ERROR, OMS_USER_PASSWORD_DEFAULT_ERROR, OMS_USER_PERMISSION_DENIED_ERROR, OMS_USER_EDIT_ADMIN_ROLE_INFO_PERMISSION_DENIED_ERROR, OMS_USER_ILLEGAL_DELETED_ERROR, CONNECTOR_TASK_NOT_FOUND_ERROR, CONNECTOR_TASK_NUM_LIMIT_ERROR, CONNECTOR_TASK_DELETE_ERROR, METRIC_SERVICE_ERROR, SYNC_PROJECT_TYPE_INVALID_ERROR, SYNC_SHARDING_COLUMNS_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_LIMIT_EXCEEDS_ERROR, SYNC_PROJECT_COMPLEMENT_CONFIG_ERROR, META_SCHEMA_CREATE_FAILED, RESUME_STEP_FAILED, SCHEMA_INCONSISTENCY, SCHEMA_CASCADE_MAPPING_NOT_SUPPORT_ERROR, SCHEMA_NOT_EXISTED, SCHEMA_EXISTED, SCHEMA_NOT_EXIST, BLACK_LIST_MATCH_ALL, BLACK_LIST_CONTAIN_NON_WHITE_SCHEMA, BLACK_WHITE_LIST_PARAM_INVALID_ERROR, OPERATOR_ERROR, OPERATOR_DIMENSION_NOT_SUPPORT, OPERATOR_PULL_LOG_ERROR, OPERATOR_UPDATE_CONFIG_NOT_SUPPORT, KAFKA_CREATE_TOPIC_ERROR, KAFKA_QUERY_TOPIC_ERROR, KAFKA_BUILD_PROPERTIES_ERROR, ROCKETMQ_CREATE_TOPIC_ERROR, ROCKETMQ_QUERY_TOPIC_ERROR, SYNC_OBJECT_EMPTY_ERROR, WRITER_NUMBER_NOT_UNIQUE, WRITER_NOT_ACTIVE, PROJECT_NAME_DUPLICATE_ERROR, EMPTY_FAILED_STRUCT_MIGRATION_TABLES_ERROR, LOGIC_TABLE_NOT_SUPPORT_UPDATE_OBJECT_ERROR, LOGIC_REQUEST_ERROR, LOGIC_DTO_BUILD_ERROR, UNEXPECTED_REMOTE_API_RESULT, OCEANBASE_USER_UNEXPECTED, STORE_CREATE_FAILED_ERROR, STORE_START_FAILED, STORE_NOT_PULL_LOG_ERROR, ALL_HOSTS_STATUS_ERROR, WORKER_ECS_NOT_FOUND_ERROR, WORKER_ECS_NOT_FOUND_FOR_USER_ERROR, WORKER_POD_NOT_FOUND_ERROR, WORKER_POD_NOT_FOUND_FOR_USER_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR_V2, and WORKER_INSTANCE_NOT_FOUND_FOR_USER_ERROR.
        self.connector_full_progress_overview = connector_full_progress_overview  # type: DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfoConnectorFullProgressOverview
        # The page size, which takes effect in a pagination query.
        self.deploy_id = deploy_id  # type: str
        # The error description (old).
        self.dst_iops = dst_iops  # type: long
        # The estimated amount of data to migrate.
        self.dst_rps = dst_rps  # type: long
        # The step progress.
        self.dst_rps_ref = dst_rps_ref  # type: long
        # The read requests per second (RPS) of the source data source.
        self.dst_rt = dst_rt  # type: long
        # A system error occurred.
        self.dst_rt_ref = dst_rt_ref  # type: long
        # The full synchronization progress.
        self.gmt = gmt  # type: long
        # The read/write throughput of the destination data source, in bytes per second.
        self.inconsistencies = inconsistencies  # type: long
        # The read throughput of the source data source, in bytes per second.
        self.incr_timestamp_checkpoint = incr_timestamp_checkpoint  # type: long
        # The error code (old).
        self.job_id = job_id  # type: str
        # The error related parameters.
        self.processed_records = processed_records  # type: long
        # The time spent in processing the request, in seconds.
        self.skipped = skipped  # type: bool
        # finishedCount / estimatedTotalCount
        self.src_iops = src_iops  # type: long
        # The end time, in the format of "2020-05-22T17:04:18".
        self.src_iops_ref = src_iops_ref  # type: long
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.src_rps = src_rps  # type: long
        # The checkpoint. The value is a unix timestamp in seconds.
        self.src_rps_ref = src_rps_ref  # type: long
        # The error code.
        self.src_rt = src_rt  # type: long
        # The checkpoint collection time. The value is a unix timestamp in seconds.
        self.src_rt_ref = src_rt_ref  # type: long
        # The read/write RPS of the destination data source.
        self.validated = validated  # type: bool

    def validate(self):
        if self.connector_full_progress_overview:
            self.connector_full_progress_overview.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.checkpoint is not None:
            result['Checkpoint'] = self.checkpoint
        if self.connector_full_progress_overview is not None:
            result['ConnectorFullProgressOverview'] = self.connector_full_progress_overview.to_map()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.dst_iops is not None:
            result['DstIops'] = self.dst_iops
        if self.dst_rps is not None:
            result['DstRps'] = self.dst_rps
        if self.dst_rps_ref is not None:
            result['DstRpsRef'] = self.dst_rps_ref
        if self.dst_rt is not None:
            result['DstRt'] = self.dst_rt
        if self.dst_rt_ref is not None:
            result['DstRtRef'] = self.dst_rt_ref
        if self.gmt is not None:
            result['Gmt'] = self.gmt
        if self.inconsistencies is not None:
            result['Inconsistencies'] = self.inconsistencies
        if self.incr_timestamp_checkpoint is not None:
            result['IncrTimestampCheckpoint'] = self.incr_timestamp_checkpoint
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.processed_records is not None:
            result['ProcessedRecords'] = self.processed_records
        if self.skipped is not None:
            result['Skipped'] = self.skipped
        if self.src_iops is not None:
            result['SrcIops'] = self.src_iops
        if self.src_iops_ref is not None:
            result['SrcIopsRef'] = self.src_iops_ref
        if self.src_rps is not None:
            result['SrcRps'] = self.src_rps
        if self.src_rps_ref is not None:
            result['SrcRpsRef'] = self.src_rps_ref
        if self.src_rt is not None:
            result['SrcRt'] = self.src_rt
        if self.src_rt_ref is not None:
            result['SrcRtRef'] = self.src_rt_ref
        if self.validated is not None:
            result['Validated'] = self.validated
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('Checkpoint') is not None:
            self.checkpoint = m.get('Checkpoint')
        if m.get('ConnectorFullProgressOverview') is not None:
            temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfoConnectorFullProgressOverview()
            self.connector_full_progress_overview = temp_model.from_map(m['ConnectorFullProgressOverview'])
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('DstIops') is not None:
            self.dst_iops = m.get('DstIops')
        if m.get('DstRps') is not None:
            self.dst_rps = m.get('DstRps')
        if m.get('DstRpsRef') is not None:
            self.dst_rps_ref = m.get('DstRpsRef')
        if m.get('DstRt') is not None:
            self.dst_rt = m.get('DstRt')
        if m.get('DstRtRef') is not None:
            self.dst_rt_ref = m.get('DstRtRef')
        if m.get('Gmt') is not None:
            self.gmt = m.get('Gmt')
        if m.get('Inconsistencies') is not None:
            self.inconsistencies = m.get('Inconsistencies')
        if m.get('IncrTimestampCheckpoint') is not None:
            self.incr_timestamp_checkpoint = m.get('IncrTimestampCheckpoint')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProcessedRecords') is not None:
            self.processed_records = m.get('ProcessedRecords')
        if m.get('Skipped') is not None:
            self.skipped = m.get('Skipped')
        if m.get('SrcIops') is not None:
            self.src_iops = m.get('SrcIops')
        if m.get('SrcIopsRef') is not None:
            self.src_iops_ref = m.get('SrcIopsRef')
        if m.get('SrcRps') is not None:
            self.src_rps = m.get('SrcRps')
        if m.get('SrcRpsRef') is not None:
            self.src_rps_ref = m.get('SrcRpsRef')
        if m.get('SrcRt') is not None:
            self.src_rt = m.get('SrcRt')
        if m.get('SrcRtRef') is not None:
            self.src_rt_ref = m.get('SrcRtRef')
        if m.get('Validated') is not None:
            self.validated = m.get('Validated')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyData(TeaModel):
    def __init__(self, estimated_remaining_seconds=None, extra_info=None, finish_time=None, interactive=None,
                 start_time=None, step_description=None, step_info=None, step_name=None, step_order=None, step_progress=None,
                 step_status=None):
        # The request ID.
        self.estimated_remaining_seconds = estimated_remaining_seconds  # type: long
        # A system error occurred.
        self.extra_info = extra_info  # type: DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfo
        # $.parameters[3].schema.example
        self.finish_time = finish_time  # type: str
        # $.parameters[5].schema.description
        self.interactive = interactive  # type: bool
        # The error details.
        self.start_time = start_time  # type: str
        # It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
        self.step_description = step_description  # type: str
        # The error related parameters.
        self.step_info = step_info  # type: DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfo
        # Alibaba Cloud provides SDKs in different languages to help you quickly integrate Alibaba Cloud products and services by using APIs. We recommend that you use an SDK to call APIs. In this way, you do not need to sign for verification.
        self.step_name = step_name  # type: str
        # DescribeOmsOpenAPIProjectSteps
        self.step_order = step_order  # type: int
        # cn-hangzhou
        self.step_progress = step_progress  # type: int
        # Indicates whether the call is successful.
        self.step_status = step_status  # type: str

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()
        if self.step_info:
            self.step_info.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_seconds is not None:
            result['EstimatedRemainingSeconds'] = self.estimated_remaining_seconds
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.interactive is not None:
            result['Interactive'] = self.interactive
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.step_description is not None:
            result['StepDescription'] = self.step_description
        if self.step_info is not None:
            result['StepInfo'] = self.step_info.to_map()
        if self.step_name is not None:
            result['StepName'] = self.step_name
        if self.step_order is not None:
            result['StepOrder'] = self.step_order
        if self.step_progress is not None:
            result['StepProgress'] = self.step_progress
        if self.step_status is not None:
            result['StepStatus'] = self.step_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingSeconds') is not None:
            self.estimated_remaining_seconds = m.get('EstimatedRemainingSeconds')
        if m.get('ExtraInfo') is not None:
            temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyDataExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Interactive') is not None:
            self.interactive = m.get('Interactive')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StepDescription') is not None:
            self.step_description = m.get('StepDescription')
        if m.get('StepInfo') is not None:
            temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyDataStepInfo()
            self.step_info = temp_model.from_map(m['StepInfo'])
        if m.get('StepName') is not None:
            self.step_name = m.get('StepName')
        if m.get('StepOrder') is not None:
            self.step_order = m.get('StepOrder')
        if m.get('StepProgress') is not None:
            self.step_progress = m.get('StepProgress')
        if m.get('StepStatus') is not None:
            self.step_status = m.get('StepStatus')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error details.
        self.code = code  # type: str
        # Valid values: CRITICAL, ERROR, and WARN.
        self.level = level  # type: str
        # A system error occurred.
        self.message = message  # type: str
        # Contact the administrator.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class DescribeOmsOpenAPIProjectStepsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # The error related parameters.
        self.advice = advice  # type: str
        # The error code (old), such as AUTHENTICATION_ERROR, PARAM_ERROR, PARAM_ERROR_MESSAGE, NOT_IMPLEMENTED_ERROR, SHARD_COLUMNS_CONFLICT_MESSAGE, FAILED_PARSE_TOKEN_MESSAGE, CONNECT_CHECK_ERROR, NOT_SUPPORT_ERROR, CE_NOT_SUPPORT_ERROR, NOT_FOUND_ERROR, SHARDING_COLUMN_NOT_INCLUDED_ERROR, INNER_ERROR, DB_QUERY_ERROR, DATAHUB_QUERY_ERROR, USER_LACK_SYS_PRIV_ERROR, USER_LACK_TABLE_PRIV_ERROR, RM_API_ERROR, RM_TASK_ERROR, CM_API_ERROR, CM_API_NOT_SUCCESS, BAGUALU_API_ERROR, IDB_API_ERROR, SUPERVISOR_API_ERROR, OCP_API_ERROR, OCP_SERVICE_ERROR, OCP_QUERY_VERSION_FAILED, OCP_VERSION_INCORRECT_ERROR, OCP_VERSION_NOT_SUPPORTED_ERROR, OCP_API_USER_PASSWORD_INCORRECT_ERROR, OBSCHEMA_ERROR, EXECUTOR_THREAD_POOL_BUSY, NO_TABLE_SELECTED, NO_VIEW_SELECTED, SOURCE_CRAWLER_START_FAILED, SOURCE_CRAWLER_START_FAILED_DATA_EXPIRED, SOURCE_CRAWLER_START_TIMEOUT, DEST_WRITER_START_FAILED, WRITER_UNKNOWN_STATUS, DRC_TOPIC_EXISTS_ERROR, TOPIC_EMPTY_ERROR, REACH_WRITER_LIMIT_ERROR, FOUND_NO_FEASIBLE_STORE_ERROR, TOO_MANY_STORES_FOR_SUBTOPIC, TIMEOUT_EXCEPTION, KIPP_API_ERROR, KIPP_API_RESOURCE_NOT_FOUND, KIPP_API_INVALID_PARAM, KIPP_API_UNKNOWN_ERROR, KIPP_API_INTERNAL_ERROR, KIPP_API_SERVICE_UNAVAILABLE, OMS_AGENT_API_ERROR, KMS_API_ERROR, OMS_ENCRYPT_API_ERROR, OMS_DECRYPT_API_ERROR, ALIYUN_SDK_ERROR, YAOCHI_API_ERROR, RESOURCE_WITHOUT_STOCK_ERROR, RESOURCE_NO_AVAILABLE_ZONE, CM_SDK_ERROR, MIGRATION_PROJECT_STEP_PRECHECK_FAILED, PRE_CHECK_ERROR, FAILURES_CORRECT_ERROR, EXECUTE_DDL_FAILURE, EXECUTE_DDL_UNSUPPORTED_OR_FAILURE, STRUCT_RECORD_DDL_NOT_FOUND, STRUCT_RECORD_INDEX_NOT_FOUND, STRUCT_RECORD_NOT_FOUND, STRUCT_RECORD_NOT_FOUND_IN_DBCAT, SCHEMA_OBJECT_TYPE_NOT_SUPPORT_ERROR, POLAR_MYSQL_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_VPC_NETWORK_NOT_SUPPORT_ERROR, DB_TYPE_NOT_SUPPORT_ERROR, SYNC_TYPE_NOT_SUPPORT_ERROR, SLAVE_OPERATION_STEP_NOT_SUPPORT_ERROR, BYTE_USED_TYPE_NOT_SUPPORT_ERROR, MANY_TO_ONE_SCHEMA_TABLE_REVERSE_INCR_NOT_SUPPORT_ERROR, DUPLICATE_SCHEMA_TABLE_ERROR, OMS_STEP_NOT_SUPPORT_ERROR, ORACLE_DATABASE_ROLE_NOT_SUPPORT_ERROR, OLD_PRE_CHECK_NOT_SUPPORT_ERROR, SCHEMA_ONE_TO_MANY_NOT_SUPPORT_ERROR, PROJECT_NOT_FOUND_ERROR, ENDPOINT_NOT_FOUND_ERROR, ENDPOINT_NAME_ALREADY_EXIST_ERROR, ENDPOINT_QUERY_ERROR, ENDPOINT_SQL_QUERY_ERROR, PROJECT_NAME_ALREADY_EXIST_ERROR, CHECKER_NOT_FOUND_ERROR, CHECKER_FAILED_ERROR, CHECKER_STATUS_UNEXPECTED_ERROR, CHECKER_NO_TASK_TYPE_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR, WORKER_INSTANCE_ALLOCATING_ERROR, LOG_SERVICE_TOPIC_NOT_FOUND_ERROR, CLUSTER_NOT_FOUND_ERROR, TENANT_NOT_FOUND_ERROR, DATABASE_NOT_FOUND_ERROR, TABLE_NOT_FOUND_ERROR, COLUMN_NOT_FOUND_ERROR, TABLE_META_NOT_FOUND_ERROR, SYBASE_CHARSET_NOT_FOUND_ERROR, OCP_NOT_FOUND_ERROR, REGION_NOT_FOUND_ERROR, OCP_ALREADY_EXIST_ERROR, ALARM_CHANNEL_NAME_ALREADY_EXIST_ERROR, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_RESPONSE, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_STATUS, LABEL_ALREADY_EXIST_ERROR, LABEL_NOT_EXIST_ERROR, OCP_ALREADY_USED_ERROR, REGION_INFO_INCONSISTENT_ERROR, OCP_NAME_EMPTY_ERROR, MASTER_SLAVE_ENDPOINT_NAME_INCONSISTENT_ERROR, LOG_FILE_NOT_FOUND_ERROR, OPERATION_NOT_ALLOWED_ERROR, PROJECT_OPERATION_NOT_ALLOWED_ERROR, PROJECT_RELEASE_FAILED, STRUCT_MIGRATION_RETRY_NOT_ALLOWED_ERROR, WORKER_INSTANCE_OPERATION_NOT_ALLOWED_ERROR, USER_OPERATION_NOT_ALLOWED_ERROR, OCP_NAME_OR_REGION_NOT_ALLOWED_UPDATE, UPDATE_CONFIG_WITH_NEWLINE_NOT_ALLOWED, EXIST_UNRELEASED_PROJECT_ERROR, EXIST_UNRELEASED_TOPIC_ERROR, LABEL_CREATE_NOT_ALLOWED_ERROR, LABEL_UPDATE_NOT_ALLOWED_ERROR, LABEL_DELETE_NOT_ALLOWED_ERROR, TOPIC_NAME_INVALID_ERROR, INVALID_STATUS_ERROR, INVALID_CSV_HEAD_ERROR, INVALID_CSV_BODY_ERROR, DUPLICATE_SCHEMA_TABLE_SETTING_ERROR, PROJECT_INVALID_STATUS_ERROR, PROJECT_INVALID_CONNECTOR_COUNT_ERROR, WORKER_INSTANCE_INVALID_STATUS_ERROR, LOG_SERVICE_INVALID_STATUS_ERROR, STEP_INVALID_STATUS_ERROR, UPDATE_ALLOW_DEST_TABLE_NOT_EMPTY_NOT_ALLOWED_ERROR, EXIST_INCONSISTENCY_ERROR, OMS_SWITCH_SUBSTEP_FAILED_ERROR, ENDPOINT_ID_INVALID_ERROR, DB_QUERY_VERSION_EMPTY_ERROR, ENDPOINT_NAME_INVALID_ERROR, ENDPOINT_SCHEMA_NOT_ALLOWED_ERROR, ENDPOINT_SCHEMA_CHAR_NOT_ALLOWED_ERROR, NAME_HAS_SPACE_EXCEPTION, CONFIG_CONVERT_VALUE_ERROR, CONFIG_VALUE_EXCEEDS_LIMIT_ERROR, CONFIG_KEY_NOT_FOUND_KEY_ERROR, CONFIG_VALUE_NOT_EMPTY_ERROR, SCHEMA_HAS_CONVERT_INFO, TIME_SERIES_QUERY_SERVICE_ERROR, ETL_VERIFY_ERROR, ETL_SYNTAX_UNSUPPORTED, ETL_FIELD_NOTFOUND, ETL_FAILED_PARSE_SQL, ETL_VAL_TYPE_ERROR, NOT_SUPPORT_GENERATE_COLUMNS, NOT_SUPPORT_UPDATE_ETL, LOCK_FAILED, OMS_USER_EXIST_ERROR, OMS_USER_NOT_FOUND_ERROR, OMS_USER_NAME_LENGTH_CONSTRAINT, OMS_USER_PASSWORD_ERROR, USER_NAME_OR_PASSWORD_ERROR, OMS_USER_PASSWORD_VALIDATION_ERROR, OMS_USER_PASSWORD_DEFAULT_ERROR, OMS_USER_PERMISSION_DENIED_ERROR, OMS_USER_EDIT_ADMIN_ROLE_INFO_PERMISSION_DENIED_ERROR, OMS_USER_ILLEGAL_DELETED_ERROR, CONNECTOR_TASK_NOT_FOUND_ERROR, CONNECTOR_TASK_NUM_LIMIT_ERROR, CONNECTOR_TASK_DELETE_ERROR, METRIC_SERVICE_ERROR, SYNC_PROJECT_TYPE_INVALID_ERROR, SYNC_SHARDING_COLUMNS_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_LIMIT_EXCEEDS_ERROR, SYNC_PROJECT_COMPLEMENT_CONFIG_ERROR, META_SCHEMA_CREATE_FAILED, RESUME_STEP_FAILED, SCHEMA_INCONSISTENCY, SCHEMA_CASCADE_MAPPING_NOT_SUPPORT_ERROR, SCHEMA_NOT_EXISTED, SCHEMA_EXISTED, SCHEMA_NOT_EXIST, BLACK_LIST_MATCH_ALL, BLACK_LIST_CONTAIN_NON_WHITE_SCHEMA, BLACK_WHITE_LIST_PARAM_INVALID_ERROR, OPERATOR_ERROR, OPERATOR_DIMENSION_NOT_SUPPORT, OPERATOR_PULL_LOG_ERROR, OPERATOR_UPDATE_CONFIG_NOT_SUPPORT, KAFKA_CREATE_TOPIC_ERROR, KAFKA_QUERY_TOPIC_ERROR, KAFKA_BUILD_PROPERTIES_ERROR, ROCKETMQ_CREATE_TOPIC_ERROR, ROCKETMQ_QUERY_TOPIC_ERROR, SYNC_OBJECT_EMPTY_ERROR, WRITER_NUMBER_NOT_UNIQUE, WRITER_NOT_ACTIVE, PROJECT_NAME_DUPLICATE_ERROR, EMPTY_FAILED_STRUCT_MIGRATION_TABLES_ERROR, LOGIC_TABLE_NOT_SUPPORT_UPDATE_OBJECT_ERROR, LOGIC_REQUEST_ERROR, LOGIC_DTO_BUILD_ERROR, UNEXPECTED_REMOTE_API_RESULT, OCEANBASE_USER_UNEXPECTED, STORE_CREATE_FAILED_ERROR, STORE_START_FAILED, STORE_NOT_PULL_LOG_ERROR, ALL_HOSTS_STATUS_ERROR, WORKER_ECS_NOT_FOUND_ERROR, WORKER_ECS_NOT_FOUND_FOR_USER_ERROR, WORKER_POD_NOT_FOUND_ERROR, WORKER_POD_NOT_FOUND_FOR_USER_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR_V2, and WORKER_INSTANCE_NOT_FOUND_FOR_USER_ERROR.
        self.code = code  # type: str
        # The step end time, in the format of "yyyy-MM-ddTHH:mm:ss".
        self.cost = cost  # type: str
        # Indicates whether the current step must be confirmed by the user, rather than scheduled in the backend.
        self.data = data  # type: list[DescribeOmsOpenAPIProjectStepsResponseBodyData]
        # The step details. The value is a JSON string.
        self.error_detail = error_detail  # type: DescribeOmsOpenAPIProjectStepsResponseBodyErrorDetail
        # A system error occurred.
        self.message = message  # type: str
        # The additional information. The value is a JSON string.
        self.page_number = page_number  # type: int
        # The step start time, in the format of "yyyy-MM-ddTHH:mm:ss".
        self.page_size = page_size  # type: int
        # The time when the error occurred.
        self.request_id = request_id  # type: str
        # The read throughput baseline of the source data source.
        self.success = success  # type: bool
        # The estimated remaining time. This parameter takes effect in full synchronization.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeOmsOpenAPIProjectStepsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOmsOpenAPIProjectStepsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOmsOpenAPIProjectStepsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOmsOpenAPIProjectStepsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOmsOpenAPIProjectStepsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOutlineBindingRequest(TeaModel):
    def __init__(self, database_name=None, instance_id=None, is_concurrent_limit=None, sqlid=None, table_name=None,
                 tenant_id=None):
        # The name of the database.
        self.database_name = database_name  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # - When the value is set to True, the throttling information in the database is queried based on the SQL ID.   
        # - When the value is set to False, the bound index or execution plan in the database is queried based on the SQL ID.
        self.is_concurrent_limit = is_concurrent_limit  # type: bool
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The name of the tenant.    
        # It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_). It cannot be set to SYS.
        self.table_name = table_name  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOutlineBindingRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_concurrent_limit is not None:
            result['IsConcurrentLimit'] = self.is_concurrent_limit
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsConcurrentLimit') is not None:
            self.is_concurrent_limit = m.get('IsConcurrentLimit')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeOutlineBindingResponseBodyOutlineBinding(TeaModel):
    def __init__(self, bind_index=None, bind_plan=None, max_concurrent=None, outline_id=None, table_name=None):
        # The bound index.
        self.bind_index = bind_index  # type: str
        # The bound plan.
        self.bind_plan = bind_plan  # type: str
        # The maximum number of concurrent tasks.
        self.max_concurrent = max_concurrent  # type: int
        # OutlineID.
        self.outline_id = outline_id  # type: long
        # 表名称
        self.table_name = table_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOutlineBindingResponseBodyOutlineBinding, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_index is not None:
            result['BindIndex'] = self.bind_index
        if self.bind_plan is not None:
            result['BindPlan'] = self.bind_plan
        if self.max_concurrent is not None:
            result['MaxConcurrent'] = self.max_concurrent
        if self.outline_id is not None:
            result['OutlineId'] = self.outline_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindIndex') is not None:
            self.bind_index = m.get('BindIndex')
        if m.get('BindPlan') is not None:
            self.bind_plan = m.get('BindPlan')
        if m.get('MaxConcurrent') is not None:
            self.max_concurrent = m.get('MaxConcurrent')
        if m.get('OutlineId') is not None:
            self.outline_id = m.get('OutlineId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class DescribeOutlineBindingResponseBody(TeaModel):
    def __init__(self, outline_binding=None, request_id=None):
        # The binding information.
        self.outline_binding = outline_binding  # type: DescribeOutlineBindingResponseBodyOutlineBinding
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.outline_binding:
            self.outline_binding.validate()

    def to_map(self):
        _map = super(DescribeOutlineBindingResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline_binding is not None:
            result['OutlineBinding'] = self.outline_binding.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OutlineBinding') is not None:
            temp_model = DescribeOutlineBindingResponseBodyOutlineBinding()
            self.outline_binding = temp_model.from_map(m['OutlineBinding'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOutlineBindingResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOutlineBindingResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOutlineBindingResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOutlineBindingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeParametersRequest(TeaModel):
    def __init__(self, dimension=None, dimension_value=None, instance_id=None):
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.dimension = dimension  # type: str
        # Alibaba Cloud CLI
        self.dimension_value = dimension_value  # type: str
        # 498529
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeParametersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.dimension_value is not None:
            result['DimensionValue'] = self.dimension_value
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('DimensionValue') is not None:
            self.dimension_value = m.get('DimensionValue')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeParametersResponseBodyParameters(TeaModel):
    def __init__(self, acceptable_value=None, current_value=None, default_value=None, description=None, name=None,
                 need_reboot=None, readonly=None, rejected_value=None, unit=None, value_type=None):
        # DescribeParameters
        self.acceptable_value = acceptable_value  # type: list[str]
        # The ID of the OceanBase cluster.
        self.current_value = current_value  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DescribeParameters
        # &InstanceId=ob317v4uif****\
        # &Dimension=TENANT
        # &DimensionValue=ob2mr3oae0****\
        # &Common request parameters
        # ```
        self.default_value = default_value  # type: str
        # The description of the parameter.
        self.description = description  # type: str
        # The request ID.
        self.name = name  # type: str
        # The name of the parameter.
        self.need_reboot = need_reboot  # type: bool
        # 参数是否只读
        self.readonly = readonly  # type: bool
        # {
        #     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
        #     "Parameters": [
        #         {
        #             "Description": "The maximum delay allowed in weak-consistency reads.",
        #             "ValueType": "CAPACITY",
        #             "CurrentValue": "600",
        #             "NeedReboot": false,
        #             "Name": "connect_timeout",
        #             "DefaultValue": "600s",
        #             "RejectedValue": [
        #                 "1s"
        #             ],
        #             "AcceptableValue": [
        #                 "1s"
        #             ]
        #         }
        #     ]
        # }
        self.rejected_value = rejected_value  # type: list[str]
        self.unit = unit  # type: str
        # The invalid value range of the parameter.    
        # It is an array with two string elements, which represents a range. The first element represents the minimum value and the second element represents the maximum value.
        self.value_type = value_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeParametersResponseBodyParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceptable_value is not None:
            result['AcceptableValue'] = self.acceptable_value
        if self.current_value is not None:
            result['CurrentValue'] = self.current_value
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.need_reboot is not None:
            result['NeedReboot'] = self.need_reboot
        if self.readonly is not None:
            result['Readonly'] = self.readonly
        if self.rejected_value is not None:
            result['RejectedValue'] = self.rejected_value
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptableValue') is not None:
            self.acceptable_value = m.get('AcceptableValue')
        if m.get('CurrentValue') is not None:
            self.current_value = m.get('CurrentValue')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedReboot') is not None:
            self.need_reboot = m.get('NeedReboot')
        if m.get('Readonly') is not None:
            self.readonly = m.get('Readonly')
        if m.get('RejectedValue') is not None:
            self.rejected_value = m.get('RejectedValue')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class DescribeParametersResponseBody(TeaModel):
    def __init__(self, parameters=None, request_id=None):
        # Indicates whether a restart is required for changes to the parameter to take effect. Valid values:   
        # - true: A restart is required.   
        # - false: A restart is not required.
        self.parameters = parameters  # type: list[DescribeParametersResponseBodyParameters]
        # The return result of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.parameters:
            for k in self.parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeParametersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Parameters'] = []
        if self.parameters is not None:
            for k in self.parameters:
                result['Parameters'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.parameters = []
        if m.get('Parameters') is not None:
            for k in m.get('Parameters'):
                temp_model = DescribeParametersResponseBodyParameters()
                self.parameters.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeParametersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeParametersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeParametersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeParametersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeParametersHistoryRequest(TeaModel):
    def __init__(self, dimension=None, dimension_value=None, end_time=None, instance_id=None, page_number=None,
                 page_size=None, start_time=None):
        # The type of the parameter.   
        # Valid values: CLUSTER and TENANT.
        self.dimension = dimension  # type: str
        # The resource ID of the parameter type.   
        # You can leave this parameter unspecified when you call this operation to query the modification history of cluster parameters. In the case of tenant parameters, pass the tenant ID.
        self.dimension_value = dimension_value  # type: str
        # The end time for the query of parameter modification history.
        self.end_time = end_time  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_number = page_number  # type: int
        # The number of rows to return on each page.   
        # - Maximum value: 100   
        # - Default value: 10
        self.page_size = page_size  # type: int
        # The start time of the time range for querying the parameter modification history.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeParametersHistoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.dimension_value is not None:
            result['DimensionValue'] = self.dimension_value
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('DimensionValue') is not None:
            self.dimension_value = m.get('DimensionValue')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeParametersHistoryResponseBodyRespondParameters(TeaModel):
    def __init__(self, create_time=None, dimension_value=None, name=None, new_value=None, old_value=None,
                 status=None, update_time=None):
        # The time when the parameter modification was initiated.
        self.create_time = create_time  # type: str
        # The resource ID of the parameter type.    
        # - When you called this operation to query the modification history of cluster parameters, the value is DEFAULT_DIMENSION_VALUE.   
        # - When you called this operation to query the modification history of tenant parameters, the value is the tenant ID.
        self.dimension_value = dimension_value  # type: str
        # The name of the parameter.
        self.name = name  # type: str
        # The value of the parameter after the modification.
        self.new_value = new_value  # type: str
        # The parameter value before modification.
        self.old_value = old_value  # type: str
        # The modification status. Valid values:    
        # - APPLIED: The modification was successful.   
        # - SCHEDULING: The modification was to be made.
        self.status = status  # type: str
        # The time when the parameter modification took effect.
        self.update_time = update_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeParametersHistoryResponseBodyRespondParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dimension_value is not None:
            result['DimensionValue'] = self.dimension_value
        if self.name is not None:
            result['Name'] = self.name
        if self.new_value is not None:
            result['NewValue'] = self.new_value
        if self.old_value is not None:
            result['OldValue'] = self.old_value
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DimensionValue') is not None:
            self.dimension_value = m.get('DimensionValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewValue') is not None:
            self.new_value = m.get('NewValue')
        if m.get('OldValue') is not None:
            self.old_value = m.get('OldValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeParametersHistoryResponseBodyRespond(TeaModel):
    def __init__(self, page_number=None, parameters=None, total_count=None):
        # The number of returned entries on each page.
        self.page_number = page_number  # type: int
        # The parameter modification history.
        self.parameters = parameters  # type: list[DescribeParametersHistoryResponseBodyRespondParameters]
        # The number of parameter modification records.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.parameters:
            for k in self.parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeParametersHistoryResponseBodyRespond, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        result['Parameters'] = []
        if self.parameters is not None:
            for k in self.parameters:
                result['Parameters'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        self.parameters = []
        if m.get('Parameters') is not None:
            for k in m.get('Parameters'):
                temp_model = DescribeParametersHistoryResponseBodyRespondParameters()
                self.parameters.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeParametersHistoryResponseBody(TeaModel):
    def __init__(self, request_id=None, respond=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The list of parameter modification records.
        self.respond = respond  # type: list[DescribeParametersHistoryResponseBodyRespond]

    def validate(self):
        if self.respond:
            for k in self.respond:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeParametersHistoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Respond'] = []
        if self.respond is not None:
            for k in self.respond:
                result['Respond'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.respond = []
        if m.get('Respond') is not None:
            for k in m.get('Respond'):
                temp_model = DescribeParametersHistoryResponseBodyRespond()
                self.respond.append(temp_model.from_map(k))
        return self


class DescribeParametersHistoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeParametersHistoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeParametersHistoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeParametersHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeProjectResponseBodyDataAlarmStats(TeaModel):
    def __init__(self, alarm_content=None, alarming=None, open_monitor=None, recently_trigger_count=None,
                 rule_to_recently_trigger_count=None, target=None):
        self.alarm_content = alarm_content  # type: str
        self.alarming = alarming  # type: bool
        self.open_monitor = open_monitor  # type: bool
        self.recently_trigger_count = recently_trigger_count  # type: int
        self.rule_to_recently_trigger_count = rule_to_recently_trigger_count  # type: dict[str, int]
        self.target = target  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataAlarmStats, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_content is not None:
            result['AlarmContent'] = self.alarm_content
        if self.alarming is not None:
            result['Alarming'] = self.alarming
        if self.open_monitor is not None:
            result['OpenMonitor'] = self.open_monitor
        if self.recently_trigger_count is not None:
            result['RecentlyTriggerCount'] = self.recently_trigger_count
        if self.rule_to_recently_trigger_count is not None:
            result['RuleToRecentlyTriggerCount'] = self.rule_to_recently_trigger_count
        if self.target is not None:
            result['Target'] = self.target
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmContent') is not None:
            self.alarm_content = m.get('AlarmContent')
        if m.get('Alarming') is not None:
            self.alarming = m.get('Alarming')
        if m.get('OpenMonitor') is not None:
            self.open_monitor = m.get('OpenMonitor')
        if m.get('RecentlyTriggerCount') is not None:
            self.recently_trigger_count = m.get('RecentlyTriggerCount')
        if m.get('RuleToRecentlyTriggerCount') is not None:
            self.rule_to_recently_trigger_count = m.get('RuleToRecentlyTriggerCount')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        return self


class DescribeProjectResponseBodyDataCommonTransferConfig(TeaModel):
    def __init__(self, active_active=None, data_works_business_name=None, datahub_topic_type=None,
                 mq_partition=None, mq_partition_mode=None, mq_serializer_type=None, rocket_mq_enable_msg_trace=None,
                 rocket_mq_msg_tags=None, rocket_mq_producer_group=None, rocket_mq_send_msg_timeout=None, table_category=None):
        self.active_active = active_active  # type: bool
        self.data_works_business_name = data_works_business_name  # type: str
        self.datahub_topic_type = datahub_topic_type  # type: str
        self.mq_partition = mq_partition  # type: int
        self.mq_partition_mode = mq_partition_mode  # type: str
        self.mq_serializer_type = mq_serializer_type  # type: str
        self.rocket_mq_enable_msg_trace = rocket_mq_enable_msg_trace  # type: bool
        self.rocket_mq_msg_tags = rocket_mq_msg_tags  # type: str
        self.rocket_mq_producer_group = rocket_mq_producer_group  # type: str
        self.rocket_mq_send_msg_timeout = rocket_mq_send_msg_timeout  # type: long
        self.table_category = table_category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataCommonTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_active is not None:
            result['ActiveActive'] = self.active_active
        if self.data_works_business_name is not None:
            result['DataWorksBusinessName'] = self.data_works_business_name
        if self.datahub_topic_type is not None:
            result['DatahubTopicType'] = self.datahub_topic_type
        if self.mq_partition is not None:
            result['MqPartition'] = self.mq_partition
        if self.mq_partition_mode is not None:
            result['MqPartitionMode'] = self.mq_partition_mode
        if self.mq_serializer_type is not None:
            result['MqSerializerType'] = self.mq_serializer_type
        if self.rocket_mq_enable_msg_trace is not None:
            result['RocketMqEnableMsgTrace'] = self.rocket_mq_enable_msg_trace
        if self.rocket_mq_msg_tags is not None:
            result['RocketMqMsgTags'] = self.rocket_mq_msg_tags
        if self.rocket_mq_producer_group is not None:
            result['RocketMqProducerGroup'] = self.rocket_mq_producer_group
        if self.rocket_mq_send_msg_timeout is not None:
            result['RocketMqSendMsgTimeout'] = self.rocket_mq_send_msg_timeout
        if self.table_category is not None:
            result['TableCategory'] = self.table_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActiveActive') is not None:
            self.active_active = m.get('ActiveActive')
        if m.get('DataWorksBusinessName') is not None:
            self.data_works_business_name = m.get('DataWorksBusinessName')
        if m.get('DatahubTopicType') is not None:
            self.datahub_topic_type = m.get('DatahubTopicType')
        if m.get('MqPartition') is not None:
            self.mq_partition = m.get('MqPartition')
        if m.get('MqPartitionMode') is not None:
            self.mq_partition_mode = m.get('MqPartitionMode')
        if m.get('MqSerializerType') is not None:
            self.mq_serializer_type = m.get('MqSerializerType')
        if m.get('RocketMqEnableMsgTrace') is not None:
            self.rocket_mq_enable_msg_trace = m.get('RocketMqEnableMsgTrace')
        if m.get('RocketMqMsgTags') is not None:
            self.rocket_mq_msg_tags = m.get('RocketMqMsgTags')
        if m.get('RocketMqProducerGroup') is not None:
            self.rocket_mq_producer_group = m.get('RocketMqProducerGroup')
        if m.get('RocketMqSendMsgTimeout') is not None:
            self.rocket_mq_send_msg_timeout = m.get('RocketMqSendMsgTimeout')
        if m.get('TableCategory') is not None:
            self.table_category = m.get('TableCategory')
        return self


class DescribeProjectResponseBodyDataExtraInfo(TeaModel):
    def __init__(self, access_ob_source=None, ignore_unsupport_ddl=None, incr_sync_timestamp=None,
                 log_service_start_checkpoint=None, max_connector_count=None, monitoring_incr=None, overwrite_config=None,
                 reverse_subtopics=None, running_progress=None, running_step=None, source_store_kept_hour=None, store_incr=None,
                 sub_conds=None, sub_dbs=None, sub_ids=None, subtopics=None, sync_delay=None,
                 sync_delay_sample_timestamp=None):
        self.access_ob_source = access_ob_source  # type: bool
        self.ignore_unsupport_ddl = ignore_unsupport_ddl  # type: bool
        self.incr_sync_timestamp = incr_sync_timestamp  # type: long
        self.log_service_start_checkpoint = log_service_start_checkpoint  # type: long
        self.max_connector_count = max_connector_count  # type: int
        self.monitoring_incr = monitoring_incr  # type: bool
        self.overwrite_config = overwrite_config  # type: bool
        self.reverse_subtopics = reverse_subtopics  # type: list[str]
        self.running_progress = running_progress  # type: int
        self.running_step = running_step  # type: str
        self.source_store_kept_hour = source_store_kept_hour  # type: int
        self.store_incr = store_incr  # type: bool
        self.sub_conds = sub_conds  # type: dict[str, list[DataExtraInfoSubCondsValue]]
        self.sub_dbs = sub_dbs  # type: dict[str, list[DataExtraInfoSubDbsValue]]
        self.sub_ids = sub_ids  # type: dict[str, str]
        self.subtopics = subtopics  # type: list[str]
        self.sync_delay = sync_delay  # type: long
        self.sync_delay_sample_timestamp = sync_delay_sample_timestamp  # type: long

    def validate(self):
        if self.sub_conds:
            for v in self.sub_conds.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.sub_dbs:
            for v in self.sub_dbs.values():
                for k1 in v:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_ob_source is not None:
            result['AccessObSource'] = self.access_ob_source
        if self.ignore_unsupport_ddl is not None:
            result['IgnoreUnsupportDdl'] = self.ignore_unsupport_ddl
        if self.incr_sync_timestamp is not None:
            result['IncrSyncTimestamp'] = self.incr_sync_timestamp
        if self.log_service_start_checkpoint is not None:
            result['LogServiceStartCheckpoint'] = self.log_service_start_checkpoint
        if self.max_connector_count is not None:
            result['MaxConnectorCount'] = self.max_connector_count
        if self.monitoring_incr is not None:
            result['MonitoringIncr'] = self.monitoring_incr
        if self.overwrite_config is not None:
            result['OverwriteConfig'] = self.overwrite_config
        if self.reverse_subtopics is not None:
            result['ReverseSubtopics'] = self.reverse_subtopics
        if self.running_progress is not None:
            result['RunningProgress'] = self.running_progress
        if self.running_step is not None:
            result['RunningStep'] = self.running_step
        if self.source_store_kept_hour is not None:
            result['SourceStoreKeptHour'] = self.source_store_kept_hour
        if self.store_incr is not None:
            result['StoreIncr'] = self.store_incr
        result['SubConds'] = {}
        if self.sub_conds is not None:
            for k, v in self.sub_conds.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['subConds'][k] = l1
        result['SubDbs'] = {}
        if self.sub_dbs is not None:
            for k, v in self.sub_dbs.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['subDbs'][k] = l1
        if self.sub_ids is not None:
            result['SubIds'] = self.sub_ids
        if self.subtopics is not None:
            result['Subtopics'] = self.subtopics
        if self.sync_delay is not None:
            result['SyncDelay'] = self.sync_delay
        if self.sync_delay_sample_timestamp is not None:
            result['SyncDelaySampleTimestamp'] = self.sync_delay_sample_timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessObSource') is not None:
            self.access_ob_source = m.get('AccessObSource')
        if m.get('IgnoreUnsupportDdl') is not None:
            self.ignore_unsupport_ddl = m.get('IgnoreUnsupportDdl')
        if m.get('IncrSyncTimestamp') is not None:
            self.incr_sync_timestamp = m.get('IncrSyncTimestamp')
        if m.get('LogServiceStartCheckpoint') is not None:
            self.log_service_start_checkpoint = m.get('LogServiceStartCheckpoint')
        if m.get('MaxConnectorCount') is not None:
            self.max_connector_count = m.get('MaxConnectorCount')
        if m.get('MonitoringIncr') is not None:
            self.monitoring_incr = m.get('MonitoringIncr')
        if m.get('OverwriteConfig') is not None:
            self.overwrite_config = m.get('OverwriteConfig')
        if m.get('ReverseSubtopics') is not None:
            self.reverse_subtopics = m.get('ReverseSubtopics')
        if m.get('RunningProgress') is not None:
            self.running_progress = m.get('RunningProgress')
        if m.get('RunningStep') is not None:
            self.running_step = m.get('RunningStep')
        if m.get('SourceStoreKeptHour') is not None:
            self.source_store_kept_hour = m.get('SourceStoreKeptHour')
        if m.get('StoreIncr') is not None:
            self.store_incr = m.get('StoreIncr')
        self.sub_conds = {}
        if m.get('SubConds') is not None:
            for k, v in m.get('SubConds').items():
                l1 = []
                for k1 in v:
                    temp_model = DataExtraInfoSubCondsValue()
                    l1.append(temp_model.from_map(k1))
                self.sub_conds['k'] = l1
        self.sub_dbs = {}
        if m.get('SubDbs') is not None:
            for k, v in m.get('SubDbs').items():
                l1 = []
                for k1 in v:
                    temp_model = DataExtraInfoSubDbsValue()
                    l1.append(temp_model.from_map(k1))
                self.sub_dbs['k'] = l1
        if m.get('SubIds') is not None:
            self.sub_ids = m.get('SubIds')
        if m.get('Subtopics') is not None:
            self.subtopics = m.get('Subtopics')
        if m.get('SyncDelay') is not None:
            self.sync_delay = m.get('SyncDelay')
        if m.get('SyncDelaySampleTimestamp') is not None:
            self.sync_delay_sample_timestamp = m.get('SyncDelaySampleTimestamp')
        return self


class DescribeProjectResponseBodyDataFullTransferConfig(TeaModel):
    def __init__(self, allow_dest_table_not_empty=None, full_transfer_speed_mode=None,
                 full_verify_speed_mode=None, none_pk_uk_truncate_dst_table=None):
        self.allow_dest_table_not_empty = allow_dest_table_not_empty  # type: bool
        self.full_transfer_speed_mode = full_transfer_speed_mode  # type: str
        self.full_verify_speed_mode = full_verify_speed_mode  # type: str
        self.none_pk_uk_truncate_dst_table = none_pk_uk_truncate_dst_table  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataFullTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_dest_table_not_empty is not None:
            result['AllowDestTableNotEmpty'] = self.allow_dest_table_not_empty
        if self.full_transfer_speed_mode is not None:
            result['FullTransferSpeedMode'] = self.full_transfer_speed_mode
        if self.full_verify_speed_mode is not None:
            result['FullVerifySpeedMode'] = self.full_verify_speed_mode
        if self.none_pk_uk_truncate_dst_table is not None:
            result['NonePkUkTruncateDstTable'] = self.none_pk_uk_truncate_dst_table
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowDestTableNotEmpty') is not None:
            self.allow_dest_table_not_empty = m.get('AllowDestTableNotEmpty')
        if m.get('FullTransferSpeedMode') is not None:
            self.full_transfer_speed_mode = m.get('FullTransferSpeedMode')
        if m.get('FullVerifySpeedMode') is not None:
            self.full_verify_speed_mode = m.get('FullVerifySpeedMode')
        if m.get('NonePkUkTruncateDstTable') is not None:
            self.none_pk_uk_truncate_dst_table = m.get('NonePkUkTruncateDstTable')
        return self


class DescribeProjectResponseBodyDataIncrTransferConfig(TeaModel):
    def __init__(self, enable_incr_sync_statistics=None, enable_sequencing_within_txn=None,
                 incr_sync_concurrency=None, record_type_white_list=None, start_timestamp=None, store_log_kept_hour=None):
        self.enable_incr_sync_statistics = enable_incr_sync_statistics  # type: bool
        self.enable_sequencing_within_txn = enable_sequencing_within_txn  # type: bool
        self.incr_sync_concurrency = incr_sync_concurrency  # type: int
        self.record_type_white_list = record_type_white_list  # type: list[str]
        self.start_timestamp = start_timestamp  # type: long
        self.store_log_kept_hour = store_log_kept_hour  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataIncrTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_incr_sync_statistics is not None:
            result['EnableIncrSyncStatistics'] = self.enable_incr_sync_statistics
        if self.enable_sequencing_within_txn is not None:
            result['EnableSequencingWithinTxn'] = self.enable_sequencing_within_txn
        if self.incr_sync_concurrency is not None:
            result['IncrSyncConcurrency'] = self.incr_sync_concurrency
        if self.record_type_white_list is not None:
            result['RecordTypeWhiteList'] = self.record_type_white_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableIncrSyncStatistics') is not None:
            self.enable_incr_sync_statistics = m.get('EnableIncrSyncStatistics')
        if m.get('EnableSequencingWithinTxn') is not None:
            self.enable_sequencing_within_txn = m.get('EnableSequencingWithinTxn')
        if m.get('IncrSyncConcurrency') is not None:
            self.incr_sync_concurrency = m.get('IncrSyncConcurrency')
        if m.get('RecordTypeWhiteList') is not None:
            self.record_type_white_list = m.get('RecordTypeWhiteList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        return self


class DescribeProjectResponseBodyDataLabels(TeaModel):
    def __init__(self, id=None, name=None):
        self.id = id  # type: str
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeProjectResponseBodyDataSinkConnectInfo(TeaModel):
    def __init__(self, charset=None, conn_extra_attributes=None, connection_info=None, db_engine=None,
                 endpoint_id=None, endpoint_name=None, endpoint_side=None, host=None, id=None, nls_length_semantics=None,
                 ocp_name=None, operating_system=None, owner=None, port=None, region=None, resource_owner=None, timezone=None,
                 username=None, version=None):
        self.charset = charset  # type: str
        self.conn_extra_attributes = conn_extra_attributes  # type: any
        self.connection_info = connection_info  # type: str
        self.db_engine = db_engine  # type: str
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_name = endpoint_name  # type: str
        self.endpoint_side = endpoint_side  # type: str
        self.host = host  # type: str
        self.id = id  # type: str
        self.nls_length_semantics = nls_length_semantics  # type: str
        self.ocp_name = ocp_name  # type: str
        self.operating_system = operating_system  # type: str
        # Owner。
        self.owner = owner  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.resource_owner = resource_owner  # type: str
        self.timezone = timezone  # type: str
        self.username = username  # type: str
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataSinkConnectInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.conn_extra_attributes is not None:
            result['ConnExtraAttributes'] = self.conn_extra_attributes
        if self.connection_info is not None:
            result['ConnectionInfo'] = self.connection_info
        if self.db_engine is not None:
            result['DbEngine'] = self.db_engine
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_side is not None:
            result['EndpointSide'] = self.endpoint_side
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.nls_length_semantics is not None:
            result['NlsLengthSemantics'] = self.nls_length_semantics
        if self.ocp_name is not None:
            result['OcpName'] = self.ocp_name
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_owner is not None:
            result['ResourceOwner'] = self.resource_owner
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.username is not None:
            result['Username'] = self.username
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ConnExtraAttributes') is not None:
            self.conn_extra_attributes = m.get('ConnExtraAttributes')
        if m.get('ConnectionInfo') is not None:
            self.connection_info = m.get('ConnectionInfo')
        if m.get('DbEngine') is not None:
            self.db_engine = m.get('DbEngine')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointSide') is not None:
            self.endpoint_side = m.get('EndpointSide')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NlsLengthSemantics') is not None:
            self.nls_length_semantics = m.get('NlsLengthSemantics')
        if m.get('OcpName') is not None:
            self.ocp_name = m.get('OcpName')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceOwner') is not None:
            self.resource_owner = m.get('ResourceOwner')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeProjectResponseBodyDataSourceConnectInfo(TeaModel):
    def __init__(self, charset=None, conn_extra_attributes=None, connection_info=None, db_engine=None,
                 endpoint_id=None, endpoint_name=None, endpoint_side=None, host=None, id=None, nls_length_semantics=None,
                 ocp_name=None, operating_system=None, owner=None, port=None, region=None, resource_owner=None, timezone=None,
                 username=None, version=None):
        self.charset = charset  # type: str
        self.conn_extra_attributes = conn_extra_attributes  # type: any
        self.connection_info = connection_info  # type: str
        self.db_engine = db_engine  # type: str
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_name = endpoint_name  # type: str
        self.endpoint_side = endpoint_side  # type: str
        self.host = host  # type: str
        self.id = id  # type: str
        self.nls_length_semantics = nls_length_semantics  # type: str
        self.ocp_name = ocp_name  # type: str
        self.operating_system = operating_system  # type: str
        # Owner。
        self.owner = owner  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.resource_owner = resource_owner  # type: str
        self.timezone = timezone  # type: str
        self.username = username  # type: str
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataSourceConnectInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.conn_extra_attributes is not None:
            result['ConnExtraAttributes'] = self.conn_extra_attributes
        if self.connection_info is not None:
            result['ConnectionInfo'] = self.connection_info
        if self.db_engine is not None:
            result['DbEngine'] = self.db_engine
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_side is not None:
            result['EndpointSide'] = self.endpoint_side
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.nls_length_semantics is not None:
            result['NlsLengthSemantics'] = self.nls_length_semantics
        if self.ocp_name is not None:
            result['OcpName'] = self.ocp_name
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_owner is not None:
            result['ResourceOwner'] = self.resource_owner
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.username is not None:
            result['Username'] = self.username
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ConnExtraAttributes') is not None:
            self.conn_extra_attributes = m.get('ConnExtraAttributes')
        if m.get('ConnectionInfo') is not None:
            self.connection_info = m.get('ConnectionInfo')
        if m.get('DbEngine') is not None:
            self.db_engine = m.get('DbEngine')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointSide') is not None:
            self.endpoint_side = m.get('EndpointSide')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NlsLengthSemantics') is not None:
            self.nls_length_semantics = m.get('NlsLengthSemantics')
        if m.get('OcpName') is not None:
            self.ocp_name = m.get('OcpName')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceOwner') is not None:
            self.resource_owner = m.get('ResourceOwner')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        # FATAL, ERROR, WARNING, CRITICAL
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectResponseBodyDataStepsExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        self.error_code = error_code  # type: str
        self.error_details = error_details  # type: list[DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails]
        self.error_msg = error_msg  # type: str
        self.error_param = error_param  # type: dict[str, str]
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataStepsExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class DescribeProjectResponseBodyDataSteps(TeaModel):
    def __init__(self, description=None, extra_info=None, finish_time=None, name=None, order=None, progress=None,
                 start_time=None, status=None, step_info=None):
        self.description = description  # type: str
        self.extra_info = extra_info  # type: DescribeProjectResponseBodyDataStepsExtraInfo
        self.finish_time = finish_time  # type: str
        self.name = name  # type: str
        self.order = order  # type: int
        self.progress = progress  # type: int
        self.start_time = start_time  # type: str
        self.status = status  # type: str
        self.step_info = step_info  # type: dict[str, any]

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataSteps, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.step_info is not None:
            result['StepInfo'] = self.step_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExtraInfo') is not None:
            temp_model = DescribeProjectResponseBodyDataStepsExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StepInfo') is not None:
            self.step_info = m.get('StepInfo')
        return self


class DescribeProjectResponseBodyDataStructTransferConfig(TeaModel):
    def __init__(self, byte_char_convert_strategy=None, defer_index_creation=None):
        self.byte_char_convert_strategy = byte_char_convert_strategy  # type: str
        self.defer_index_creation = defer_index_creation  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataStructTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.byte_char_convert_strategy is not None:
            result['ByteCharConvertStrategy'] = self.byte_char_convert_strategy
        if self.defer_index_creation is not None:
            result['DeferIndexCreation'] = self.defer_index_creation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ByteCharConvertStrategy') is not None:
            self.byte_char_convert_strategy = m.get('ByteCharConvertStrategy')
        if m.get('DeferIndexCreation') is not None:
            self.defer_index_creation = m.get('DeferIndexCreation')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabases(TeaModel):
    def __init__(self, id=None, mapped_name=None, name=None, specific_tables=None, specific_views=None, tables=None,
                 tenant_name=None, type=None, views=None):
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.specific_tables = specific_tables  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables]
        self.specific_views = specific_views  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews]
        self.tables = tables  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesTables]
        self.tenant_name = tenant_name  # type: str
        self.type = type  # type: str
        self.views = views  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesViews]

    def validate(self):
        if self.specific_tables:
            for k in self.specific_tables:
                if k:
                    k.validate()
        if self.specific_views:
            for k in self.specific_views:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.views:
            for k in self.views:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        result['SpecificTables'] = []
        if self.specific_tables is not None:
            for k in self.specific_tables:
                result['SpecificTables'].append(k.to_map() if k else None)
        result['SpecificViews'] = []
        if self.specific_views is not None:
            for k in self.specific_views:
                result['SpecificViews'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.type is not None:
            result['Type'] = self.type
        result['Views'] = []
        if self.views is not None:
            for k in self.views:
                result['Views'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.specific_tables = []
        if m.get('SpecificTables') is not None:
            for k in m.get('SpecificTables'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables()
                self.specific_tables.append(temp_model.from_map(k))
        self.specific_views = []
        if m.get('SpecificViews') is not None:
            for k in m.get('SpecificViews'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews()
                self.specific_views.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.views = []
        if m.get('Views') is not None:
            for k in m.get('Views'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesViews()
                self.views.append(temp_model.from_map(k))
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        self.distributed_keys = distributed_keys  # type: list[str]
        self.partition_life_cycle = partition_life_cycle  # type: str
        self.partition_statement = partition_statement  # type: str
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, id=None, mapped_name=None, name=None,
                 shard_columns=None, where_clause=None):
        self.adb_table_schema = adb_table_schema  # type: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema
        self.filter_columns = filter_columns  # type: list[str]
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.shard_columns = shard_columns  # type: list[str]
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class DescribeProjectResponseBodyDataTransferMappingDatabasesBlack(TeaModel):
    def __init__(self, id=None, mapped_name=None, name=None, specific_tables=None, specific_views=None, tables=None,
                 tenant_name=None, type=None, views=None):
        self.id = id  # type: str
        self.mapped_name = mapped_name  # type: str
        self.name = name  # type: str
        self.specific_tables = specific_tables  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables]
        self.specific_views = specific_views  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews]
        self.tables = tables  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables]
        self.tenant_name = tenant_name  # type: str
        self.type = type  # type: str
        self.views = views  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews]

    def validate(self):
        if self.specific_tables:
            for k in self.specific_tables:
                if k:
                    k.validate()
        if self.specific_views:
            for k in self.specific_views:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.views:
            for k in self.views:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMappingDatabasesBlack, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.name is not None:
            result['Name'] = self.name
        result['SpecificTables'] = []
        if self.specific_tables is not None:
            for k in self.specific_tables:
                result['SpecificTables'].append(k.to_map() if k else None)
        result['SpecificViews'] = []
        if self.specific_views is not None:
            for k in self.specific_views:
                result['SpecificViews'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.type is not None:
            result['Type'] = self.type
        result['Views'] = []
        if self.views is not None:
            for k in self.views:
                result['Views'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.specific_tables = []
        if m.get('SpecificTables') is not None:
            for k in m.get('SpecificTables'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables()
                self.specific_tables.append(temp_model.from_map(k))
        self.specific_views = []
        if m.get('SpecificViews') is not None:
            for k in m.get('SpecificViews'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews()
                self.specific_views.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.views = []
        if m.get('Views') is not None:
            for k in m.get('Views'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews()
                self.views.append(temp_model.from_map(k))
        return self


class DescribeProjectResponseBodyDataTransferMapping(TeaModel):
    def __init__(self, databases=None, databases_black=None, mode=None, table_and_view_black_list=None,
                 table_and_view_white_list=None):
        self.databases = databases  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabases]
        self.databases_black = databases_black  # type: list[DescribeProjectResponseBodyDataTransferMappingDatabasesBlack]
        self.mode = mode  # type: str
        self.table_and_view_black_list = table_and_view_black_list  # type: list[str]
        self.table_and_view_white_list = table_and_view_white_list  # type: list[str]

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()
        if self.databases_black:
            for k in self.databases_black:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyDataTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        result['DatabasesBlack'] = []
        if self.databases_black is not None:
            for k in self.databases_black:
                result['DatabasesBlack'].append(k.to_map() if k else None)
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.table_and_view_black_list is not None:
            result['TableAndViewBlackList'] = self.table_and_view_black_list
        if self.table_and_view_white_list is not None:
            result['TableAndViewWhiteList'] = self.table_and_view_white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabases()
                self.databases.append(temp_model.from_map(k))
        self.databases_black = []
        if m.get('DatabasesBlack') is not None:
            for k in m.get('DatabasesBlack'):
                temp_model = DescribeProjectResponseBodyDataTransferMappingDatabasesBlack()
                self.databases_black.append(temp_model.from_map(k))
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('TableAndViewBlackList') is not None:
            self.table_and_view_black_list = m.get('TableAndViewBlackList')
        if m.get('TableAndViewWhiteList') is not None:
            self.table_and_view_white_list = m.get('TableAndViewWhiteList')
        return self


class DescribeProjectResponseBodyData(TeaModel):
    def __init__(self, alarm_stats=None, common_transfer_config=None, dest_conn_id=None, enable_full_transfer=None,
                 enable_full_verify=None, enable_incr_transfer=None, enable_incr_verify=None, enable_reverse_incr_transfer=None,
                 enable_struct_transfer=None, extra_info=None, full_transfer_config=None, gmt_create=None, gmt_finish=None,
                 gmt_modified=None, gmt_start=None, id=None, importance=None, incr_transfer_config=None, is_merging=None,
                 is_modifying=None, is_sub_project=None, labels=None, name=None, owner=None, sink_connect_info=None,
                 sink_endpoint_type=None, source_connect_info=None, source_endpoint_type=None, status=None, steps=None,
                 struct_transfer_config=None, transfer_mapping=None, type=None, worker_grade_id=None):
        self.alarm_stats = alarm_stats  # type: DescribeProjectResponseBodyDataAlarmStats
        self.common_transfer_config = common_transfer_config  # type: DescribeProjectResponseBodyDataCommonTransferConfig
        self.dest_conn_id = dest_conn_id  # type: str
        self.enable_full_transfer = enable_full_transfer  # type: bool
        self.enable_full_verify = enable_full_verify  # type: bool
        self.enable_incr_transfer = enable_incr_transfer  # type: bool
        self.enable_incr_verify = enable_incr_verify  # type: bool
        self.enable_reverse_incr_transfer = enable_reverse_incr_transfer  # type: bool
        self.enable_struct_transfer = enable_struct_transfer  # type: bool
        self.extra_info = extra_info  # type: DescribeProjectResponseBodyDataExtraInfo
        self.full_transfer_config = full_transfer_config  # type: DescribeProjectResponseBodyDataFullTransferConfig
        self.gmt_create = gmt_create  # type: str
        self.gmt_finish = gmt_finish  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.gmt_start = gmt_start  # type: str
        self.id = id  # type: str
        self.importance = importance  # type: str
        self.incr_transfer_config = incr_transfer_config  # type: DescribeProjectResponseBodyDataIncrTransferConfig
        self.is_merging = is_merging  # type: bool
        self.is_modifying = is_modifying  # type: bool
        self.is_sub_project = is_sub_project  # type: bool
        self.labels = labels  # type: list[DescribeProjectResponseBodyDataLabels]
        self.name = name  # type: str
        self.owner = owner  # type: str
        self.sink_connect_info = sink_connect_info  # type: DescribeProjectResponseBodyDataSinkConnectInfo
        self.sink_endpoint_type = sink_endpoint_type  # type: str
        self.source_connect_info = source_connect_info  # type: DescribeProjectResponseBodyDataSourceConnectInfo
        self.source_endpoint_type = source_endpoint_type  # type: str
        self.status = status  # type: str
        self.steps = steps  # type: list[DescribeProjectResponseBodyDataSteps]
        self.struct_transfer_config = struct_transfer_config  # type: DescribeProjectResponseBodyDataStructTransferConfig
        self.transfer_mapping = transfer_mapping  # type: DescribeProjectResponseBodyDataTransferMapping
        self.type = type  # type: str
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        if self.alarm_stats:
            self.alarm_stats.validate()
        if self.common_transfer_config:
            self.common_transfer_config.validate()
        if self.extra_info:
            self.extra_info.validate()
        if self.full_transfer_config:
            self.full_transfer_config.validate()
        if self.incr_transfer_config:
            self.incr_transfer_config.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.sink_connect_info:
            self.sink_connect_info.validate()
        if self.source_connect_info:
            self.source_connect_info.validate()
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()
        if self.struct_transfer_config:
            self.struct_transfer_config.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_stats is not None:
            result['AlarmStats'] = self.alarm_stats.to_map()
        if self.common_transfer_config is not None:
            result['CommonTransferConfig'] = self.common_transfer_config.to_map()
        if self.dest_conn_id is not None:
            result['DestConnId'] = self.dest_conn_id
        if self.enable_full_transfer is not None:
            result['EnableFullTransfer'] = self.enable_full_transfer
        if self.enable_full_verify is not None:
            result['EnableFullVerify'] = self.enable_full_verify
        if self.enable_incr_transfer is not None:
            result['EnableIncrTransfer'] = self.enable_incr_transfer
        if self.enable_incr_verify is not None:
            result['EnableIncrVerify'] = self.enable_incr_verify
        if self.enable_reverse_incr_transfer is not None:
            result['EnableReverseIncrTransfer'] = self.enable_reverse_incr_transfer
        if self.enable_struct_transfer is not None:
            result['EnableStructTransfer'] = self.enable_struct_transfer
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.full_transfer_config is not None:
            result['FullTransferConfig'] = self.full_transfer_config.to_map()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_finish is not None:
            result['GmtFinish'] = self.gmt_finish
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['GmtStart'] = self.gmt_start
        if self.id is not None:
            result['Id'] = self.id
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.incr_transfer_config is not None:
            result['IncrTransferConfig'] = self.incr_transfer_config.to_map()
        if self.is_merging is not None:
            result['IsMerging'] = self.is_merging
        if self.is_modifying is not None:
            result['IsModifying'] = self.is_modifying
        if self.is_sub_project is not None:
            result['IsSubProject'] = self.is_sub_project
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.sink_connect_info is not None:
            result['SinkConnectInfo'] = self.sink_connect_info.to_map()
        if self.sink_endpoint_type is not None:
            result['SinkEndpointType'] = self.sink_endpoint_type
        if self.source_connect_info is not None:
            result['SourceConnectInfo'] = self.source_connect_info.to_map()
        if self.source_endpoint_type is not None:
            result['SourceEndpointType'] = self.source_endpoint_type
        if self.status is not None:
            result['Status'] = self.status
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.struct_transfer_config is not None:
            result['StructTransferConfig'] = self.struct_transfer_config.to_map()
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmStats') is not None:
            temp_model = DescribeProjectResponseBodyDataAlarmStats()
            self.alarm_stats = temp_model.from_map(m['AlarmStats'])
        if m.get('CommonTransferConfig') is not None:
            temp_model = DescribeProjectResponseBodyDataCommonTransferConfig()
            self.common_transfer_config = temp_model.from_map(m['CommonTransferConfig'])
        if m.get('DestConnId') is not None:
            self.dest_conn_id = m.get('DestConnId')
        if m.get('EnableFullTransfer') is not None:
            self.enable_full_transfer = m.get('EnableFullTransfer')
        if m.get('EnableFullVerify') is not None:
            self.enable_full_verify = m.get('EnableFullVerify')
        if m.get('EnableIncrTransfer') is not None:
            self.enable_incr_transfer = m.get('EnableIncrTransfer')
        if m.get('EnableIncrVerify') is not None:
            self.enable_incr_verify = m.get('EnableIncrVerify')
        if m.get('EnableReverseIncrTransfer') is not None:
            self.enable_reverse_incr_transfer = m.get('EnableReverseIncrTransfer')
        if m.get('EnableStructTransfer') is not None:
            self.enable_struct_transfer = m.get('EnableStructTransfer')
        if m.get('ExtraInfo') is not None:
            temp_model = DescribeProjectResponseBodyDataExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FullTransferConfig') is not None:
            temp_model = DescribeProjectResponseBodyDataFullTransferConfig()
            self.full_transfer_config = temp_model.from_map(m['FullTransferConfig'])
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtFinish') is not None:
            self.gmt_finish = m.get('GmtFinish')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtStart') is not None:
            self.gmt_start = m.get('GmtStart')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('IncrTransferConfig') is not None:
            temp_model = DescribeProjectResponseBodyDataIncrTransferConfig()
            self.incr_transfer_config = temp_model.from_map(m['IncrTransferConfig'])
        if m.get('IsMerging') is not None:
            self.is_merging = m.get('IsMerging')
        if m.get('IsModifying') is not None:
            self.is_modifying = m.get('IsModifying')
        if m.get('IsSubProject') is not None:
            self.is_sub_project = m.get('IsSubProject')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeProjectResponseBodyDataLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('SinkConnectInfo') is not None:
            temp_model = DescribeProjectResponseBodyDataSinkConnectInfo()
            self.sink_connect_info = temp_model.from_map(m['SinkConnectInfo'])
        if m.get('SinkEndpointType') is not None:
            self.sink_endpoint_type = m.get('SinkEndpointType')
        if m.get('SourceConnectInfo') is not None:
            temp_model = DescribeProjectResponseBodyDataSourceConnectInfo()
            self.source_connect_info = temp_model.from_map(m['SourceConnectInfo'])
        if m.get('SourceEndpointType') is not None:
            self.source_endpoint_type = m.get('SourceEndpointType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = DescribeProjectResponseBodyDataSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('StructTransferConfig') is not None:
            temp_model = DescribeProjectResponseBodyDataStructTransferConfig()
            self.struct_transfer_config = temp_model.from_map(m['StructTransferConfig'])
        if m.get('TransferMapping') is not None:
            temp_model = DescribeProjectResponseBodyDataTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class DescribeProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: DescribeProjectResponseBodyData
        self.error_detail = error_detail  # type: DescribeProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = DescribeProjectResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectComponentsRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataFullImportComponents(TeaModel):
    def __init__(self, error_details=None, gmt_create=None, gmt_modify=None, identity=None, ip=None, name=None,
                 progress=None, region=None, status=None):
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails]
        self.gmt_create = gmt_create  # type: str
        self.gmt_modify = gmt_modify  # type: str
        self.identity = identity  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.progress = progress  # type: int
        self.region = region  # type: str
        self.status = status  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataFullImportComponents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modify is not None:
            result['GmtModify'] = self.gmt_modify
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModify') is not None:
            self.gmt_modify = m.get('GmtModify')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataFullVerifyComponents(TeaModel):
    def __init__(self, consistent_quantity=None, error_details=None, inconsistent_quantity=None, ip=None, name=None,
                 progress=None, record_progress=None, region=None, status=None, task_id=None):
        self.consistent_quantity = consistent_quantity  # type: long
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails]
        self.inconsistent_quantity = inconsistent_quantity  # type: long
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.progress = progress  # type: str
        self.record_progress = record_progress  # type: int
        self.region = region  # type: str
        self.status = status  # type: str
        self.task_id = task_id  # type: long

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataFullVerifyComponents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consistent_quantity is not None:
            result['ConsistentQuantity'] = self.consistent_quantity
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.inconsistent_quantity is not None:
            result['InconsistentQuantity'] = self.inconsistent_quantity
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.record_progress is not None:
            result['RecordProgress'] = self.record_progress
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConsistentQuantity') is not None:
            self.consistent_quantity = m.get('ConsistentQuantity')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('InconsistentQuantity') is not None:
            self.inconsistent_quantity = m.get('InconsistentQuantity')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RecordProgress') is not None:
            self.record_progress = m.get('RecordProgress')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataIncrSyncComponents(TeaModel):
    def __init__(self, checkpoint=None, checkpoint_sample_timestamp=None, delay=None, error_details=None,
                 gmt_create=None, gmt_modify=None, identity=None, ip=None, name=None, region=None, status=None, subtopics=None,
                 tps=None):
        self.checkpoint = checkpoint  # type: str
        self.checkpoint_sample_timestamp = checkpoint_sample_timestamp  # type: long
        self.delay = delay  # type: long
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails]
        self.gmt_create = gmt_create  # type: str
        self.gmt_modify = gmt_modify  # type: str
        self.identity = identity  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.region = region  # type: str
        self.status = status  # type: str
        self.subtopics = subtopics  # type: list[str]
        self.tps = tps  # type: long

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataIncrSyncComponents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checkpoint is not None:
            result['Checkpoint'] = self.checkpoint
        if self.checkpoint_sample_timestamp is not None:
            result['CheckpointSampleTimestamp'] = self.checkpoint_sample_timestamp
        if self.delay is not None:
            result['Delay'] = self.delay
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modify is not None:
            result['GmtModify'] = self.gmt_modify
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.subtopics is not None:
            result['Subtopics'] = self.subtopics
        if self.tps is not None:
            result['Tps'] = self.tps
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Checkpoint') is not None:
            self.checkpoint = m.get('Checkpoint')
        if m.get('CheckpointSampleTimestamp') is not None:
            self.checkpoint_sample_timestamp = m.get('CheckpointSampleTimestamp')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModify') is not None:
            self.gmt_modify = m.get('GmtModify')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtopics') is not None:
            self.subtopics = m.get('Subtopics')
        if m.get('Tps') is not None:
            self.tps = m.get('Tps')
        return self


class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents(TeaModel):
    def __init__(self, checkpoint=None, checkpoint_sample_timestamp=None, delay=None, error_details=None,
                 gmt_create=None, gmt_modify=None, identity=None, ip=None, name=None, region=None, status=None, subtopics=None,
                 tps=None):
        self.checkpoint = checkpoint  # type: str
        self.checkpoint_sample_timestamp = checkpoint_sample_timestamp  # type: long
        self.delay = delay  # type: long
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails]
        self.gmt_create = gmt_create  # type: str
        self.gmt_modify = gmt_modify  # type: str
        self.identity = identity  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.region = region  # type: str
        self.status = status  # type: str
        self.subtopics = subtopics  # type: list[str]
        self.tps = tps  # type: long

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checkpoint is not None:
            result['Checkpoint'] = self.checkpoint
        if self.checkpoint_sample_timestamp is not None:
            result['CheckpointSampleTimestamp'] = self.checkpoint_sample_timestamp
        if self.delay is not None:
            result['Delay'] = self.delay
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modify is not None:
            result['GmtModify'] = self.gmt_modify
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.subtopics is not None:
            result['Subtopics'] = self.subtopics
        if self.tps is not None:
            result['Tps'] = self.tps
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Checkpoint') is not None:
            self.checkpoint = m.get('Checkpoint')
        if m.get('CheckpointSampleTimestamp') is not None:
            self.checkpoint_sample_timestamp = m.get('CheckpointSampleTimestamp')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModify') is not None:
            self.gmt_modify = m.get('GmtModify')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtopics') is not None:
            self.subtopics = m.get('Subtopics')
        if m.get('Tps') is not None:
            self.tps = m.get('Tps')
        return self


class DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataReverseStoreList(TeaModel):
    def __init__(self, begin_checkpoint=None, conn=None, delay=None, end_checkpoint=None, err_msg=None,
                 error_details=None, gmt=None, gmt_create=None, gmt_modified=None, ip=None, lately_heartbeat_time_sec=None,
                 name=None, port=None, region=None, status=None, store_port=None, subtopic=None, to_switch=None,
                 topic=None, tps=None):
        self.begin_checkpoint = begin_checkpoint  # type: str
        self.conn = conn  # type: long
        self.delay = delay  # type: long
        self.end_checkpoint = end_checkpoint  # type: str
        self.err_msg = err_msg  # type: str
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails]
        self.gmt = gmt  # type: long
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.ip = ip  # type: str
        self.lately_heartbeat_time_sec = lately_heartbeat_time_sec  # type: long
        self.name = name  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.status = status  # type: str
        self.store_port = store_port  # type: int
        # SubTopic。
        self.subtopic = subtopic  # type: str
        self.to_switch = to_switch  # type: bool
        # Topic。
        self.topic = topic  # type: str
        self.tps = tps  # type: long

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataReverseStoreList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_checkpoint is not None:
            result['BeginCheckpoint'] = self.begin_checkpoint
        if self.conn is not None:
            result['Conn'] = self.conn
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.end_checkpoint is not None:
            result['EndCheckpoint'] = self.end_checkpoint
        if self.err_msg is not None:
            result['ErrMsg'] = self.err_msg
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.gmt is not None:
            result['Gmt'] = self.gmt
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.lately_heartbeat_time_sec is not None:
            result['LatelyHeartbeatTimeSec'] = self.lately_heartbeat_time_sec
        if self.name is not None:
            result['Name'] = self.name
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.store_port is not None:
            result['StorePort'] = self.store_port
        if self.subtopic is not None:
            result['Subtopic'] = self.subtopic
        if self.to_switch is not None:
            result['ToSwitch'] = self.to_switch
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.tps is not None:
            result['Tps'] = self.tps
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginCheckpoint') is not None:
            self.begin_checkpoint = m.get('BeginCheckpoint')
        if m.get('Conn') is not None:
            self.conn = m.get('Conn')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('EndCheckpoint') is not None:
            self.end_checkpoint = m.get('EndCheckpoint')
        if m.get('ErrMsg') is not None:
            self.err_msg = m.get('ErrMsg')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('Gmt') is not None:
            self.gmt = m.get('Gmt')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('LatelyHeartbeatTimeSec') is not None:
            self.lately_heartbeat_time_sec = m.get('LatelyHeartbeatTimeSec')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorePort') is not None:
            self.store_port = m.get('StorePort')
        if m.get('Subtopic') is not None:
            self.subtopic = m.get('Subtopic')
        if m.get('ToSwitch') is not None:
            self.to_switch = m.get('ToSwitch')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Tps') is not None:
            self.tps = m.get('Tps')
        return self


class DescribeProjectComponentsResponseBodyDataStoreListErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataStoreListErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBodyDataStoreList(TeaModel):
    def __init__(self, begin_checkpoint=None, conn=None, delay=None, end_checkpoint=None, err_msg=None,
                 error_details=None, gmt=None, gmt_create=None, gmt_modified=None, ip=None, lately_heartbeat_time_sec=None,
                 name=None, port=None, region=None, status=None, store_port=None, subtopic=None, to_switch=None,
                 topic=None, tps=None):
        self.begin_checkpoint = begin_checkpoint  # type: str
        self.conn = conn  # type: long
        self.delay = delay  # type: long
        self.end_checkpoint = end_checkpoint  # type: str
        self.err_msg = err_msg  # type: str
        self.error_details = error_details  # type: list[DescribeProjectComponentsResponseBodyDataStoreListErrorDetails]
        self.gmt = gmt  # type: long
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.ip = ip  # type: str
        self.lately_heartbeat_time_sec = lately_heartbeat_time_sec  # type: long
        self.name = name  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.status = status  # type: str
        self.store_port = store_port  # type: int
        # SubTopic。
        self.subtopic = subtopic  # type: str
        self.to_switch = to_switch  # type: bool
        # Topic。
        self.topic = topic  # type: str
        self.tps = tps  # type: long

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyDataStoreList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_checkpoint is not None:
            result['BeginCheckpoint'] = self.begin_checkpoint
        if self.conn is not None:
            result['Conn'] = self.conn
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.end_checkpoint is not None:
            result['EndCheckpoint'] = self.end_checkpoint
        if self.err_msg is not None:
            result['ErrMsg'] = self.err_msg
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.gmt is not None:
            result['Gmt'] = self.gmt
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.lately_heartbeat_time_sec is not None:
            result['LatelyHeartbeatTimeSec'] = self.lately_heartbeat_time_sec
        if self.name is not None:
            result['Name'] = self.name
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.store_port is not None:
            result['StorePort'] = self.store_port
        if self.subtopic is not None:
            result['Subtopic'] = self.subtopic
        if self.to_switch is not None:
            result['ToSwitch'] = self.to_switch
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.tps is not None:
            result['Tps'] = self.tps
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginCheckpoint') is not None:
            self.begin_checkpoint = m.get('BeginCheckpoint')
        if m.get('Conn') is not None:
            self.conn = m.get('Conn')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('EndCheckpoint') is not None:
            self.end_checkpoint = m.get('EndCheckpoint')
        if m.get('ErrMsg') is not None:
            self.err_msg = m.get('ErrMsg')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectComponentsResponseBodyDataStoreListErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('Gmt') is not None:
            self.gmt = m.get('Gmt')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('LatelyHeartbeatTimeSec') is not None:
            self.lately_heartbeat_time_sec = m.get('LatelyHeartbeatTimeSec')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorePort') is not None:
            self.store_port = m.get('StorePort')
        if m.get('Subtopic') is not None:
            self.subtopic = m.get('Subtopic')
        if m.get('ToSwitch') is not None:
            self.to_switch = m.get('ToSwitch')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Tps') is not None:
            self.tps = m.get('Tps')
        return self


class DescribeProjectComponentsResponseBodyData(TeaModel):
    def __init__(self, full_import_components=None, full_verify_components=None, incr_sync_components=None,
                 reverse_incr_sync_components=None, reverse_store_list=None, store_list=None):
        self.full_import_components = full_import_components  # type: list[DescribeProjectComponentsResponseBodyDataFullImportComponents]
        self.full_verify_components = full_verify_components  # type: list[DescribeProjectComponentsResponseBodyDataFullVerifyComponents]
        self.incr_sync_components = incr_sync_components  # type: list[DescribeProjectComponentsResponseBodyDataIncrSyncComponents]
        self.reverse_incr_sync_components = reverse_incr_sync_components  # type: list[DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents]
        self.reverse_store_list = reverse_store_list  # type: list[DescribeProjectComponentsResponseBodyDataReverseStoreList]
        self.store_list = store_list  # type: list[DescribeProjectComponentsResponseBodyDataStoreList]

    def validate(self):
        if self.full_import_components:
            for k in self.full_import_components:
                if k:
                    k.validate()
        if self.full_verify_components:
            for k in self.full_verify_components:
                if k:
                    k.validate()
        if self.incr_sync_components:
            for k in self.incr_sync_components:
                if k:
                    k.validate()
        if self.reverse_incr_sync_components:
            for k in self.reverse_incr_sync_components:
                if k:
                    k.validate()
        if self.reverse_store_list:
            for k in self.reverse_store_list:
                if k:
                    k.validate()
        if self.store_list:
            for k in self.store_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FullImportComponents'] = []
        if self.full_import_components is not None:
            for k in self.full_import_components:
                result['FullImportComponents'].append(k.to_map() if k else None)
        result['FullVerifyComponents'] = []
        if self.full_verify_components is not None:
            for k in self.full_verify_components:
                result['FullVerifyComponents'].append(k.to_map() if k else None)
        result['IncrSyncComponents'] = []
        if self.incr_sync_components is not None:
            for k in self.incr_sync_components:
                result['IncrSyncComponents'].append(k.to_map() if k else None)
        result['ReverseIncrSyncComponents'] = []
        if self.reverse_incr_sync_components is not None:
            for k in self.reverse_incr_sync_components:
                result['ReverseIncrSyncComponents'].append(k.to_map() if k else None)
        result['ReverseStoreList'] = []
        if self.reverse_store_list is not None:
            for k in self.reverse_store_list:
                result['ReverseStoreList'].append(k.to_map() if k else None)
        result['StoreList'] = []
        if self.store_list is not None:
            for k in self.store_list:
                result['StoreList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.full_import_components = []
        if m.get('FullImportComponents') is not None:
            for k in m.get('FullImportComponents'):
                temp_model = DescribeProjectComponentsResponseBodyDataFullImportComponents()
                self.full_import_components.append(temp_model.from_map(k))
        self.full_verify_components = []
        if m.get('FullVerifyComponents') is not None:
            for k in m.get('FullVerifyComponents'):
                temp_model = DescribeProjectComponentsResponseBodyDataFullVerifyComponents()
                self.full_verify_components.append(temp_model.from_map(k))
        self.incr_sync_components = []
        if m.get('IncrSyncComponents') is not None:
            for k in m.get('IncrSyncComponents'):
                temp_model = DescribeProjectComponentsResponseBodyDataIncrSyncComponents()
                self.incr_sync_components.append(temp_model.from_map(k))
        self.reverse_incr_sync_components = []
        if m.get('ReverseIncrSyncComponents') is not None:
            for k in m.get('ReverseIncrSyncComponents'):
                temp_model = DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents()
                self.reverse_incr_sync_components.append(temp_model.from_map(k))
        self.reverse_store_list = []
        if m.get('ReverseStoreList') is not None:
            for k in m.get('ReverseStoreList'):
                temp_model = DescribeProjectComponentsResponseBodyDataReverseStoreList()
                self.reverse_store_list.append(temp_model.from_map(k))
        self.store_list = []
        if m.get('StoreList') is not None:
            for k in m.get('StoreList'):
                temp_model = DescribeProjectComponentsResponseBodyDataStoreList()
                self.store_list.append(temp_model.from_map(k))
        return self


class DescribeProjectComponentsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectComponentsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: DescribeProjectComponentsResponseBodyData
        self.error_detail = error_detail  # type: DescribeProjectComponentsResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = DescribeProjectComponentsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeProjectComponentsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeProjectComponentsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectComponentsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectComponentsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectProgressRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectProgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeProjectProgressResponseBodyData(TeaModel):
    def __init__(self, alarm_level=None, current_step=None, enable_full_transfer=None, enable_incr_sync=None,
                 enable_reverse_incr_transfer=None, enable_struct_transfer=None, full_transfer_progress=None, incr_sync_checkpoint=None,
                 project_id=None, reverse_incr_transfer_checkpoint=None, status=None, struct_transfer_progress=None):
        self.alarm_level = alarm_level  # type: str
        self.current_step = current_step  # type: str
        self.enable_full_transfer = enable_full_transfer  # type: bool
        self.enable_incr_sync = enable_incr_sync  # type: bool
        self.enable_reverse_incr_transfer = enable_reverse_incr_transfer  # type: bool
        self.enable_struct_transfer = enable_struct_transfer  # type: bool
        self.full_transfer_progress = full_transfer_progress  # type: int
        self.incr_sync_checkpoint = incr_sync_checkpoint  # type: long
        self.project_id = project_id  # type: str
        self.reverse_incr_transfer_checkpoint = reverse_incr_transfer_checkpoint  # type: long
        self.status = status  # type: str
        self.struct_transfer_progress = struct_transfer_progress  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectProgressResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_level is not None:
            result['AlarmLevel'] = self.alarm_level
        if self.current_step is not None:
            result['CurrentStep'] = self.current_step
        if self.enable_full_transfer is not None:
            result['EnableFullTransfer'] = self.enable_full_transfer
        if self.enable_incr_sync is not None:
            result['EnableIncrSync'] = self.enable_incr_sync
        if self.enable_reverse_incr_transfer is not None:
            result['EnableReverseIncrTransfer'] = self.enable_reverse_incr_transfer
        if self.enable_struct_transfer is not None:
            result['EnableStructTransfer'] = self.enable_struct_transfer
        if self.full_transfer_progress is not None:
            result['FullTransferProgress'] = self.full_transfer_progress
        if self.incr_sync_checkpoint is not None:
            result['IncrSyncCheckpoint'] = self.incr_sync_checkpoint
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.reverse_incr_transfer_checkpoint is not None:
            result['ReverseIncrTransferCheckpoint'] = self.reverse_incr_transfer_checkpoint
        if self.status is not None:
            result['Status'] = self.status
        if self.struct_transfer_progress is not None:
            result['StructTransferProgress'] = self.struct_transfer_progress
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmLevel') is not None:
            self.alarm_level = m.get('AlarmLevel')
        if m.get('CurrentStep') is not None:
            self.current_step = m.get('CurrentStep')
        if m.get('EnableFullTransfer') is not None:
            self.enable_full_transfer = m.get('EnableFullTransfer')
        if m.get('EnableIncrSync') is not None:
            self.enable_incr_sync = m.get('EnableIncrSync')
        if m.get('EnableReverseIncrTransfer') is not None:
            self.enable_reverse_incr_transfer = m.get('EnableReverseIncrTransfer')
        if m.get('EnableStructTransfer') is not None:
            self.enable_struct_transfer = m.get('EnableStructTransfer')
        if m.get('FullTransferProgress') is not None:
            self.full_transfer_progress = m.get('FullTransferProgress')
        if m.get('IncrSyncCheckpoint') is not None:
            self.incr_sync_checkpoint = m.get('IncrSyncCheckpoint')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ReverseIncrTransferCheckpoint') is not None:
            self.reverse_incr_transfer_checkpoint = m.get('ReverseIncrTransferCheckpoint')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StructTransferProgress') is not None:
            self.struct_transfer_progress = m.get('StructTransferProgress')
        return self


class DescribeProjectProgressResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectProgressResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectProgressResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: DescribeProjectProgressResponseBodyData
        self.error_detail = error_detail  # type: DescribeProjectProgressResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeProjectProgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = DescribeProjectProgressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeProjectProgressResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeProjectProgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectProgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectProgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectStepMetricRequest(TeaModel):
    def __init__(self, aggregator=None, begin_timestamp=None, end_timestamp=None, max_point_num=None,
                 metric_type=None, project_id=None, step_name=None):
        self.aggregator = aggregator  # type: str
        self.begin_timestamp = begin_timestamp  # type: long
        self.end_timestamp = end_timestamp  # type: long
        self.max_point_num = max_point_num  # type: int
        self.metric_type = metric_type  # type: str
        self.project_id = project_id  # type: str
        self.step_name = step_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepMetricRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregator is not None:
            result['Aggregator'] = self.aggregator
        if self.begin_timestamp is not None:
            result['BeginTimestamp'] = self.begin_timestamp
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.max_point_num is not None:
            result['MaxPointNum'] = self.max_point_num
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.step_name is not None:
            result['StepName'] = self.step_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Aggregator') is not None:
            self.aggregator = m.get('Aggregator')
        if m.get('BeginTimestamp') is not None:
            self.begin_timestamp = m.get('BeginTimestamp')
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('MaxPointNum') is not None:
            self.max_point_num = m.get('MaxPointNum')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('StepName') is not None:
            self.step_name = m.get('StepName')
        return self


class DescribeProjectStepMetricResponseBodyDataMetricsDataPoints(TeaModel):
    def __init__(self, timestamp=None, value=None):
        self.timestamp = timestamp  # type: long
        self.value = value  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponseBodyDataMetricsDataPoints, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeProjectStepMetricResponseBodyDataMetrics(TeaModel):
    def __init__(self, data_points=None, name=None, tags=None):
        self.data_points = data_points  # type: list[DescribeProjectStepMetricResponseBodyDataMetricsDataPoints]
        self.name = name  # type: str
        self.tags = tags  # type: dict[str, str]

    def validate(self):
        if self.data_points:
            for k in self.data_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponseBodyDataMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataPoints'] = []
        if self.data_points is not None:
            for k in self.data_points:
                result['DataPoints'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_points = []
        if m.get('DataPoints') is not None:
            for k in m.get('DataPoints'):
                temp_model = DescribeProjectStepMetricResponseBodyDataMetricsDataPoints()
                self.data_points.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeProjectStepMetricResponseBodyData(TeaModel):
    def __init__(self, aggregator=None, metrics=None, reference_value=None):
        self.aggregator = aggregator  # type: str
        self.metrics = metrics  # type: list[DescribeProjectStepMetricResponseBodyDataMetrics]
        self.reference_value = reference_value  # type: long

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregator is not None:
            result['Aggregator'] = self.aggregator
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.reference_value is not None:
            result['ReferenceValue'] = self.reference_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Aggregator') is not None:
            self.aggregator = m.get('Aggregator')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeProjectStepMetricResponseBodyDataMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('ReferenceValue') is not None:
            self.reference_value = m.get('ReferenceValue')
        return self


class DescribeProjectStepMetricResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectStepMetricResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: DescribeProjectStepMetricResponseBodyData
        self.error_detail = error_detail  # type: DescribeProjectStepMetricResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = DescribeProjectStepMetricResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeProjectStepMetricResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeProjectStepMetricResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectStepMetricResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectStepMetricResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectStepMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectStepsRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectStepsResponseBodyDataExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        self.error_code = error_code  # type: str
        self.error_details = error_details  # type: list[DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails]
        self.error_msg = error_msg  # type: str
        self.error_param = error_param  # type: dict[str, str]
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectStepsResponseBodyDataExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class DescribeProjectStepsResponseBodyData(TeaModel):
    def __init__(self, description=None, extra_info=None, finish_time=None, name=None, order=None, progress=None,
                 start_time=None, status=None, step_info=None):
        self.description = description  # type: str
        self.extra_info = extra_info  # type: DescribeProjectStepsResponseBodyDataExtraInfo
        self.finish_time = finish_time  # type: str
        self.name = name  # type: str
        self.order = order  # type: int
        self.progress = progress  # type: int
        self.start_time = start_time  # type: str
        self.status = status  # type: str
        self.step_info = step_info  # type: dict[str, any]

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()

    def to_map(self):
        _map = super(DescribeProjectStepsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.step_info is not None:
            result['StepInfo'] = self.step_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExtraInfo') is not None:
            temp_model = DescribeProjectStepsResponseBodyDataExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StepInfo') is not None:
            self.step_info = m.get('StepInfo')
        return self


class DescribeProjectStepsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectStepsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class DescribeProjectStepsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: list[DescribeProjectStepsResponseBodyData]
        self.error_detail = error_detail  # type: DescribeProjectStepsResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(DescribeProjectStepsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeProjectStepsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = DescribeProjectStepsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeProjectStepsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectStepsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectStepsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectStepsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendIndexRequest(TeaModel):
    def __init__(self, instance_id=None, sqlid=None, tenant_id=None):
        # The return result of the request.
        self.instance_id = instance_id  # type: str
        # The ID of the OceanBase cluster.
        self.sqlid = sqlid  # type: str
        # The index recommended for the SQL statement after calculation by the diagnostic system.   
        # - If the recommended index is the primary key, PRIMARY is returned.  
        # - If an index created by the user is recommended, the index name is returned.   
        # The system recommends only one index for an SQL statement. You can call the DescribeIndexes operation to view the indexes of a table.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRecommendIndexRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeRecommendIndexResponseBodyRecommendIndex(TeaModel):
    def __init__(self, suggest_index=None, table_list=None, tenant_mode=None):
        # Example 1
        self.suggest_index = suggest_index  # type: str
        self.table_list = table_list  # type: str
        self.tenant_mode = tenant_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRecommendIndexResponseBodyRecommendIndex, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.suggest_index is not None:
            result['SuggestIndex'] = self.suggest_index
        if self.table_list is not None:
            result['TableList'] = self.table_list
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SuggestIndex') is not None:
            self.suggest_index = m.get('SuggestIndex')
        if m.get('TableList') is not None:
            self.table_list = m.get('TableList')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        return self


class DescribeRecommendIndexResponseBody(TeaModel):
    def __init__(self, recommend_index=None, request_id=None):
        # The information about the recommended index.
        self.recommend_index = recommend_index  # type: DescribeRecommendIndexResponseBodyRecommendIndex
        # The tenant mode.   Valid values:  
        # Oracle   
        # MySQL
        self.request_id = request_id  # type: str

    def validate(self):
        if self.recommend_index:
            self.recommend_index.validate()

    def to_map(self):
        _map = super(DescribeRecommendIndexResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recommend_index is not None:
            result['RecommendIndex'] = self.recommend_index.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RecommendIndex') is not None:
            temp_model = DescribeRecommendIndexResponseBodyRecommendIndex()
            self.recommend_index = temp_model.from_map(m['RecommendIndex'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRecommendIndexResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRecommendIndexResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRecommendIndexResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendIndexResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSQLDetailsRequest(TeaModel):
    def __init__(self, sqlid=None, tenant_id=None):
        # The SQL text.
        self.sqlid = sqlid  # type: str
        # SQLID.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSQLDetailsResponseBodySQLDetails(TeaModel):
    def __init__(self, db_name=None, sqltext=None, user_name=None):
        self.db_name = db_name  # type: str
        # {"name":"DescribeSQLDetails","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\"name\":\"Action\",\"position\":\"Query\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"description\":\"\",\"example\":\"DescribeSQLDetails\"},{\"name\":\"TenantId\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"t2mr3oae0****\"},{\"name\":\"SQLId\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"SQLID\",\"description\":\"SQLID。\",\"example\":\"8D6E84****0B8FB1823D199E2CA1****\"}]","response_headers":"[]","response":"{\"type\":\"Object\",\"children\":[{\"name\":\"RequestId\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E\"},{\"name\":\"SQLDetails\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"Array\",\"subType\":\"Object\",\"description\":\"  \",\"children\":[{\"name\":\"SQLText\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC\"},{\"name\":\"DbName\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"testdb\"},{\"name\":\"UserName\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"tester\"}],\"title\":\"\"}],\"title\":\"\",\"description\":\"\"}","errors":"{}"}
        self.sqltext = sqltext  # type: str
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLDetailsResponseBodySQLDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.sqltext is not None:
            result['SQLText'] = self.sqltext
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('SQLText') is not None:
            self.sqltext = m.get('SQLText')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeSQLDetailsResponseBody(TeaModel):
    def __init__(self, request_id=None, sqldetails=None):
        # The operation that you want to perform.   
        # Set the value to **DescribeSQLDetails**.
        self.request_id = request_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DescribeSQLDetails
        # &TenantId=t2mr3oae0****\
        # &SQLId=8D6E84****0B8FB1823D199E2CA1****\
        # &Common request parameters
        # ```
        self.sqldetails = sqldetails  # type: list[DescribeSQLDetailsResponseBodySQLDetails]

    def validate(self):
        if self.sqldetails:
            for k in self.sqldetails:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSQLDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SQLDetails'] = []
        if self.sqldetails is not None:
            for k in self.sqldetails:
                result['SQLDetails'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sqldetails = []
        if m.get('SQLDetails') is not None:
            for k in m.get('SQLDetails'):
                temp_model = DescribeSQLDetailsResponseBodySQLDetails()
                self.sqldetails.append(temp_model.from_map(k))
        return self


class DescribeSQLDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSQLDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSQLDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSQLDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSQLHistoryListRequest(TeaModel):
    def __init__(self, end_time=None, page_number=None, page_size=None, sqlid=None, start_time=None, tenant_id=None):
        # The end time of the time range for querying the SQL execution history.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The page number.
        self.page_number = page_number  # type: int
        # The number of entries returned on each page.   
        # Default value: 10.
        self.page_size = page_size  # type: int
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The start time of the time range for querying the SQL execution history.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLHistoryListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSQLHistoryListResponseBodySQLHistoryListList(TeaModel):
    def __init__(self, affected_rows=None, app_wait_time=None, block_cache_hit=None, block_index_cache_hit=None,
                 bloom_filter_cache_hit=None, client_ip=None, concurrency_wait_time=None, cpu_time=None, db_name=None, decode_time=None,
                 disk_read=None, elapsed_time=None, end_time=None, end_time_utcstring=None, event=None, exec_per_second=None,
                 execute_time=None, executions=None, fail_times=None, get_plan_time=None, iowait_time=None, logical_read=None,
                 max_cpu_time=None, max_elapsed_time=None, memstore_read_row_count=None, miss_plans=None, net_wait_time=None,
                 node_ip=None, queue_time=None, rpccount=None, remote_plans=None, retry_count=None, return_rows=None,
                 row_cache_hit=None, schedule_time=None, ssstore_read_row_count=None, total_wait_time=None, user_name=None):
        # The number of rows affected.
        self.affected_rows = affected_rows  # type: long
        # The wait time of the client.
        self.app_wait_time = app_wait_time  # type: float
        # The number of block cache hits.
        self.block_cache_hit = block_cache_hit  # type: long
        # The number of block index cache hits.
        self.block_index_cache_hit = block_index_cache_hit  # type: long
        # The number of Bloom filter cache hits.
        self.bloom_filter_cache_hit = bloom_filter_cache_hit  # type: long
        # The IP address of the client.
        self.client_ip = client_ip  # type: str
        # The wait time in concurrent execution.
        self.concurrency_wait_time = concurrency_wait_time  # type: float
        # The average CPU time.
        self.cpu_time = cpu_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # The time to wait for decoding.
        self.decode_time = decode_time  # type: float
        # The number of physical reads.
        self.disk_read = disk_read  # type: long
        # The average response time.
        self.elapsed_time = elapsed_time  # type: float
        # The end time.
        self.end_time = end_time  # type: long
        # The end time in UTC +0.
        self.end_time_utcstring = end_time_utcstring  # type: str
        # The wait event.
        self.event = event  # type: str
        # The number of executions per second.
        self.exec_per_second = exec_per_second  # type: long
        # The internal execution time.
        self.execute_time = execute_time  # type: float
        # The number of executions.
        self.executions = executions  # type: long
        # The number of failures.
        self.fail_times = fail_times  # type: long
        # The time spent in hard parsing.
        self.get_plan_time = get_plan_time  # type: float
        # The I/O wait time.
        self.iowait_time = iowait_time  # type: float
        # The number of logical reads.
        self.logical_read = logical_read  # type: long
        # The maximum CPU time.
        self.max_cpu_time = max_cpu_time  # type: float
        # The maximum response time.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # The number of rows read from the memory.
        self.memstore_read_row_count = memstore_read_row_count  # type: long
        # The number of plan misses.
        self.miss_plans = miss_plans  # type: long
        # The network latency.
        self.net_wait_time = net_wait_time  # type: float
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The queuing time.
        self.queue_time = queue_time  # type: float
        # The number of RPCs.
        self.rpccount = rpccount  # type: long
        # The number of remote plans.
        self.remote_plans = remote_plans  # type: long
        # The number of retries.
        self.retry_count = retry_count  # type: long
        # The number of rows returned.
        self.return_rows = return_rows  # type: long
        # The number of row cache hits.
        self.row_cache_hit = row_cache_hit  # type: long
        # The scheduling duration.
        self.schedule_time = schedule_time  # type: float
        # The number of rows read from the disk.
        self.ssstore_read_row_count = ssstore_read_row_count  # type: long
        # The internal wait time.
        self.total_wait_time = total_wait_time  # type: float
        # The username.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLHistoryListResponseBodySQLHistoryListList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_rows is not None:
            result['AffectedRows'] = self.affected_rows
        if self.app_wait_time is not None:
            result['AppWaitTime'] = self.app_wait_time
        if self.block_cache_hit is not None:
            result['BlockCacheHit'] = self.block_cache_hit
        if self.block_index_cache_hit is not None:
            result['BlockIndexCacheHit'] = self.block_index_cache_hit
        if self.bloom_filter_cache_hit is not None:
            result['BloomFilterCacheHit'] = self.bloom_filter_cache_hit
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.concurrency_wait_time is not None:
            result['ConcurrencyWaitTime'] = self.concurrency_wait_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.decode_time is not None:
            result['DecodeTime'] = self.decode_time
        if self.disk_read is not None:
            result['DiskRead'] = self.disk_read
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_time_utcstring is not None:
            result['EndTimeUTCString'] = self.end_time_utcstring
        if self.event is not None:
            result['Event'] = self.event
        if self.exec_per_second is not None:
            result['ExecPerSecond'] = self.exec_per_second
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_times is not None:
            result['FailTimes'] = self.fail_times
        if self.get_plan_time is not None:
            result['GetPlanTime'] = self.get_plan_time
        if self.iowait_time is not None:
            result['IOWaitTime'] = self.iowait_time
        if self.logical_read is not None:
            result['LogicalRead'] = self.logical_read
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.memstore_read_row_count is not None:
            result['MemstoreReadRowCount'] = self.memstore_read_row_count
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.net_wait_time is not None:
            result['NetWaitTime'] = self.net_wait_time
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.rpccount is not None:
            result['RPCCount'] = self.rpccount
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.return_rows is not None:
            result['ReturnRows'] = self.return_rows
        if self.row_cache_hit is not None:
            result['RowCacheHit'] = self.row_cache_hit
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.ssstore_read_row_count is not None:
            result['SsstoreReadRowCount'] = self.ssstore_read_row_count
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedRows') is not None:
            self.affected_rows = m.get('AffectedRows')
        if m.get('AppWaitTime') is not None:
            self.app_wait_time = m.get('AppWaitTime')
        if m.get('BlockCacheHit') is not None:
            self.block_cache_hit = m.get('BlockCacheHit')
        if m.get('BlockIndexCacheHit') is not None:
            self.block_index_cache_hit = m.get('BlockIndexCacheHit')
        if m.get('BloomFilterCacheHit') is not None:
            self.bloom_filter_cache_hit = m.get('BloomFilterCacheHit')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ConcurrencyWaitTime') is not None:
            self.concurrency_wait_time = m.get('ConcurrencyWaitTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DecodeTime') is not None:
            self.decode_time = m.get('DecodeTime')
        if m.get('DiskRead') is not None:
            self.disk_read = m.get('DiskRead')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimeUTCString') is not None:
            self.end_time_utcstring = m.get('EndTimeUTCString')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('ExecPerSecond') is not None:
            self.exec_per_second = m.get('ExecPerSecond')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailTimes') is not None:
            self.fail_times = m.get('FailTimes')
        if m.get('GetPlanTime') is not None:
            self.get_plan_time = m.get('GetPlanTime')
        if m.get('IOWaitTime') is not None:
            self.iowait_time = m.get('IOWaitTime')
        if m.get('LogicalRead') is not None:
            self.logical_read = m.get('LogicalRead')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MemstoreReadRowCount') is not None:
            self.memstore_read_row_count = m.get('MemstoreReadRowCount')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('NetWaitTime') is not None:
            self.net_wait_time = m.get('NetWaitTime')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RPCCount') is not None:
            self.rpccount = m.get('RPCCount')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('ReturnRows') is not None:
            self.return_rows = m.get('ReturnRows')
        if m.get('RowCacheHit') is not None:
            self.row_cache_hit = m.get('RowCacheHit')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('SsstoreReadRowCount') is not None:
            self.ssstore_read_row_count = m.get('SsstoreReadRowCount')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeSQLHistoryListResponseBodySQLHistoryList(TeaModel):
    def __init__(self, count=None, list=None):
        # The quantity.
        self.count = count  # type: long
        self.list = list  # type: list[DescribeSQLHistoryListResponseBodySQLHistoryListList]

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSQLHistoryListResponseBodySQLHistoryList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeSQLHistoryListResponseBodySQLHistoryListList()
                self.list.append(temp_model.from_map(k))
        return self


class DescribeSQLHistoryListResponseBody(TeaModel):
    def __init__(self, request_id=None, sqlhistory_list=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The execution history of the SQL statement.
        self.sqlhistory_list = sqlhistory_list  # type: DescribeSQLHistoryListResponseBodySQLHistoryList

    def validate(self):
        if self.sqlhistory_list:
            self.sqlhistory_list.validate()

    def to_map(self):
        _map = super(DescribeSQLHistoryListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqlhistory_list is not None:
            result['SQLHistoryList'] = self.sqlhistory_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLHistoryList') is not None:
            temp_model = DescribeSQLHistoryListResponseBodySQLHistoryList()
            self.sqlhistory_list = temp_model.from_map(m['SQLHistoryList'])
        return self


class DescribeSQLHistoryListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSQLHistoryListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSQLHistoryListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSQLHistoryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSQLPlansRequest(TeaModel):
    def __init__(self, sqlid=None, tenant_id=None):
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLPlansRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSQLPlansResponseBodySQLPlans(TeaModel):
    def __init__(self, avg_execution_ms=None, avg_execution_time_ms=None, first_load_time=None,
                 first_load_time_utcstring=None, hit_count=None, merged_version=None, node_ip=None, outline_data=None, outline_id=None,
                 outline_time=None, outline_time_utcstring=None, plan_full=None, plan_id=None, plan_info=None,
                 plan_union_hash=None, query_sql=None):
        # The average execution duration, in ms.
        self.avg_execution_ms = avg_execution_ms  # type: float
        # The average execution duration when the database uses this execution plan, in ms.
        self.avg_execution_time_ms = avg_execution_time_ms  # type: long
        # The time when the plan was loaded for the first time, .
        self.first_load_time = first_load_time  # type: long
        # The time when the plan was loaded for the first time, in UTC +0.
        self.first_load_time_utcstring = first_load_time_utcstring  # type: str
        # The number of hits.
        self.hit_count = hit_count  # type: int
        # The major compaction version.
        self.merged_version = merged_version  # type: int
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The outline data.
        self.outline_data = outline_data  # type: str
        # OutlineID.
        self.outline_id = outline_id  # type: long
        # The time when the plan was bound.
        self.outline_time = outline_time  # type: long
        # The time when the plan was bound, in UTC +0.
        self.outline_time_utcstring = outline_time_utcstring  # type: str
        # The complete execution plan of the SQL statement.
        self.plan_full = plan_full  # type: str
        # The ID of the SQL execution plan in the database.
        self.plan_id = plan_id  # type: int
        # The information about the plan.
        self.plan_info = plan_info  # type: str
        # The unique identifier of the SQL execution plan in the diagnostic system.
        self.plan_union_hash = plan_union_hash  # type: str
        # The query SQL statement.
        self.query_sql = query_sql  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLPlansResponseBodySQLPlans, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_execution_ms is not None:
            result['AvgExecutionMS'] = self.avg_execution_ms
        if self.avg_execution_time_ms is not None:
            result['AvgExecutionTimeMS'] = self.avg_execution_time_ms
        if self.first_load_time is not None:
            result['FirstLoadTime'] = self.first_load_time
        if self.first_load_time_utcstring is not None:
            result['FirstLoadTimeUTCString'] = self.first_load_time_utcstring
        if self.hit_count is not None:
            result['HitCount'] = self.hit_count
        if self.merged_version is not None:
            result['MergedVersion'] = self.merged_version
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.outline_data is not None:
            result['OutlineData'] = self.outline_data
        if self.outline_id is not None:
            result['OutlineId'] = self.outline_id
        if self.outline_time is not None:
            result['OutlineTime'] = self.outline_time
        if self.outline_time_utcstring is not None:
            result['OutlineTimeUTCString'] = self.outline_time_utcstring
        if self.plan_full is not None:
            result['PlanFull'] = self.plan_full
        if self.plan_id is not None:
            result['PlanId'] = self.plan_id
        if self.plan_info is not None:
            result['PlanInfo'] = self.plan_info
        if self.plan_union_hash is not None:
            result['PlanUnionHash'] = self.plan_union_hash
        if self.query_sql is not None:
            result['QuerySQL'] = self.query_sql
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgExecutionMS') is not None:
            self.avg_execution_ms = m.get('AvgExecutionMS')
        if m.get('AvgExecutionTimeMS') is not None:
            self.avg_execution_time_ms = m.get('AvgExecutionTimeMS')
        if m.get('FirstLoadTime') is not None:
            self.first_load_time = m.get('FirstLoadTime')
        if m.get('FirstLoadTimeUTCString') is not None:
            self.first_load_time_utcstring = m.get('FirstLoadTimeUTCString')
        if m.get('HitCount') is not None:
            self.hit_count = m.get('HitCount')
        if m.get('MergedVersion') is not None:
            self.merged_version = m.get('MergedVersion')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('OutlineData') is not None:
            self.outline_data = m.get('OutlineData')
        if m.get('OutlineId') is not None:
            self.outline_id = m.get('OutlineId')
        if m.get('OutlineTime') is not None:
            self.outline_time = m.get('OutlineTime')
        if m.get('OutlineTimeUTCString') is not None:
            self.outline_time_utcstring = m.get('OutlineTimeUTCString')
        if m.get('PlanFull') is not None:
            self.plan_full = m.get('PlanFull')
        if m.get('PlanId') is not None:
            self.plan_id = m.get('PlanId')
        if m.get('PlanInfo') is not None:
            self.plan_info = m.get('PlanInfo')
        if m.get('PlanUnionHash') is not None:
            self.plan_union_hash = m.get('PlanUnionHash')
        if m.get('QuerySQL') is not None:
            self.query_sql = m.get('QuerySQL')
        return self


class DescribeSQLPlansResponseBody(TeaModel):
    def __init__(self, request_id=None, sqlplans=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The information about the execution plan.
        self.sqlplans = sqlplans  # type: list[DescribeSQLPlansResponseBodySQLPlans]

    def validate(self):
        if self.sqlplans:
            for k in self.sqlplans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSQLPlansResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SQLPlans'] = []
        if self.sqlplans is not None:
            for k in self.sqlplans:
                result['SQLPlans'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sqlplans = []
        if m.get('SQLPlans') is not None:
            for k in m.get('SQLPlans'):
                temp_model = DescribeSQLPlansResponseBodySQLPlans()
                self.sqlplans.append(temp_model.from_map(k))
        return self


class DescribeSQLPlansResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSQLPlansResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSQLPlansResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSQLPlansResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSQLSamplesRequest(TeaModel):
    def __init__(self, db_name=None, end_time=None, instance_id=None, sql_id=None, start_time=None, tenant_id=None):
        # The database name.
        self.db_name = db_name  # type: str
        # The end time of querying the slow query execution.
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The instance ID.
        self.instance_id = instance_id  # type: str
        # SQL ID.
        self.sql_id = sql_id  # type: str
        # The start time of querying the slow query execution.
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The tenant ID.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLSamplesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSQLSamplesResponseBodyData(TeaModel):
    def __init__(self, affected_rows=None, application_wait_time=None, block_cache_hit=None,
                 block_index_cache_hit=None, bloom_filter_cache_hit=None, client_ip=None, client_port=None, concurrency_wait_time=None,
                 consistency_level=None, cpu_time=None, db_name=None, decode_time=None, disk_reads=None, elapsed_time=None,
                 execute_time=None, executor_rpc=None, expected_worker_count=None, full_sql_text=None, get_plan_time=None,
                 hit_plan=None, inner=None, memstore_read_rows=None, net_time=None, net_wait_time=None, ob_db_id=None,
                 ob_server_id=None, ob_user_id=None, partition_count=None, plan_id=None, plan_type=None, queue_time=None,
                 request_id=None, request_time=None, ret_code=None, retry_count=None, return_rows=None, row_cache_hit=None,
                 rpc_count=None, schedule_time=None, server=None, sql_type=None, ssstore_read_rows=None, statement=None,
                 table_scan=None, trace_id=None, trans_hash=None, used_worker_count=None, user_io_wait_time=None,
                 user_name=None, wait_count=None, wait_event=None, wait_time=None):
        # Average updated rows during the execution period.
        self.affected_rows = affected_rows  # type: float
        # Application event waiting time (in milliseconds).
        self.application_wait_time = application_wait_time  # type: float
        # BlockCache hit count
        self.block_cache_hit = block_cache_hit  # type: float
        # BlockIndexCache hit count
        self.block_index_cache_hit = block_index_cache_hit  # type: float
        # BloomFilterCache hit count.
        self.bloom_filter_cache_hit = bloom_filter_cache_hit  # type: float
        # Client IP.
        self.client_ip = client_ip  # type: str
        # Client port.
        self.client_port = client_port  # type: str
        # Concurrency event waiting time (in milliseconds).
        self.concurrency_wait_time = concurrency_wait_time  # type: float
        # Consistency level.
        self.consistency_level = consistency_level  # type: str
        # CPU time (in milliseconds).
        self.cpu_time = cpu_time  # type: float
        # Database name.
        self.db_name = db_name  # type: str
        # Syntax parsing time (in milliseconds).
        self.decode_time = decode_time  # type: float
        # Disk read count.
        self.disk_reads = disk_reads  # type: float
        # Response time (in milliseconds).
        self.elapsed_time = elapsed_time  # type: float
        # Plan execution time (in milliseconds).
        self.execute_time = execute_time  # type: float
        # Whether to initiate RPC.
        self.executor_rpc = executor_rpc  # type: bool
        # Degree of parallelism.
        self.expected_worker_count = expected_worker_count  # type: float
        self.full_sql_text = full_sql_text  # type: str
        # Plan generation time (in milliseconds).
        self.get_plan_time = get_plan_time  # type: float
        # Whether to hit the execution plan.
        self.hit_plan = hit_plan  # type: bool
        # Whether an internal SQL.
        self.inner = inner  # type: bool
        # Memstore read row count.
        self.memstore_read_rows = memstore_read_rows  # type: float
        # Network transmission time (in milliseconds).
        self.net_time = net_time  # type: float
        # Network enqueue time (in milliseconds).
        self.net_wait_time = net_wait_time  # type: float
        # Database ID.
        self.ob_db_id = ob_db_id  # type: float
        # Server  ID.
        self.ob_server_id = ob_server_id  # type: float
        # User ID.
        self.ob_user_id = ob_user_id  # type: float
        # Average number of partition accessed during the execution period.
        self.partition_count = partition_count  # type: float
        # The execution plan ID.
        self.plan_id = plan_id  # type: float
        # Plan type.
        self.plan_type = plan_type  # type: str
        # Queueing time (in milliseconds).
        self.queue_time = queue_time  # type: float
        # Request ID.
        self.request_id = request_id  # type: str
        # SQL request time.
        self.request_time = request_time  # type: str
        # Result code.
        self.ret_code = ret_code  # type: float
        # Retry count.
        self.retry_count = retry_count  # type: float
        # Average returned rows during the execution period.
        self.return_rows = return_rows  # type: float
        # RowCache hit count.
        self.row_cache_hit = row_cache_hit  # type: float
        # Number of RPC sent.
        self.rpc_count = rpc_count  # type: float
        # Schedule event waiting time (in milliseconds).
        self.schedule_time = schedule_time  # type: float
        # The server where the SQL is executed.
        self.server = server  # type: str
        # SQL type.
        self.sql_type = sql_type  # type: str
        # Ssstore read row count.
        self.ssstore_read_rows = ssstore_read_rows  # type: float
        # Parameterized SQL text.
        self.statement = statement  # type: str
        # Whether to perform full table scan.
        self.table_scan = table_scan  # type: bool
        # Trace ID.
        self.trace_id = trace_id  # type: str
        # Transaction hash.
        self.trans_hash = trans_hash  # type: str
        # Actual number of SQL execution threads.
        self.used_worker_count = used_worker_count  # type: float
        # UserIO event waiting time (in milliseconds).
        self.user_io_wait_time = user_io_wait_time  # type: float
        # Username.
        self.user_name = user_name  # type: str
        # Wait count.
        self.wait_count = wait_count  # type: float
        # Longest wait event during the execution period.
        self.wait_event = wait_event  # type: str
        # Wait time (in milliseconds).
        self.wait_time = wait_time  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSQLSamplesResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_rows is not None:
            result['AffectedRows'] = self.affected_rows
        if self.application_wait_time is not None:
            result['ApplicationWaitTime'] = self.application_wait_time
        if self.block_cache_hit is not None:
            result['BlockCacheHit'] = self.block_cache_hit
        if self.block_index_cache_hit is not None:
            result['BlockIndexCacheHit'] = self.block_index_cache_hit
        if self.bloom_filter_cache_hit is not None:
            result['BloomFilterCacheHit'] = self.bloom_filter_cache_hit
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.client_port is not None:
            result['ClientPort'] = self.client_port
        if self.concurrency_wait_time is not None:
            result['ConcurrencyWaitTime'] = self.concurrency_wait_time
        if self.consistency_level is not None:
            result['ConsistencyLevel'] = self.consistency_level
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.decode_time is not None:
            result['DecodeTime'] = self.decode_time
        if self.disk_reads is not None:
            result['DiskReads'] = self.disk_reads
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executor_rpc is not None:
            result['ExecutorRpc'] = self.executor_rpc
        if self.expected_worker_count is not None:
            result['ExpectedWorkerCount'] = self.expected_worker_count
        if self.full_sql_text is not None:
            result['FullSqlText'] = self.full_sql_text
        if self.get_plan_time is not None:
            result['GetPlanTime'] = self.get_plan_time
        if self.hit_plan is not None:
            result['HitPlan'] = self.hit_plan
        if self.inner is not None:
            result['Inner'] = self.inner
        if self.memstore_read_rows is not None:
            result['MemstoreReadRows'] = self.memstore_read_rows
        if self.net_time is not None:
            result['NetTime'] = self.net_time
        if self.net_wait_time is not None:
            result['NetWaitTime'] = self.net_wait_time
        if self.ob_db_id is not None:
            result['ObDbId'] = self.ob_db_id
        if self.ob_server_id is not None:
            result['ObServerId'] = self.ob_server_id
        if self.ob_user_id is not None:
            result['ObUserId'] = self.ob_user_id
        if self.partition_count is not None:
            result['PartitionCount'] = self.partition_count
        if self.plan_id is not None:
            result['PlanId'] = self.plan_id
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.request_time is not None:
            result['RequestTime'] = self.request_time
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.return_rows is not None:
            result['ReturnRows'] = self.return_rows
        if self.row_cache_hit is not None:
            result['RowCacheHit'] = self.row_cache_hit
        if self.rpc_count is not None:
            result['RpcCount'] = self.rpc_count
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.server is not None:
            result['Server'] = self.server
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.ssstore_read_rows is not None:
            result['SsstoreReadRows'] = self.ssstore_read_rows
        if self.statement is not None:
            result['Statement'] = self.statement
        if self.table_scan is not None:
            result['TableScan'] = self.table_scan
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        if self.trans_hash is not None:
            result['TransHash'] = self.trans_hash
        if self.used_worker_count is not None:
            result['UsedWorkerCount'] = self.used_worker_count
        if self.user_io_wait_time is not None:
            result['UserIoWaitTime'] = self.user_io_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.wait_count is not None:
            result['WaitCount'] = self.wait_count
        if self.wait_event is not None:
            result['WaitEvent'] = self.wait_event
        if self.wait_time is not None:
            result['WaitTime'] = self.wait_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedRows') is not None:
            self.affected_rows = m.get('AffectedRows')
        if m.get('ApplicationWaitTime') is not None:
            self.application_wait_time = m.get('ApplicationWaitTime')
        if m.get('BlockCacheHit') is not None:
            self.block_cache_hit = m.get('BlockCacheHit')
        if m.get('BlockIndexCacheHit') is not None:
            self.block_index_cache_hit = m.get('BlockIndexCacheHit')
        if m.get('BloomFilterCacheHit') is not None:
            self.bloom_filter_cache_hit = m.get('BloomFilterCacheHit')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ClientPort') is not None:
            self.client_port = m.get('ClientPort')
        if m.get('ConcurrencyWaitTime') is not None:
            self.concurrency_wait_time = m.get('ConcurrencyWaitTime')
        if m.get('ConsistencyLevel') is not None:
            self.consistency_level = m.get('ConsistencyLevel')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DecodeTime') is not None:
            self.decode_time = m.get('DecodeTime')
        if m.get('DiskReads') is not None:
            self.disk_reads = m.get('DiskReads')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('ExecutorRpc') is not None:
            self.executor_rpc = m.get('ExecutorRpc')
        if m.get('ExpectedWorkerCount') is not None:
            self.expected_worker_count = m.get('ExpectedWorkerCount')
        if m.get('FullSqlText') is not None:
            self.full_sql_text = m.get('FullSqlText')
        if m.get('GetPlanTime') is not None:
            self.get_plan_time = m.get('GetPlanTime')
        if m.get('HitPlan') is not None:
            self.hit_plan = m.get('HitPlan')
        if m.get('Inner') is not None:
            self.inner = m.get('Inner')
        if m.get('MemstoreReadRows') is not None:
            self.memstore_read_rows = m.get('MemstoreReadRows')
        if m.get('NetTime') is not None:
            self.net_time = m.get('NetTime')
        if m.get('NetWaitTime') is not None:
            self.net_wait_time = m.get('NetWaitTime')
        if m.get('ObDbId') is not None:
            self.ob_db_id = m.get('ObDbId')
        if m.get('ObServerId') is not None:
            self.ob_server_id = m.get('ObServerId')
        if m.get('ObUserId') is not None:
            self.ob_user_id = m.get('ObUserId')
        if m.get('PartitionCount') is not None:
            self.partition_count = m.get('PartitionCount')
        if m.get('PlanId') is not None:
            self.plan_id = m.get('PlanId')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RequestTime') is not None:
            self.request_time = m.get('RequestTime')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('ReturnRows') is not None:
            self.return_rows = m.get('ReturnRows')
        if m.get('RowCacheHit') is not None:
            self.row_cache_hit = m.get('RowCacheHit')
        if m.get('RpcCount') is not None:
            self.rpc_count = m.get('RpcCount')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('SsstoreReadRows') is not None:
            self.ssstore_read_rows = m.get('SsstoreReadRows')
        if m.get('Statement') is not None:
            self.statement = m.get('Statement')
        if m.get('TableScan') is not None:
            self.table_scan = m.get('TableScan')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        if m.get('TransHash') is not None:
            self.trans_hash = m.get('TransHash')
        if m.get('UsedWorkerCount') is not None:
            self.used_worker_count = m.get('UsedWorkerCount')
        if m.get('UserIoWaitTime') is not None:
            self.user_io_wait_time = m.get('UserIoWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('WaitCount') is not None:
            self.wait_count = m.get('WaitCount')
        if m.get('WaitEvent') is not None:
            self.wait_event = m.get('WaitEvent')
        if m.get('WaitTime') is not None:
            self.wait_time = m.get('WaitTime')
        return self


class DescribeSQLSamplesResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of sample data of slow query execution details.
        self.data = data  # type: list[DescribeSQLSamplesResponseBodyData]
        # Request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSQLSamplesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeSQLSamplesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSQLSamplesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSQLSamplesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSQLSamplesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSQLSamplesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityIpGroupsRequest(TeaModel):
    def __init__(self, instance_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityIpGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeSecurityIpGroupsResponseBodySecurityIpGroups(TeaModel):
    def __init__(self, security_ip_group_name=None, security_ips=None):
        self.security_ip_group_name = security_ip_group_name  # type: str
        self.security_ips = security_ips  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityIpGroupsResponseBodySecurityIpGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        return self


class DescribeSecurityIpGroupsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_groups=None, total_count=None):
        # The request ID.
        self.request_id = request_id  # type: str
        self.security_ip_groups = security_ip_groups  # type: list[DescribeSecurityIpGroupsResponseBodySecurityIpGroups]
        # Example 1
        self.total_count = total_count  # type: int

    def validate(self):
        if self.security_ip_groups:
            for k in self.security_ip_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityIpGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityIpGroups'] = []
        if self.security_ip_groups is not None:
            for k in self.security_ip_groups:
                result['SecurityIpGroups'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_ip_groups = []
        if m.get('SecurityIpGroups') is not None:
            for k in m.get('SecurityIpGroups'):
                temp_model = DescribeSecurityIpGroupsResponseBodySecurityIpGroups()
                self.security_ip_groups.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecurityIpGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityIpGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityIpGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityIpGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSlowSQLHistoryListRequest(TeaModel):
    def __init__(self, end_time=None, page_number=None, page_size=None, sqlid=None, start_time=None, tenant_id=None):
        # The end time of the time range for querying the execution history of the slow SQL statement.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_number = page_number  # type: int
        # The number of rows to return on each page.  
        # - Maximum value: 100   
        # - Default value: 10
        self.page_size = page_size  # type: int
        # The SQL ID, which uniquely identifies an SQL statement.
        self.sqlid = sqlid  # type: str
        # The start time of the time range for querying the execution history of the slow SQL statement.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSlowSQLHistoryListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList(TeaModel):
    def __init__(self, affected_rows=None, app_wait_time=None, block_cache_hit=None, block_index_cache_hit=None,
                 bloom_filter_cache_hit=None, client_ip=None, concurrency_wait_time=None, cpu_time=None, db_name=None, decode_time=None,
                 disk_read=None, elapsed_time=None, end_time_utcstring=None, event=None, exec_per_second=None,
                 execute_time=None, executions=None, fail_times=None, get_plan_time=None, iowait_time=None, logical_read=None,
                 max_cpu_time=None, max_elapsed_time=None, memstore_read_row_count=None, miss_plans=None, net_wait_time=None,
                 node_ip=None, queue_time=None, rpccount=None, remote_plans=None, retry_count=None, return_rows=None,
                 row_cache_hit=None, schedule_time=None, sql_id=None, sql_type=None, ssstore_read_row_count=None,
                 tenant_name=None, total_wait_time=None, user_name=None):
        # The number of rows affected.
        self.affected_rows = affected_rows  # type: float
        # The wait time of the client.
        self.app_wait_time = app_wait_time  # type: float
        # The number of block cache hits.
        self.block_cache_hit = block_cache_hit  # type: float
        # The number of block index cache hits.
        self.block_index_cache_hit = block_index_cache_hit  # type: float
        # The number of Bloom filter cache hits.
        self.bloom_filter_cache_hit = bloom_filter_cache_hit  # type: float
        # The IP address of the client.
        self.client_ip = client_ip  # type: str
        # The wait time in concurrent execution.
        self.concurrency_wait_time = concurrency_wait_time  # type: float
        # The average CPU time.
        self.cpu_time = cpu_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # The time to wait for decoding.
        self.decode_time = decode_time  # type: float
        # The number of physical reads.
        self.disk_read = disk_read  # type: float
        # The average response time.
        self.elapsed_time = elapsed_time  # type: float
        # The end time.
        self.end_time_utcstring = end_time_utcstring  # type: str
        # The wait event.
        self.event = event  # type: str
        # The number of executions per second.
        self.exec_per_second = exec_per_second  # type: float
        # The internal execution time.
        self.execute_time = execute_time  # type: float
        # The number of executions.
        self.executions = executions  # type: float
        # The number of failures.
        self.fail_times = fail_times  # type: float
        # Hard parsing time.
        self.get_plan_time = get_plan_time  # type: float
        # The I/O wait time.
        self.iowait_time = iowait_time  # type: float
        # The number of logical reads.
        self.logical_read = logical_read  # type: float
        # The maximum CPU time.
        self.max_cpu_time = max_cpu_time  # type: float
        # The maximum response time.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # The number of rows read from the memory.
        self.memstore_read_row_count = memstore_read_row_count  # type: float
        # The number of plan misses.
        self.miss_plans = miss_plans  # type: float
        # The wait time for network.
        self.net_wait_time = net_wait_time  # type: float
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The queuing time.
        self.queue_time = queue_time  # type: float
        # The number of RPCs.
        self.rpccount = rpccount  # type: float
        # The number of remote plans.
        self.remote_plans = remote_plans  # type: float
        # The number of retries.
        self.retry_count = retry_count  # type: float
        # The number of rows returned.
        self.return_rows = return_rows  # type: float
        # The number of row cache hits.
        self.row_cache_hit = row_cache_hit  # type: float
        # The scheduling duration.
        self.schedule_time = schedule_time  # type: float
        # SQLID.
        self.sql_id = sql_id  # type: str
        # The SQL type.
        self.sql_type = sql_type  # type: str
        # The number of rows read from the disk.
        self.ssstore_read_row_count = ssstore_read_row_count  # type: float
        # The name of the tenant.
        self.tenant_name = tenant_name  # type: str
        # The internal wait time.
        self.total_wait_time = total_wait_time  # type: float
        # The username.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_rows is not None:
            result['AffectedRows'] = self.affected_rows
        if self.app_wait_time is not None:
            result['AppWaitTime'] = self.app_wait_time
        if self.block_cache_hit is not None:
            result['BlockCacheHit'] = self.block_cache_hit
        if self.block_index_cache_hit is not None:
            result['BlockIndexCacheHit'] = self.block_index_cache_hit
        if self.bloom_filter_cache_hit is not None:
            result['BloomFilterCacheHit'] = self.bloom_filter_cache_hit
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.concurrency_wait_time is not None:
            result['ConcurrencyWaitTime'] = self.concurrency_wait_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.decode_time is not None:
            result['DecodeTime'] = self.decode_time
        if self.disk_read is not None:
            result['DiskRead'] = self.disk_read
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.end_time_utcstring is not None:
            result['EndTimeUTCString'] = self.end_time_utcstring
        if self.event is not None:
            result['Event'] = self.event
        if self.exec_per_second is not None:
            result['ExecPerSecond'] = self.exec_per_second
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_times is not None:
            result['FailTimes'] = self.fail_times
        if self.get_plan_time is not None:
            result['GetPlanTime'] = self.get_plan_time
        if self.iowait_time is not None:
            result['IOWaitTime'] = self.iowait_time
        if self.logical_read is not None:
            result['LogicalRead'] = self.logical_read
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.memstore_read_row_count is not None:
            result['MemstoreReadRowCount'] = self.memstore_read_row_count
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.net_wait_time is not None:
            result['NetWaitTime'] = self.net_wait_time
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.rpccount is not None:
            result['RPCCount'] = self.rpccount
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.return_rows is not None:
            result['ReturnRows'] = self.return_rows
        if self.row_cache_hit is not None:
            result['RowCacheHit'] = self.row_cache_hit
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.ssstore_read_row_count is not None:
            result['SsstoreReadRowCount'] = self.ssstore_read_row_count
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedRows') is not None:
            self.affected_rows = m.get('AffectedRows')
        if m.get('AppWaitTime') is not None:
            self.app_wait_time = m.get('AppWaitTime')
        if m.get('BlockCacheHit') is not None:
            self.block_cache_hit = m.get('BlockCacheHit')
        if m.get('BlockIndexCacheHit') is not None:
            self.block_index_cache_hit = m.get('BlockIndexCacheHit')
        if m.get('BloomFilterCacheHit') is not None:
            self.bloom_filter_cache_hit = m.get('BloomFilterCacheHit')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ConcurrencyWaitTime') is not None:
            self.concurrency_wait_time = m.get('ConcurrencyWaitTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DecodeTime') is not None:
            self.decode_time = m.get('DecodeTime')
        if m.get('DiskRead') is not None:
            self.disk_read = m.get('DiskRead')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('EndTimeUTCString') is not None:
            self.end_time_utcstring = m.get('EndTimeUTCString')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('ExecPerSecond') is not None:
            self.exec_per_second = m.get('ExecPerSecond')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailTimes') is not None:
            self.fail_times = m.get('FailTimes')
        if m.get('GetPlanTime') is not None:
            self.get_plan_time = m.get('GetPlanTime')
        if m.get('IOWaitTime') is not None:
            self.iowait_time = m.get('IOWaitTime')
        if m.get('LogicalRead') is not None:
            self.logical_read = m.get('LogicalRead')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MemstoreReadRowCount') is not None:
            self.memstore_read_row_count = m.get('MemstoreReadRowCount')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('NetWaitTime') is not None:
            self.net_wait_time = m.get('NetWaitTime')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RPCCount') is not None:
            self.rpccount = m.get('RPCCount')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('ReturnRows') is not None:
            self.return_rows = m.get('ReturnRows')
        if m.get('RowCacheHit') is not None:
            self.row_cache_hit = m.get('RowCacheHit')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('SsstoreReadRowCount') is not None:
            self.ssstore_read_row_count = m.get('SsstoreReadRowCount')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList(TeaModel):
    def __init__(self, count=None, list=None):
        # The quantity.
        self.count = count  # type: long
        # The return result of the request.
        self.list = list  # type: list[DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList]

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList()
                self.list.append(temp_model.from_map(k))
        return self


class DescribeSlowSQLHistoryListResponseBody(TeaModel):
    def __init__(self, request_id=None, slow_sqlhistory_list=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The execution history of the slow SQL statement.
        self.slow_sqlhistory_list = slow_sqlhistory_list  # type: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList

    def validate(self):
        if self.slow_sqlhistory_list:
            self.slow_sqlhistory_list.validate()

    def to_map(self):
        _map = super(DescribeSlowSQLHistoryListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slow_sqlhistory_list is not None:
            result['SlowSQLHistoryList'] = self.slow_sqlhistory_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SlowSQLHistoryList') is not None:
            temp_model = DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList()
            self.slow_sqlhistory_list = temp_model.from_map(m['SlowSQLHistoryList'])
        return self


class DescribeSlowSQLHistoryListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSlowSQLHistoryListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSlowSQLHistoryListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSlowSQLHistoryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSlowSQLListRequest(TeaModel):
    def __init__(self, db_name=None, end_time=None, filter_condition=None, node_ip=None, page_number=None,
                 page_size=None, sqlid=None, search_key_word=None, search_parameter=None, search_rule=None, search_value=None,
                 sort_column=None, sort_order=None, start_time=None, tenant_id=None):
        # The name of the database.
        self.db_name = db_name  # type: str
        # The end time of the time range for querying slow SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The filter condition.
        self.filter_condition = filter_condition  # type: dict[str, any]
        # The IP address of the database node.
        self.node_ip = node_ip  # type: str
        # The number of rows to return on each page.  
        # - Maximum value: 100  
        # - Default value: 10
        self.page_number = page_number  # type: int
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_size = page_size  # type: int
        # The SQL ID, which uniquely identifies an SQL statement.
        self.sqlid = sqlid  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_parameter = search_parameter  # type: str
        # The search rule.
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # The sorted column.
        self.sort_column = sort_column  # type: str
        # The sorting rule.
        self.sort_order = sort_order  # type: str
        # The start time of the time range for querying slow SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSlowSQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSlowSQLListShrinkRequest(TeaModel):
    def __init__(self, db_name=None, end_time=None, filter_condition_shrink=None, node_ip=None, page_number=None,
                 page_size=None, sqlid=None, search_key_word=None, search_parameter=None, search_rule=None, search_value=None,
                 sort_column=None, sort_order=None, start_time=None, tenant_id=None):
        # The name of the database.
        self.db_name = db_name  # type: str
        # The end time of the time range for querying slow SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.end_time = end_time  # type: str
        # The filter condition.
        self.filter_condition_shrink = filter_condition_shrink  # type: str
        # The IP address of the database node.
        self.node_ip = node_ip  # type: str
        # The number of rows to return on each page.  
        # - Maximum value: 100  
        # - Default value: 10
        self.page_number = page_number  # type: int
        # The number of the page to return.    
        # - Start value: 1   
        # - Default value: 1
        self.page_size = page_size  # type: int
        # The SQL ID, which uniquely identifies an SQL statement.
        self.sqlid = sqlid  # type: str
        # The search keyword.
        self.search_key_word = search_key_word  # type: str
        # The search parameter.
        self.search_parameter = search_parameter  # type: str
        # The search rule.
        self.search_rule = search_rule  # type: str
        # The search value.
        self.search_value = search_value  # type: str
        # The sorted column.
        self.sort_column = sort_column  # type: str
        # The sorting rule.
        self.sort_order = sort_order  # type: str
        # The start time of the time range for querying slow SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.start_time = start_time  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSlowSQLListShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition_shrink is not None:
            result['FilterCondition'] = self.filter_condition_shrink
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition_shrink = m.get('FilterCondition')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeSlowSQLListResponseBodySlowSQLList(TeaModel):
    def __init__(self, affected_rows=None, app_wait_time=None, block_cache_hit=None, block_index_cache_hit=None,
                 bloom_filter_cache_hit=None, client_ip=None, concurrency_wait_time=None, cpu_time=None, db_name=None, decode_time=None,
                 disk_read=None, elapsed_time=None, event=None, exec_per_second=None, execute_time=None, executions=None,
                 fail_times=None, get_plan_time=None, iowait_time=None, key=None, logical_read=None, max_cpu_time=None,
                 max_elapsed_time=None, memstore_read_row_count=None, miss_plans=None, net_wait_time=None, node_ip=None,
                 queue_time=None, rpccount=None, remote_plans=None, retry_count=None, return_rows=None, row_cache_hit=None,
                 sqlid=None, sqltext=None, sqltype=None, schedule_time=None, ssstore_read_row_count=None,
                 total_wait_time=None, user_name=None):
        # The number of rows affected.
        self.affected_rows = affected_rows  # type: long
        # The wait time of the client.
        self.app_wait_time = app_wait_time  # type: float
        # The number of block cache hits.
        self.block_cache_hit = block_cache_hit  # type: long
        # The number of block index cache hits.
        self.block_index_cache_hit = block_index_cache_hit  # type: long
        # The number of Bloom filter cache hits.
        self.bloom_filter_cache_hit = bloom_filter_cache_hit  # type: long
        # The IP address of the client.
        self.client_ip = client_ip  # type: str
        # The wait time in concurrent execution.
        self.concurrency_wait_time = concurrency_wait_time  # type: float
        # The average CPU time.
        self.cpu_time = cpu_time  # type: float
        # The name of the database.
        self.db_name = db_name  # type: str
        # The time to wait for decoding.
        self.decode_time = decode_time  # type: float
        # The number of physical reads.
        self.disk_read = disk_read  # type: long
        # The average response time.
        self.elapsed_time = elapsed_time  # type: float
        # The wait event.
        self.event = event  # type: str
        # The number of executions per second.
        self.exec_per_second = exec_per_second  # type: float
        # The internal execution time.
        self.execute_time = execute_time  # type: float
        # The number of executions.
        self.executions = executions  # type: long
        # The number of failures.
        self.fail_times = fail_times  # type: long
        # The time spent in hard parsing.
        self.get_plan_time = get_plan_time  # type: float
        # The I/O wait time.
        self.iowait_time = iowait_time  # type: float
        # The sequence number of the returned SQL statement.
        self.key = key  # type: long
        # The number of logical reads.
        self.logical_read = logical_read  # type: long
        # The maximum CPU time.
        self.max_cpu_time = max_cpu_time  # type: float
        # The maximum response time.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # The number of rows read from the memory.
        self.memstore_read_row_count = memstore_read_row_count  # type: long
        # The number of plan misses.
        self.miss_plans = miss_plans  # type: long
        # The network latency.
        self.net_wait_time = net_wait_time  # type: float
        # The IP address of the node.
        self.node_ip = node_ip  # type: str
        # The queuing time.
        self.queue_time = queue_time  # type: float
        # The number of RPCs.
        self.rpccount = rpccount  # type: long
        # The number of remote plans.
        self.remote_plans = remote_plans  # type: long
        # The number of retries.
        self.retry_count = retry_count  # type: long
        # The number of rows returned.
        self.return_rows = return_rows  # type: long
        # The number of row cache hits.
        self.row_cache_hit = row_cache_hit  # type: long
        # SQLID.
        self.sqlid = sqlid  # type: str
        # The SQL text.
        self.sqltext = sqltext  # type: str
        # The SQL type.
        self.sqltype = sqltype  # type: long
        # The scheduling duration.
        self.schedule_time = schedule_time  # type: float
        # The number of rows read from the disk.
        self.ssstore_read_row_count = ssstore_read_row_count  # type: long
        # The internal wait time.
        self.total_wait_time = total_wait_time  # type: float
        # The username.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSlowSQLListResponseBodySlowSQLList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_rows is not None:
            result['AffectedRows'] = self.affected_rows
        if self.app_wait_time is not None:
            result['AppWaitTime'] = self.app_wait_time
        if self.block_cache_hit is not None:
            result['BlockCacheHit'] = self.block_cache_hit
        if self.block_index_cache_hit is not None:
            result['BlockIndexCacheHit'] = self.block_index_cache_hit
        if self.bloom_filter_cache_hit is not None:
            result['BloomFilterCacheHit'] = self.bloom_filter_cache_hit
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.concurrency_wait_time is not None:
            result['ConcurrencyWaitTime'] = self.concurrency_wait_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.decode_time is not None:
            result['DecodeTime'] = self.decode_time
        if self.disk_read is not None:
            result['DiskRead'] = self.disk_read
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.event is not None:
            result['Event'] = self.event
        if self.exec_per_second is not None:
            result['ExecPerSecond'] = self.exec_per_second
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_times is not None:
            result['FailTimes'] = self.fail_times
        if self.get_plan_time is not None:
            result['GetPlanTime'] = self.get_plan_time
        if self.iowait_time is not None:
            result['IOWaitTime'] = self.iowait_time
        if self.key is not None:
            result['Key'] = self.key
        if self.logical_read is not None:
            result['LogicalRead'] = self.logical_read
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.memstore_read_row_count is not None:
            result['MemstoreReadRowCount'] = self.memstore_read_row_count
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.net_wait_time is not None:
            result['NetWaitTime'] = self.net_wait_time
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.rpccount is not None:
            result['RPCCount'] = self.rpccount
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.return_rows is not None:
            result['ReturnRows'] = self.return_rows
        if self.row_cache_hit is not None:
            result['RowCacheHit'] = self.row_cache_hit
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqltext is not None:
            result['SQLText'] = self.sqltext
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.ssstore_read_row_count is not None:
            result['SsstoreReadRowCount'] = self.ssstore_read_row_count
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedRows') is not None:
            self.affected_rows = m.get('AffectedRows')
        if m.get('AppWaitTime') is not None:
            self.app_wait_time = m.get('AppWaitTime')
        if m.get('BlockCacheHit') is not None:
            self.block_cache_hit = m.get('BlockCacheHit')
        if m.get('BlockIndexCacheHit') is not None:
            self.block_index_cache_hit = m.get('BlockIndexCacheHit')
        if m.get('BloomFilterCacheHit') is not None:
            self.bloom_filter_cache_hit = m.get('BloomFilterCacheHit')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ConcurrencyWaitTime') is not None:
            self.concurrency_wait_time = m.get('ConcurrencyWaitTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DecodeTime') is not None:
            self.decode_time = m.get('DecodeTime')
        if m.get('DiskRead') is not None:
            self.disk_read = m.get('DiskRead')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('ExecPerSecond') is not None:
            self.exec_per_second = m.get('ExecPerSecond')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailTimes') is not None:
            self.fail_times = m.get('FailTimes')
        if m.get('GetPlanTime') is not None:
            self.get_plan_time = m.get('GetPlanTime')
        if m.get('IOWaitTime') is not None:
            self.iowait_time = m.get('IOWaitTime')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('LogicalRead') is not None:
            self.logical_read = m.get('LogicalRead')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MemstoreReadRowCount') is not None:
            self.memstore_read_row_count = m.get('MemstoreReadRowCount')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('NetWaitTime') is not None:
            self.net_wait_time = m.get('NetWaitTime')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RPCCount') is not None:
            self.rpccount = m.get('RPCCount')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('ReturnRows') is not None:
            self.return_rows = m.get('ReturnRows')
        if m.get('RowCacheHit') is not None:
            self.row_cache_hit = m.get('RowCacheHit')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLText') is not None:
            self.sqltext = m.get('SQLText')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('SsstoreReadRowCount') is not None:
            self.ssstore_read_row_count = m.get('SsstoreReadRowCount')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeSlowSQLListResponseBody(TeaModel):
    def __init__(self, request_id=None, slow_sqllist=None, total_count=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The list of slow SQL statements.
        self.slow_sqllist = slow_sqllist  # type: list[DescribeSlowSQLListResponseBodySlowSQLList]
        # The total count.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.slow_sqllist:
            for k in self.slow_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSlowSQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SlowSQLList'] = []
        if self.slow_sqllist is not None:
            for k in self.slow_sqllist:
                result['SlowSQLList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.slow_sqllist = []
        if m.get('SlowSQLList') is not None:
            for k in m.get('SlowSQLList'):
                temp_model = DescribeSlowSQLListResponseBodySlowSQLList()
                self.slow_sqllist.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSlowSQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSlowSQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSlowSQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSlowSQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None):
        # The status of the Internet address for accessing the tenant. Valid values:   
        # - CLOSED: The address is disabled.   
        # - ALLOCATING_INTERNET_ADDRESS: An address is being applied for.   
        # - PENDING_OFFLINE_INTERNET_ADDRESS: The address is being disabled.   
        # - ONLINE: The address is in service.
        self.instance_id = instance_id  # type: str
        # Indicates whether to enable transaction splitting.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit(TeaModel):
    def __init__(self, max_capacity_unit=None, min_capacity_unit=None, used_capacit=None):
        self.max_capacity_unit = max_capacity_unit  # type: int
        self.min_capacity_unit = min_capacity_unit  # type: int
        self.used_capacit = used_capacit  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity_unit is not None:
            result['MaxCapacityUnit'] = self.max_capacity_unit
        if self.min_capacity_unit is not None:
            result['MinCapacityUnit'] = self.min_capacity_unit
        if self.used_capacit is not None:
            result['UsedCapacit'] = self.used_capacit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCapacityUnit') is not None:
            self.max_capacity_unit = m.get('MaxCapacityUnit')
        if m.get('MinCapacityUnit') is not None:
            self.min_capacity_unit = m.get('MinCapacityUnit')
        if m.get('UsedCapacit') is not None:
            self.used_capacit = m.get('UsedCapacit')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResourceCpu(TeaModel):
    def __init__(self, total_cpu=None, unit_cpu=None, used_cpu=None):
        self.total_cpu = total_cpu  # type: float
        self.unit_cpu = unit_cpu  # type: float
        self.used_cpu = used_cpu  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize(TeaModel):
    def __init__(self, used_disk_size=None):
        self.used_disk_size = used_disk_size  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize(TeaModel):
    def __init__(self, total_log_disk=None, unit_log_disk=None):
        self.total_log_disk = total_log_disk  # type: int
        self.unit_log_disk = unit_log_disk  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_log_disk is not None:
            result['TotalLogDisk'] = self.total_log_disk
        if self.unit_log_disk is not None:
            result['UnitLogDisk'] = self.unit_log_disk
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalLogDisk') is not None:
            self.total_log_disk = m.get('TotalLogDisk')
        if m.get('UnitLogDisk') is not None:
            self.unit_log_disk = m.get('UnitLogDisk')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResourceMemory(TeaModel):
    def __init__(self, total_memory=None, unit_memory=None, used_memory=None):
        self.total_memory = total_memory  # type: float
        self.unit_memory = unit_memory  # type: float
        self.used_memory = used_memory  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeTenantResponseBodyTenantReadOnlyResource(TeaModel):
    def __init__(self, capacity_unit=None, cpu=None, disk_size=None, log_disk_size=None, memory=None, unit_num=None):
        self.capacity_unit = capacity_unit  # type: DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit
        self.cpu = cpu  # type: DescribeTenantResponseBodyTenantReadOnlyResourceCpu
        self.disk_size = disk_size  # type: DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize
        self.log_disk_size = log_disk_size  # type: DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize
        self.memory = memory  # type: DescribeTenantResponseBodyTenantReadOnlyResourceMemory
        self.unit_num = unit_num  # type: int

    def validate(self):
        if self.capacity_unit:
            self.capacity_unit.validate()
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.log_disk_size:
            self.log_disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantReadOnlyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_unit is not None:
            result['CapacityUnit'] = self.capacity_unit.to_map()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.log_disk_size is not None:
            result['LogDiskSize'] = self.log_disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityUnit') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit()
            self.capacity_unit = temp_model.from_map(m['CapacityUnit'])
        if m.get('Cpu') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('LogDiskSize') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize()
            self.log_disk_size = temp_model.from_map(m['LogDiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        return self


class DescribeTenantResponseBodyTenantTenantConnections(TeaModel):
    def __init__(self, address_type=None, connection_replica_type=None, connection_zones=None,
                 enable_transaction_split=None, internet_address=None, internet_address_status=None, internet_port=None,
                 intranet_address=None, intranet_address_master_zone_id=None, intranet_address_slave_zone_id=None,
                 intranet_address_status=None, intranet_port=None, max_connection_num=None, parallel_query_degree=None,
                 tenant_endpoint_id=None, transaction_split=None, v_switch_id=None, vpc_id=None):
        # The primary zone of the tenant.
        self.address_type = address_type  # type: str
        self.connection_replica_type = connection_replica_type  # type: str
        # The Internet address for accessing the tenant.
        self.connection_zones = connection_zones  # type: list[str]
        self.enable_transaction_split = enable_transaction_split  # type: bool
        # The ID of the VPC.
        self.internet_address = internet_address  # type: str
        # 实例系列
        self.internet_address_status = internet_address_status  # type: str
        # 实例类型
        self.internet_port = internet_port  # type: int
        # The deployment type of the cluster. Valid values:  
        # - multiple: multi-IDC deployment   
        # - single: single-IDC deployment   
        # - dual: dual-IDC deployment
        self.intranet_address = intranet_address  # type: str
        # PayCore business database
        self.intranet_address_master_zone_id = intranet_address_master_zone_id  # type: str
        # The total number of CPU cores of the tenant.
        self.intranet_address_slave_zone_id = intranet_address_slave_zone_id  # type: str
        # 付费类型
        self.intranet_address_status = intranet_address_status  # type: str
        # The ID of the tenant.
        self.intranet_port = intranet_port  # type: int
        self.max_connection_num = max_connection_num  # type: long
        self.parallel_query_degree = parallel_query_degree  # type: long
        self.tenant_endpoint_id = tenant_endpoint_id  # type: str
        # The primary zone corresponding to the address for accessing the tenant.
        self.transaction_split = transaction_split  # type: bool
        # The connection access information of the tenant.
        self.v_switch_id = v_switch_id  # type: str
        # The service mode of the connection address. Valid values:  
        # ReadWrite: provides strong-consistency read and write services.   
        # ReadOnly: provides the read-only service to ensure ultimate consistency of data.   
        # Clog: provides transaction log services.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantConnections, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.connection_replica_type is not None:
            result['ConnectionReplicaType'] = self.connection_replica_type
        if self.connection_zones is not None:
            result['ConnectionZones'] = self.connection_zones
        if self.enable_transaction_split is not None:
            result['EnableTransactionSplit'] = self.enable_transaction_split
        if self.internet_address is not None:
            result['InternetAddress'] = self.internet_address
        if self.internet_address_status is not None:
            result['InternetAddressStatus'] = self.internet_address_status
        if self.internet_port is not None:
            result['InternetPort'] = self.internet_port
        if self.intranet_address is not None:
            result['IntranetAddress'] = self.intranet_address
        if self.intranet_address_master_zone_id is not None:
            result['IntranetAddressMasterZoneId'] = self.intranet_address_master_zone_id
        if self.intranet_address_slave_zone_id is not None:
            result['IntranetAddressSlaveZoneId'] = self.intranet_address_slave_zone_id
        if self.intranet_address_status is not None:
            result['IntranetAddressStatus'] = self.intranet_address_status
        if self.intranet_port is not None:
            result['IntranetPort'] = self.intranet_port
        if self.max_connection_num is not None:
            result['MaxConnectionNum'] = self.max_connection_num
        if self.parallel_query_degree is not None:
            result['ParallelQueryDegree'] = self.parallel_query_degree
        if self.tenant_endpoint_id is not None:
            result['TenantEndpointId'] = self.tenant_endpoint_id
        if self.transaction_split is not None:
            result['TransactionSplit'] = self.transaction_split
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('ConnectionReplicaType') is not None:
            self.connection_replica_type = m.get('ConnectionReplicaType')
        if m.get('ConnectionZones') is not None:
            self.connection_zones = m.get('ConnectionZones')
        if m.get('EnableTransactionSplit') is not None:
            self.enable_transaction_split = m.get('EnableTransactionSplit')
        if m.get('InternetAddress') is not None:
            self.internet_address = m.get('InternetAddress')
        if m.get('InternetAddressStatus') is not None:
            self.internet_address_status = m.get('InternetAddressStatus')
        if m.get('InternetPort') is not None:
            self.internet_port = m.get('InternetPort')
        if m.get('IntranetAddress') is not None:
            self.intranet_address = m.get('IntranetAddress')
        if m.get('IntranetAddressMasterZoneId') is not None:
            self.intranet_address_master_zone_id = m.get('IntranetAddressMasterZoneId')
        if m.get('IntranetAddressSlaveZoneId') is not None:
            self.intranet_address_slave_zone_id = m.get('IntranetAddressSlaveZoneId')
        if m.get('IntranetAddressStatus') is not None:
            self.intranet_address_status = m.get('IntranetAddressStatus')
        if m.get('IntranetPort') is not None:
            self.intranet_port = m.get('IntranetPort')
        if m.get('MaxConnectionNum') is not None:
            self.max_connection_num = m.get('MaxConnectionNum')
        if m.get('ParallelQueryDegree') is not None:
            self.parallel_query_degree = m.get('ParallelQueryDegree')
        if m.get('TenantEndpointId') is not None:
            self.tenant_endpoint_id = m.get('TenantEndpointId')
        if m.get('TransactionSplit') is not None:
            self.transaction_split = m.get('TransactionSplit')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeTenantResponseBodyTenantTenantResourceCapacityUnit(TeaModel):
    def __init__(self, max_capacity_unit=None, min_capacity_unit=None, used_capacit=None):
        self.max_capacity_unit = max_capacity_unit  # type: int
        self.min_capacity_unit = min_capacity_unit  # type: int
        self.used_capacit = used_capacit  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResourceCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity_unit is not None:
            result['MaxCapacityUnit'] = self.max_capacity_unit
        if self.min_capacity_unit is not None:
            result['MinCapacityUnit'] = self.min_capacity_unit
        if self.used_capacit is not None:
            result['UsedCapacit'] = self.used_capacit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxCapacityUnit') is not None:
            self.max_capacity_unit = m.get('MaxCapacityUnit')
        if m.get('MinCapacityUnit') is not None:
            self.min_capacity_unit = m.get('MinCapacityUnit')
        if m.get('UsedCapacit') is not None:
            self.used_capacit = m.get('UsedCapacit')
        return self


class DescribeTenantResponseBodyTenantTenantResourceCpu(TeaModel):
    def __init__(self, total_cpu=None, unit_cpu=None, used_cpu=None):
        # The data replica distribution mode of the tenant.    
        # 
        # - For the high availability version, N-N-N indicates the three-zone mode, and N-N indicates the dual-zone or single-zone mode.
        # - For the basic version, N indicates the single-zone mode. 
        # 
        # > <br>N represents the number of nodes in a single zone.
        self.total_cpu = total_cpu  # type: float
        # The zone corresponding to the tenant connection.
        self.unit_cpu = unit_cpu  # type: float
        # The tenant mode.   
        # Valid values: 
        # Oracle   
        # MySQL
        self.used_cpu = used_cpu  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResourceCpu, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_cpu is not None:
            result['TotalCpu'] = self.total_cpu
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.used_cpu is not None:
            result['UsedCpu'] = self.used_cpu
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalCpu') is not None:
            self.total_cpu = m.get('TotalCpu')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UsedCpu') is not None:
            self.used_cpu = m.get('UsedCpu')
        return self


class DescribeTenantResponseBodyTenantTenantResourceDiskSize(TeaModel):
    def __init__(self, used_disk_size=None):
        # The total memory size of the tenant, in GB.
        self.used_disk_size = used_disk_size  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResourceDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        return self


class DescribeTenantResponseBodyTenantTenantResourceLogDiskSize(TeaModel):
    def __init__(self, total_log_disk=None, unit_log_disk=None):
        self.total_log_disk = total_log_disk  # type: int
        self.unit_log_disk = unit_log_disk  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResourceLogDiskSize, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_log_disk is not None:
            result['TotalLogDisk'] = self.total_log_disk
        if self.unit_log_disk is not None:
            result['UnitLogDisk'] = self.unit_log_disk
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalLogDisk') is not None:
            self.total_log_disk = m.get('TotalLogDisk')
        if m.get('UnitLogDisk') is not None:
            self.unit_log_disk = m.get('UnitLogDisk')
        return self


class DescribeTenantResponseBodyTenantTenantResourceMemory(TeaModel):
    def __init__(self, total_memory=None, unit_memory=None, used_memory=None):
        # The information about the memory resources of the tenant.
        self.total_memory = total_memory  # type: float
        # The time when the tenant was created.
        self.unit_memory = unit_memory  # type: float
        # The status of the Internet address for accessing the tenant. Valid values:   
        # Closed: The address is disabled.   
        # - ALLOCATING_INTERNET_ADDRESS: An address is being applied for.   
        # - PENDING_OFFLINE_INTERNET_ADDRESS: The address is being disabled.   
        # - ONLINE: The address is in service.
        self.used_memory = used_memory  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResourceMemory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.unit_memory is not None:
            result['UnitMemory'] = self.unit_memory
        if self.used_memory is not None:
            result['UsedMemory'] = self.used_memory
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('UnitMemory') is not None:
            self.unit_memory = m.get('UnitMemory')
        if m.get('UsedMemory') is not None:
            self.used_memory = m.get('UsedMemory')
        return self


class DescribeTenantResponseBodyTenantTenantResource(TeaModel):
    def __init__(self, capacity_unit=None, cpu=None, disk_size=None, log_disk_size=None, memory=None, unit_num=None):
        self.capacity_unit = capacity_unit  # type: DescribeTenantResponseBodyTenantTenantResourceCapacityUnit
        # The enabling status of the Clog service.  
        # CLOSED: The Clog service is disabled.  
        # - ONLINE: The Clog service is running.
        self.cpu = cpu  # type: DescribeTenantResponseBodyTenantTenantResourceCpu
        # The status of the intranet address for accessing the tenant.  
        # The value ONLINE indicates that the address is in service.
        self.disk_size = disk_size  # type: DescribeTenantResponseBodyTenantTenantResourceDiskSize
        self.log_disk_size = log_disk_size  # type: DescribeTenantResponseBodyTenantTenantResourceLogDiskSize
        # The description of the tenant.
        self.memory = memory  # type: DescribeTenantResponseBodyTenantTenantResourceMemory
        # Alibaba Cloud CLI
        self.unit_num = unit_num  # type: int

    def validate(self):
        if self.capacity_unit:
            self.capacity_unit.validate()
        if self.cpu:
            self.cpu.validate()
        if self.disk_size:
            self.disk_size.validate()
        if self.log_disk_size:
            self.log_disk_size.validate()
        if self.memory:
            self.memory.validate()

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_unit is not None:
            result['CapacityUnit'] = self.capacity_unit.to_map()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size.to_map()
        if self.log_disk_size is not None:
            result['LogDiskSize'] = self.log_disk_size.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityUnit') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResourceCapacityUnit()
            self.capacity_unit = temp_model.from_map(m['CapacityUnit'])
        if m.get('Cpu') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResourceCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('DiskSize') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResourceDiskSize()
            self.disk_size = temp_model.from_map(m['DiskSize'])
        if m.get('LogDiskSize') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResourceLogDiskSize()
            self.log_disk_size = temp_model.from_map(m['LogDiskSize'])
        if m.get('Memory') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResourceMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        return self


class DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas(TeaModel):
    def __init__(self, full_copy_id=None, logic_zone_name=None, read_only_copy_id=None, zone_copy_id=None,
                 zone_nodes=None, zone_replica_type=None):
        self.full_copy_id = full_copy_id  # type: int
        self.logic_zone_name = logic_zone_name  # type: str
        self.read_only_copy_id = read_only_copy_id  # type: str
        self.zone_copy_id = zone_copy_id  # type: int
        self.zone_nodes = zone_nodes  # type: str
        self.zone_replica_type = zone_replica_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_copy_id is not None:
            result['FullCopyId'] = self.full_copy_id
        if self.logic_zone_name is not None:
            result['LogicZoneName'] = self.logic_zone_name
        if self.read_only_copy_id is not None:
            result['ReadOnlyCopyId'] = self.read_only_copy_id
        if self.zone_copy_id is not None:
            result['ZoneCopyId'] = self.zone_copy_id
        if self.zone_nodes is not None:
            result['ZoneNodes'] = self.zone_nodes
        if self.zone_replica_type is not None:
            result['ZoneReplicaType'] = self.zone_replica_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FullCopyId') is not None:
            self.full_copy_id = m.get('FullCopyId')
        if m.get('LogicZoneName') is not None:
            self.logic_zone_name = m.get('LogicZoneName')
        if m.get('ReadOnlyCopyId') is not None:
            self.read_only_copy_id = m.get('ReadOnlyCopyId')
        if m.get('ZoneCopyId') is not None:
            self.zone_copy_id = m.get('ZoneCopyId')
        if m.get('ZoneNodes') is not None:
            self.zone_nodes = m.get('ZoneNodes')
        if m.get('ZoneReplicaType') is not None:
            self.zone_replica_type = m.get('ZoneReplicaType')
        return self


class DescribeTenantResponseBodyTenantTenantZones(TeaModel):
    def __init__(self, region=None, tenant_zone_id=None, tenant_zone_replicas=None, tenant_zone_role=None):
        # 是否允许开启读写分离地址
        self.region = region  # type: str
        # The intranet port for accessing the tenant.
        self.tenant_zone_id = tenant_zone_id  # type: str
        self.tenant_zone_replicas = tenant_zone_replicas  # type: list[DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas]
        # The character set.
        self.tenant_zone_role = tenant_zone_role  # type: str

    def validate(self):
        if self.tenant_zone_replicas:
            for k in self.tenant_zone_replicas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenantTenantZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region is not None:
            result['Region'] = self.region
        if self.tenant_zone_id is not None:
            result['TenantZoneId'] = self.tenant_zone_id
        result['TenantZoneReplicas'] = []
        if self.tenant_zone_replicas is not None:
            for k in self.tenant_zone_replicas:
                result['TenantZoneReplicas'].append(k.to_map() if k else None)
        if self.tenant_zone_role is not None:
            result['TenantZoneRole'] = self.tenant_zone_role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('TenantZoneId') is not None:
            self.tenant_zone_id = m.get('TenantZoneId')
        self.tenant_zone_replicas = []
        if m.get('TenantZoneReplicas') is not None:
            for k in m.get('TenantZoneReplicas'):
                temp_model = DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas()
                self.tenant_zone_replicas.append(temp_model.from_map(k))
        if m.get('TenantZoneRole') is not None:
            self.tenant_zone_role = m.get('TenantZoneRole')
        return self


class DescribeTenantResponseBodyTenant(TeaModel):
    def __init__(self, available_zones=None, charset=None, clog_service_status=None, collation=None,
                 create_time=None, data_merge_time=None, deploy_mode=None, deploy_type=None, description=None, disk_type=None,
                 enable_binlog_service=None, enable_clog_service=None, enable_internet_address_service=None, enable_parallel_query=None,
                 enable_read_write_split=None, instance_type=None, master_intranet_address_zone=None, max_parallel_query_degree=None,
                 pay_type=None, primary_zone=None, primary_zone_deploy_type=None, read_only_resource=None, series=None,
                 status=None, tenant_connections=None, tenant_id=None, tenant_mode=None, tenant_name=None,
                 tenant_resource=None, tenant_zones=None, time_zone=None, vpc_id=None):
        # DescribeTenant
        self.available_zones = available_zones  # type: list[str]
        # The number of CPU cores in each resource unit of the tenant.
        self.charset = charset  # type: str
        # 地址类型
        self.clog_service_status = clog_service_status  # type: str
        # The request ID.
        self.collation = collation  # type: str
        # You can call this operation to create a single tenant in a specific cluster.
        self.create_time = create_time  # type: str
        self.data_merge_time = data_merge_time  # type: str
        # The list of zones.
        self.deploy_mode = deploy_mode  # type: str
        # The series of the instance.
        self.deploy_type = deploy_type  # type: str
        # Indicates whether to enable read/write splitting endpoint.
        self.description = description  # type: str
        # You can call this operation to query the information of a specific tenant in a specific cluster.
        self.disk_type = disk_type  # type: str
        # 是否可以申请Binlog服务
        self.enable_binlog_service = enable_binlog_service  # type: bool
        # The intranet address for accessing the tenant.
        self.enable_clog_service = enable_clog_service  # type: bool
        # The deployment type of the primary zone.
        self.enable_internet_address_service = enable_internet_address_service  # type: bool
        self.enable_parallel_query = enable_parallel_query  # type: bool
        self.enable_read_write_split = enable_read_write_split  # type: bool
        # {
        #     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
        #     "Tenant": {
        #         "TenantId": "t33h8y08k****",
        #         "TenantName": "pay_online",
        #         "TenantMode": "Oracle",
        #         "VpcId": "vpc-bp1d2q3mhg9i23ofi****",
        #         "Status": "ONLINE",
        #         "PrimaryZone": "cn-hangzhou-i",
        #         "DeployType": "multiple",
        #         "DeployMode": "1-1-1",
        #         "Description": "PayCore business database",
        #         "CreateTime": "2021-09-17 15:52:17",
        #         "TenantResource": {
        #             "UnitNum": 1,
        #             "Cpu": {
        #                 "UsedCpu": 8,
        #                 "TotalCpu": 10,
        #                 "UnitCpu": 8
        #             },
        #             "Memory": {
        #                 "UsedMemory": 30,
        #                 "TotalMemory": 64,
        #                 "UnitMemory": 32
        #             },
        #             "DiskSize": {
        #                 "UsedDiskSize": 86
        #             }
        #         },
        #         "TenantConnections": [
        #             {
        #                 "ConnectionRole": "ReadWrite",
        #                 "IntranetAddress": "t32a7ru5u****.oceanbase.aliyuncs.com",
        #                 "IntranetPort": 3306,
        #                 "InternetAddress": "t32a7ru5u****mo.oceanbase.aliyuncs.com",
        #                 "InternetPort": 3306,
        #                 "VpcId": "vpc-bp1qiail1asmfe23t****",
        #                 "VSwitchId": "vsw-bp11k1aypnzu1l3whi****",
        #                 "IntranetAddressMasterZoneId": "cn-hangzhou-i",
        #                 "IntranetAddressSlaveZoneId": "cn-hangzhou-j",
        #                 "IntranetAddressStatus": "ONLINE",
        #                 "ConnectionZones": [
        #                     "cn-hangzhou-i"
        #                 ],
        #                 "InternetAddressStatus": "CLOSED"
        #             }
        #         ],
        #         "TenantZones": [
        #             {
        #                 "TenantZoneId": "cn-hangzhou-i",
        #                 "Region": "cn-hangzhou",
        #                 "TenantZoneRole": "ReadOnly"
        #             }
        #         ],
        #         "ClogServiceStatus": "CLOSED"
        #     }
        # }
        self.instance_type = instance_type  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=DescribeTenant
        # &InstanceId=ob317v4uif****\
        # &TenantId=ob2mr3oae0****\
        # &Common request parameters
        # ```
        self.master_intranet_address_zone = master_intranet_address_zone  # type: str
        self.max_parallel_query_degree = max_parallel_query_degree  # type: long
        self.pay_type = pay_type  # type: str
        # The type of the payment.
        self.primary_zone = primary_zone  # type: str
        # Example 1
        self.primary_zone_deploy_type = primary_zone_deploy_type  # type: str
        self.read_only_resource = read_only_resource  # type: DescribeTenantResponseBodyTenantReadOnlyResource
        # <DescribeTenantResponse>
        #     <RequestId>EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C</RequestId>
        #     <Tenant>
        #         <TenantId>t33h8y08k****</TenantId>
        #         <TenantName>pay_online</TenantName>
        #         <TenantMode>Oracle</TenantMode>
        #         <VpcId>vpc-bp1d2q3mhg9i23ofi****</VpcId>
        #         <Status>ONLINE</Status>
        #         <PrimaryZone>cn-hangzhou-i</PrimaryZone>
        #         <DeployType>multiple</DeployType>
        #         <DeployMode>1-1-1</DeployMode>
        #         <Description>PayCore business database</Description>
        #         <CreateTime>2021-09-17 15:52:17</CreateTime>
        #         <TenantResource>
        #             <UnitNum>1</UnitNum>
        #             <Cpu>
        #                 <UsedCpu>8</UsedCpu>
        #                 <TotalCpu>10</TotalCpu>
        #                 <UnitCpu>8</UnitCpu>
        #             </Cpu>
        #             <Memory>
        #                 <UsedMemory>30</UsedMemory>
        #                 <TotalMemory>64</TotalMemory>
        #                 <UnitMemory>32</UnitMemory>
        #             </Memory>
        #             <DiskSize>
        #                 <UsedDiskSize>86</UsedDiskSize>
        #             </DiskSize>
        #         </TenantResource>
        #         <TenantConnections>
        #             <ConnectionRole>ReadWrite</ConnectionRole>
        #             <IntranetAddress>t32a7ru5u****.oceanbase.aliyuncs.com</IntranetAddress>
        #             <IntranetPort>3306</IntranetPort>
        #             <InternetAddress>t32a7ru5u****mo.oceanbase.aliyuncs.com</InternetAddress>
        #             <InternetPort>3306</InternetPort>
        #             <VpcId>vpc-bp1qiail1asmfe23t****</VpcId>
        #             <VSwitchId>vsw-bp11k1aypnzu1l3whi****</VSwitchId>
        #             <IntranetAddressMasterZoneId>cn-hangzhou-i</IntranetAddressMasterZoneId>
        #             <IntranetAddressSlaveZoneId>cn-hangzhou-j</IntranetAddressSlaveZoneId>
        #             <IntranetAddressStatus>ONLINE</IntranetAddressStatus>
        #             <ConnectionZones>cn-hangzhou-i</ConnectionZones>
        #             <InternetAddressStatus>CLOSED</InternetAddressStatus>
        #         </TenantConnections>
        #         <TenantZones>
        #             <TenantZoneId>cn-hangzhou-i</TenantZoneId>
        #             <Region>cn-hangzhou</Region>
        #             <TenantZoneRole>ReadOnly</TenantZoneRole>
        #         </TenantZones>
        #         <ClogServiceStatus>CLOSED</ClogServiceStatus>
        #     </Tenant>
        # </DescribeTenantResponse>
        self.series = series  # type: str
        # The character set.
        self.status = status  # type: str
        # The status of the tenant.   
        # - PENDING_CREATE: The tenant is being created.   
        # - RESTORE: The tenant is being recovered.   
        # - ONLINE: The tenant is running.   
        # - SPEC_MODIFYING: The specification of the tenant is being modified.   
        # - ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.  
        # - PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.  
        # - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.  
        # - PARAMETER_MODIFYING: Parameters are being modified.   
        # - WHITE_LIST_MODIFYING: The whitelist is being modified.
        self.tenant_connections = tenant_connections  # type: list[DescribeTenantResponseBodyTenantTenantConnections]
        # The region where the zone of the tenant resides.
        self.tenant_id = tenant_id  # type: str
        # The enabling status of the clog service.  
        # - CLOSED: The clog service is disabled.  
        # - ONLINE: The clog service is running.
        self.tenant_mode = tenant_mode  # type: str
        # The request type of the zone of the tenant.  ReadWrite: The zone supports data reads and writes. ReadOnly: The zone supports only data reads. For a high availability cluster with multiple IDCs, the primary zone provides ReadWrite services, and the standby zone provides ReadOnly services. For a high availability cluster with a single IDC, all zones provide ReadWrite services.
        self.tenant_name = tenant_name  # type: str
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.tenant_resource = tenant_resource  # type: DescribeTenantResponseBodyTenantTenantResource
        # The standby zone corresponding to the address for accessing the tenant.
        self.tenant_zones = tenant_zones  # type: list[DescribeTenantResponseBodyTenantTenantZones]
        self.time_zone = time_zone  # type: str
        # Indicates whether the clog service is available. To enable the clog service, submit a ticket.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.read_only_resource:
            self.read_only_resource.validate()
        if self.tenant_connections:
            for k in self.tenant_connections:
                if k:
                    k.validate()
        if self.tenant_resource:
            self.tenant_resource.validate()
        if self.tenant_zones:
            for k in self.tenant_zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantResponseBodyTenant, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_zones is not None:
            result['AvailableZones'] = self.available_zones
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.clog_service_status is not None:
            result['ClogServiceStatus'] = self.clog_service_status
        if self.collation is not None:
            result['Collation'] = self.collation
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_merge_time is not None:
            result['DataMergeTime'] = self.data_merge_time
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.enable_binlog_service is not None:
            result['EnableBinlogService'] = self.enable_binlog_service
        if self.enable_clog_service is not None:
            result['EnableClogService'] = self.enable_clog_service
        if self.enable_internet_address_service is not None:
            result['EnableInternetAddressService'] = self.enable_internet_address_service
        if self.enable_parallel_query is not None:
            result['EnableParallelQuery'] = self.enable_parallel_query
        if self.enable_read_write_split is not None:
            result['EnableReadWriteSplit'] = self.enable_read_write_split
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.master_intranet_address_zone is not None:
            result['MasterIntranetAddressZone'] = self.master_intranet_address_zone
        if self.max_parallel_query_degree is not None:
            result['MaxParallelQueryDegree'] = self.max_parallel_query_degree
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.primary_zone is not None:
            result['PrimaryZone'] = self.primary_zone
        if self.primary_zone_deploy_type is not None:
            result['PrimaryZoneDeployType'] = self.primary_zone_deploy_type
        if self.read_only_resource is not None:
            result['ReadOnlyResource'] = self.read_only_resource.to_map()
        if self.series is not None:
            result['Series'] = self.series
        if self.status is not None:
            result['Status'] = self.status
        result['TenantConnections'] = []
        if self.tenant_connections is not None:
            for k in self.tenant_connections:
                result['TenantConnections'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tenant_resource is not None:
            result['TenantResource'] = self.tenant_resource.to_map()
        result['TenantZones'] = []
        if self.tenant_zones is not None:
            for k in self.tenant_zones:
                result['TenantZones'].append(k.to_map() if k else None)
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableZones') is not None:
            self.available_zones = m.get('AvailableZones')
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ClogServiceStatus') is not None:
            self.clog_service_status = m.get('ClogServiceStatus')
        if m.get('Collation') is not None:
            self.collation = m.get('Collation')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataMergeTime') is not None:
            self.data_merge_time = m.get('DataMergeTime')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EnableBinlogService') is not None:
            self.enable_binlog_service = m.get('EnableBinlogService')
        if m.get('EnableClogService') is not None:
            self.enable_clog_service = m.get('EnableClogService')
        if m.get('EnableInternetAddressService') is not None:
            self.enable_internet_address_service = m.get('EnableInternetAddressService')
        if m.get('EnableParallelQuery') is not None:
            self.enable_parallel_query = m.get('EnableParallelQuery')
        if m.get('EnableReadWriteSplit') is not None:
            self.enable_read_write_split = m.get('EnableReadWriteSplit')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MasterIntranetAddressZone') is not None:
            self.master_intranet_address_zone = m.get('MasterIntranetAddressZone')
        if m.get('MaxParallelQueryDegree') is not None:
            self.max_parallel_query_degree = m.get('MaxParallelQueryDegree')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('PrimaryZone') is not None:
            self.primary_zone = m.get('PrimaryZone')
        if m.get('PrimaryZoneDeployType') is not None:
            self.primary_zone_deploy_type = m.get('PrimaryZoneDeployType')
        if m.get('ReadOnlyResource') is not None:
            temp_model = DescribeTenantResponseBodyTenantReadOnlyResource()
            self.read_only_resource = temp_model.from_map(m['ReadOnlyResource'])
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tenant_connections = []
        if m.get('TenantConnections') is not None:
            for k in m.get('TenantConnections'):
                temp_model = DescribeTenantResponseBodyTenantTenantConnections()
                self.tenant_connections.append(temp_model.from_map(k))
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('TenantResource') is not None:
            temp_model = DescribeTenantResponseBodyTenantTenantResource()
            self.tenant_resource = temp_model.from_map(m['TenantResource'])
        self.tenant_zones = []
        if m.get('TenantZones') is not None:
            for k in m.get('TenantZones'):
                temp_model = DescribeTenantResponseBodyTenantTenantZones()
                self.tenant_zones.append(temp_model.from_map(k))
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeTenantResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant=None):
        # The zone information of the tenant.
        self.request_id = request_id  # type: str
        # The ID of the zone.
        self.tenant = tenant  # type: DescribeTenantResponseBodyTenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        _map = super(DescribeTenantResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant is not None:
            result['Tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tenant') is not None:
            temp_model = DescribeTenantResponseBodyTenant()
            self.tenant = temp_model.from_map(m['Tenant'])
        return self


class DescribeTenantResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantEncryptionRequest(TeaModel):
    def __init__(self, instance_id=None, page_number=None, page_size=None, tenant_id=None, tenant_name=None):
        self.instance_id = instance_id  # type: str
        self.page_number = page_number  # type: long
        self.page_size = page_size  # type: long
        self.tenant_id = tenant_id  # type: str
        self.tenant_name = tenant_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantEncryptionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        return self


class DescribeTenantEncryptionResponseBodyTenantEncryptions(TeaModel):
    def __init__(self, enable_encryption=None, encryption_key_id=None, encryption_type=None, status=None,
                 tenant_id=None, tenant_mode=None, tenant_name=None, tenant_status=None):
        self.enable_encryption = enable_encryption  # type: bool
        self.encryption_key_id = encryption_key_id  # type: str
        self.encryption_type = encryption_type  # type: str
        self.status = status  # type: str
        self.tenant_id = tenant_id  # type: str
        self.tenant_mode = tenant_mode  # type: str
        self.tenant_name = tenant_name  # type: str
        self.tenant_status = tenant_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantEncryptionResponseBodyTenantEncryptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_encryption is not None:
            result['EnableEncryption'] = self.enable_encryption
        if self.encryption_key_id is not None:
            result['EncryptionKeyId'] = self.encryption_key_id
        if self.encryption_type is not None:
            result['EncryptionType'] = self.encryption_type
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tenant_status is not None:
            result['TenantStatus'] = self.tenant_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableEncryption') is not None:
            self.enable_encryption = m.get('EnableEncryption')
        if m.get('EncryptionKeyId') is not None:
            self.encryption_key_id = m.get('EncryptionKeyId')
        if m.get('EncryptionType') is not None:
            self.encryption_type = m.get('EncryptionType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('TenantStatus') is not None:
            self.tenant_status = m.get('TenantStatus')
        return self


class DescribeTenantEncryptionResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_encryptions=None, total_count=None):
        self.request_id = request_id  # type: str
        self.tenant_encryptions = tenant_encryptions  # type: list[DescribeTenantEncryptionResponseBodyTenantEncryptions]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.tenant_encryptions:
            for k in self.tenant_encryptions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantEncryptionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TenantEncryptions'] = []
        if self.tenant_encryptions is not None:
            for k in self.tenant_encryptions:
                result['TenantEncryptions'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tenant_encryptions = []
        if m.get('TenantEncryptions') is not None:
            for k in m.get('TenantEncryptions'):
                temp_model = DescribeTenantEncryptionResponseBodyTenantEncryptions()
                self.tenant_encryptions.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTenantEncryptionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantEncryptionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantEncryptionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantEncryptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantMetricsRequest(TeaModel):
    def __init__(self, end_time=None, instance_id=None, metrics=None, page_number=None, page_size=None,
                 start_time=None, tenant_id=None, tenant_id_list=None, tenant_name=None):
        self.end_time = end_time  # type: str
        # 2021-06-13T15:40:43Z
        self.instance_id = instance_id  # type: str
        # {"name":"DescribeTenantMetrics","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\"name\":\"Action\",\"position\":\"Query\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"description\":\"\",\"example\":\"DescribeTenantMetrics\"},{\"name\":\"InstanceId\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"ob317v4uif****\"},{\"name\":\"PageSize\",\"position\":\"Body\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"Integer\",\"title\":\"\",\"description\":\"\",\"example\":\"10\"},{\"name\":\"PageNumber\",\"position\":\"Body\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"Integer\",\"title\":\"\",\"description\":\"\",\"example\":\"1\"},{\"name\":\"TenantName\",\"position\":\"Body\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":true,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"pay_online\"},{\"name\":\"StartTime\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"2021-06-13T15:40:43Z\"},{\"name\":\"EndTime\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"2021-06-13T15:45:43Z\"},{\"name\":\"Metrics\",\"position\":\"Body\",\"required\":true,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"tps\"},{\"name\":\"TenantId\",\"position\":\"Body\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":true,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"tfafd34fs****\"},{\"name\":\"TenantIdList\",\"position\":\"Body\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"[tdak3nac****,tdakc42df****]\"}]","response_headers":"[]","response":"{\"type\":\"Object\",\"children\":[{\"name\":\"TotalCount\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"Integer\",\"title\":\"\",\"description\":\"\",\"example\":\"9\"},{\"name\":\"RequestId\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C\"},{\"name\":\"TenantMetrics\",\"required\":false,\"checkBlank\":false,\"visibility\":\"Public\",\"deprecated\":false,\"type\":\"String\",\"title\":\"\",\"description\":\"\",\"example\":\"\\\"Metrics\\\":[ {\\\"request_queue_rt\\\":0.0,\\\"TimeStamp\\\":\\\"2022-02-23T01:58:00Z\\\"}]\"}],\"title\":\"\",\"description\":\"\"}","errors":"{}"}
        self.metrics = metrics  # type: str
        # The ID of the OceanBase cluster.
        self.page_number = page_number  # type: int
        # tfafd34fs****\
        self.page_size = page_size  # type: int
        # Example 1
        self.start_time = start_time  # type: str
        self.tenant_id = tenant_id  # type: str
        self.tenant_id_list = tenant_id_list  # type: str
        # 2021-06-13T15:45:43Z
        self.tenant_name = tenant_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantMetricsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.metrics is not None:
            result['Metrics'] = self.metrics
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_id_list is not None:
            result['TenantIdList'] = self.tenant_id_list
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Metrics') is not None:
            self.metrics = m.get('Metrics')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantIdList') is not None:
            self.tenant_id_list = m.get('TenantIdList')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        return self


class DescribeTenantMetricsResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_metrics=None, total_count=None):
        self.request_id = request_id  # type: str
        self.tenant_metrics = tenant_metrics  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantMetricsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_metrics is not None:
            result['TenantMetrics'] = self.tenant_metrics
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantMetrics') is not None:
            self.tenant_metrics = m.get('TenantMetrics')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTenantMetricsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantMetricsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantMetricsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantSecurityConfigsRequest(TeaModel):
    def __init__(self, check_id=None, instance_id=None, tenant_id=None):
        self.check_id = check_id  # type: str
        self.instance_id = instance_id  # type: str
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs(TeaModel):
    def __init__(self, config_description=None, config_group=None, config_name=None, risk=None,
                 risk_description=None):
        self.config_description = config_description  # type: str
        self.config_group = config_group  # type: str
        self.config_name = config_name  # type: str
        self.risk = risk  # type: bool
        self.risk_description = risk_description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_description is not None:
            result['ConfigDescription'] = self.config_description
        if self.config_group is not None:
            result['ConfigGroup'] = self.config_group
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        if self.risk is not None:
            result['Risk'] = self.risk
        if self.risk_description is not None:
            result['RiskDescription'] = self.risk_description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigDescription') is not None:
            self.config_description = m.get('ConfigDescription')
        if m.get('ConfigGroup') is not None:
            self.config_group = m.get('ConfigGroup')
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        if m.get('Risk') is not None:
            self.risk = m.get('Risk')
        if m.get('RiskDescription') is not None:
            self.risk_description = m.get('RiskDescription')
        return self


class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs(TeaModel):
    def __init__(self, risk_count=None, security_configs=None, tenant_id=None, tenant_name=None):
        self.risk_count = risk_count  # type: int
        self.security_configs = security_configs  # type: list[DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs]
        self.tenant_id = tenant_id  # type: str
        self.tenant_name = tenant_name  # type: str

    def validate(self):
        if self.security_configs:
            for k in self.security_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        result['SecurityConfigs'] = []
        if self.security_configs is not None:
            for k in self.security_configs:
                result['SecurityConfigs'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        self.security_configs = []
        if m.get('SecurityConfigs') is not None:
            for k in m.get('SecurityConfigs'):
                temp_model = DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs()
                self.security_configs.append(temp_model.from_map(k))
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        return self


class DescribeTenantSecurityConfigsResponseBodyConfigs(TeaModel):
    def __init__(self, check_id=None, check_time=None, instance_id=None, tenant_security_configs=None,
                 total_check_count=None, total_risk_count=None):
        self.check_id = check_id  # type: str
        self.check_time = check_time  # type: str
        self.instance_id = instance_id  # type: str
        self.tenant_security_configs = tenant_security_configs  # type: list[DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs]
        self.total_check_count = total_check_count  # type: int
        self.total_risk_count = total_risk_count  # type: int

    def validate(self):
        if self.tenant_security_configs:
            for k in self.tenant_security_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsResponseBodyConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_time is not None:
            result['CheckTime'] = self.check_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['TenantSecurityConfigs'] = []
        if self.tenant_security_configs is not None:
            for k in self.tenant_security_configs:
                result['TenantSecurityConfigs'].append(k.to_map() if k else None)
        if self.total_check_count is not None:
            result['TotalCheckCount'] = self.total_check_count
        if self.total_risk_count is not None:
            result['TotalRiskCount'] = self.total_risk_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckTime') is not None:
            self.check_time = m.get('CheckTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.tenant_security_configs = []
        if m.get('TenantSecurityConfigs') is not None:
            for k in m.get('TenantSecurityConfigs'):
                temp_model = DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs()
                self.tenant_security_configs.append(temp_model.from_map(k))
        if m.get('TotalCheckCount') is not None:
            self.total_check_count = m.get('TotalCheckCount')
        if m.get('TotalRiskCount') is not None:
            self.total_risk_count = m.get('TotalRiskCount')
        return self


class DescribeTenantSecurityConfigsResponseBody(TeaModel):
    def __init__(self, configs=None, request_id=None):
        self.configs = configs  # type: DescribeTenantSecurityConfigsResponseBodyConfigs
        self.request_id = request_id  # type: str

    def validate(self):
        if self.configs:
            self.configs.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configs is not None:
            result['Configs'] = self.configs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Configs') is not None:
            temp_model = DescribeTenantSecurityConfigsResponseBodyConfigs()
            self.configs = temp_model.from_map(m['Configs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTenantSecurityConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantSecurityConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantSecurityConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantSecurityIpGroupsRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantSecurityIpGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups(TeaModel):
    def __init__(self, security_ip_group_name=None, security_ip_group_type=None, security_ips=None, tenant_id=None):
        # The group name.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The whitelist group type.
        # - instance: the whitelist group from the cluster.
        # - tenant: the whitelist group of the current tenant.
        self.security_ip_group_type = security_ip_group_type  # type: str
        # The whitelist of IP addresses. It is a string separated by commas, and each object is an IP string or a CIDR block.
        self.security_ips = security_ips  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ip_group_type is not None:
            result['SecurityIpGroupType'] = self.security_ip_group_type
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIpGroupType') is not None:
            self.security_ip_group_type = m.get('SecurityIpGroupType')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantSecurityIpGroupsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_groups=None, total_count=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The list of the whitelist groups.
        self.security_ip_groups = security_ip_groups  # type: list[DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups]
        # The total number of the whitelist groups.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.security_ip_groups:
            for k in self.security_ip_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityIpGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityIpGroups'] = []
        if self.security_ip_groups is not None:
            for k in self.security_ip_groups:
                result['SecurityIpGroups'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_ip_groups = []
        if m.get('SecurityIpGroups') is not None:
            for k in m.get('SecurityIpGroups'):
                temp_model = DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups()
                self.security_ip_groups.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTenantSecurityIpGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantSecurityIpGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantSecurityIpGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantSecurityIpGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantTagsRequest(TeaModel):
    def __init__(self, instance_id=None, tags=None, tenant_ids=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The tags.
        self.tags = tags  # type: str
        # The JSON string of the tenant ID.
        self.tenant_ids = tenant_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.tenant_ids is not None:
            result['TenantIds'] = self.tenant_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TenantIds') is not None:
            self.tenant_ids = m.get('TenantIds')
        return self


class DescribeTenantTagsResponseBodyTagResources(TeaModel):
    def __init__(self, resource_id=None, resource_type=None, tag=None):
        # The resource ID.
        self.resource_id = resource_id  # type: str
        # The type of the resource.
        self.resource_type = resource_type  # type: str
        # The tag of the resource.
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantTagsResponseBodyTagResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeTenantTagsResponseBody(TeaModel):
    def __init__(self, request_id=None, tag_resources=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The list of tags.
        self.tag_resources = tag_resources  # type: list[DescribeTenantTagsResponseBodyTagResources]

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = DescribeTenantTagsResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class DescribeTenantTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantUserRolesRequest(TeaModel):
    def __init__(self, tenant_id=None):
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantUserRolesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantUserRolesResponseBody(TeaModel):
    def __init__(self, request_id=None, role=None):
        self.request_id = request_id  # type: str
        self.role = role  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantUserRolesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class DescribeTenantUserRolesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantUserRolesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantUserRolesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantUserRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantUsersRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, search_key=None, tenant_id=None, user_name=None):
        # The database privileges of the account.
        self.page_number = page_number  # type: int
        # The return result of the request.
        self.page_size = page_size  # type: int
        # The return result of the request.
        self.search_key = search_key  # type: str
        # The return result of the request.
        self.tenant_id = tenant_id  # type: str
        # The operation that you want to perform.   
        # Set the value to **DescribeTenantUsers**.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeTenantUsersResponseBodyTenantUsersDatabases(TeaModel):
    def __init__(self, database=None, privileges=None, role=None, table=None):
        self.database = database  # type: str
        self.privileges = privileges  # type: str
        self.role = role  # type: str
        self.table = table  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantUsersResponseBodyTenantUsersDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.privileges is not None:
            result['Privileges'] = self.privileges
        if self.role is not None:
            result['Role'] = self.role
        if self.table is not None:
            result['Table'] = self.table
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Privileges') is not None:
            self.privileges = m.get('Privileges')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Table') is not None:
            self.table = m.get('Table')
        return self


class DescribeTenantUsersResponseBodyTenantUsers(TeaModel):
    def __init__(self, databases=None, description=None, instance_id=None, tenant_id=None, user_name=None,
                 user_status=None, user_type=None):
        self.databases = databases  # type: list[DescribeTenantUsersResponseBodyTenantUsersDatabases]
        self.description = description  # type: str
        # 所属集群Id
        self.instance_id = instance_id  # type: str
        # 所属租户Id
        self.tenant_id = tenant_id  # type: str
        self.user_name = user_name  # type: str
        self.user_status = user_status  # type: str
        self.user_type = user_type  # type: str

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantUsersResponseBodyTenantUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = DescribeTenantUsersResponseBodyTenantUsersDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeTenantUsersResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_users=None, total_count=None):
        # The name of the database account.
        self.request_id = request_id  # type: str
        # The type of the database account. Valid values:    
        # - Admin: the super administrator account.   
        # - NORMAL: a general account.
        self.tenant_users = tenant_users  # type: list[DescribeTenantUsersResponseBodyTenantUsers]
        # The role of the account.   
        # In Oracle mode, a role is a schema-level role. Valid values:  
        # - ReadWrite: a role that has the read and write privileges, including: CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE SYNONYM, CREATE SEQUENCE, CREATE TRIGGER, CREATE TYPE, CREATE SESSION, EXECUTE ANY PROCEDURE, CREATE ANY OUTLINE, ALTER ANY OUTLINE, DROP ANY OUTLINE, CREATE ANY PROCEDURE, ALTER ANY PROCEDURE, DROP ANY PROCEDURE, CREATE ANY SEQUENCE, ALTER ANY SEQUENCE, DROP ANY SEQUENCE, CREATE ANY TYPE, ALTER ANY TYPE, DROP ANY TYPE, SYSKM, CREATE ANY TRIGGER, ALTER ANY TRIGGER, DROP ANY TRIGGER, CREATE PROFILE, ALTER PROFILE, and DROP PROFILE.  
        # - ReadOnly: a role that has only the read-only privilege SELECT.
        # In MySQL mode, a role is a database-level role. Valid values: 
        # - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.   
        # - ReadOnly: a role that has only the read-only privilege SELECT.   
        # - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
        # - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.   
        # 
        # > <br>By default, an Oracle account has the read and write privileges on its own schema, which are not listed here.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.tenant_users:
            for k in self.tenant_users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TenantUsers'] = []
        if self.tenant_users is not None:
            for k in self.tenant_users:
                result['TenantUsers'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tenant_users = []
        if m.get('TenantUsers') is not None:
            for k in m.get('TenantUsers'):
                temp_model = DescribeTenantUsersResponseBodyTenantUsers()
                self.tenant_users.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTenantUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantZonesReadRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None):
        # The zone information of the tenant.
        self.instance_id = instance_id  # type: str
        # The return result of the request.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantZonesReadRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTenantZonesReadResponseBodyTenantZones(TeaModel):
    def __init__(self, is_electable=None, is_primary=None, is_readable=None, zone=None):
        # Example 1
        self.is_electable = is_electable  # type: bool
        self.is_primary = is_primary  # type: bool
        self.is_readable = is_readable  # type: str
        self.zone = zone  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantZonesReadResponseBodyTenantZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_electable is not None:
            result['IsElectable'] = self.is_electable
        if self.is_primary is not None:
            result['IsPrimary'] = self.is_primary
        if self.is_readable is not None:
            result['IsReadable'] = self.is_readable
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsElectable') is not None:
            self.is_electable = m.get('IsElectable')
        if m.get('IsPrimary') is not None:
            self.is_primary = m.get('IsPrimary')
        if m.get('IsReadable') is not None:
            self.is_readable = m.get('IsReadable')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class DescribeTenantZonesReadResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_zones=None):
        # Indicates whether a read-only connection needs to be created for the zone.
        self.request_id = request_id  # type: str
        # The request ID.
        self.tenant_zones = tenant_zones  # type: list[DescribeTenantZonesReadResponseBodyTenantZones]

    def validate(self):
        if self.tenant_zones:
            for k in self.tenant_zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantZonesReadResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TenantZones'] = []
        if self.tenant_zones is not None:
            for k in self.tenant_zones:
                result['TenantZones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tenant_zones = []
        if m.get('TenantZones') is not None:
            for k in m.get('TenantZones'):
                temp_model = DescribeTenantZonesReadResponseBodyTenantZones()
                self.tenant_zones.append(temp_model.from_map(k))
        return self


class DescribeTenantZonesReadResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantZonesReadResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantZonesReadResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantZonesReadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTenantsRequest(TeaModel):
    def __init__(self, instance_id=None, page_number=None, page_size=None, search_key=None, tenant_id=None,
                 tenant_name=None):
        # The number of used disks of the tenant.
        self.instance_id = instance_id  # type: str
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.page_number = page_number  # type: int
        # You can call this operation to query the tenants in an OceanBase cluster.
        self.page_size = page_size  # type: int
        # The primary zone of the tenant.
        self.search_key = search_key  # type: str
        # Alibaba Cloud CLI
        self.tenant_id = tenant_id  # type: str
        # The information of tenants.
        self.tenant_name = tenant_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        return self


class DescribeTenantsResponseBodyTenants(TeaModel):
    def __init__(self, charset=None, collation=None, cpu=None, create_time=None, deploy_mode=None, deploy_type=None,
                 description=None, mem=None, primary_zone=None, status=None, tenant_id=None, tenant_mode=None, tenant_name=None,
                 unit_cpu=None, unit_mem=None, unit_num=None, used_disk_size=None, vpc_id=None):
        self.charset = charset  # type: str
        self.collation = collation  # type: str
        # The total number of CPU cores of the tenant.
        self.cpu = cpu  # type: int
        # The number of CPU cores in each resource unit of the tenant.
        self.create_time = create_time  # type: str
        # The search keyword.
        self.deploy_mode = deploy_mode  # type: str
        # The name of the tenant.   
        # It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
        self.deploy_type = deploy_type  # type: str
        # Example 1
        self.description = description  # type: str
        # The number of the page to return.   
        # Start value: 1
        # - Default value: 1
        self.mem = mem  # type: int
        # The return result of the request.
        self.primary_zone = primary_zone  # type: str
        # The status of the tenant.  <br>
        # - PENDING_CREATE: The tenant is being created.
        # - RESTORE: The tenant is being recovered.
        # - ONLINE: The tenant is running.
        # - SPEC_MODIFYING: The specification of the tenant is being modified.
        # ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.
        # PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.
        # - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.
        # - PARAMETER_MODIFYING: Parameters are being modified.
        # - WHITE_LIST_MODIFYING: The whitelist is being modified.
        self.status = status  # type: str
        # You can call this operation to query the tenants in an OceanBase cluster.
        self.tenant_id = tenant_id  # type: str
        # {
        #     "TotalCount": 1,
        #     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
        #     "Tenants": [
        #         {
        #             "VpcId": "vpc-bp1d2q3mhg9i23ofi****",
        #             "Status": "ONLINE",
        #             "PrimaryZone": "cn-hangzhou-i",
        #             "DeployType": "multiple",
        #             "DeployMode": "1-1-1",
        #             "CreateTime": "2021-09-17 15:52:17.0",
        #             "TenantName": "pay_online",
        #             "Mem": 20,
        #             "Cpu": 10,
        #             "Description": "PayCore business database",
        #             "TenantMode": "Oracle",
        #             "TenantId": "t33h8y08k****",
        #             "UnitCpu": 5,
        #             "UnitMem": 10,
        #             "UnitNum": 2,
        #             "UsedDiskSize": 10
        #         }
        #     ]
        # }
        self.tenant_mode = tenant_mode  # type: str
        # The information of tenants.
        self.tenant_name = tenant_name  # type: str
        self.unit_cpu = unit_cpu  # type: int
        self.unit_mem = unit_mem  # type: int
        self.unit_num = unit_num  # type: int
        self.used_disk_size = used_disk_size  # type: float
        # The time when the tenant was created.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTenantsResponseBodyTenants, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.collation is not None:
            result['Collation'] = self.collation
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.description is not None:
            result['Description'] = self.description
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.primary_zone is not None:
            result['PrimaryZone'] = self.primary_zone
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.tenant_mode is not None:
            result['TenantMode'] = self.tenant_mode
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.unit_cpu is not None:
            result['UnitCpu'] = self.unit_cpu
        if self.unit_mem is not None:
            result['UnitMem'] = self.unit_mem
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        if self.used_disk_size is not None:
            result['UsedDiskSize'] = self.used_disk_size
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('Collation') is not None:
            self.collation = m.get('Collation')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('PrimaryZone') is not None:
            self.primary_zone = m.get('PrimaryZone')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TenantMode') is not None:
            self.tenant_mode = m.get('TenantMode')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('UnitCpu') is not None:
            self.unit_cpu = m.get('UnitCpu')
        if m.get('UnitMem') is not None:
            self.unit_mem = m.get('UnitMem')
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        if m.get('UsedDiskSize') is not None:
            self.used_disk_size = m.get('UsedDiskSize')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeTenantsResponseBody(TeaModel):
    def __init__(self, request_id=None, tenants=None, total_count=None):
        # The ID of the tenant.
        self.request_id = request_id  # type: str
        # The ID of the OceanBase cluster.
        self.tenants = tenants  # type: list[DescribeTenantsResponseBodyTenants]
        # The total memory size of the tenant, in GB.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTenantsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['Tenants'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tenants = []
        if m.get('Tenants') is not None:
            for k in m.get('Tenants'):
                temp_model = DescribeTenantsResponseBodyTenants()
                self.tenants.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTenantsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTenantsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTenantsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTenantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTimeZonesResponseBodyTimeZonesList(TeaModel):
    def __init__(self, description=None, time_zone=None):
        # Example 1
        self.description = description  # type: str
        # The operation that you want to perform.   
        # Set the value to **DescribeTimeZones**.
        self.time_zone = time_zone  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTimeZonesResponseBodyTimeZonesList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class DescribeTimeZonesResponseBodyTimeZones(TeaModel):
    def __init__(self, default=None, list=None):
        self.default = default  # type: str
        # The list of time zones.
        self.list = list  # type: list[DescribeTimeZonesResponseBodyTimeZonesList]

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTimeZonesResponseBodyTimeZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default is not None:
            result['Default'] = self.default
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Default') is not None:
            self.default = m.get('Default')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeTimeZonesResponseBodyTimeZonesList()
                self.list.append(temp_model.from_map(k))
        return self


class DescribeTimeZonesResponseBody(TeaModel):
    def __init__(self, request_id=None, time_zones=None):
        # DescribeTimeZones
        self.request_id = request_id  # type: str
        # The description of the time zone.
        self.time_zones = time_zones  # type: DescribeTimeZonesResponseBodyTimeZones

    def validate(self):
        if self.time_zones:
            self.time_zones.validate()

    def to_map(self):
        _map = super(DescribeTimeZonesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_zones is not None:
            result['TimeZones'] = self.time_zones.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeZones') is not None:
            temp_model = DescribeTimeZonesResponseBodyTimeZones()
            self.time_zones = temp_model.from_map(m['TimeZones'])
        return self


class DescribeTimeZonesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTimeZonesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTimeZonesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTimeZonesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTopSQLListRequest(TeaModel):
    def __init__(self, db_name=None, end_time=None, filter_condition=None, node_ip=None, page_number=None,
                 page_size=None, sqlid=None, search_key_word=None, search_parameter=None, search_rule=None, search_value=None,
                 sort_column=None, sort_order=None, start_time=None, tenant_id=None):
        # The number of block index cache hits.
        self.db_name = db_name  # type: str
        # The SQL type.
        self.end_time = end_time  # type: str
        # The average number of logical reads of the SQL statement during the specified period of time.   
        # The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
        # 
        # > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
        self.filter_condition = filter_condition  # type: dict[str, any]
        # The number of failures.
        self.node_ip = node_ip  # type: str
        # The queuing time, in ms.
        self.page_number = page_number  # type: int
        # The number of row cache hits.
        self.page_size = page_size  # type: int
        # The I/O wait time, in ms.
        self.sqlid = sqlid  # type: str
        # The number of retries.
        self.search_key_word = search_key_word  # type: str
        # SQLID.
        self.search_parameter = search_parameter  # type: str
        # The IP address of the client.
        self.search_rule = search_rule  # type: str
        # The number of Bloom filter cache hits.
        self.search_value = search_value  # type: str
        # The number of rows read from the disk.
        self.sort_column = sort_column  # type: str
        # The list of top SQL statements.
        self.sort_order = sort_order  # type: str
        # The maximum response time, in ms.
        self.start_time = start_time  # type: str
        # The average CPU time, in ms.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTopSQLListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition is not None:
            result['FilterCondition'] = self.filter_condition
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition = m.get('FilterCondition')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTopSQLListShrinkRequest(TeaModel):
    def __init__(self, db_name=None, end_time=None, filter_condition_shrink=None, node_ip=None, page_number=None,
                 page_size=None, sqlid=None, search_key_word=None, search_parameter=None, search_rule=None, search_value=None,
                 sort_column=None, sort_order=None, start_time=None, tenant_id=None):
        # The number of block index cache hits.
        self.db_name = db_name  # type: str
        # The SQL type.
        self.end_time = end_time  # type: str
        # The average number of logical reads of the SQL statement during the specified period of time.   
        # The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
        # 
        # > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
        self.filter_condition_shrink = filter_condition_shrink  # type: str
        # The number of failures.
        self.node_ip = node_ip  # type: str
        # The queuing time, in ms.
        self.page_number = page_number  # type: int
        # The number of row cache hits.
        self.page_size = page_size  # type: int
        # The I/O wait time, in ms.
        self.sqlid = sqlid  # type: str
        # The number of retries.
        self.search_key_word = search_key_word  # type: str
        # SQLID.
        self.search_parameter = search_parameter  # type: str
        # The IP address of the client.
        self.search_rule = search_rule  # type: str
        # The number of Bloom filter cache hits.
        self.search_value = search_value  # type: str
        # The number of rows read from the disk.
        self.sort_column = sort_column  # type: str
        # The list of top SQL statements.
        self.sort_order = sort_order  # type: str
        # The maximum response time, in ms.
        self.start_time = start_time  # type: str
        # The average CPU time, in ms.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTopSQLListShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_condition_shrink is not None:
            result['FilterCondition'] = self.filter_condition_shrink
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.search_key_word is not None:
            result['SearchKeyWord'] = self.search_key_word
        if self.search_parameter is not None:
            result['SearchParameter'] = self.search_parameter
        if self.search_rule is not None:
            result['SearchRule'] = self.search_rule
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FilterCondition') is not None:
            self.filter_condition_shrink = m.get('FilterCondition')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SearchKeyWord') is not None:
            self.search_key_word = m.get('SearchKeyWord')
        if m.get('SearchParameter') is not None:
            self.search_parameter = m.get('SearchParameter')
        if m.get('SearchRule') is not None:
            self.search_rule = m.get('SearchRule')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeTopSQLListResponseBodyTopSQLList(TeaModel):
    def __init__(self, affected_rows=None, app_wait_time=None, block_cache_hit=None, block_index_cache_hit=None,
                 bloom_filter_cache_hit=None, client_ip=None, concurrency_wait_time=None, cpu_time=None, db_name=None, decode_time=None,
                 disk_read=None, elapsed_time=None, event=None, exec_per_second=None, execute_time=None, executions=None,
                 fail_times=None, get_plan_time=None, iowait_time=None, key=None, logical_read=None, max_cpu_time=None,
                 max_elapsed_time=None, memstore_read_row_count=None, miss_plans=None, net_wait_time=None, node_ip=None,
                 queue_time=None, rpccount=None, remote_plans=None, retry_count=None, return_rows=None, row_cache_hit=None,
                 sqlid=None, sqltext=None, sqltype=None, schedule_time=None, ssstore_read_row_count=None,
                 total_wait_time=None, user_name=None):
        # The internal wait time, in ms.
        self.affected_rows = affected_rows  # type: long
        # The wait time in concurrent execution, in ms.
        self.app_wait_time = app_wait_time  # type: float
        # The average CPU time, in ms.
        self.block_cache_hit = block_cache_hit  # type: long
        # $.parameters[16].schema.example
        self.block_index_cache_hit = block_index_cache_hit  # type: long
        # $.parameters[14].schema.enumValueTitles
        self.bloom_filter_cache_hit = bloom_filter_cache_hit  # type: long
        # $.parameters[14].schema.description
        self.client_ip = client_ip  # type: str
        # The number of rows returned.
        self.concurrency_wait_time = concurrency_wait_time  # type: float
        # The maximum CPU time, in ms.
        self.cpu_time = cpu_time  # type: float
        # The number of remote plans.
        self.db_name = db_name  # type: str
        # The number of rows to return on each page.   
        # - Maximum value: 100   
        # - Default value: 10
        self.decode_time = decode_time  # type: float
        # The IP address of the client.
        self.disk_read = disk_read  # type: long
        # The sorting rule.
        self.elapsed_time = elapsed_time  # type: float
        # The number of rows read from the disk.
        self.event = event  # type: str
        # The operation that you want to perform.   
        # Set the value to **DescribeTopSQLList**.
        self.exec_per_second = exec_per_second  # type: float
        # The number of rows read from the memory.
        self.execute_time = execute_time  # type: float
        # The number of executions per second.
        self.executions = executions  # type: long
        # $.parameters[12].schema.description
        self.fail_times = fail_times  # type: long
        # The queuing time, in ms.
        self.get_plan_time = get_plan_time  # type: float
        # $.parameters[15].schema.example
        self.iowait_time = iowait_time  # type: float
        # The name of the database.
        self.key = key  # type: long
        # You can call this operation to query SQL execution performance data collected by the diagnostic system.
        self.logical_read = logical_read  # type: long
        # SQLID.
        self.max_cpu_time = max_cpu_time  # type: float
        # The sequence number of the returned SQL statement.
        self.max_elapsed_time = max_elapsed_time  # type: float
        # The name of the database.
        self.memstore_read_row_count = memstore_read_row_count  # type: long
        # The total count.
        self.miss_plans = miss_plans  # type: long
        # The end time of the time range for querying TOP SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.net_wait_time = net_wait_time  # type: float
        # The username.
        self.node_ip = node_ip  # type: str
        # $.parameters[12].schema.enumValueTitles
        self.queue_time = queue_time  # type: float
        # The start time of the time range for querying TOP SQL statements.   
        # The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
        self.rpccount = rpccount  # type: long
        # The return result of the request.
        self.remote_plans = remote_plans  # type: long
        # $.parameters[13].schema.description
        self.retry_count = retry_count  # type: long
        # The wait event.
        self.return_rows = return_rows  # type: long
        # ```
        # http(s)://[Endpoint]/?Action=DescribeTopSQLList
        # &TenantId=t2mr3oae0****\
        # &StartTime=2021-06-13 15:40:43
        # &EndTime=2021-09-13 15:40:43
        # &DbName=testdb
        # &SearchKeyWord=update
        # &SearchParameter=cputime
        # &SearchRule=>
        # &SearchValue=0.01
        # &SQLId=8D6E84****0B8FB1823D199E2CA1****\
        # &NodeIp=i-bp19y05uq6xpacyqnlrc
        # &PageNumber=1
        # &PageSize=10
        # &SortColumn=cputime
        # &SortOrder=desc
        # &Common request parameters
        # ```
        self.row_cache_hit = row_cache_hit  # type: long
        # $.parameters[13].schema.example
        self.sqlid = sqlid  # type: str
        # The list of top SQL statements.
        self.sqltext = sqltext  # type: str
        # The request ID.
        self.sqltype = sqltype  # type: long
        # The search keyword.
        self.schedule_time = schedule_time  # type: float
        self.ssstore_read_row_count = ssstore_read_row_count  # type: long
        # -\
        self.total_wait_time = total_wait_time  # type: float
        # The number of Bloom filter cache hits.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTopSQLListResponseBodyTopSQLList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_rows is not None:
            result['AffectedRows'] = self.affected_rows
        if self.app_wait_time is not None:
            result['AppWaitTime'] = self.app_wait_time
        if self.block_cache_hit is not None:
            result['BlockCacheHit'] = self.block_cache_hit
        if self.block_index_cache_hit is not None:
            result['BlockIndexCacheHit'] = self.block_index_cache_hit
        if self.bloom_filter_cache_hit is not None:
            result['BloomFilterCacheHit'] = self.bloom_filter_cache_hit
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.concurrency_wait_time is not None:
            result['ConcurrencyWaitTime'] = self.concurrency_wait_time
        if self.cpu_time is not None:
            result['CpuTime'] = self.cpu_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.decode_time is not None:
            result['DecodeTime'] = self.decode_time
        if self.disk_read is not None:
            result['DiskRead'] = self.disk_read
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.event is not None:
            result['Event'] = self.event
        if self.exec_per_second is not None:
            result['ExecPerSecond'] = self.exec_per_second
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executions is not None:
            result['Executions'] = self.executions
        if self.fail_times is not None:
            result['FailTimes'] = self.fail_times
        if self.get_plan_time is not None:
            result['GetPlanTime'] = self.get_plan_time
        if self.iowait_time is not None:
            result['IOWaitTime'] = self.iowait_time
        if self.key is not None:
            result['Key'] = self.key
        if self.logical_read is not None:
            result['LogicalRead'] = self.logical_read
        if self.max_cpu_time is not None:
            result['MaxCpuTime'] = self.max_cpu_time
        if self.max_elapsed_time is not None:
            result['MaxElapsedTime'] = self.max_elapsed_time
        if self.memstore_read_row_count is not None:
            result['MemstoreReadRowCount'] = self.memstore_read_row_count
        if self.miss_plans is not None:
            result['MissPlans'] = self.miss_plans
        if self.net_wait_time is not None:
            result['NetWaitTime'] = self.net_wait_time
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.rpccount is not None:
            result['RPCCount'] = self.rpccount
        if self.remote_plans is not None:
            result['RemotePlans'] = self.remote_plans
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.return_rows is not None:
            result['ReturnRows'] = self.return_rows
        if self.row_cache_hit is not None:
            result['RowCacheHit'] = self.row_cache_hit
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqltext is not None:
            result['SQLText'] = self.sqltext
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.ssstore_read_row_count is not None:
            result['SsstoreReadRowCount'] = self.ssstore_read_row_count
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedRows') is not None:
            self.affected_rows = m.get('AffectedRows')
        if m.get('AppWaitTime') is not None:
            self.app_wait_time = m.get('AppWaitTime')
        if m.get('BlockCacheHit') is not None:
            self.block_cache_hit = m.get('BlockCacheHit')
        if m.get('BlockIndexCacheHit') is not None:
            self.block_index_cache_hit = m.get('BlockIndexCacheHit')
        if m.get('BloomFilterCacheHit') is not None:
            self.bloom_filter_cache_hit = m.get('BloomFilterCacheHit')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ConcurrencyWaitTime') is not None:
            self.concurrency_wait_time = m.get('ConcurrencyWaitTime')
        if m.get('CpuTime') is not None:
            self.cpu_time = m.get('CpuTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DecodeTime') is not None:
            self.decode_time = m.get('DecodeTime')
        if m.get('DiskRead') is not None:
            self.disk_read = m.get('DiskRead')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('ExecPerSecond') is not None:
            self.exec_per_second = m.get('ExecPerSecond')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Executions') is not None:
            self.executions = m.get('Executions')
        if m.get('FailTimes') is not None:
            self.fail_times = m.get('FailTimes')
        if m.get('GetPlanTime') is not None:
            self.get_plan_time = m.get('GetPlanTime')
        if m.get('IOWaitTime') is not None:
            self.iowait_time = m.get('IOWaitTime')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('LogicalRead') is not None:
            self.logical_read = m.get('LogicalRead')
        if m.get('MaxCpuTime') is not None:
            self.max_cpu_time = m.get('MaxCpuTime')
        if m.get('MaxElapsedTime') is not None:
            self.max_elapsed_time = m.get('MaxElapsedTime')
        if m.get('MemstoreReadRowCount') is not None:
            self.memstore_read_row_count = m.get('MemstoreReadRowCount')
        if m.get('MissPlans') is not None:
            self.miss_plans = m.get('MissPlans')
        if m.get('NetWaitTime') is not None:
            self.net_wait_time = m.get('NetWaitTime')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RPCCount') is not None:
            self.rpccount = m.get('RPCCount')
        if m.get('RemotePlans') is not None:
            self.remote_plans = m.get('RemotePlans')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('ReturnRows') is not None:
            self.return_rows = m.get('ReturnRows')
        if m.get('RowCacheHit') is not None:
            self.row_cache_hit = m.get('RowCacheHit')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLText') is not None:
            self.sqltext = m.get('SQLText')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('SsstoreReadRowCount') is not None:
            self.ssstore_read_row_count = m.get('SsstoreReadRowCount')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeTopSQLListResponseBody(TeaModel):
    def __init__(self, request_id=None, top_sqllist=None, total_count=None):
        # Alibaba Cloud CLI
        self.request_id = request_id  # type: str
        # The I/O wait time, in ms.
        self.top_sqllist = top_sqllist  # type: list[DescribeTopSQLListResponseBodyTopSQLList]
        # It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.top_sqllist:
            for k in self.top_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTopSQLListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TopSQLList'] = []
        if self.top_sqllist is not None:
            for k in self.top_sqllist:
                result['TopSQLList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.top_sqllist = []
        if m.get('TopSQLList') is not None:
            for k in m.get('TopSQLList'):
                temp_model = DescribeTopSQLListResponseBodyTopSQLList()
                self.top_sqllist.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTopSQLListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTopSQLListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTopSQLListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTopSQLListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeZonesRequest(TeaModel):
    def __init__(self, deploy_type=None, series=None):
        # The operation that you want to perform.   
        # Set the value to **DescribeZones**.
        self.deploy_type = deploy_type  # type: str
        # The deployment mode.
        self.series = series  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.series is not None:
            result['Series'] = self.series
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        return self


class DescribeZonesResponseBodyZones(TeaModel):
    def __init__(self, deploy_type=None, series=None, zone_id=None, zone_name=None):
        self.deploy_type = deploy_type  # type: str
        self.series = series  # type: str
        self.zone_id = zone_id  # type: str
        self.zone_name = zone_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_type is not None:
            result['DeployType'] = self.deploy_type
        if self.series is not None:
            result['Series'] = self.series
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        if self.zone_name is not None:
            result['ZoneName'] = self.zone_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeployType') is not None:
            self.deploy_type = m.get('DeployType')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        if m.get('ZoneName') is not None:
            self.zone_name = m.get('ZoneName')
        return self


class DescribeZonesResponseBody(TeaModel):
    def __init__(self, request_id=None, zones=None):
        # ```
        # http(s)://[Endpoint]/?Action=DescribeZones
        # &Series=normal
        # &DeployType=single
        # &Common request parameters
        # ```
        self.request_id = request_id  # type: str
        # You can call this operation to learn of zones where a cluster can be created in an Alibaba Cloud region.
        self.zones = zones  # type: list[DescribeZonesResponseBodyZones]

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['Zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.zones = []
        if m.get('Zones') is not None:
            for k in m.get('Zones'):
                temp_model = DescribeZonesResponseBodyZones()
                self.zones.append(temp_model.from_map(k))
        return self


class DescribeZonesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeZonesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeZonesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeZonesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUploadOssUrlRequest(TeaModel):
    def __init__(self, effective_time_minutes=None, type=None):
        self.effective_time_minutes = effective_time_minutes  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUploadOssUrlRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effective_time_minutes is not None:
            result['EffectiveTimeMinutes'] = self.effective_time_minutes
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EffectiveTimeMinutes') is not None:
            self.effective_time_minutes = m.get('EffectiveTimeMinutes')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetUploadOssUrlResponseBodyData(TeaModel):
    def __init__(self, expected_expiration_time=None, oss_key=None, oss_url=None):
        self.expected_expiration_time = expected_expiration_time  # type: str
        self.oss_key = oss_key  # type: str
        self.oss_url = oss_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUploadOssUrlResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expected_expiration_time is not None:
            result['ExpectedExpirationTime'] = self.expected_expiration_time
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.oss_url is not None:
            result['OssUrl'] = self.oss_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExpectedExpirationTime') is not None:
            self.expected_expiration_time = m.get('ExpectedExpirationTime')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('OssUrl') is not None:
            self.oss_url = m.get('OssUrl')
        return self


class GetUploadOssUrlResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUploadOssUrlResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class GetUploadOssUrlResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: GetUploadOssUrlResponseBodyData
        self.error_detail = error_detail  # type: GetUploadOssUrlResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(GetUploadOssUrlResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = GetUploadOssUrlResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = GetUploadOssUrlResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetUploadOssUrlResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetUploadOssUrlResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetUploadOssUrlResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUploadOssUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class KillProcessListRequest(TeaModel):
    def __init__(self, instance_id=None, session_list=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The list of the sessions that need to be closed.
        self.session_list = session_list  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(KillProcessListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.session_list is not None:
            result['SessionList'] = self.session_list
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SessionList') is not None:
            self.session_list = m.get('SessionList')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class KillProcessListResponseBodyData(TeaModel):
    def __init__(self, client_ip=None, command=None, database=None, error_message=None, execute_time=None,
                 server_ip=None, session_id=None, sql_text=None, status=None, tenant_id=None, user=None):
        # The client IP address.
        self.client_ip = client_ip  # type: str
        # The start command for the container of the application.
        self.command = command  # type: str
        # The name of the database.
        self.database = database  # type: str
        # The error message.
        self.error_message = error_message  # type: str
        # Execution time (UTC+8). If it is left empty, it means to execute immediately.
        self.execute_time = execute_time  # type: str
        # The IP address of the server.
        self.server_ip = server_ip  # type: str
        # The ID of the session.
        self.session_id = session_id  # type: long
        # The SQL statement.
        self.sql_text = sql_text  # type: str
        # The status of the task.
        self.status = status  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # The database username.
        self.user = user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(KillProcessListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.command is not None:
            result['Command'] = self.command
        if self.database is not None:
            result['Database'] = self.database
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.sql_text is not None:
            result['SqlText'] = self.sql_text
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SqlText') is not None:
            self.sql_text = m.get('SqlText')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class KillProcessListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The data returned.
        self.data = data  # type: list[KillProcessListResponseBodyData]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(KillProcessListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = KillProcessListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class KillProcessListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: KillProcessListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(KillProcessListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = KillProcessListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllLabelsResponseBodyData(TeaModel):
    def __init__(self, id=None, name=None):
        self.id = id  # type: str
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAllLabelsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAllLabelsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAllLabelsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListAllLabelsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: list[ListAllLabelsResponseBodyData]
        self.error_detail = error_detail  # type: ListAllLabelsResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ListAllLabelsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAllLabelsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = ListAllLabelsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAllLabelsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListAllLabelsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListAllLabelsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllLabelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourceRequest(TeaModel):
    def __init__(self, order=None, page_number=None, page_size=None, search_key=None, sort_field=None, types=None):
        self.order = order  # type: str
        self.page_number = page_number  # type: str
        self.page_size = page_size  # type: str
        self.search_key = search_key  # type: str
        self.sort_field = sort_field  # type: str
        self.types = types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataSourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.sort_field is not None:
            result['SortField'] = self.sort_field
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SortField') is not None:
            self.sort_field = m.get('SortField')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListDataSourceShrinkRequest(TeaModel):
    def __init__(self, order=None, page_number=None, page_size=None, search_key=None, sort_field=None,
                 types_shrink=None):
        self.order = order  # type: str
        self.page_number = page_number  # type: str
        self.page_size = page_size  # type: str
        self.search_key = search_key  # type: str
        self.sort_field = sort_field  # type: str
        self.types_shrink = types_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataSourceShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.sort_field is not None:
            result['SortField'] = self.sort_field
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SortField') is not None:
            self.sort_field = m.get('SortField')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListDataSourceResponseBodyData(TeaModel):
    def __init__(self, charset=None, cluster=None, conn_extra_attributes=None, description=None, gmt_create=None,
                 gmt_modified=None, id=None, ip=None, name=None, operating_system=None, oracle_nls_length_semantics=None,
                 oracle_sid=None, owner=None, partner_id=None, port=None, region=None, resource_owner=None, role=None,
                 schema=None, tenant=None, timezone=None, type=None, user_name=None, version=None, vpc_id=None):
        self.charset = charset  # type: str
        self.cluster = cluster  # type: str
        self.conn_extra_attributes = conn_extra_attributes  # type: any
        self.description = description  # type: str
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.id = id  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.operating_system = operating_system  # type: str
        self.oracle_nls_length_semantics = oracle_nls_length_semantics  # type: str
        self.oracle_sid = oracle_sid  # type: str
        self.owner = owner  # type: str
        self.partner_id = partner_id  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.resource_owner = resource_owner  # type: str
        self.role = role  # type: str
        self.schema = schema  # type: str
        self.tenant = tenant  # type: str
        self.timezone = timezone  # type: str
        self.type = type  # type: str
        self.user_name = user_name  # type: str
        self.version = version  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataSourceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.cluster is not None:
            result['Cluster'] = self.cluster
        if self.conn_extra_attributes is not None:
            result['ConnExtraAttributes'] = self.conn_extra_attributes
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.oracle_nls_length_semantics is not None:
            result['OracleNlsLengthSemantics'] = self.oracle_nls_length_semantics
        if self.oracle_sid is not None:
            result['OracleSid'] = self.oracle_sid
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.partner_id is not None:
            result['PartnerId'] = self.partner_id
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_owner is not None:
            result['ResourceOwner'] = self.resource_owner
        if self.role is not None:
            result['Role'] = self.role
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.tenant is not None:
            result['Tenant'] = self.tenant
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.version is not None:
            result['Version'] = self.version
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('Cluster') is not None:
            self.cluster = m.get('Cluster')
        if m.get('ConnExtraAttributes') is not None:
            self.conn_extra_attributes = m.get('ConnExtraAttributes')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('OracleNlsLengthSemantics') is not None:
            self.oracle_nls_length_semantics = m.get('OracleNlsLengthSemantics')
        if m.get('OracleSid') is not None:
            self.oracle_sid = m.get('OracleSid')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PartnerId') is not None:
            self.partner_id = m.get('PartnerId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceOwner') is not None:
            self.resource_owner = m.get('ResourceOwner')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('Tenant') is not None:
            self.tenant = m.get('Tenant')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListDataSourceResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDataSourceResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListDataSourceResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: list[ListDataSourceResponseBodyData]
        self.error_detail = error_detail  # type: ListDataSourceResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ListDataSourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDataSourceResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = ListDataSourceResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataSourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDataSourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDataSourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectFullVerifyResultRequest(TeaModel):
    def __init__(self, dest_schemas=None, page_number=None, page_size=None, project_id=None, source_schemas=None,
                 status=None):
        self.dest_schemas = dest_schemas  # type: list[str]
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.project_id = project_id  # type: str
        self.source_schemas = source_schemas  # type: list[str]
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectFullVerifyResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_schemas is not None:
            result['DestSchemas'] = self.dest_schemas
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_schemas is not None:
            result['SourceSchemas'] = self.source_schemas
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestSchemas') is not None:
            self.dest_schemas = m.get('DestSchemas')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceSchemas') is not None:
            self.source_schemas = m.get('SourceSchemas')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectFullVerifyResultShrinkRequest(TeaModel):
    def __init__(self, dest_schemas_shrink=None, page_number=None, page_size=None, project_id=None,
                 source_schemas_shrink=None, status=None):
        self.dest_schemas_shrink = dest_schemas_shrink  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.project_id = project_id  # type: str
        self.source_schemas_shrink = source_schemas_shrink  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectFullVerifyResultShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_schemas_shrink is not None:
            result['DestSchemas'] = self.dest_schemas_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_schemas_shrink is not None:
            result['SourceSchemas'] = self.source_schemas_shrink
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestSchemas') is not None:
            self.dest_schemas_shrink = m.get('DestSchemas')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceSchemas') is not None:
            self.source_schemas_shrink = m.get('SourceSchemas')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics(TeaModel):
    def __init__(self, consistent_count=None, dest_only_count=None, dest_schema_name=None, error_details=None,
                 message=None, mismatched_count=None, progress=None, result_desc=None, result_type=None,
                 source_only_count=None, source_schema_name=None, source_table_name=None, status=None):
        self.consistent_count = consistent_count  # type: long
        self.dest_only_count = dest_only_count  # type: long
        self.dest_schema_name = dest_schema_name  # type: str
        self.error_details = error_details  # type: list[ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails]
        self.message = message  # type: str
        self.mismatched_count = mismatched_count  # type: long
        self.progress = progress  # type: str
        self.result_desc = result_desc  # type: str
        self.result_type = result_type  # type: str
        self.source_only_count = source_only_count  # type: long
        self.source_schema_name = source_schema_name  # type: str
        self.source_table_name = source_table_name  # type: str
        self.status = status  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consistent_count is not None:
            result['ConsistentCount'] = self.consistent_count
        if self.dest_only_count is not None:
            result['DestOnlyCount'] = self.dest_only_count
        if self.dest_schema_name is not None:
            result['DestSchemaName'] = self.dest_schema_name
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.mismatched_count is not None:
            result['MismatchedCount'] = self.mismatched_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_desc is not None:
            result['ResultDesc'] = self.result_desc
        if self.result_type is not None:
            result['ResultType'] = self.result_type
        if self.source_only_count is not None:
            result['SourceOnlyCount'] = self.source_only_count
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConsistentCount') is not None:
            self.consistent_count = m.get('ConsistentCount')
        if m.get('DestOnlyCount') is not None:
            self.dest_only_count = m.get('DestOnlyCount')
        if m.get('DestSchemaName') is not None:
            self.dest_schema_name = m.get('DestSchemaName')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MismatchedCount') is not None:
            self.mismatched_count = m.get('MismatchedCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultDesc') is not None:
            self.result_desc = m.get('ResultDesc')
        if m.get('ResultType') is not None:
            self.result_type = m.get('ResultType')
        if m.get('SourceOnlyCount') is not None:
            self.source_only_count = m.get('SourceOnlyCount')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectFullVerifyResultResponseBodyData(TeaModel):
    def __init__(self, different_number=None, full_verify_table_statistics=None):
        self.different_number = different_number  # type: long
        self.full_verify_table_statistics = full_verify_table_statistics  # type: list[ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics]

    def validate(self):
        if self.full_verify_table_statistics:
            for k in self.full_verify_table_statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.different_number is not None:
            result['DifferentNumber'] = self.different_number
        result['FullVerifyTableStatistics'] = []
        if self.full_verify_table_statistics is not None:
            for k in self.full_verify_table_statistics:
                result['FullVerifyTableStatistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DifferentNumber') is not None:
            self.different_number = m.get('DifferentNumber')
        self.full_verify_table_statistics = []
        if m.get('FullVerifyTableStatistics') is not None:
            for k in m.get('FullVerifyTableStatistics'):
                temp_model = ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics()
                self.full_verify_table_statistics.append(temp_model.from_map(k))
        return self


class ListProjectFullVerifyResultResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListProjectFullVerifyResultResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: ListProjectFullVerifyResultResponseBodyData
        self.error_detail = error_detail  # type: ListProjectFullVerifyResultResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = ListProjectFullVerifyResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = ListProjectFullVerifyResultResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectFullVerifyResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListProjectFullVerifyResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListProjectFullVerifyResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectFullVerifyResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectsRequest(TeaModel):
    def __init__(self, label_ids=None, order=None, page_number=None, page_size=None, search_key=None,
                 sink_endpoint_types=None, sort_field=None, source_endpoint_types=None, status=None, type=None,
                 visible_sub_project=None):
        self.label_ids = label_ids  # type: list[str]
        self.order = order  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.search_key = search_key  # type: str
        self.sink_endpoint_types = sink_endpoint_types  # type: list[str]
        self.sort_field = sort_field  # type: str
        self.source_endpoint_types = source_endpoint_types  # type: list[str]
        self.status = status  # type: list[str]
        self.type = type  # type: str
        self.visible_sub_project = visible_sub_project  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_ids is not None:
            result['LabelIds'] = self.label_ids
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.sink_endpoint_types is not None:
            result['SinkEndpointTypes'] = self.sink_endpoint_types
        if self.sort_field is not None:
            result['SortField'] = self.sort_field
        if self.source_endpoint_types is not None:
            result['SourceEndpointTypes'] = self.source_endpoint_types
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.visible_sub_project is not None:
            result['VisibleSubProject'] = self.visible_sub_project
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LabelIds') is not None:
            self.label_ids = m.get('LabelIds')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SinkEndpointTypes') is not None:
            self.sink_endpoint_types = m.get('SinkEndpointTypes')
        if m.get('SortField') is not None:
            self.sort_field = m.get('SortField')
        if m.get('SourceEndpointTypes') is not None:
            self.source_endpoint_types = m.get('SourceEndpointTypes')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VisibleSubProject') is not None:
            self.visible_sub_project = m.get('VisibleSubProject')
        return self


class ListProjectsShrinkRequest(TeaModel):
    def __init__(self, label_ids_shrink=None, order=None, page_number=None, page_size=None, search_key=None,
                 sink_endpoint_types_shrink=None, sort_field=None, source_endpoint_types_shrink=None, status_shrink=None, type=None,
                 visible_sub_project=None):
        self.label_ids_shrink = label_ids_shrink  # type: str
        self.order = order  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.search_key = search_key  # type: str
        self.sink_endpoint_types_shrink = sink_endpoint_types_shrink  # type: str
        self.sort_field = sort_field  # type: str
        self.source_endpoint_types_shrink = source_endpoint_types_shrink  # type: str
        self.status_shrink = status_shrink  # type: str
        self.type = type  # type: str
        self.visible_sub_project = visible_sub_project  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_ids_shrink is not None:
            result['LabelIds'] = self.label_ids_shrink
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.sink_endpoint_types_shrink is not None:
            result['SinkEndpointTypes'] = self.sink_endpoint_types_shrink
        if self.sort_field is not None:
            result['SortField'] = self.sort_field
        if self.source_endpoint_types_shrink is not None:
            result['SourceEndpointTypes'] = self.source_endpoint_types_shrink
        if self.status_shrink is not None:
            result['Status'] = self.status_shrink
        if self.type is not None:
            result['Type'] = self.type
        if self.visible_sub_project is not None:
            result['VisibleSubProject'] = self.visible_sub_project
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LabelIds') is not None:
            self.label_ids_shrink = m.get('LabelIds')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SinkEndpointTypes') is not None:
            self.sink_endpoint_types_shrink = m.get('SinkEndpointTypes')
        if m.get('SortField') is not None:
            self.sort_field = m.get('SortField')
        if m.get('SourceEndpointTypes') is not None:
            self.source_endpoint_types_shrink = m.get('SourceEndpointTypes')
        if m.get('Status') is not None:
            self.status_shrink = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VisibleSubProject') is not None:
            self.visible_sub_project = m.get('VisibleSubProject')
        return self


class ListProjectsResponseBodyDataAlarmStats(TeaModel):
    def __init__(self, alarm_content=None, alarming=None, open_monitor=None, recently_trigger_count=None,
                 rule_to_recently_trigger_count=None, target=None):
        self.alarm_content = alarm_content  # type: str
        self.alarming = alarming  # type: bool
        self.open_monitor = open_monitor  # type: bool
        self.recently_trigger_count = recently_trigger_count  # type: int
        self.rule_to_recently_trigger_count = rule_to_recently_trigger_count  # type: dict[str, int]
        self.target = target  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataAlarmStats, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_content is not None:
            result['AlarmContent'] = self.alarm_content
        if self.alarming is not None:
            result['Alarming'] = self.alarming
        if self.open_monitor is not None:
            result['OpenMonitor'] = self.open_monitor
        if self.recently_trigger_count is not None:
            result['RecentlyTriggerCount'] = self.recently_trigger_count
        if self.rule_to_recently_trigger_count is not None:
            result['RuleToRecentlyTriggerCount'] = self.rule_to_recently_trigger_count
        if self.target is not None:
            result['Target'] = self.target
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmContent') is not None:
            self.alarm_content = m.get('AlarmContent')
        if m.get('Alarming') is not None:
            self.alarming = m.get('Alarming')
        if m.get('OpenMonitor') is not None:
            self.open_monitor = m.get('OpenMonitor')
        if m.get('RecentlyTriggerCount') is not None:
            self.recently_trigger_count = m.get('RecentlyTriggerCount')
        if m.get('RuleToRecentlyTriggerCount') is not None:
            self.rule_to_recently_trigger_count = m.get('RuleToRecentlyTriggerCount')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        return self


class ListProjectsResponseBodyDataCommonTransferConfig(TeaModel):
    def __init__(self, active_active=None, data_works_business_name=None, datahub_topic_type=None,
                 mq_partition=None, mq_partition_mode=None, mq_serializer_type=None, rocket_mq_enable_msg_trace=None,
                 rocket_mq_msg_tags=None, rocket_mq_producer_group=None, rocket_mq_send_msg_timeout=None, table_category=None):
        self.active_active = active_active  # type: bool
        self.data_works_business_name = data_works_business_name  # type: str
        self.datahub_topic_type = datahub_topic_type  # type: str
        self.mq_partition = mq_partition  # type: int
        self.mq_partition_mode = mq_partition_mode  # type: str
        self.mq_serializer_type = mq_serializer_type  # type: str
        self.rocket_mq_enable_msg_trace = rocket_mq_enable_msg_trace  # type: bool
        self.rocket_mq_msg_tags = rocket_mq_msg_tags  # type: str
        self.rocket_mq_producer_group = rocket_mq_producer_group  # type: str
        self.rocket_mq_send_msg_timeout = rocket_mq_send_msg_timeout  # type: long
        self.table_category = table_category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataCommonTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_active is not None:
            result['ActiveActive'] = self.active_active
        if self.data_works_business_name is not None:
            result['DataWorksBusinessName'] = self.data_works_business_name
        if self.datahub_topic_type is not None:
            result['DatahubTopicType'] = self.datahub_topic_type
        if self.mq_partition is not None:
            result['MqPartition'] = self.mq_partition
        if self.mq_partition_mode is not None:
            result['MqPartitionMode'] = self.mq_partition_mode
        if self.mq_serializer_type is not None:
            result['MqSerializerType'] = self.mq_serializer_type
        if self.rocket_mq_enable_msg_trace is not None:
            result['RocketMqEnableMsgTrace'] = self.rocket_mq_enable_msg_trace
        if self.rocket_mq_msg_tags is not None:
            result['RocketMqMsgTags'] = self.rocket_mq_msg_tags
        if self.rocket_mq_producer_group is not None:
            result['RocketMqProducerGroup'] = self.rocket_mq_producer_group
        if self.rocket_mq_send_msg_timeout is not None:
            result['RocketMqSendMsgTimeout'] = self.rocket_mq_send_msg_timeout
        if self.table_category is not None:
            result['TableCategory'] = self.table_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActiveActive') is not None:
            self.active_active = m.get('ActiveActive')
        if m.get('DataWorksBusinessName') is not None:
            self.data_works_business_name = m.get('DataWorksBusinessName')
        if m.get('DatahubTopicType') is not None:
            self.datahub_topic_type = m.get('DatahubTopicType')
        if m.get('MqPartition') is not None:
            self.mq_partition = m.get('MqPartition')
        if m.get('MqPartitionMode') is not None:
            self.mq_partition_mode = m.get('MqPartitionMode')
        if m.get('MqSerializerType') is not None:
            self.mq_serializer_type = m.get('MqSerializerType')
        if m.get('RocketMqEnableMsgTrace') is not None:
            self.rocket_mq_enable_msg_trace = m.get('RocketMqEnableMsgTrace')
        if m.get('RocketMqMsgTags') is not None:
            self.rocket_mq_msg_tags = m.get('RocketMqMsgTags')
        if m.get('RocketMqProducerGroup') is not None:
            self.rocket_mq_producer_group = m.get('RocketMqProducerGroup')
        if m.get('RocketMqSendMsgTimeout') is not None:
            self.rocket_mq_send_msg_timeout = m.get('RocketMqSendMsgTimeout')
        if m.get('TableCategory') is not None:
            self.table_category = m.get('TableCategory')
        return self


class ListProjectsResponseBodyDataExtraInfo(TeaModel):
    def __init__(self, access_ob_source=None, ignore_unsupport_ddl=None, incr_sync_timestamp=None,
                 log_service_start_checkpoint=None, max_connector_count=None, monitoring_incr=None, overwrite_config=None,
                 reverse_subtopics=None, running_progress=None, running_step=None, source_store_kept_hour=None, store_incr=None,
                 sub_conds=None, sub_dbs=None, sub_ids=None, subtopics=None, sync_delay=None,
                 sync_delay_sample_timestamp=None):
        self.access_ob_source = access_ob_source  # type: bool
        self.ignore_unsupport_ddl = ignore_unsupport_ddl  # type: bool
        self.incr_sync_timestamp = incr_sync_timestamp  # type: long
        self.log_service_start_checkpoint = log_service_start_checkpoint  # type: long
        self.max_connector_count = max_connector_count  # type: int
        self.monitoring_incr = monitoring_incr  # type: bool
        self.overwrite_config = overwrite_config  # type: bool
        self.reverse_subtopics = reverse_subtopics  # type: list[str]
        self.running_progress = running_progress  # type: int
        self.running_step = running_step  # type: str
        self.source_store_kept_hour = source_store_kept_hour  # type: int
        self.store_incr = store_incr  # type: bool
        self.sub_conds = sub_conds  # type: dict[str, list[DataExtraInfoSubCondsValue]]
        self.sub_dbs = sub_dbs  # type: dict[str, list[DataExtraInfoSubDbsValue]]
        self.sub_ids = sub_ids  # type: dict[str, str]
        self.subtopics = subtopics  # type: list[str]
        self.sync_delay = sync_delay  # type: long
        self.sync_delay_sample_timestamp = sync_delay_sample_timestamp  # type: long

    def validate(self):
        if self.sub_conds:
            for v in self.sub_conds.values():
                for k1 in v:
                    if k1:
                        k1.validate()
        if self.sub_dbs:
            for v in self.sub_dbs.values():
                for k1 in v:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_ob_source is not None:
            result['AccessObSource'] = self.access_ob_source
        if self.ignore_unsupport_ddl is not None:
            result['IgnoreUnsupportDdl'] = self.ignore_unsupport_ddl
        if self.incr_sync_timestamp is not None:
            result['IncrSyncTimestamp'] = self.incr_sync_timestamp
        if self.log_service_start_checkpoint is not None:
            result['LogServiceStartCheckpoint'] = self.log_service_start_checkpoint
        if self.max_connector_count is not None:
            result['MaxConnectorCount'] = self.max_connector_count
        if self.monitoring_incr is not None:
            result['MonitoringIncr'] = self.monitoring_incr
        if self.overwrite_config is not None:
            result['OverwriteConfig'] = self.overwrite_config
        if self.reverse_subtopics is not None:
            result['ReverseSubtopics'] = self.reverse_subtopics
        if self.running_progress is not None:
            result['RunningProgress'] = self.running_progress
        if self.running_step is not None:
            result['RunningStep'] = self.running_step
        if self.source_store_kept_hour is not None:
            result['SourceStoreKeptHour'] = self.source_store_kept_hour
        if self.store_incr is not None:
            result['StoreIncr'] = self.store_incr
        result['SubConds'] = {}
        if self.sub_conds is not None:
            for k, v in self.sub_conds.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['subConds'][k] = l1
        result['SubDbs'] = {}
        if self.sub_dbs is not None:
            for k, v in self.sub_dbs.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['subDbs'][k] = l1
        if self.sub_ids is not None:
            result['SubIds'] = self.sub_ids
        if self.subtopics is not None:
            result['Subtopics'] = self.subtopics
        if self.sync_delay is not None:
            result['SyncDelay'] = self.sync_delay
        if self.sync_delay_sample_timestamp is not None:
            result['SyncDelaySampleTimestamp'] = self.sync_delay_sample_timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessObSource') is not None:
            self.access_ob_source = m.get('AccessObSource')
        if m.get('IgnoreUnsupportDdl') is not None:
            self.ignore_unsupport_ddl = m.get('IgnoreUnsupportDdl')
        if m.get('IncrSyncTimestamp') is not None:
            self.incr_sync_timestamp = m.get('IncrSyncTimestamp')
        if m.get('LogServiceStartCheckpoint') is not None:
            self.log_service_start_checkpoint = m.get('LogServiceStartCheckpoint')
        if m.get('MaxConnectorCount') is not None:
            self.max_connector_count = m.get('MaxConnectorCount')
        if m.get('MonitoringIncr') is not None:
            self.monitoring_incr = m.get('MonitoringIncr')
        if m.get('OverwriteConfig') is not None:
            self.overwrite_config = m.get('OverwriteConfig')
        if m.get('ReverseSubtopics') is not None:
            self.reverse_subtopics = m.get('ReverseSubtopics')
        if m.get('RunningProgress') is not None:
            self.running_progress = m.get('RunningProgress')
        if m.get('RunningStep') is not None:
            self.running_step = m.get('RunningStep')
        if m.get('SourceStoreKeptHour') is not None:
            self.source_store_kept_hour = m.get('SourceStoreKeptHour')
        if m.get('StoreIncr') is not None:
            self.store_incr = m.get('StoreIncr')
        self.sub_conds = {}
        if m.get('SubConds') is not None:
            for k, v in m.get('SubConds').items():
                l1 = []
                for k1 in v:
                    temp_model = DataExtraInfoSubCondsValue()
                    l1.append(temp_model.from_map(k1))
                self.sub_conds['k'] = l1
        self.sub_dbs = {}
        if m.get('SubDbs') is not None:
            for k, v in m.get('SubDbs').items():
                l1 = []
                for k1 in v:
                    temp_model = DataExtraInfoSubDbsValue()
                    l1.append(temp_model.from_map(k1))
                self.sub_dbs['k'] = l1
        if m.get('SubIds') is not None:
            self.sub_ids = m.get('SubIds')
        if m.get('Subtopics') is not None:
            self.subtopics = m.get('Subtopics')
        if m.get('SyncDelay') is not None:
            self.sync_delay = m.get('SyncDelay')
        if m.get('SyncDelaySampleTimestamp') is not None:
            self.sync_delay_sample_timestamp = m.get('SyncDelaySampleTimestamp')
        return self


class ListProjectsResponseBodyDataFullTransferConfig(TeaModel):
    def __init__(self, allow_dest_table_not_empty=None, full_transfer_speed_mode=None,
                 full_verify_speed_mode=None, none_pk_uk_truncate_dst_table=None):
        self.allow_dest_table_not_empty = allow_dest_table_not_empty  # type: bool
        self.full_transfer_speed_mode = full_transfer_speed_mode  # type: str
        self.full_verify_speed_mode = full_verify_speed_mode  # type: str
        self.none_pk_uk_truncate_dst_table = none_pk_uk_truncate_dst_table  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataFullTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_dest_table_not_empty is not None:
            result['AllowDestTableNotEmpty'] = self.allow_dest_table_not_empty
        if self.full_transfer_speed_mode is not None:
            result['FullTransferSpeedMode'] = self.full_transfer_speed_mode
        if self.full_verify_speed_mode is not None:
            result['FullVerifySpeedMode'] = self.full_verify_speed_mode
        if self.none_pk_uk_truncate_dst_table is not None:
            result['NonePkUkTruncateDstTable'] = self.none_pk_uk_truncate_dst_table
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowDestTableNotEmpty') is not None:
            self.allow_dest_table_not_empty = m.get('AllowDestTableNotEmpty')
        if m.get('FullTransferSpeedMode') is not None:
            self.full_transfer_speed_mode = m.get('FullTransferSpeedMode')
        if m.get('FullVerifySpeedMode') is not None:
            self.full_verify_speed_mode = m.get('FullVerifySpeedMode')
        if m.get('NonePkUkTruncateDstTable') is not None:
            self.none_pk_uk_truncate_dst_table = m.get('NonePkUkTruncateDstTable')
        return self


class ListProjectsResponseBodyDataIncrTransferConfig(TeaModel):
    def __init__(self, enable_incr_sync_statistics=None, enable_sequencing_within_txn=None,
                 incr_sync_concurrency=None, record_type_white_list=None, start_timestamp=None, store_log_kept_hour=None):
        self.enable_incr_sync_statistics = enable_incr_sync_statistics  # type: bool
        self.enable_sequencing_within_txn = enable_sequencing_within_txn  # type: bool
        self.incr_sync_concurrency = incr_sync_concurrency  # type: int
        self.record_type_white_list = record_type_white_list  # type: list[str]
        self.start_timestamp = start_timestamp  # type: long
        self.store_log_kept_hour = store_log_kept_hour  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataIncrTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_incr_sync_statistics is not None:
            result['EnableIncrSyncStatistics'] = self.enable_incr_sync_statistics
        if self.enable_sequencing_within_txn is not None:
            result['EnableSequencingWithinTxn'] = self.enable_sequencing_within_txn
        if self.incr_sync_concurrency is not None:
            result['IncrSyncConcurrency'] = self.incr_sync_concurrency
        if self.record_type_white_list is not None:
            result['RecordTypeWhiteList'] = self.record_type_white_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableIncrSyncStatistics') is not None:
            self.enable_incr_sync_statistics = m.get('EnableIncrSyncStatistics')
        if m.get('EnableSequencingWithinTxn') is not None:
            self.enable_sequencing_within_txn = m.get('EnableSequencingWithinTxn')
        if m.get('IncrSyncConcurrency') is not None:
            self.incr_sync_concurrency = m.get('IncrSyncConcurrency')
        if m.get('RecordTypeWhiteList') is not None:
            self.record_type_white_list = m.get('RecordTypeWhiteList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        return self


class ListProjectsResponseBodyDataLabels(TeaModel):
    def __init__(self, count=None, creator=None, id=None, name=None, type=None):
        self.count = count  # type: int
        self.creator = creator  # type: str
        self.id = id  # type: str
        self.name = name  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectsResponseBodyDataSinkConnectInfo(TeaModel):
    def __init__(self, charset=None, conn_extra_attributes=None, connection_info=None, db_engine=None,
                 endpoint_id=None, endpoint_name=None, endpoint_side=None, host=None, id=None, nls_length_semantics=None,
                 ocp_name=None, operating_system=None, owner=None, port=None, region=None, resource_owner=None, timezone=None,
                 username=None, version=None):
        self.charset = charset  # type: str
        self.conn_extra_attributes = conn_extra_attributes  # type: any
        self.connection_info = connection_info  # type: str
        self.db_engine = db_engine  # type: str
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_name = endpoint_name  # type: str
        self.endpoint_side = endpoint_side  # type: str
        self.host = host  # type: str
        self.id = id  # type: str
        self.nls_length_semantics = nls_length_semantics  # type: str
        self.ocp_name = ocp_name  # type: str
        self.operating_system = operating_system  # type: str
        # Owner。
        self.owner = owner  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.resource_owner = resource_owner  # type: str
        self.timezone = timezone  # type: str
        self.username = username  # type: str
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataSinkConnectInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.conn_extra_attributes is not None:
            result['ConnExtraAttributes'] = self.conn_extra_attributes
        if self.connection_info is not None:
            result['ConnectionInfo'] = self.connection_info
        if self.db_engine is not None:
            result['DbEngine'] = self.db_engine
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_side is not None:
            result['EndpointSide'] = self.endpoint_side
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.nls_length_semantics is not None:
            result['NlsLengthSemantics'] = self.nls_length_semantics
        if self.ocp_name is not None:
            result['OcpName'] = self.ocp_name
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_owner is not None:
            result['ResourceOwner'] = self.resource_owner
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.username is not None:
            result['Username'] = self.username
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ConnExtraAttributes') is not None:
            self.conn_extra_attributes = m.get('ConnExtraAttributes')
        if m.get('ConnectionInfo') is not None:
            self.connection_info = m.get('ConnectionInfo')
        if m.get('DbEngine') is not None:
            self.db_engine = m.get('DbEngine')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointSide') is not None:
            self.endpoint_side = m.get('EndpointSide')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NlsLengthSemantics') is not None:
            self.nls_length_semantics = m.get('NlsLengthSemantics')
        if m.get('OcpName') is not None:
            self.ocp_name = m.get('OcpName')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceOwner') is not None:
            self.resource_owner = m.get('ResourceOwner')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListProjectsResponseBodyDataSourceConnectInfo(TeaModel):
    def __init__(self, charset=None, conn_extra_attributes=None, connection_info=None, db_engine=None,
                 endpoint_id=None, endpoint_name=None, endpoint_side=None, host=None, id=None, nls_length_semantics=None,
                 ocp_name=None, operating_system=None, owner=None, port=None, region=None, resource_owner=None, timezone=None,
                 username=None, version=None):
        self.charset = charset  # type: str
        self.conn_extra_attributes = conn_extra_attributes  # type: any
        self.connection_info = connection_info  # type: str
        self.db_engine = db_engine  # type: str
        self.endpoint_id = endpoint_id  # type: str
        self.endpoint_name = endpoint_name  # type: str
        self.endpoint_side = endpoint_side  # type: str
        self.host = host  # type: str
        self.id = id  # type: str
        self.nls_length_semantics = nls_length_semantics  # type: str
        self.ocp_name = ocp_name  # type: str
        self.operating_system = operating_system  # type: str
        # Owner。
        self.owner = owner  # type: str
        self.port = port  # type: int
        self.region = region  # type: str
        self.resource_owner = resource_owner  # type: str
        self.timezone = timezone  # type: str
        self.username = username  # type: str
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataSourceConnectInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.conn_extra_attributes is not None:
            result['ConnExtraAttributes'] = self.conn_extra_attributes
        if self.connection_info is not None:
            result['ConnectionInfo'] = self.connection_info
        if self.db_engine is not None:
            result['DbEngine'] = self.db_engine
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_name is not None:
            result['EndpointName'] = self.endpoint_name
        if self.endpoint_side is not None:
            result['EndpointSide'] = self.endpoint_side
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.nls_length_semantics is not None:
            result['NlsLengthSemantics'] = self.nls_length_semantics
        if self.ocp_name is not None:
            result['OcpName'] = self.ocp_name
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.port is not None:
            result['Port'] = self.port
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_owner is not None:
            result['ResourceOwner'] = self.resource_owner
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.username is not None:
            result['Username'] = self.username
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ConnExtraAttributes') is not None:
            self.conn_extra_attributes = m.get('ConnExtraAttributes')
        if m.get('ConnectionInfo') is not None:
            self.connection_info = m.get('ConnectionInfo')
        if m.get('DbEngine') is not None:
            self.db_engine = m.get('DbEngine')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointName') is not None:
            self.endpoint_name = m.get('EndpointName')
        if m.get('EndpointSide') is not None:
            self.endpoint_side = m.get('EndpointSide')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NlsLengthSemantics') is not None:
            self.nls_length_semantics = m.get('NlsLengthSemantics')
        if m.get('OcpName') is not None:
            self.ocp_name = m.get('OcpName')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceOwner') is not None:
            self.resource_owner = m.get('ResourceOwner')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListProjectsResponseBodyDataStepsExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataStepsExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListProjectsResponseBodyDataStepsExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        self.error_code = error_code  # type: str
        self.error_details = error_details  # type: list[ListProjectsResponseBodyDataStepsExtraInfoErrorDetails]
        self.error_msg = error_msg  # type: str
        self.error_param = error_param  # type: dict[str, str]
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataStepsExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = ListProjectsResponseBodyDataStepsExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class ListProjectsResponseBodyDataSteps(TeaModel):
    def __init__(self, description=None, extra_info=None, finish_time=None, name=None, order=None, progress=None,
                 start_time=None, status=None, step_info=None):
        self.description = description  # type: str
        self.extra_info = extra_info  # type: ListProjectsResponseBodyDataStepsExtraInfo
        self.finish_time = finish_time  # type: str
        self.name = name  # type: str
        self.order = order  # type: int
        self.progress = progress  # type: int
        self.start_time = start_time  # type: str
        self.status = status  # type: str
        self.step_info = step_info  # type: dict[str, any]

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataSteps, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.step_info is not None:
            result['StepInfo'] = self.step_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExtraInfo') is not None:
            temp_model = ListProjectsResponseBodyDataStepsExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StepInfo') is not None:
            self.step_info = m.get('StepInfo')
        return self


class ListProjectsResponseBodyDataStructTransferConfig(TeaModel):
    def __init__(self, byte_char_convert_strategy=None, defer_index_creation=None):
        self.byte_char_convert_strategy = byte_char_convert_strategy  # type: str
        self.defer_index_creation = defer_index_creation  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataStructTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.byte_char_convert_strategy is not None:
            result['ByteCharConvertStrategy'] = self.byte_char_convert_strategy
        if self.defer_index_creation is not None:
            result['DeferIndexCreation'] = self.defer_index_creation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ByteCharConvertStrategy') is not None:
            self.byte_char_convert_strategy = m.get('ByteCharConvertStrategy')
        if m.get('DeferIndexCreation') is not None:
            self.defer_index_creation = m.get('DeferIndexCreation')
        return self


class ListProjectsResponseBodyDataTransferMapping(TeaModel):
    def __init__(self, mode=None):
        self.mode = mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyDataTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class ListProjectsResponseBodyData(TeaModel):
    def __init__(self, alarm_stats=None, common_transfer_config=None, dest_conn_id=None, enable_full_transfer=None,
                 enable_full_verify=None, enable_incr_transfer=None, enable_incr_verify=None, enable_reverse_incr_transfer=None,
                 enable_struct_transfer=None, extra_info=None, full_transfer_config=None, gmt_create=None, gmt_finish=None,
                 gmt_modified=None, gmt_start=None, id=None, importance=None, incr_transfer_config=None, is_merging=None,
                 is_modifying=None, is_sub_project=None, labels=None, name=None, owner=None, sink_connect_info=None,
                 sink_endpoint_type=None, source_connect_info=None, source_endpoint_type=None, status=None, steps=None,
                 struct_transfer_config=None, transfer_mapping=None, type=None, worker_grade_id=None):
        self.alarm_stats = alarm_stats  # type: ListProjectsResponseBodyDataAlarmStats
        self.common_transfer_config = common_transfer_config  # type: ListProjectsResponseBodyDataCommonTransferConfig
        self.dest_conn_id = dest_conn_id  # type: str
        self.enable_full_transfer = enable_full_transfer  # type: bool
        self.enable_full_verify = enable_full_verify  # type: bool
        self.enable_incr_transfer = enable_incr_transfer  # type: bool
        self.enable_incr_verify = enable_incr_verify  # type: bool
        self.enable_reverse_incr_transfer = enable_reverse_incr_transfer  # type: bool
        self.enable_struct_transfer = enable_struct_transfer  # type: bool
        self.extra_info = extra_info  # type: ListProjectsResponseBodyDataExtraInfo
        self.full_transfer_config = full_transfer_config  # type: ListProjectsResponseBodyDataFullTransferConfig
        self.gmt_create = gmt_create  # type: str
        self.gmt_finish = gmt_finish  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.gmt_start = gmt_start  # type: str
        self.id = id  # type: str
        self.importance = importance  # type: str
        self.incr_transfer_config = incr_transfer_config  # type: ListProjectsResponseBodyDataIncrTransferConfig
        self.is_merging = is_merging  # type: bool
        self.is_modifying = is_modifying  # type: bool
        self.is_sub_project = is_sub_project  # type: bool
        self.labels = labels  # type: list[ListProjectsResponseBodyDataLabels]
        self.name = name  # type: str
        self.owner = owner  # type: str
        self.sink_connect_info = sink_connect_info  # type: ListProjectsResponseBodyDataSinkConnectInfo
        self.sink_endpoint_type = sink_endpoint_type  # type: str
        self.source_connect_info = source_connect_info  # type: ListProjectsResponseBodyDataSourceConnectInfo
        self.source_endpoint_type = source_endpoint_type  # type: str
        self.status = status  # type: str
        self.steps = steps  # type: list[ListProjectsResponseBodyDataSteps]
        self.struct_transfer_config = struct_transfer_config  # type: ListProjectsResponseBodyDataStructTransferConfig
        self.transfer_mapping = transfer_mapping  # type: ListProjectsResponseBodyDataTransferMapping
        self.type = type  # type: str
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        if self.alarm_stats:
            self.alarm_stats.validate()
        if self.common_transfer_config:
            self.common_transfer_config.validate()
        if self.extra_info:
            self.extra_info.validate()
        if self.full_transfer_config:
            self.full_transfer_config.validate()
        if self.incr_transfer_config:
            self.incr_transfer_config.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.sink_connect_info:
            self.sink_connect_info.validate()
        if self.source_connect_info:
            self.source_connect_info.validate()
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()
        if self.struct_transfer_config:
            self.struct_transfer_config.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()

    def to_map(self):
        _map = super(ListProjectsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_stats is not None:
            result['AlarmStats'] = self.alarm_stats.to_map()
        if self.common_transfer_config is not None:
            result['CommonTransferConfig'] = self.common_transfer_config.to_map()
        if self.dest_conn_id is not None:
            result['DestConnId'] = self.dest_conn_id
        if self.enable_full_transfer is not None:
            result['EnableFullTransfer'] = self.enable_full_transfer
        if self.enable_full_verify is not None:
            result['EnableFullVerify'] = self.enable_full_verify
        if self.enable_incr_transfer is not None:
            result['EnableIncrTransfer'] = self.enable_incr_transfer
        if self.enable_incr_verify is not None:
            result['EnableIncrVerify'] = self.enable_incr_verify
        if self.enable_reverse_incr_transfer is not None:
            result['EnableReverseIncrTransfer'] = self.enable_reverse_incr_transfer
        if self.enable_struct_transfer is not None:
            result['EnableStructTransfer'] = self.enable_struct_transfer
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.full_transfer_config is not None:
            result['FullTransferConfig'] = self.full_transfer_config.to_map()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_finish is not None:
            result['GmtFinish'] = self.gmt_finish
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['GmtStart'] = self.gmt_start
        if self.id is not None:
            result['Id'] = self.id
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.incr_transfer_config is not None:
            result['IncrTransferConfig'] = self.incr_transfer_config.to_map()
        if self.is_merging is not None:
            result['IsMerging'] = self.is_merging
        if self.is_modifying is not None:
            result['IsModifying'] = self.is_modifying
        if self.is_sub_project is not None:
            result['IsSubProject'] = self.is_sub_project
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.sink_connect_info is not None:
            result['SinkConnectInfo'] = self.sink_connect_info.to_map()
        if self.sink_endpoint_type is not None:
            result['SinkEndpointType'] = self.sink_endpoint_type
        if self.source_connect_info is not None:
            result['SourceConnectInfo'] = self.source_connect_info.to_map()
        if self.source_endpoint_type is not None:
            result['SourceEndpointType'] = self.source_endpoint_type
        if self.status is not None:
            result['Status'] = self.status
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.struct_transfer_config is not None:
            result['StructTransferConfig'] = self.struct_transfer_config.to_map()
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmStats') is not None:
            temp_model = ListProjectsResponseBodyDataAlarmStats()
            self.alarm_stats = temp_model.from_map(m['AlarmStats'])
        if m.get('CommonTransferConfig') is not None:
            temp_model = ListProjectsResponseBodyDataCommonTransferConfig()
            self.common_transfer_config = temp_model.from_map(m['CommonTransferConfig'])
        if m.get('DestConnId') is not None:
            self.dest_conn_id = m.get('DestConnId')
        if m.get('EnableFullTransfer') is not None:
            self.enable_full_transfer = m.get('EnableFullTransfer')
        if m.get('EnableFullVerify') is not None:
            self.enable_full_verify = m.get('EnableFullVerify')
        if m.get('EnableIncrTransfer') is not None:
            self.enable_incr_transfer = m.get('EnableIncrTransfer')
        if m.get('EnableIncrVerify') is not None:
            self.enable_incr_verify = m.get('EnableIncrVerify')
        if m.get('EnableReverseIncrTransfer') is not None:
            self.enable_reverse_incr_transfer = m.get('EnableReverseIncrTransfer')
        if m.get('EnableStructTransfer') is not None:
            self.enable_struct_transfer = m.get('EnableStructTransfer')
        if m.get('ExtraInfo') is not None:
            temp_model = ListProjectsResponseBodyDataExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FullTransferConfig') is not None:
            temp_model = ListProjectsResponseBodyDataFullTransferConfig()
            self.full_transfer_config = temp_model.from_map(m['FullTransferConfig'])
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtFinish') is not None:
            self.gmt_finish = m.get('GmtFinish')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtStart') is not None:
            self.gmt_start = m.get('GmtStart')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('IncrTransferConfig') is not None:
            temp_model = ListProjectsResponseBodyDataIncrTransferConfig()
            self.incr_transfer_config = temp_model.from_map(m['IncrTransferConfig'])
        if m.get('IsMerging') is not None:
            self.is_merging = m.get('IsMerging')
        if m.get('IsModifying') is not None:
            self.is_modifying = m.get('IsModifying')
        if m.get('IsSubProject') is not None:
            self.is_sub_project = m.get('IsSubProject')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = ListProjectsResponseBodyDataLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('SinkConnectInfo') is not None:
            temp_model = ListProjectsResponseBodyDataSinkConnectInfo()
            self.sink_connect_info = temp_model.from_map(m['SinkConnectInfo'])
        if m.get('SinkEndpointType') is not None:
            self.sink_endpoint_type = m.get('SinkEndpointType')
        if m.get('SourceConnectInfo') is not None:
            temp_model = ListProjectsResponseBodyDataSourceConnectInfo()
            self.source_connect_info = temp_model.from_map(m['SourceConnectInfo'])
        if m.get('SourceEndpointType') is not None:
            self.source_endpoint_type = m.get('SourceEndpointType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = ListProjectsResponseBodyDataSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('StructTransferConfig') is not None:
            temp_model = ListProjectsResponseBodyDataStructTransferConfig()
            self.struct_transfer_config = temp_model.from_map(m['StructTransferConfig'])
        if m.get('TransferMapping') is not None:
            temp_model = ListProjectsResponseBodyDataTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class ListProjectsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListProjectsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListProjectsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: list[ListProjectsResponseBodyData]
        self.error_detail = error_detail  # type: ListProjectsResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ListProjectsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListProjectsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = ListProjectsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListProjectsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListProjectsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkerInstancesRequest(TeaModel):
    def __init__(self, dest_type=None, instance_name=None, only_bindable=None, page_number=None, page_size=None,
                 source_type=None, specs=None):
        self.dest_type = dest_type  # type: str
        self.instance_name = instance_name  # type: str
        self.only_bindable = only_bindable  # type: bool
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.source_type = source_type  # type: str
        self.specs = specs  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkerInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_type is not None:
            result['DestType'] = self.dest_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.only_bindable is not None:
            result['OnlyBindable'] = self.only_bindable
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.specs is not None:
            result['Specs'] = self.specs
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestType') is not None:
            self.dest_type = m.get('DestType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OnlyBindable') is not None:
            self.only_bindable = m.get('OnlyBindable')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Specs') is not None:
            self.specs = m.get('Specs')
        return self


class ListWorkerInstancesShrinkRequest(TeaModel):
    def __init__(self, dest_type=None, instance_name=None, only_bindable=None, page_number=None, page_size=None,
                 source_type=None, specs_shrink=None):
        self.dest_type = dest_type  # type: str
        self.instance_name = instance_name  # type: str
        self.only_bindable = only_bindable  # type: bool
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.source_type = source_type  # type: str
        self.specs_shrink = specs_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkerInstancesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_type is not None:
            result['DestType'] = self.dest_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.only_bindable is not None:
            result['OnlyBindable'] = self.only_bindable
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.specs_shrink is not None:
            result['Specs'] = self.specs_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestType') is not None:
            self.dest_type = m.get('DestType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OnlyBindable') is not None:
            self.only_bindable = m.get('OnlyBindable')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Specs') is not None:
            self.specs_shrink = m.get('Specs')
        return self


class ListWorkerInstancesResponseBodyData(TeaModel):
    def __init__(self, gmt_create=None, id=None, name=None, project_id=None, project_name=None, project_type=None,
                 region=None, spec=None, status=None):
        self.gmt_create = gmt_create  # type: str
        self.id = id  # type: str
        self.name = name  # type: str
        self.project_id = project_id  # type: str
        self.project_name = project_name  # type: str
        self.project_type = project_type  # type: str
        self.region = region  # type: str
        self.spec = spec  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkerInstancesResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.region is not None:
            result['Region'] = self.region
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListWorkerInstancesResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListWorkerInstancesResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ListWorkerInstancesResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: list[ListWorkerInstancesResponseBodyData]
        self.error_detail = error_detail  # type: ListWorkerInstancesResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ListWorkerInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListWorkerInstancesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = ListWorkerInstancesResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListWorkerInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListWorkerInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListWorkerInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDatabaseDescriptionRequest(TeaModel):
    def __init__(self, database_name=None, description=None, instance_id=None, tenant_id=None):
        # Example 1
        self.database_name = database_name  # type: str
        self.description = description  # type: str
        # The description of the database.
        self.instance_id = instance_id  # type: str
        # The operation that you want to perform.   
        # Set the value to **ModifyDatabaseDescription**.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDatabaseDescriptionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyDatabaseDescriptionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDatabaseDescriptionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDatabaseDescriptionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDatabaseDescriptionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDatabaseDescriptionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDatabaseDescriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDatabaseUserRolesRequest(TeaModel):
    def __init__(self, database_name=None, instance_id=None, tenant_id=None, users=None):
        # The ID of the tenant.
        self.database_name = database_name  # type: str
        # The account information.
        self.instance_id = instance_id  # type: str
        # A list of usernames and their respective roles.
        self.tenant_id = tenant_id  # type: str
        # The ID of the OceanBase cluster.
        self.users = users  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDatabaseUserRolesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class ModifyDatabaseUserRolesResponseBodyTenantUserUsers(TeaModel):
    def __init__(self, role=None, user_name=None):
        self.role = role  # type: str
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDatabaseUserRolesResponseBodyTenantUserUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role is not None:
            result['Role'] = self.role
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ModifyDatabaseUserRolesResponseBodyTenantUser(TeaModel):
    def __init__(self, database_name=None, tenant_id=None, users=None):
        # Example 1
        self.database_name = database_name  # type: str
        self.tenant_id = tenant_id  # type: str
        self.users = users  # type: list[ModifyDatabaseUserRolesResponseBodyTenantUserUsers]

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyDatabaseUserRolesResponseBodyTenantUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ModifyDatabaseUserRolesResponseBodyTenantUserUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ModifyDatabaseUserRolesResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_user=None):
        self.request_id = request_id  # type: str
        # The name of the database.
        self.tenant_user = tenant_user  # type: ModifyDatabaseUserRolesResponseBodyTenantUser

    def validate(self):
        if self.tenant_user:
            self.tenant_user.validate()

    def to_map(self):
        _map = super(ModifyDatabaseUserRolesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_user is not None:
            result['TenantUser'] = self.tenant_user.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantUser') is not None:
            temp_model = ModifyDatabaseUserRolesResponseBodyTenantUser()
            self.tenant_user = temp_model.from_map(m['TenantUser'])
        return self


class ModifyDatabaseUserRolesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDatabaseUserRolesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDatabaseUserRolesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDatabaseUserRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceNameRequest(TeaModel):
    def __init__(self, instance_id=None, instance_name=None):
        # It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
        self.instance_id = instance_id  # type: str
        # The ID of the OceanBase cluster.
        self.instance_name = instance_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class ModifyInstanceNameResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The operation that you want to perform.   
        # Set the value to **ModifyInstanceName**.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceNodeNumRequest(TeaModel):
    def __init__(self, dry_run=None, instance_id=None, node_num=None):
        self.dry_run = dry_run  # type: bool
        self.instance_id = instance_id  # type: str
        self.node_num = node_num  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNodeNumRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        return self


class ModifyInstanceNodeNumResponseBodyData(TeaModel):
    def __init__(self, dry_run_result=None, order_id=None):
        self.dry_run_result = dry_run_result  # type: bool
        self.order_id = order_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNodeNumResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run_result is not None:
            result['DryRunResult'] = self.dry_run_result
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRunResult') is not None:
            self.dry_run_result = m.get('DryRunResult')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        return self


class ModifyInstanceNodeNumResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: ModifyInstanceNodeNumResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(ModifyInstanceNodeNumResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ModifyInstanceNodeNumResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceNodeNumResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceNodeNumResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceNodeNumResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceNodeNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceSpecRequest(TeaModel):
    def __init__(self, disk_size=None, disk_type=None, dry_run=None, instance_class=None, instance_id=None):
        self.disk_size = disk_size  # type: long
        self.disk_type = disk_type  # type: str
        self.dry_run = dry_run  # type: bool
        self.instance_class = instance_class  # type: str
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_class is not None:
            result['InstanceClass'] = self.instance_class
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceClass') is not None:
            self.instance_class = m.get('InstanceClass')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ModifyInstanceSpecResponseBodyData(TeaModel):
    def __init__(self, dry_run_result=None, order_id=None):
        self.dry_run_result = dry_run_result  # type: bool
        self.order_id = order_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceSpecResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run_result is not None:
            result['DryRunResult'] = self.dry_run_result
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRunResult') is not None:
            self.dry_run_result = m.get('DryRunResult')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        return self


class ModifyInstanceSpecResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: ModifyInstanceSpecResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(ModifyInstanceSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ModifyInstanceSpecResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceTagsRequest(TeaModel):
    def __init__(self, instance_id=None, tags=None):
        # The tags.
        self.instance_id = instance_id  # type: str
        # You can call this operation to modify the value of the cluster tags.
        self.tags = tags  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ModifyInstanceTagsResponseBody(TeaModel):
    def __init__(self, message=None, request_id=None):
        self.message = message  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceTemporaryCapacityRequest(TeaModel):
    def __init__(self, accept_language=None, disk_size=None, instance_id=None, spec=None):
        self.accept_language = accept_language  # type: str
        # The disk size. Unit: GB.
        self.disk_size = disk_size  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # Specification.
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceTemporaryCapacityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class ModifyInstanceTemporaryCapacityResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceTemporaryCapacityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceTemporaryCapacityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceTemporaryCapacityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceTemporaryCapacityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceTemporaryCapacityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyParametersRequest(TeaModel):
    def __init__(self, dimension=None, dimension_value=None, instance_id=None, parameters=None):
        # The ID of the OceanBase cluster.
        self.dimension = dimension  # type: str
        # The cause of the modification failure.
        self.dimension_value = dimension_value  # type: str
        # Alibaba Cloud CLI
        self.instance_id = instance_id  # type: str
        # The resource ID of the parameter type.    
        # You can leave this parameter unspecified when you call this operation to modify cluster parameters. In the case of tenant parameters, pass the tenant ID.
        self.parameters = parameters  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyParametersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.dimension_value is not None:
            result['DimensionValue'] = self.dimension_value
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('DimensionValue') is not None:
            self.dimension_value = m.get('DimensionValue')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class ModifyParametersResponseBodyResults(TeaModel):
    def __init__(self, message=None, success=None):
        self.message = message  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyParametersResponseBodyResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyParametersResponseBody(TeaModel):
    def __init__(self, request_id=None, results=None):
        # The operation that you want to perform.   
        # Set the value to **ModifyParameters**.
        self.request_id = request_id  # type: str
        # Example 1
        self.results = results  # type: ModifyParametersResponseBodyResults

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super(ModifyParametersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Results') is not None:
            temp_model = ModifyParametersResponseBodyResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class ModifyParametersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyParametersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyParametersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyParametersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityIpsRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The information of the IP address whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The list of IP addresses and CIDR blocks in the whitelist.   
        # It is a JSON array. Each object in the array is an IP address or CIDR block. You can specify at most 40 IP addresses or CIDR blocks.
        self.security_ips = security_ips  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityIpsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        return self


class ModifySecurityIpsResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None):
        self.instance_id = instance_id  # type: str
        self.security_ip_group_name = security_ip_group_name  # type: str
        self.security_ips = security_ips  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityIpsResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        return self


class ModifySecurityIpsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # Example 1
        self.security_ip_group = security_ip_group  # type: ModifySecurityIpsResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(ModifySecurityIpsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = ModifySecurityIpsResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class ModifySecurityIpsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityIpsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityIpsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityIpsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantEncryptionRequest(TeaModel):
    def __init__(self, encryption_key_id=None, encryption_type=None, instance_id=None, tenant_id=None):
        self.encryption_key_id = encryption_key_id  # type: str
        self.encryption_type = encryption_type  # type: str
        self.instance_id = instance_id  # type: str
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantEncryptionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encryption_key_id is not None:
            result['EncryptionKeyId'] = self.encryption_key_id
        if self.encryption_type is not None:
            result['EncryptionType'] = self.encryption_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EncryptionKeyId') is not None:
            self.encryption_key_id = m.get('EncryptionKeyId')
        if m.get('EncryptionType') is not None:
            self.encryption_type = m.get('EncryptionType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantEncryptionResponseBodyTenantEncryption(TeaModel):
    def __init__(self, encryption_type=None, instance_id=None, tenant_id=None):
        self.encryption_type = encryption_type  # type: str
        self.instance_id = instance_id  # type: str
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantEncryptionResponseBodyTenantEncryption, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encryption_type is not None:
            result['EncryptionType'] = self.encryption_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EncryptionType') is not None:
            self.encryption_type = m.get('EncryptionType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantEncryptionResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_encryption=None):
        # Id of the request
        self.request_id = request_id  # type: str
        # job
        self.tenant_encryption = tenant_encryption  # type: ModifyTenantEncryptionResponseBodyTenantEncryption

    def validate(self):
        if self.tenant_encryption:
            self.tenant_encryption.validate()

    def to_map(self):
        _map = super(ModifyTenantEncryptionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_encryption is not None:
            result['TenantEncryption'] = self.tenant_encryption.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantEncryption') is not None:
            temp_model = ModifyTenantEncryptionResponseBodyTenantEncryption()
            self.tenant_encryption = temp_model.from_map(m['TenantEncryption'])
        return self


class ModifyTenantEncryptionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantEncryptionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantEncryptionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantEncryptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantPrimaryZoneRequest(TeaModel):
    def __init__(self, instance_id=None, master_intranet_address_zone=None, primary_zone=None,
                 tenant_endpoint_direct_id=None, tenant_endpoint_id=None, tenant_id=None, user_direct_vswitch_id=None, user_vswitch_id=None):
        # The primary zone of the tenant.    
        # It is one of the zones in which the cluster is deployed.
        self.instance_id = instance_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=ModifyTenantPrimaryZone
        # &TenantId=ob2mr3oae0****\
        # &InstanceId=ob317v4uif****\
        # &PrimaryZone=cn-hangzhou-h
        # &Common request parameters
        # ```
        self.master_intranet_address_zone = master_intranet_address_zone  # type: str
        # The ID of the vSwitch.
        self.primary_zone = primary_zone  # type: str
        self.tenant_endpoint_direct_id = tenant_endpoint_direct_id  # type: str
        self.tenant_endpoint_id = tenant_endpoint_id  # type: str
        # The return result of the request.
        self.tenant_id = tenant_id  # type: str
        self.user_direct_vswitch_id = user_direct_vswitch_id  # type: str
        # The request ID.
        self.user_vswitch_id = user_vswitch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantPrimaryZoneRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.master_intranet_address_zone is not None:
            result['MasterIntranetAddressZone'] = self.master_intranet_address_zone
        if self.primary_zone is not None:
            result['PrimaryZone'] = self.primary_zone
        if self.tenant_endpoint_direct_id is not None:
            result['TenantEndpointDirectId'] = self.tenant_endpoint_direct_id
        if self.tenant_endpoint_id is not None:
            result['TenantEndpointId'] = self.tenant_endpoint_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_direct_vswitch_id is not None:
            result['UserDirectVSwitchId'] = self.user_direct_vswitch_id
        if self.user_vswitch_id is not None:
            result['UserVSwitchId'] = self.user_vswitch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MasterIntranetAddressZone') is not None:
            self.master_intranet_address_zone = m.get('MasterIntranetAddressZone')
        if m.get('PrimaryZone') is not None:
            self.primary_zone = m.get('PrimaryZone')
        if m.get('TenantEndpointDirectId') is not None:
            self.tenant_endpoint_direct_id = m.get('TenantEndpointDirectId')
        if m.get('TenantEndpointId') is not None:
            self.tenant_endpoint_id = m.get('TenantEndpointId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserDirectVSwitchId') is not None:
            self.user_direct_vswitch_id = m.get('UserDirectVSwitchId')
        if m.get('UserVSwitchId') is not None:
            self.user_vswitch_id = m.get('UserVSwitchId')
        return self


class ModifyTenantPrimaryZoneResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantPrimaryZoneResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTenantPrimaryZoneResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantPrimaryZoneResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantPrimaryZoneResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantPrimaryZoneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantResourceRequest(TeaModel):
    def __init__(self, cpu=None, instance_id=None, log_disk=None, memory=None, read_only_zone_list=None,
                 tenant_id=None):
        # The memory size of the tenant, in GB.
        self.cpu = cpu  # type: int
        # The operation that you want to perform.   
        # Set the value to **ModifyTenantResource**.
        self.instance_id = instance_id  # type: str
        self.log_disk = log_disk  # type: long
        # The ID of the tenant.
        self.memory = memory  # type: int
        self.read_only_zone_list = read_only_zone_list  # type: str
        # The information about the CPU resources of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantResourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.log_disk is not None:
            result['LogDisk'] = self.log_disk
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.read_only_zone_list is not None:
            result['ReadOnlyZoneList'] = self.read_only_zone_list
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LogDisk') is not None:
            self.log_disk = m.get('LogDisk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('ReadOnlyZoneList') is not None:
            self.read_only_zone_list = m.get('ReadOnlyZoneList')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantResourceResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_id=None):
        self.request_id = request_id  # type: str
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantResourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantResourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantResourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantResourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantSecurityIpGroupRequest(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The group name of the whitelist group of IP addresses.
        # 
        # It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The list of IP addresses in the whitelist group.
        # 
        # It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
        self.security_ips = security_ips  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantSecurityIpGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup(TeaModel):
    def __init__(self, instance_id=None, security_ip_group_name=None, security_ips=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The name of the whitelist group.
        self.security_ip_group_name = security_ip_group_name  # type: str
        # The list of IP addresses in the IP address whitelist group.
        # 
        # It is a string separated by commas, and each object is an IP address or a CIDR block.
        self.security_ips = security_ips  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.security_ip_group_name is not None:
            result['SecurityIpGroupName'] = self.security_ip_group_name
        if self.security_ips is not None:
            result['SecurityIps'] = self.security_ips
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SecurityIpGroupName') is not None:
            self.security_ip_group_name = m.get('SecurityIpGroupName')
        if m.get('SecurityIps') is not None:
            self.security_ips = m.get('SecurityIps')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantSecurityIpGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_ip_group=None):
        # The request ID.
        self.request_id = request_id  # type: str
        # The information of the IP address whitelist group.
        self.security_ip_group = security_ip_group  # type: ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup

    def validate(self):
        if self.security_ip_group:
            self.security_ip_group.validate()

    def to_map(self):
        _map = super(ModifyTenantSecurityIpGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_ip_group is not None:
            result['SecurityIpGroup'] = self.security_ip_group.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityIpGroup') is not None:
            temp_model = ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup()
            self.security_ip_group = temp_model.from_map(m['SecurityIpGroup'])
        return self


class ModifyTenantSecurityIpGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantSecurityIpGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantSecurityIpGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantSecurityIpGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantTagsRequest(TeaModel):
    def __init__(self, instance_id=None, tags=None, tenant_id=None):
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The tags.
        self.tags = tags  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ModifyTenantTagsResponseBody(TeaModel):
    def __init__(self, message=None, request_id=None):
        # The update status of the tags.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTenantTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantUserDescriptionRequest(TeaModel):
    def __init__(self, description=None, instance_id=None, tenant_id=None, user_name=None):
        # The operation that you want to perform.   
        # Set the value to **ModifyTenantUserDescription**.
        self.description = description  # type: str
        # The ID of the OceanBase cluster.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # The description of the database.
        self.user_name = user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserDescriptionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ModifyTenantUserDescriptionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # You can call this operation to modify the description of a specified account in a tenant.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserDescriptionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTenantUserDescriptionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantUserDescriptionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantUserDescriptionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantUserDescriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantUserPasswordRequest(TeaModel):
    def __init__(self, encryption_type=None, instance_id=None, tenant_id=None, user_name=None, user_password=None):
        # 加密方式。
        self.encryption_type = encryption_type  # type: str
        self.instance_id = instance_id  # type: str
        # ```
        # http(s)://[Endpoint]/?Action=ModifyTenantUserPassword
        # &UserName=pay_test
        # &TenantId=ob2mr3oae0****\
        # &UserPassword=!Aliyun4Oceanbase
        # &InstanceId=ob317v4uif****\
        # &Common request parameters
        # ```
        self.tenant_id = tenant_id  # type: str
        # The ID of the OceanBase cluster.
        self.user_name = user_name  # type: str
        # You can call this operation to change the logon password of a specified account in a tenant.
        self.user_password = user_password  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserPasswordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encryption_type is not None:
            result['EncryptionType'] = self.encryption_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_password is not None:
            result['UserPassword'] = self.user_password
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EncryptionType') is not None:
            self.encryption_type = m.get('EncryptionType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserPassword') is not None:
            self.user_password = m.get('UserPassword')
        return self


class ModifyTenantUserPasswordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserPasswordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTenantUserPasswordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantUserPasswordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantUserPasswordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantUserPasswordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantUserRolesRequest(TeaModel):
    def __init__(self, instance_id=None, modify_type=None, tenant_id=None, user_name=None, user_role=None):
        # The type of the privilege modification operation.   
        # Valid values:  
        # update: updates all privileges. This is the default value.  
        # add: adds a privilege.  
        # delete: deletes a privilege.
        self.instance_id = instance_id  # type: str
        # The name of the table.
        self.modify_type = modify_type  # type: str
        # The operation that you want to perform.   
        # Set the value to **ModifyTenantUserRoles**.
        self.tenant_id = tenant_id  # type: str
        # The role of the database account.
        self.user_name = user_name  # type: str
        # The type of the account. Valid values:   
        # - Admin: the super administrator account.   
        # - Normal: a general account.
        self.user_role = user_role  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserRolesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.modify_type is not None:
            result['ModifyType'] = self.modify_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_role is not None:
            result['UserRole'] = self.user_role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModifyType') is not None:
            self.modify_type = m.get('ModifyType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserRole') is not None:
            self.user_role = m.get('UserRole')
        return self


class ModifyTenantUserRolesResponseBodyTenantUserUserRole(TeaModel):
    def __init__(self, database=None, is_success=None, role=None, table=None):
        # ```
        # http(s)://[Endpoint]/?Action=ModifyTenantUserRoles
        # &UserName=pay_test
        # &TenantId=ob2mr3oae0****\
        # &UserRole=[{"Database":"20210824160559","Role":"readwrite"}]
        # &InstanceId=ob317v4uif****\
        # &ModifyType=update
        # &Common request parameters
        # ```
        self.database = database  # type: str
        self.is_success = is_success  # type: bool
        # You can call this operation to modify the database privileges of a specified account in a tenant.
        self.role = role  # type: str
        self.table = table  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserRolesResponseBodyTenantUserUserRole, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.role is not None:
            result['Role'] = self.role
        if self.table is not None:
            result['Table'] = self.table
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Table') is not None:
            self.table = m.get('Table')
        return self


class ModifyTenantUserRolesResponseBodyTenantUser(TeaModel):
    def __init__(self, tenant_id=None, user_name=None, user_role=None):
        self.tenant_id = tenant_id  # type: str
        self.user_name = user_name  # type: str
        # The name of the database (MySQL mode) or schema (Oracle mode).
        self.user_role = user_role  # type: list[ModifyTenantUserRolesResponseBodyTenantUserUserRole]

    def validate(self):
        if self.user_role:
            for k in self.user_role:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyTenantUserRolesResponseBodyTenantUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        result['UserRole'] = []
        if self.user_role is not None:
            for k in self.user_role:
                result['UserRole'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        self.user_role = []
        if m.get('UserRole') is not None:
            for k in m.get('UserRole'):
                temp_model = ModifyTenantUserRolesResponseBodyTenantUserUserRole()
                self.user_role.append(temp_model.from_map(k))
        return self


class ModifyTenantUserRolesResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_user=None):
        self.request_id = request_id  # type: str
        # The ID of the tenant.
        self.tenant_user = tenant_user  # type: ModifyTenantUserRolesResponseBodyTenantUser

    def validate(self):
        if self.tenant_user:
            self.tenant_user.validate()

    def to_map(self):
        _map = super(ModifyTenantUserRolesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tenant_user is not None:
            result['TenantUser'] = self.tenant_user.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TenantUser') is not None:
            temp_model = ModifyTenantUserRolesResponseBodyTenantUser()
            self.tenant_user = temp_model.from_map(m['TenantUser'])
        return self


class ModifyTenantUserRolesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantUserRolesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantUserRolesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantUserRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTenantUserStatusRequest(TeaModel):
    def __init__(self, instance_id=None, tenant_id=None, user_name=None, user_status=None):
        # The operation that you want to perform.   
        # Set the value to **ModifyTenantUserStatus**.
        self.instance_id = instance_id  # type: str
        # The ID of the tenant.
        self.tenant_id = tenant_id  # type: str
        # The list of database accounts in the tenant.
        self.user_name = user_name  # type: str
        # The status of the database account. Valid values:   
        # - Locked: The account is locked. 
        # - Online: The account is unlocked.
        self.user_status = user_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        return self


class ModifyTenantUserStatusResponseBodyTenantUser(TeaModel):
    def __init__(self, tenant_id=None, user_name=None, user_status=None):
        self.tenant_id = tenant_id  # type: str
        self.user_name = user_name  # type: str
        self.user_status = user_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTenantUserStatusResponseBodyTenantUser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        return self


class ModifyTenantUserStatusResponseBody(TeaModel):
    def __init__(self, request_id=None, tenant_user=None):
        # Example 1
        self.request_id = request_id  # type: str
        self.tenant_user = tenant_user  # type: list[ModifyTenantUserStatusResponseBodyTenantUser]

    def validate(self):
        if self.tenant_user:
            for k in self.tenant_user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyTenantUserStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TenantUser'] = []
        if self.tenant_user is not None:
            for k in self.tenant_user:
                result['TenantUser'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tenant_user = []
        if m.get('TenantUser') is not None:
            for k in m.get('TenantUser'):
                temp_model = ModifyTenantUserStatusResponseBodyTenantUser()
                self.tenant_user.append(temp_model.from_map(k))
        return self


class ModifyTenantUserStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTenantUserStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTenantUserStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTenantUserStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The total count, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # Contact the administrator.
        self.page_size = page_size  # type: int
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.project_id = project_id  # type: str
        # Indicates whether the call is successful.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class ReleaseOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The operation that you want to perform. Set the value to **ReleaseOmsOpenAPIProject**.
        self.code = code  # type: str
        # The error description (old).
        self.level = level  # type: str
        # The error code (new).
        self.message = message  # type: str
        # The page number, which takes effect in a pagination query.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class ReleaseOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # You can call this operation to release a data synchronization project.
        self.advice = advice  # type: str
        # Indicates whether the project is released.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # The suggestions (new).
        self.error_detail = error_detail  # type: ReleaseOmsOpenAPIProjectResponseBodyErrorDetail
        # A system error occurred.
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        # The page number, which takes effect in a pagination query.
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ReleaseOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = ReleaseOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ReleaseOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleaseOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleaseOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ReleaseProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ReleaseProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: any
        self.error_detail = error_detail  # type: ReleaseProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ReleaseProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = ReleaseProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ReleaseProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleaseProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleaseProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The total count, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # Contact the administrator.
        self.page_size = page_size  # type: int
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.project_id = project_id  # type: str
        # Indicates whether the call is successful.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class ResetOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The operation that you want to perform. Set the value to **ResetOmsOpenAPIProject**.
        self.code = code  # type: str
        # The error description (old).
        self.level = level  # type: str
        # The error code (new).
        self.message = message  # type: str
        # The page number, which takes effect in a pagination query.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class ResetOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # You can call this operation to reset a data synchronization project.
        self.advice = advice  # type: str
        # Indicates whether the resetting is successful.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # The suggestions (new).
        self.error_detail = error_detail  # type: ResetOmsOpenAPIProjectResponseBodyErrorDetail
        # A system error occurred.
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        # The page number, which takes effect in a pagination query.
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ResetOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = ResetOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ResetOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # Contact the administrator.
        self.page_number = page_number  # type: int
        # Indicates whether the call is successful.
        self.page_size = page_size  # type: int
        # Contact the administrator.
        self.project_id = project_id  # type: str
        # The suggestions (old).
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class ResumeOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The suggestions (new).
        self.code = code  # type: str
        # The operation that you want to perform. Set the value to **ResumeOmsOpenAPIProject**.
        self.level = level  # type: str
        # The error description (old).
        self.message = message  # type: str
        # The error code (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class ResumeOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # The request ID.
        self.advice = advice  # type: str
        # The page number, which takes effect in a pagination query.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # The page number, which takes effect in a pagination query.
        self.error_detail = error_detail  # type: ResumeOmsOpenAPIProjectResponseBodyErrorDetail
        # The error details.
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        # Example 1
        self.request_id = request_id  # type: str
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ResumeOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = ResumeOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ResumeOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResumeOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResumeOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ResumeProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResumeProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class ResumeProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: any
        self.error_detail = error_detail  # type: ResumeProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(ResumeProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = ResumeProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ResumeProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResumeProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResumeProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchOmsOpenAPIMonitorMetricRequest(TeaModel):
    def __init__(self, begin_time=None, end_time=None, max_point_num=None, metric=None, page_number=None,
                 page_size=None, project_id=None, worker_grade_id=None):
        # Alibaba Cloud provides SDKs in different languages to help you quickly integrate Alibaba Cloud products and services by using APIs. We recommend that you use an SDK to call APIs. In this way, you do not need to sign for verification.
        self.begin_time = begin_time  # type: long
        # It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
        self.end_time = end_time  # type: long
        # Contact the administrator.
        self.max_point_num = max_point_num  # type: long
        # The business data returned.
        self.metric = metric  # type: str
        # The information about the object.
        self.page_number = page_number  # type: int
        # A millisecond-level timestamp.
        self.page_size = page_size  # type: int
        # The value corresponding to the time.
        self.project_id = project_id  # type: str
        # The name of the metric.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.max_point_num is not None:
            result['MaxPointNum'] = self.max_point_num
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MaxPointNum') is not None:
            self.max_point_num = m.get('MaxPointNum')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class SearchOmsOpenAPIMonitorMetricResponseBodyDataDataPoints(TeaModel):
    def __init__(self, timestamp=None, value=None):
        self.timestamp = timestamp  # type: long
        self.value = value  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricResponseBodyDataDataPoints, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchOmsOpenAPIMonitorMetricResponseBodyData(TeaModel):
    def __init__(self, data_points=None, metric=None, tags=None):
        # connector data point
        self.data_points = data_points  # type: list[SearchOmsOpenAPIMonitorMetricResponseBodyDataDataPoints]
        self.metric = metric  # type: str
        # metric tags
        self.tags = tags  # type: dict[str, str]

    def validate(self):
        if self.data_points:
            for k in self.data_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataPoints'] = []
        if self.data_points is not None:
            for k in self.data_points:
                result['DataPoints'].append(k.to_map() if k else None)
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_points = []
        if m.get('DataPoints') is not None:
            for k in m.get('DataPoints'):
                temp_model = SearchOmsOpenAPIMonitorMetricResponseBodyDataDataPoints()
                self.data_points.append(temp_model.from_map(k))
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class SearchOmsOpenAPIMonitorMetricResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The information about the object.
        self.code = code  # type: str
        # The error code (old).
        self.level = level  # type: str
        # The ID of the project to query.
        self.message = message  # type: str
        # The error description (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class SearchOmsOpenAPIMonitorMetricResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.advice = advice  # type: str
        # The business data returned.
        self.code = code  # type: str
        # The request ID.
        self.cost = cost  # type: str
        self.data = data  # type: list[SearchOmsOpenAPIMonitorMetricResponseBodyData]
        # A system error occurred.
        self.error_detail = error_detail  # type: SearchOmsOpenAPIMonitorMetricResponseBodyErrorDetail
        # The suggestions (old).
        self.message = message  # type: str
        # The error code (new).
        self.page_number = page_number  # type: int
        # The page number, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The time spent in processing the request, in seconds.
        self.request_id = request_id  # type: str
        # The total count, which takes effect in a pagination query.
        self.success = success  # type: bool
        # The error details.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = SearchOmsOpenAPIMonitorMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = SearchOmsOpenAPIMonitorMetricResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchOmsOpenAPIMonitorMetricResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchOmsOpenAPIMonitorMetricResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIMonitorMetricResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchOmsOpenAPIMonitorMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchOmsOpenAPIProjectsRequest(TeaModel):
    def __init__(self, dest_db_types=None, label_ids=None, page_number=None, page_size=None, search_key=None,
                 source_db_types=None, status_list=None, worker_grade_id=None):
        # The types of destination data sources.
        self.dest_db_types = dest_db_types  # type: list[str]
        # The list of labels.
        self.label_ids = label_ids  # type: list[str]
        # The page number, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # The page size, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The keyword for fuzzy search. A fuzzy search is performed based on the project ID and name.
        self.search_key = search_key  # type: str
        # The types of source data sources.
        self.source_db_types = source_db_types  # type: list[str]
        # The list of project statuses.
        self.status_list = status_list  # type: list[str]
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_db_types is not None:
            result['DestDbTypes'] = self.dest_db_types
        if self.label_ids is not None:
            result['LabelIds'] = self.label_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.source_db_types is not None:
            result['SourceDbTypes'] = self.source_db_types
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestDbTypes') is not None:
            self.dest_db_types = m.get('DestDbTypes')
        if m.get('LabelIds') is not None:
            self.label_ids = m.get('LabelIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SourceDbTypes') is not None:
            self.source_db_types = m.get('SourceDbTypes')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class SearchOmsOpenAPIProjectsShrinkRequest(TeaModel):
    def __init__(self, dest_db_types_shrink=None, label_ids_shrink=None, page_number=None, page_size=None,
                 search_key=None, source_db_types_shrink=None, status_list_shrink=None, worker_grade_id=None):
        # The types of destination data sources.
        self.dest_db_types_shrink = dest_db_types_shrink  # type: str
        # The list of labels.
        self.label_ids_shrink = label_ids_shrink  # type: str
        # The page number, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # The page size, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The keyword for fuzzy search. A fuzzy search is performed based on the project ID and name.
        self.search_key = search_key  # type: str
        # The types of source data sources.
        self.source_db_types_shrink = source_db_types_shrink  # type: str
        # The list of project statuses.
        self.status_list_shrink = status_list_shrink  # type: str
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_db_types_shrink is not None:
            result['DestDbTypes'] = self.dest_db_types_shrink
        if self.label_ids_shrink is not None:
            result['LabelIds'] = self.label_ids_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.source_db_types_shrink is not None:
            result['SourceDbTypes'] = self.source_db_types_shrink
        if self.status_list_shrink is not None:
            result['StatusList'] = self.status_list_shrink
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestDbTypes') is not None:
            self.dest_db_types_shrink = m.get('DestDbTypes')
        if m.get('LabelIds') is not None:
            self.label_ids_shrink = m.get('LabelIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SourceDbTypes') is not None:
            self.source_db_types_shrink = m.get('SourceDbTypes')
        if m.get('StatusList') is not None:
            self.status_list_shrink = m.get('StatusList')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataDestConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        # Indicates whether message tracing is enabled when the destination data source is RocketMQ.
        self.enable_msg_trace = enable_msg_trace  # type: bool
        # The ID of the data source.
        self.endpoint_id = endpoint_id  # type: str
        # The type of the data source. Valid values: MYSQL, MARIADB, OB_MYSQL, OB_MYSQL_CE, OB_ORACLE, ORACLE, DB2_LUW, KAFKA, ROCKETMQ, DATAHUB, SYBASE, LOGPROXY, ADB, DBP_OP_ROUTE, DMS, IDB, and TIDB.
        self.endpoint_type = endpoint_type  # type: str
        # The tag of the Post message when the destination data source is RocketMQ.
        self.msg_tags = msg_tags  # type: str
        # The partitioned index, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, and RocketMQ, and the partitioning mode is set to ONE.
        self.partition = partition  # type: int
        # The partitioning mode, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: ONE, HASH, and TABLE.
        self.partition_mode = partition_mode  # type: str
        # The producer group of the Post message when the destination data source is RocketMQ.
        self.producer_group = producer_group  # type: str
        # The timeout period in seconds for a single Post message when the destination data source is RocketMQ.
        self.send_msg_timeout = send_msg_timeout  # type: long
        # Indicates whether message sequencing is enabled when the destination data source is DataHub.
        self.sequence_enable = sequence_enable  # type: bool
        # The start time of the sequence, which must be specified if the destination data source is DataHub and message sequencing is enabled. The value is a timestamp in seconds.
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        # The text serialization type, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: Default, DefaultExtendColumnType, Canal, Dataworks, and SharePlex.
        self.serializer_type = serializer_type  # type: str
        # The type of the topic to which the Post message belongs when the destination data source is DataHub. Valid values: Tuple and Blob.
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataDestConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataLabels(TeaModel):
    def __init__(self, count=None, creator=None, id=None, name=None):
        # The number of projects that use this label.
        self.count = count  # type: int
        # The creator. This parameter value is returned only when you log on as the administrator.
        self.creator = creator  # type: str
        # The ID of a label.
        self.id = id  # type: str
        # The name of the label.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataSourceConfig(TeaModel):
    def __init__(self, enable_msg_trace=None, endpoint_id=None, endpoint_type=None, msg_tags=None, partition=None,
                 partition_mode=None, producer_group=None, send_msg_timeout=None, sequence_enable=None,
                 sequence_start_timestamp=None, serializer_type=None, topic_type=None):
        # Indicates whether message tracing is enabled when the destination data source is RocketMQ.
        self.enable_msg_trace = enable_msg_trace  # type: bool
        # The ID of the data source.
        self.endpoint_id = endpoint_id  # type: str
        # The type of the data source. Valid values: `MYSQL`, `MARIADB`, `OB_MYSQL`, `OB_MYSQL_CE`, `OB_ORACLE`, `ORACLE`, `DB2_LUW`, `KAFKA`, `ROCKETMQ`, `DATAHUB`, `SYBASE`, `LOGPROXY`, `ADB`, `DBP_OP_ROUTE`, `DMS`, `IDB`, and `TIDB`.
        self.endpoint_type = endpoint_type  # type: str
        # The tag of the Post message when the destination data source is RocketMQ.
        self.msg_tags = msg_tags  # type: str
        # The partitioned index, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ, and the partitioning mode is set to ONE.
        self.partition = partition  # type: int
        # The partitioning mode, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: ONE, HASH, and TABLE.
        self.partition_mode = partition_mode  # type: str
        # The producer group of the Post message when the destination data source is RocketMQ.
        self.producer_group = producer_group  # type: str
        # The timeout period in seconds for a single Post message when the destination data source is RocketMQ.
        self.send_msg_timeout = send_msg_timeout  # type: long
        # Indicates whether message sequencing is enabled when the destination data source is DataHub.
        self.sequence_enable = sequence_enable  # type: bool
        # The start time of the sequence, which must be specified if the destination data source is DataHub and message sequencing is enabled. The value is a timestamp in seconds.
        self.sequence_start_timestamp = sequence_start_timestamp  # type: long
        # The text serialization type, which must be specified if the destination data source is a message queue system, such as Kafka, DataHub, or RocketMQ. Valid values: Default, DefaultExtendColumnType, Canal, Dataworks, and SharePlex.
        self.serializer_type = serializer_type  # type: str
        # The type of the topic to which the Post message belongs when the destination data source is DataHub. Valid values: Tuple and Blob.
        self.topic_type = topic_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataSourceConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_msg_trace is not None:
            result['EnableMsgTrace'] = self.enable_msg_trace
        if self.endpoint_id is not None:
            result['EndpointId'] = self.endpoint_id
        if self.endpoint_type is not None:
            result['EndpointType'] = self.endpoint_type
        if self.msg_tags is not None:
            result['MsgTags'] = self.msg_tags
        if self.partition is not None:
            result['Partition'] = self.partition
        if self.partition_mode is not None:
            result['PartitionMode'] = self.partition_mode
        if self.producer_group is not None:
            result['ProducerGroup'] = self.producer_group
        if self.send_msg_timeout is not None:
            result['SendMsgTimeout'] = self.send_msg_timeout
        if self.sequence_enable is not None:
            result['SequenceEnable'] = self.sequence_enable
        if self.sequence_start_timestamp is not None:
            result['SequenceStartTimestamp'] = self.sequence_start_timestamp
        if self.serializer_type is not None:
            result['SerializerType'] = self.serializer_type
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableMsgTrace') is not None:
            self.enable_msg_trace = m.get('EnableMsgTrace')
        if m.get('EndpointId') is not None:
            self.endpoint_id = m.get('EndpointId')
        if m.get('EndpointType') is not None:
            self.endpoint_type = m.get('EndpointType')
        if m.get('MsgTags') is not None:
            self.msg_tags = m.get('MsgTags')
        if m.get('Partition') is not None:
            self.partition = m.get('Partition')
        if m.get('PartitionMode') is not None:
            self.partition_mode = m.get('PartitionMode')
        if m.get('ProducerGroup') is not None:
            self.producer_group = m.get('ProducerGroup')
        if m.get('SendMsgTimeout') is not None:
            self.send_msg_timeout = m.get('SendMsgTimeout')
        if m.get('SequenceEnable') is not None:
            self.sequence_enable = m.get('SequenceEnable')
        if m.get('SequenceStartTimestamp') is not None:
            self.sequence_start_timestamp = m.get('SequenceStartTimestamp')
        if m.get('SerializerType') is not None:
            self.serializer_type = m.get('SerializerType')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfoErrorDetails(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error code.
        self.code = code  # type: str
        # Valid values: CRITICAL, ERROR, and WARN.
        self.level = level  # type: str
        # The error message.
        self.message = message  # type: str
        # The suggestions.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfoErrorDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfo(TeaModel):
    def __init__(self, error_code=None, error_details=None, error_msg=None, error_param=None, failed_time=None):
        # The error code, such as AUTHENTICATION_ERROR, PARAM_ERROR, PARAM_ERROR_MESSAGE, NOT_IMPLEMENTED_ERROR, SHARD_COLUMNS_CONFLICT_MESSAGE, FAILED_PARSE_TOKEN_MESSAGE, CONNECT_CHECK_ERROR, NOT_SUPPORT_ERROR, CE_NOT_SUPPORT_ERROR, NOT_FOUND_ERROR, SHARDING_COLUMN_NOT_INCLUDED_ERROR, INNER_ERROR, DB_QUERY_ERROR, DATAHUB_QUERY_ERROR, USER_LACK_SYS_PRIV_ERROR, USER_LACK_TABLE_PRIV_ERROR, RM_API_ERROR, RM_TASK_ERROR, CM_API_ERROR, CM_API_NOT_SUCCESS, BAGUALU_API_ERROR, IDB_API_ERROR, SUPERVISOR_API_ERROR, OCP_API_ERROR, OCP_SERVICE_ERROR, OCP_QUERY_VERSION_FAILED, OCP_VERSION_INCORRECT_ERROR, OCP_VERSION_NOT_SUPPORTED_ERROR, OCP_API_USER_PASSWORD_INCORRECT_ERROR, OBSCHEMA_ERROR, EXECUTOR_THREAD_POOL_BUSY, NO_TABLE_SELECTED, NO_VIEW_SELECTED, SOURCE_CRAWLER_START_FAILED, SOURCE_CRAWLER_START_FAILED_DATA_EXPIRED, SOURCE_CRAWLER_START_TIMEOUT, DEST_WRITER_START_FAILED, WRITER_UNKNOWN_STATUS, DRC_TOPIC_EXISTS_ERROR, TOPIC_EMPTY_ERROR, REACH_WRITER_LIMIT_ERROR, FOUND_NO_FEASIBLE_STORE_ERROR, TOO_MANY_STORES_FOR_SUBTOPIC, TIMEOUT_EXCEPTION, KIPP_API_ERROR, KIPP_API_RESOURCE_NOT_FOUND, KIPP_API_INVALID_PARAM, KIPP_API_UNKNOWN_ERROR, KIPP_API_INTERNAL_ERROR, KIPP_API_SERVICE_UNAVAILABLE, OMS_AGENT_API_ERROR, KMS_API_ERROR, OMS_ENCRYPT_API_ERROR, OMS_DECRYPT_API_ERROR, ALIYUN_SDK_ERROR, YAOCHI_API_ERROR, RESOURCE_WITHOUT_STOCK_ERROR, RESOURCE_NO_AVAILABLE_ZONE, CM_SDK_ERROR, MIGRATION_PROJECT_STEP_PRECHECK_FAILED, PRE_CHECK_ERROR, FAILURES_CORRECT_ERROR, EXECUTE_DDL_FAILURE, EXECUTE_DDL_UNSUPPORTED_OR_FAILURE, STRUCT_RECORD_DDL_NOT_FOUND, STRUCT_RECORD_INDEX_NOT_FOUND, STRUCT_RECORD_NOT_FOUND, STRUCT_RECORD_NOT_FOUND_IN_DBCAT, SCHEMA_OBJECT_TYPE_NOT_SUPPORT_ERROR, POLAR_MYSQL_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_NETWORK_TYPE_NOT_SUPPORT_ERROR, RDS_VPC_NETWORK_NOT_SUPPORT_ERROR, DB_TYPE_NOT_SUPPORT_ERROR, SYNC_TYPE_NOT_SUPPORT_ERROR, SLAVE_OPERATION_STEP_NOT_SUPPORT_ERROR, BYTE_USED_TYPE_NOT_SUPPORT_ERROR, MANY_TO_ONE_SCHEMA_TABLE_REVERSE_INCR_NOT_SUPPORT_ERROR, DUPLICATE_SCHEMA_TABLE_ERROR, OMS_STEP_NOT_SUPPORT_ERROR, ORACLE_DATABASE_ROLE_NOT_SUPPORT_ERROR, OLD_PRE_CHECK_NOT_SUPPORT_ERROR, SCHEMA_ONE_TO_MANY_NOT_SUPPORT_ERROR, PROJECT_NOT_FOUND_ERROR, ENDPOINT_NOT_FOUND_ERROR, ENDPOINT_NAME_ALREADY_EXIST_ERROR, ENDPOINT_QUERY_ERROR, ENDPOINT_SQL_QUERY_ERROR, PROJECT_NAME_ALREADY_EXIST_ERROR, CHECKER_NOT_FOUND_ERROR, CHECKER_FAILED_ERROR, CHECKER_STATUS_UNEXPECTED_ERROR, CHECKER_NO_TASK_TYPE_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR, WORKER_INSTANCE_ALLOCATING_ERROR, LOG_SERVICE_TOPIC_NOT_FOUND_ERROR, CLUSTER_NOT_FOUND_ERROR, TENANT_NOT_FOUND_ERROR, DATABASE_NOT_FOUND_ERROR, TABLE_NOT_FOUND_ERROR, COLUMN_NOT_FOUND_ERROR, TABLE_META_NOT_FOUND_ERROR, SYBASE_CHARSET_NOT_FOUND_ERROR, OCP_NOT_FOUND_ERROR, REGION_NOT_FOUND_ERROR, OCP_ALREADY_EXIST_ERROR, ALARM_CHANNEL_NAME_ALREADY_EXIST_ERROR, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_RESPONSE, SEND_MARKDOWN_TEXT_TO_WEBHOOK_FAILED_EXCEPTION_STATUS, LABEL_ALREADY_EXIST_ERROR, LABEL_NOT_EXIST_ERROR, OCP_ALREADY_USED_ERROR, REGION_INFO_INCONSISTENT_ERROR, OCP_NAME_EMPTY_ERROR, MASTER_SLAVE_ENDPOINT_NAME_INCONSISTENT_ERROR, LOG_FILE_NOT_FOUND_ERROR, OPERATION_NOT_ALLOWED_ERROR, PROJECT_OPERATION_NOT_ALLOWED_ERROR, PROJECT_RELEASE_FAILED, STRUCT_MIGRATION_RETRY_NOT_ALLOWED_ERROR, WORKER_INSTANCE_OPERATION_NOT_ALLOWED_ERROR, USER_OPERATION_NOT_ALLOWED_ERROR, OCP_NAME_OR_REGION_NOT_ALLOWED_UPDATE, UPDATE_CONFIG_WITH_NEWLINE_NOT_ALLOWED, EXIST_UNRELEASED_PROJECT_ERROR, EXIST_UNRELEASED_TOPIC_ERROR, LABEL_CREATE_NOT_ALLOWED_ERROR, LABEL_UPDATE_NOT_ALLOWED_ERROR, LABEL_DELETE_NOT_ALLOWED_ERROR, TOPIC_NAME_INVALID_ERROR, INVALID_STATUS_ERROR, INVALID_CSV_HEAD_ERROR, INVALID_CSV_BODY_ERROR, DUPLICATE_SCHEMA_TABLE_SETTING_ERROR, PROJECT_INVALID_STATUS_ERROR, PROJECT_INVALID_CONNECTOR_COUNT_ERROR, WORKER_INSTANCE_INVALID_STATUS_ERROR, LOG_SERVICE_INVALID_STATUS_ERROR, STEP_INVALID_STATUS_ERROR, UPDATE_ALLOW_DEST_TABLE_NOT_EMPTY_NOT_ALLOWED_ERROR, EXIST_INCONSISTENCY_ERROR, OMS_SWITCH_SUBSTEP_FAILED_ERROR, ENDPOINT_ID_INVALID_ERROR, DB_QUERY_VERSION_EMPTY_ERROR, ENDPOINT_NAME_INVALID_ERROR, ENDPOINT_SCHEMA_NOT_ALLOWED_ERROR, ENDPOINT_SCHEMA_CHAR_NOT_ALLOWED_ERROR, NAME_HAS_SPACE_EXCEPTION, CONFIG_CONVERT_VALUE_ERROR, CONFIG_VALUE_EXCEEDS_LIMIT_ERROR, CONFIG_KEY_NOT_FOUND_KEY_ERROR, CONFIG_VALUE_NOT_EMPTY_ERROR, SCHEMA_HAS_CONVERT_INFO, TIME_SERIES_QUERY_SERVICE_ERROR, ETL_VERIFY_ERROR, ETL_SYNTAX_UNSUPPORTED, ETL_FIELD_NOTFOUND, ETL_FAILED_PARSE_SQL, ETL_VAL_TYPE_ERROR, NOT_SUPPORT_GENERATE_COLUMNS, NOT_SUPPORT_UPDATE_ETL, LOCK_FAILED, OMS_USER_EXIST_ERROR, OMS_USER_NOT_FOUND_ERROR, OMS_USER_NAME_LENGTH_CONSTRAINT, OMS_USER_PASSWORD_ERROR, USER_NAME_OR_PASSWORD_ERROR, OMS_USER_PASSWORD_VALIDATION_ERROR, OMS_USER_PASSWORD_DEFAULT_ERROR, OMS_USER_PERMISSION_DENIED_ERROR, OMS_USER_EDIT_ADMIN_ROLE_INFO_PERMISSION_DENIED_ERROR, OMS_USER_ILLEGAL_DELETED_ERROR, CONNECTOR_TASK_NOT_FOUND_ERROR, CONNECTOR_TASK_NUM_LIMIT_ERROR, CONNECTOR_TASK_DELETE_ERROR, METRIC_SERVICE_ERROR, SYNC_PROJECT_TYPE_INVALID_ERROR, SYNC_SHARDING_COLUMNS_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_INVALID_ERROR, SYNC_PROJECT_PRODUCER_GROUP_LIMIT_EXCEEDS_ERROR, SYNC_PROJECT_COMPLEMENT_CONFIG_ERROR, META_SCHEMA_CREATE_FAILED, RESUME_STEP_FAILED, SCHEMA_INCONSISTENCY, SCHEMA_CASCADE_MAPPING_NOT_SUPPORT_ERROR, SCHEMA_NOT_EXISTED, SCHEMA_EXISTED, SCHEMA_NOT_EXIST, BLACK_LIST_MATCH_ALL, BLACK_LIST_CONTAIN_NON_WHITE_SCHEMA, BLACK_WHITE_LIST_PARAM_INVALID_ERROR, OPERATOR_ERROR, OPERATOR_DIMENSION_NOT_SUPPORT, OPERATOR_PULL_LOG_ERROR, OPERATOR_UPDATE_CONFIG_NOT_SUPPORT, KAFKA_CREATE_TOPIC_ERROR, KAFKA_QUERY_TOPIC_ERROR, KAFKA_BUILD_PROPERTIES_ERROR, ROCKETMQ_CREATE_TOPIC_ERROR, ROCKETMQ_QUERY_TOPIC_ERROR, SYNC_OBJECT_EMPTY_ERROR, WRITER_NUMBER_NOT_UNIQUE, WRITER_NOT_ACTIVE, PROJECT_NAME_DUPLICATE_ERROR, EMPTY_FAILED_STRUCT_MIGRATION_TABLES_ERROR, LOGIC_TABLE_NOT_SUPPORT_UPDATE_OBJECT_ERROR, LOGIC_REQUEST_ERROR, LOGIC_DTO_BUILD_ERROR, UNEXPECTED_REMOTE_API_RESULT, OCEANBASE_USER_UNEXPECTED, STORE_CREATE_FAILED_ERROR, STORE_START_FAILED, STORE_NOT_PULL_LOG_ERROR, ALL_HOSTS_STATUS_ERROR, WORKER_ECS_NOT_FOUND_ERROR, WORKER_ECS_NOT_FOUND_FOR_USER_ERROR, WORKER_POD_NOT_FOUND_ERROR, WORKER_POD_NOT_FOUND_FOR_USER_ERROR, WORKER_INSTANCE_NOT_FOUND_ERROR_V2, and WORKER_INSTANCE_NOT_FOUND_FOR_USER_ERROR.
        self.error_code = error_code  # type: str
        # The error details.
        self.error_details = error_details  # type: list[SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfoErrorDetails]
        # The error message.
        self.error_msg = error_msg  # type: str
        # The error related parameters.
        self.error_param = error_param  # type: dict[str, str]
        # The time when the error occurred.
        self.failed_time = failed_time  # type: str

    def validate(self):
        if self.error_details:
            for k in self.error_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorDetails'] = []
        if self.error_details is not None:
            for k in self.error_details:
                result['ErrorDetails'].append(k.to_map() if k else None)
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.error_param is not None:
            result['ErrorParam'] = self.error_param
        if self.failed_time is not None:
            result['FailedTime'] = self.failed_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_details = []
        if m.get('ErrorDetails') is not None:
            for k in m.get('ErrorDetails'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfoErrorDetails()
                self.error_details.append(temp_model.from_map(k))
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('ErrorParam') is not None:
            self.error_param = m.get('ErrorParam')
        if m.get('FailedTime') is not None:
            self.failed_time = m.get('FailedTime')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfoConnectorFullProgressOverview(TeaModel):
    def __init__(self, estimated_remaining_time_of_sec=None, estimated_total_count=None, finished_count=None,
                 progress=None):
        # The estimated maximum time remained, in seconds.
        self.estimated_remaining_time_of_sec = estimated_remaining_time_of_sec  # type: long
        # The estimated amount of data to migrate.
        self.estimated_total_count = estimated_total_count  # type: long
        # The amount of data migrated.
        self.finished_count = finished_count  # type: long
        # finishedCount / estimatedTotalCount
        self.progress = progress  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfoConnectorFullProgressOverview, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_time_of_sec is not None:
            result['EstimatedRemainingTimeOfSec'] = self.estimated_remaining_time_of_sec
        if self.estimated_total_count is not None:
            result['EstimatedTotalCount'] = self.estimated_total_count
        if self.finished_count is not None:
            result['FinishedCount'] = self.finished_count
        if self.progress is not None:
            result['Progress'] = self.progress
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingTimeOfSec') is not None:
            self.estimated_remaining_time_of_sec = m.get('EstimatedRemainingTimeOfSec')
        if m.get('EstimatedTotalCount') is not None:
            self.estimated_total_count = m.get('EstimatedTotalCount')
        if m.get('FinishedCount') is not None:
            self.finished_count = m.get('FinishedCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfo(TeaModel):
    def __init__(self, capacity=None, checkpoint=None, connector_full_progress_overview=None, deploy_id=None,
                 dst_iops=None, dst_rps=None, dst_rps_ref=None, dst_rt=None, dst_rt_ref=None, gmt=None, inconsistencies=None,
                 incr_timestamp_checkpoint=None, job_id=None, processed_records=None, skipped=None, src_iops=None, src_iops_ref=None,
                 src_rps=None, src_rps_ref=None, src_rt=None, src_rt_ref=None, validated=None):
        # The estimated total number of rows.
        self.capacity = capacity  # type: long
        # The checkpoint. The value is a unix timestamp in seconds.
        self.checkpoint = checkpoint  # type: str
        # The full synchronization progress.
        self.connector_full_progress_overview = connector_full_progress_overview  # type: SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfoConnectorFullProgressOverview
        # The resource deployment ID.
        self.deploy_id = deploy_id  # type: str
        # The read/write throughput of the destination data source, in bytes per second.
        self.dst_iops = dst_iops  # type: long
        # The read/write RPS of the destination data source.
        self.dst_rps = dst_rps  # type: long
        # The read/write RPS baseline of the destination data source.
        self.dst_rps_ref = dst_rps_ref  # type: long
        # The read/write RT per record of the destination data source, in ms.
        self.dst_rt = dst_rt  # type: long
        # The read/write RT baseline of the destination data source.
        self.dst_rt_ref = dst_rt_ref  # type: long
        # The checkpoint collection time. The value is a unix timestamp in seconds.
        self.gmt = gmt  # type: long
        # The amount of inconsistent data found during full verification.
        self.inconsistencies = inconsistencies  # type: long
        # The checkpoint in incremental synchronization. The value is a unix timestamp in seconds.
        self.incr_timestamp_checkpoint = incr_timestamp_checkpoint  # type: long
        # The ID of the current job of the step.
        self.job_id = job_id  # type: str
        # The number of migrated rows.
        self.processed_records = processed_records  # type: long
        # A sub-status that indicates whether this step is skipped.
        self.skipped = skipped  # type: bool
        # The read throughput of the source data source, in bytes per second.
        self.src_iops = src_iops  # type: long
        # The read throughput baseline of the source data source.
        self.src_iops_ref = src_iops_ref  # type: long
        # The read requests per second (RPS) of the source data source.
        self.src_rps = src_rps  # type: long
        # The read RPS baseline of the source data source.
        self.src_rps_ref = src_rps_ref  # type: long
        # The read response time (RT) per record of the source data source, in ms.
        self.src_rt = src_rt  # type: long
        # The read RT baseline of the source data source.
        self.src_rt_ref = src_rt_ref  # type: long
        # A sub-status that indicates whether the checker has completed full verification.
        self.validated = validated  # type: bool

    def validate(self):
        if self.connector_full_progress_overview:
            self.connector_full_progress_overview.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.checkpoint is not None:
            result['Checkpoint'] = self.checkpoint
        if self.connector_full_progress_overview is not None:
            result['ConnectorFullProgressOverview'] = self.connector_full_progress_overview.to_map()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.dst_iops is not None:
            result['DstIops'] = self.dst_iops
        if self.dst_rps is not None:
            result['DstRps'] = self.dst_rps
        if self.dst_rps_ref is not None:
            result['DstRpsRef'] = self.dst_rps_ref
        if self.dst_rt is not None:
            result['DstRt'] = self.dst_rt
        if self.dst_rt_ref is not None:
            result['DstRtRef'] = self.dst_rt_ref
        if self.gmt is not None:
            result['Gmt'] = self.gmt
        if self.inconsistencies is not None:
            result['Inconsistencies'] = self.inconsistencies
        if self.incr_timestamp_checkpoint is not None:
            result['IncrTimestampCheckpoint'] = self.incr_timestamp_checkpoint
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.processed_records is not None:
            result['ProcessedRecords'] = self.processed_records
        if self.skipped is not None:
            result['Skipped'] = self.skipped
        if self.src_iops is not None:
            result['SrcIops'] = self.src_iops
        if self.src_iops_ref is not None:
            result['SrcIopsRef'] = self.src_iops_ref
        if self.src_rps is not None:
            result['SrcRps'] = self.src_rps
        if self.src_rps_ref is not None:
            result['SrcRpsRef'] = self.src_rps_ref
        if self.src_rt is not None:
            result['SrcRt'] = self.src_rt
        if self.src_rt_ref is not None:
            result['SrcRtRef'] = self.src_rt_ref
        if self.validated is not None:
            result['Validated'] = self.validated
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('Checkpoint') is not None:
            self.checkpoint = m.get('Checkpoint')
        if m.get('ConnectorFullProgressOverview') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfoConnectorFullProgressOverview()
            self.connector_full_progress_overview = temp_model.from_map(m['ConnectorFullProgressOverview'])
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('DstIops') is not None:
            self.dst_iops = m.get('DstIops')
        if m.get('DstRps') is not None:
            self.dst_rps = m.get('DstRps')
        if m.get('DstRpsRef') is not None:
            self.dst_rps_ref = m.get('DstRpsRef')
        if m.get('DstRt') is not None:
            self.dst_rt = m.get('DstRt')
        if m.get('DstRtRef') is not None:
            self.dst_rt_ref = m.get('DstRtRef')
        if m.get('Gmt') is not None:
            self.gmt = m.get('Gmt')
        if m.get('Inconsistencies') is not None:
            self.inconsistencies = m.get('Inconsistencies')
        if m.get('IncrTimestampCheckpoint') is not None:
            self.incr_timestamp_checkpoint = m.get('IncrTimestampCheckpoint')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProcessedRecords') is not None:
            self.processed_records = m.get('ProcessedRecords')
        if m.get('Skipped') is not None:
            self.skipped = m.get('Skipped')
        if m.get('SrcIops') is not None:
            self.src_iops = m.get('SrcIops')
        if m.get('SrcIopsRef') is not None:
            self.src_iops_ref = m.get('SrcIopsRef')
        if m.get('SrcRps') is not None:
            self.src_rps = m.get('SrcRps')
        if m.get('SrcRpsRef') is not None:
            self.src_rps_ref = m.get('SrcRpsRef')
        if m.get('SrcRt') is not None:
            self.src_rt = m.get('SrcRt')
        if m.get('SrcRtRef') is not None:
            self.src_rt_ref = m.get('SrcRtRef')
        if m.get('Validated') is not None:
            self.validated = m.get('Validated')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataSteps(TeaModel):
    def __init__(self, estimated_remaining_seconds=None, extra_info=None, finish_time=None, interactive=None,
                 start_time=None, step_description=None, step_info=None, step_name=None, step_order=None, step_progress=None,
                 step_status=None):
        # The estimated time remained.
        self.estimated_remaining_seconds = estimated_remaining_seconds  # type: long
        # The additional information. The value is a JSON string.
        self.extra_info = extra_info  # type: SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfo
        # The end time, in the format of "2020-05-22T17:04:18".
        self.finish_time = finish_time  # type: str
        # Indicates whether the current step must be confirmed by the user, rather than scheduled in the backend.
        self.interactive = interactive  # type: bool
        # The start time, in the format of "2020-05-22T17:04:18".
        self.start_time = start_time  # type: str
        # The description of the step, for example, schema migration, full migration, full verification, incremental log pull, incremental synchronization, or incremental verification.
        self.step_description = step_description  # type: str
        # The step details. The value is a JSON string.
        self.step_info = step_info  # type: SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfo
        # The step name. Valid values: struct_migration, full_migration, full_validation, incr_log_pull, incr_sync/incr_validation, PRE_CHECK, PREPARE, STRUCT_MIGRATION, INDEX_MIGRATION, STRUCT_SYNC, FULL_MIGRATION, APP_SWITCH, REVERSE_INCR_SYNC, FULL_VALIDATION, INCR_LOG_PULL, INCR_SYNC, INCR_VALIDATION, SYNC_PREPARE, SYNC_INCR_LOG_PULL, CONNECTOR_FULL_SYNC, or CONNECTOR_INCR_SYNC.
        self.step_name = step_name  # type: str
        # The sequence of steps.
        self.step_order = step_order  # type: int
        # The step progress.
        self.step_progress = step_progress  # type: int
        # The step status. Valid values: INIT, RUNNING, FAILED, FINISHED, SUSPEND, and MONITORING. The value MONITORING indicates the continuous monitoring of incremental synchronization and incremental verification.
        self.step_status = step_status  # type: str

    def validate(self):
        if self.extra_info:
            self.extra_info.validate()
        if self.step_info:
            self.step_info.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataSteps, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.estimated_remaining_seconds is not None:
            result['EstimatedRemainingSeconds'] = self.estimated_remaining_seconds
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.interactive is not None:
            result['Interactive'] = self.interactive
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.step_description is not None:
            result['StepDescription'] = self.step_description
        if self.step_info is not None:
            result['StepInfo'] = self.step_info.to_map()
        if self.step_name is not None:
            result['StepName'] = self.step_name
        if self.step_order is not None:
            result['StepOrder'] = self.step_order
        if self.step_progress is not None:
            result['StepProgress'] = self.step_progress
        if self.step_status is not None:
            result['StepStatus'] = self.step_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EstimatedRemainingSeconds') is not None:
            self.estimated_remaining_seconds = m.get('EstimatedRemainingSeconds')
        if m.get('ExtraInfo') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataStepsExtraInfo()
            self.extra_info = temp_model.from_map(m['ExtraInfo'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Interactive') is not None:
            self.interactive = m.get('Interactive')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StepDescription') is not None:
            self.step_description = m.get('StepDescription')
        if m.get('StepInfo') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataStepsStepInfo()
            self.step_info = temp_model.from_map(m['StepInfo'])
        if m.get('StepName') is not None:
            self.step_name = m.get('StepName')
        if m.get('StepOrder') is not None:
            self.step_order = m.get('StepOrder')
        if m.get('StepProgress') is not None:
            self.step_progress = m.get('StepProgress')
        if m.get('StepStatus') is not None:
            self.step_status = m.get('StepStatus')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema(TeaModel):
    def __init__(self, distributed_keys=None, partition_life_cycle=None, partition_statement=None,
                 primary_keys=None):
        # The list of distribution key columns.
        self.distributed_keys = distributed_keys  # type: list[str]
        # The lifecycle of the table.
        self.partition_life_cycle = partition_life_cycle  # type: int
        # The partitioning expression.
        self.partition_statement = partition_statement  # type: str
        # The list of primary key columns.
        self.primary_keys = primary_keys  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distributed_keys is not None:
            result['DistributedKeys'] = self.distributed_keys
        if self.partition_life_cycle is not None:
            result['PartitionLifeCycle'] = self.partition_life_cycle
        if self.partition_statement is not None:
            result['PartitionStatement'] = self.partition_statement
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DistributedKeys') is not None:
            self.distributed_keys = m.get('DistributedKeys')
        if m.get('PartitionLifeCycle') is not None:
            self.partition_life_cycle = m.get('PartitionLifeCycle')
        if m.get('PartitionStatement') is not None:
            self.partition_statement = m.get('PartitionStatement')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTables(TeaModel):
    def __init__(self, adb_table_schema=None, filter_columns=None, mapped_name=None, shard_columns=None,
                 table_id=None, table_name=None, type=None, where_clause=None):
        # The schema of the ADB table. If the destination data source is ADB, you need to configure additional information for schema synchronization.
        self.adb_table_schema = adb_table_schema  # type: SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema
        # The list of filter columns, which are the columns to be synchronized.
        self.filter_columns = filter_columns  # type: list[str]
        # The name of the mapped-to table or topic. If the destination data source is a database, this parameter specifies the name of the mapped-to table. If the destination data source is a message queue system, this parameter specifies the name of the mapped-to topic.
        self.mapped_name = mapped_name  # type: str
        # The list of sharding key columns. This parameter applies to scenarios where the destination data source is a message queue system.
        self.shard_columns = shard_columns  # type: list[str]
        # The ID of the table. This parameter takes effect when the source data source is IDB.
        self.table_id = table_id  # type: str
        # The name of the table.
        self.table_name = table_name  # type: str
        # DATABASE, TABLE
        self.type = type  # type: str
        # The row filter conditions.
        self.where_clause = where_clause  # type: str

    def validate(self):
        if self.adb_table_schema:
            self.adb_table_schema.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adb_table_schema is not None:
            result['AdbTableSchema'] = self.adb_table_schema.to_map()
        if self.filter_columns is not None:
            result['FilterColumns'] = self.filter_columns
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        if self.shard_columns is not None:
            result['ShardColumns'] = self.shard_columns
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.type is not None:
            result['Type'] = self.type
        if self.where_clause is not None:
            result['WhereClause'] = self.where_clause
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdbTableSchema') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema()
            self.adb_table_schema = temp_model.from_map(m['AdbTableSchema'])
        if m.get('FilterColumns') is not None:
            self.filter_columns = m.get('FilterColumns')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        if m.get('ShardColumns') is not None:
            self.shard_columns = m.get('ShardColumns')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WhereClause') is not None:
            self.where_clause = m.get('WhereClause')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabases(TeaModel):
    def __init__(self, database_id=None, database_name=None, mapped_name=None, tables=None, tenant_name=None,
                 type=None):
        # The ID of the database. This parameter takes effect when the source data source is IDB.
        self.database_id = database_id  # type: str
        # The name of the database.
        self.database_name = database_name  # type: str
        # The mapped-to database. This parameter takes effect when the destination data source is a database.
        self.mapped_name = mapped_name  # type: str
        # The settings for the target table objects in the current database.
        self.tables = tables  # type: list[SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTables]
        # The mapped-to tenant. This parameter takes effect when the source data source is OceanBase Database.
        self.tenant_name = tenant_name  # type: str
        # DATABASE, TABLE
        self.type = type  # type: str

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabases, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.mapped_name is not None:
            result['MappedName'] = self.mapped_name
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('MappedName') is not None:
            self.mapped_name = m.get('MappedName')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabasesTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferMapping(TeaModel):
    def __init__(self, databases=None, mode=None):
        # The table mapping in the source data source, which is a conventional mapping scheme and takes effect only when Mode is set to NORMAL.
        self.databases = databases  # type: list[SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabases]
        # The mapping type. Valid values: \"NORMAL\" and \"WHITE_AND_BLACK_LIST\".
        self.mode = mode  # type: str

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferMappingDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig(TeaModel):
    def __init__(self, record_type_list=None, start_timestamp=None, store_log_kept_hour=None,
                 store_transaction_enabled=None, transfer_step_type=None):
        # The list of data types of incremental data synchronized in incremental synchronization.
        self.record_type_list = record_type_list  # type: list[str]
        # The start time for incremental synchronization. The value is a timestamp in seconds.
        self.start_timestamp = start_timestamp  # type: long
        # The retention time of logs when incremental synchronization is enabled and the incremental log pull component is Store.
        self.store_log_kept_hour = store_log_kept_hour  # type: long
        # Indicates whether intra-transaction sequencing is enabled when incremental synchronization is enabled and the incremental log pull component is Store.
        self.store_transaction_enabled = store_transaction_enabled  # type: bool
        # STRUCT, FULL, INCR
        self.transfer_step_type = transfer_step_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_type_list is not None:
            result['RecordTypeList'] = self.record_type_list
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.store_log_kept_hour is not None:
            result['StoreLogKeptHour'] = self.store_log_kept_hour
        if self.store_transaction_enabled is not None:
            result['StoreTransactionEnabled'] = self.store_transaction_enabled
        if self.transfer_step_type is not None:
            result['TransferStepType'] = self.transfer_step_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RecordTypeList') is not None:
            self.record_type_list = m.get('RecordTypeList')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('StoreLogKeptHour') is not None:
            self.store_log_kept_hour = m.get('StoreLogKeptHour')
        if m.get('StoreTransactionEnabled') is not None:
            self.store_transaction_enabled = m.get('StoreTransactionEnabled')
        if m.get('TransferStepType') is not None:
            self.transfer_step_type = m.get('TransferStepType')
        return self


class SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfig(TeaModel):
    def __init__(self, enable_full_sync=None, enable_incr_sync=None, enable_struct_sync=None,
                 incr_sync_step_transfer_config=None):
        # Indicates whether full migration is enabled.
        self.enable_full_sync = enable_full_sync  # type: bool
        # Indicates whether incremental synchronization is enabled.
        self.enable_incr_sync = enable_incr_sync  # type: bool
        # Indicates whether schema synchronization is enabled.
        self.enable_struct_sync = enable_struct_sync  # type: bool
        # The settings of incremental synchronization steps.
        self.incr_sync_step_transfer_config = incr_sync_step_transfer_config  # type: SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig

    def validate(self):
        if self.incr_sync_step_transfer_config:
            self.incr_sync_step_transfer_config.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_full_sync is not None:
            result['EnableFullSync'] = self.enable_full_sync
        if self.enable_incr_sync is not None:
            result['EnableIncrSync'] = self.enable_incr_sync
        if self.enable_struct_sync is not None:
            result['EnableStructSync'] = self.enable_struct_sync
        if self.incr_sync_step_transfer_config is not None:
            result['IncrSyncStepTransferConfig'] = self.incr_sync_step_transfer_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableFullSync') is not None:
            self.enable_full_sync = m.get('EnableFullSync')
        if m.get('EnableIncrSync') is not None:
            self.enable_incr_sync = m.get('EnableIncrSync')
        if m.get('EnableStructSync') is not None:
            self.enable_struct_sync = m.get('EnableStructSync')
        if m.get('IncrSyncStepTransferConfig') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfigIncrSyncStepTransferConfig()
            self.incr_sync_step_transfer_config = temp_model.from_map(m['IncrSyncStepTransferConfig'])
        return self


class SearchOmsOpenAPIProjectsResponseBodyData(TeaModel):
    def __init__(self, business_name=None, dest_config=None, labels=None, project_id=None, project_name=None,
                 project_owner=None, source_config=None, steps=None, transfer_mapping=None, transfer_step_config=None):
        # The business system identifier, which is optional and is a specific field of the Post message.
        self.business_name = business_name  # type: str
        # The settings of the destination data source.
        self.dest_config = dest_config  # type: SearchOmsOpenAPIProjectsResponseBodyDataDestConfig
        # A collection of label IDs.
        self.labels = labels  # type: list[SearchOmsOpenAPIProjectsResponseBodyDataLabels]
        # The project ID.
        self.project_id = project_id  # type: str
        # The name of the project.
        self.project_name = project_name  # type: str
        # The project owner.
        self.project_owner = project_owner  # type: str
        # The settings of the source data source.
        self.source_config = source_config  # type: SearchOmsOpenAPIProjectsResponseBodyDataSourceConfig
        # The detailed project steps.
        self.steps = steps  # type: list[SearchOmsOpenAPIProjectsResponseBodyDataSteps]
        # The mappings for the synchronization objects.
        self.transfer_mapping = transfer_mapping  # type: SearchOmsOpenAPIProjectsResponseBodyDataTransferMapping
        # The settings of synchronization steps
        self.transfer_step_config = transfer_step_config  # type: SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfig

    def validate(self):
        if self.dest_config:
            self.dest_config.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.source_config:
            self.source_config.validate()
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()
        if self.transfer_mapping:
            self.transfer_mapping.validate()
        if self.transfer_step_config:
            self.transfer_step_config.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.dest_config is not None:
            result['DestConfig'] = self.dest_config.to_map()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        if self.project_owner is not None:
            result['ProjectOwner'] = self.project_owner
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config.to_map()
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.transfer_mapping is not None:
            result['TransferMapping'] = self.transfer_mapping.to_map()
        if self.transfer_step_config is not None:
            result['TransferStepConfig'] = self.transfer_step_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('DestConfig') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataDestConfig()
            self.dest_config = temp_model.from_map(m['DestConfig'])
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyDataLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        if m.get('ProjectOwner') is not None:
            self.project_owner = m.get('ProjectOwner')
        if m.get('SourceConfig') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataSourceConfig()
            self.source_config = temp_model.from_map(m['SourceConfig'])
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyDataSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('TransferMapping') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferMapping()
            self.transfer_mapping = temp_model.from_map(m['TransferMapping'])
        if m.get('TransferStepConfig') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyDataTransferStepConfig()
            self.transfer_step_config = temp_model.from_map(m['TransferStepConfig'])
        return self


class SearchOmsOpenAPIProjectsResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error code (new).
        self.code = code  # type: str
        # The error level. Valid values: CRITICAL, ERROR, and WARN.
        self.level = level  # type: str
        # The error description (new).
        self.message = message  # type: str
        # The suggestions (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class SearchOmsOpenAPIProjectsResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # The suggestions (old).
        self.advice = advice  # type: str
        # The error code (old).
        self.code = code  # type: str
        # The time spent in processing the request, in seconds.
        self.cost = cost  # type: str
        # The business data returned.
        self.data = data  # type: list[SearchOmsOpenAPIProjectsResponseBodyData]
        # The error details.
        self.error_detail = error_detail  # type: SearchOmsOpenAPIProjectsResponseBodyErrorDetail
        # The error description (old).
        self.message = message  # type: str
        # The page number, which takes effect in a pagination query.
        self.page_number = page_number  # type: int
        # The page size, which takes effect in a pagination query.
        self.page_size = page_size  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful.
        self.success = success  # type: bool
        # The total count, which takes effect in a pagination query.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = SearchOmsOpenAPIProjectsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorDetail') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchOmsOpenAPIProjectsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchOmsOpenAPIProjectsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchOmsOpenAPIProjectsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchOmsOpenAPIProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # Contact the administrator.
        self.page_number = page_number  # type: int
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.page_size = page_size  # type: int
        # The page number, which takes effect in a pagination query.
        self.project_id = project_id  # type: str
        # The total count, which takes effect in a pagination query.
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class StartOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The error description (old).
        self.code = code  # type: str
        # The error code (new).
        self.level = level  # type: str
        # The page number, which takes effect in a pagination query.
        self.message = message  # type: str
        # The error details.
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class StartOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        # The request ID.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # The operation that you want to perform. Set the value to **StartOmsOpenAPIProject**.
        self.error_detail = error_detail  # type: StartOmsOpenAPIProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        # The suggestions (new).
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StartOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = StartOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StartOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class StartProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class StartProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: StartProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StartProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = StartProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StartProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartProjectsByLabelRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartProjectsByLabelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class StartProjectsByLabelResponseBodyData(TeaModel):
    def __init__(self, failed_project_ids=None, succeed_project_ids=None, total=None):
        self.failed_project_ids = failed_project_ids  # type: list[str]
        self.succeed_project_ids = succeed_project_ids  # type: list[str]
        self.total = total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartProjectsByLabelResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_project_ids is not None:
            result['FailedProjectIds'] = self.failed_project_ids
        if self.succeed_project_ids is not None:
            result['SucceedProjectIds'] = self.succeed_project_ids
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailedProjectIds') is not None:
            self.failed_project_ids = m.get('FailedProjectIds')
        if m.get('SucceedProjectIds') is not None:
            self.succeed_project_ids = m.get('SucceedProjectIds')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class StartProjectsByLabelResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartProjectsByLabelResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class StartProjectsByLabelResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: StartProjectsByLabelResponseBodyData
        self.error_detail = error_detail  # type: StartProjectsByLabelResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StartProjectsByLabelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = StartProjectsByLabelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = StartProjectsByLabelResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StartProjectsByLabelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartProjectsByLabelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartProjectsByLabelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartProjectsByLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopOmsOpenAPIProjectRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, project_id=None, worker_grade_id=None):
        # The suggestions (old).
        self.page_number = page_number  # type: int
        # Contact the administrator.
        self.page_size = page_size  # type: int
        # The total count, which takes effect in a pagination query.
        self.project_id = project_id  # type: str
        # Alibaba Cloud CLI
        self.worker_grade_id = worker_grade_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopOmsOpenAPIProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.worker_grade_id is not None:
            result['WorkerGradeId'] = self.worker_grade_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WorkerGradeId') is not None:
            self.worker_grade_id = m.get('WorkerGradeId')
        return self


class StopOmsOpenAPIProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, level=None, message=None, proposal=None):
        # The time spent in processing the request, in seconds.
        self.code = code  # type: str
        # The error code (old).
        self.level = level  # type: str
        # The project ID.
        self.message = message  # type: str
        # The error description (new).
        self.proposal = proposal  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopOmsOpenAPIProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        return self


class StopOmsOpenAPIProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        # Indicates whether the project is paused.
        self.advice = advice  # type: str
        # The page size, which takes effect in a pagination query.
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: bool
        # A system error occurred.
        self.error_detail = error_detail  # type: StopOmsOpenAPIProjectResponseBodyErrorDetail
        # The page size, which takes effect in a pagination query.
        self.message = message  # type: str
        # Pause a data synchronization project
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        # A system error occurred.
        self.request_id = request_id  # type: str
        # The ID of the migration instance. Generally, if you want to create a project on a public cloud, you must first purchase a migration instance.
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StopOmsOpenAPIProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = StopOmsOpenAPIProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StopOmsOpenAPIProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopOmsOpenAPIProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopOmsOpenAPIProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopOmsOpenAPIProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopProjectRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class StopProjectResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopProjectResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class StopProjectResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: str
        self.error_detail = error_detail  # type: StopProjectResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StopProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorDetail') is not None:
            temp_model = StopProjectResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StopProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopProjectsByLabelRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopProjectsByLabelRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class StopProjectsByLabelResponseBodyData(TeaModel):
    def __init__(self, failed_project_ids=None, succeed_project_ids=None, total=None):
        self.failed_project_ids = failed_project_ids  # type: list[str]
        self.succeed_project_ids = succeed_project_ids  # type: list[str]
        self.total = total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopProjectsByLabelResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_project_ids is not None:
            result['FailedProjectIds'] = self.failed_project_ids
        if self.succeed_project_ids is not None:
            result['SucceedProjectIds'] = self.succeed_project_ids
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailedProjectIds') is not None:
            self.failed_project_ids = m.get('FailedProjectIds')
        if m.get('SucceedProjectIds') is not None:
            self.succeed_project_ids = m.get('SucceedProjectIds')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class StopProjectsByLabelResponseBodyErrorDetail(TeaModel):
    def __init__(self, code=None, extra_context=None, level=None, message=None, message_mcms_context=None,
                 message_mcms_key=None, proposal=None, proposal_mcms_context=None, proposal_mcms_key=None, reason=None,
                 reason_mcms_context=None, reason_mcms_key=None, upstream_error_detail=None):
        self.code = code  # type: str
        self.extra_context = extra_context  # type: dict[str, any]
        self.level = level  # type: str
        self.message = message  # type: str
        self.message_mcms_context = message_mcms_context  # type: dict[str, str]
        self.message_mcms_key = message_mcms_key  # type: str
        self.proposal = proposal  # type: str
        self.proposal_mcms_context = proposal_mcms_context  # type: dict[str, str]
        self.proposal_mcms_key = proposal_mcms_key  # type: str
        self.reason = reason  # type: str
        self.reason_mcms_context = reason_mcms_context  # type: dict[str, str]
        self.reason_mcms_key = reason_mcms_key  # type: str
        self.upstream_error_detail = upstream_error_detail  # type: any

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopProjectsByLabelResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.extra_context is not None:
            result['ExtraContext'] = self.extra_context
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.message_mcms_context is not None:
            result['MessageMcmsContext'] = self.message_mcms_context
        if self.message_mcms_key is not None:
            result['MessageMcmsKey'] = self.message_mcms_key
        if self.proposal is not None:
            result['Proposal'] = self.proposal
        if self.proposal_mcms_context is not None:
            result['ProposalMcmsContext'] = self.proposal_mcms_context
        if self.proposal_mcms_key is not None:
            result['ProposalMcmsKey'] = self.proposal_mcms_key
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.reason_mcms_context is not None:
            result['ReasonMcmsContext'] = self.reason_mcms_context
        if self.reason_mcms_key is not None:
            result['ReasonMcmsKey'] = self.reason_mcms_key
        if self.upstream_error_detail is not None:
            result['UpstreamErrorDetail'] = self.upstream_error_detail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ExtraContext') is not None:
            self.extra_context = m.get('ExtraContext')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MessageMcmsContext') is not None:
            self.message_mcms_context = m.get('MessageMcmsContext')
        if m.get('MessageMcmsKey') is not None:
            self.message_mcms_key = m.get('MessageMcmsKey')
        if m.get('Proposal') is not None:
            self.proposal = m.get('Proposal')
        if m.get('ProposalMcmsContext') is not None:
            self.proposal_mcms_context = m.get('ProposalMcmsContext')
        if m.get('ProposalMcmsKey') is not None:
            self.proposal_mcms_key = m.get('ProposalMcmsKey')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ReasonMcmsContext') is not None:
            self.reason_mcms_context = m.get('ReasonMcmsContext')
        if m.get('ReasonMcmsKey') is not None:
            self.reason_mcms_key = m.get('ReasonMcmsKey')
        if m.get('UpstreamErrorDetail') is not None:
            self.upstream_error_detail = m.get('UpstreamErrorDetail')
        return self


class StopProjectsByLabelResponseBody(TeaModel):
    def __init__(self, advice=None, code=None, cost=None, data=None, error_detail=None, message=None,
                 page_number=None, page_size=None, request_id=None, success=None, total_count=None):
        self.advice = advice  # type: str
        self.code = code  # type: str
        self.cost = cost  # type: str
        self.data = data  # type: StopProjectsByLabelResponseBodyData
        self.error_detail = error_detail  # type: StopProjectsByLabelResponseBodyErrorDetail
        self.message = message  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.total_count = total_count  # type: long

    def validate(self):
        if self.data:
            self.data.validate()
        if self.error_detail:
            self.error_detail.validate()

    def to_map(self):
        _map = super(StopProjectsByLabelResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            temp_model = StopProjectsByLabelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorDetail') is not None:
            temp_model = StopProjectsByLabelResponseBodyErrorDetail()
            self.error_detail = temp_model.from_map(m['ErrorDetail'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class StopProjectsByLabelResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopProjectsByLabelResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopProjectsByLabelResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopProjectsByLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchoverInstanceRequest(TeaModel):
    def __init__(self, forced=None, instance_id=None, target_instance_id=None):
        # Whether to force the switchover.
        # - true: Force the switchover.
        # - false: Do not force the switchover.
        self.forced = forced  # type: bool
        # The instance ID of the primary/standby instance. You can set the default value to the instance ID of the instance to be switched to the primary instance.
        self.instance_id = instance_id  # type: str
        # The instance ID of the instance to be switched to the primary instance.
        self.target_instance_id = target_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SwitchoverInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forced is not None:
            result['Forced'] = self.forced
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Forced') is not None:
            self.forced = m.get('Forced')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        return self


class SwitchoverInstanceResponseBodyData(TeaModel):
    def __init__(self, message=None, success=None):
        # The message of the switchover.
        self.message = message  # type: str
        # Whether the switchover is successful.
        # - true: the switchover succeeded.
        # - false: the switchover failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SwitchoverInstanceResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SwitchoverInstanceResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The list of data for the switchover.
        self.data = data  # type: SwitchoverInstanceResponseBodyData
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(SwitchoverInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SwitchoverInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SwitchoverInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SwitchoverInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SwitchoverInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchoverInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


