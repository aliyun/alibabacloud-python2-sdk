# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class QueryIncidentTracingSubNodesCountRequest(TeaModel):
    def __init__(self, vertex_id_and_type_list=None):
        self.vertex_id_and_type_list = vertex_id_and_type_list  # type: list[list[str]]

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryIncidentTracingSubNodesCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vertex_id_and_type_list is not None:
            result['VertexIdAndTypeList'] = self.vertex_id_and_type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VertexIdAndTypeList') is not None:
            self.vertex_id_and_type_list = m.get('VertexIdAndTypeList')
        return self


class AddCheckInstanceResultWhiteListRequest(TeaModel):
    def __init__(self, check_group_id=None, check_id=None, instance_ids=None):
        self.check_group_id = check_group_id  # type: str
        self.check_id = check_id  # type: long
        self.instance_ids = instance_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCheckInstanceResultWhiteListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_group_id is not None:
            result['CheckGroupId'] = self.check_group_id
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckGroupId') is not None:
            self.check_group_id = m.get('CheckGroupId')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class AddCheckInstanceResultWhiteListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: dict[str, any]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCheckInstanceResultWhiteListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCheckInstanceResultWhiteListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddCheckInstanceResultWhiteListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddCheckInstanceResultWhiteListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCheckInstanceResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCheckResultWhiteListRequest(TeaModel):
    def __init__(self, check_ids=None):
        self.check_ids = check_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCheckResultWhiteListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        return self


class AddCheckResultWhiteListResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: dict[str, any]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCheckResultWhiteListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCheckResultWhiteListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddCheckResultWhiteListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddCheckResultWhiteListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCheckResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddClientUserDefineRuleRequest(TeaModel):
    def __init__(self, action_type=None, cmdline=None, file_path=None, ip=None, md_5list=None, name=None,
                 new_file_path=None, parent_cmdline=None, parent_proc_path=None, platform=None, port=None, port_str=None,
                 proc_path=None, registry_content=None, registry_key=None, type=None):
        self.action_type = action_type  # type: int
        self.cmdline = cmdline  # type: str
        self.file_path = file_path  # type: str
        self.ip = ip  # type: str
        self.md_5list = md_5list  # type: str
        self.name = name  # type: str
        self.new_file_path = new_file_path  # type: str
        self.parent_cmdline = parent_cmdline  # type: str
        self.parent_proc_path = parent_proc_path  # type: str
        self.platform = platform  # type: str
        self.port = port  # type: int
        self.port_str = port_str  # type: str
        self.proc_path = proc_path  # type: str
        self.registry_content = registry_content  # type: str
        self.registry_key = registry_key  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddClientUserDefineRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.ip is not None:
            result['IP'] = self.ip
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult(TeaModel):
    def __init__(self, id=None, platform=None, switch_id=None):
        self.id = id  # type: long
        self.platform = platform  # type: str
        self.switch_id = switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        return self


class AddClientUserDefineRuleResponseBody(TeaModel):
    def __init__(self, request_id=None, user_define_rule_add_result=None):
        self.request_id = request_id  # type: str
        self.user_define_rule_add_result = user_define_rule_add_result  # type: AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult

    def validate(self):
        if self.user_define_rule_add_result:
            self.user_define_rule_add_result.validate()

    def to_map(self):
        _map = super(AddClientUserDefineRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_add_result is not None:
            result['UserDefineRuleAddResult'] = self.user_define_rule_add_result.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleAddResult') is not None:
            temp_model = AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult()
            self.user_define_rule_add_result = temp_model.from_map(m['UserDefineRuleAddResult'])
        return self


class AddClientUserDefineRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddClientUserDefineRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddClientUserDefineRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddInstallCodeRequest(TeaModel):
    def __init__(self, expired_date=None, group_id=None, only_image=None, os=None, vendor_name=None):
        # The validity period of the installation command. The value is a 13-digit timestamp.
        # 
        # >  The installation command is valid only within the validity period. An expired installation command cannot be used to install the Security Center agent.
        self.expired_date = expired_date  # type: long
        # The ID of the asset group to which the you want to add the asset.
        # 
        # >  You can call the [DescribeAllGroups](~~describeallgroups~~) operation to query the IDs of asset groups.
        self.group_id = group_id  # type: long
        # Specifies whether to create an image. Default value: **false**. Valid values:
        # 
        # *   **false**: does not create an image.
        # *   **true**: creates an image.
        self.only_image = only_image  # type: bool
        # The operating system of the instance. Default value: **linux**. Valid values:
        # 
        # *   **linux**\
        # *   **windows**\
        # *   **windows-2003**\
        self.os = os  # type: str
        # The name of the service provider for the asset. Default value: **ALIYUN**.
        # 
        # >  You can call the [DescribeVendorList](~~DescribeVendorList~~) operation to query the names of service providers.
        self.vendor_name = vendor_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddInstallCodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expired_date is not None:
            result['ExpiredDate'] = self.expired_date
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.only_image is not None:
            result['OnlyImage'] = self.only_image
        if self.os is not None:
            result['Os'] = self.os
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExpiredDate') is not None:
            self.expired_date = m.get('ExpiredDate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OnlyImage') is not None:
            self.only_image = m.get('OnlyImage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class AddInstallCodeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddInstallCodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddInstallCodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddInstallCodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddInstallCodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTagWithUuidRequest(TeaModel):
    def __init__(self, tag_name=None, uuid_list=None):
        self.tag_name = tag_name  # type: str
        self.uuid_list = uuid_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagWithUuidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class AddTagWithUuidResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagWithUuidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddTagWithUuidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddTagWithUuidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddTagWithUuidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddUninstallClientsByUuidsRequest(TeaModel):
    def __init__(self, call_method=None, feedback=None, region=None, source_ip=None, uuids=None):
        self.call_method = call_method  # type: str
        self.feedback = feedback  # type: str
        self.region = region  # type: str
        self.source_ip = source_ip  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddUninstallClientsByUuidsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_method is not None:
            result['CallMethod'] = self.call_method
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.region is not None:
            result['Region'] = self.region
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CallMethod') is not None:
            self.call_method = m.get('CallMethod')
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class AddUninstallClientsByUuidsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddUninstallClientsByUuidsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddUninstallClientsByUuidsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddUninstallClientsByUuidsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddUninstallClientsByUuidsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddUninstallClientsByUuidsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddVpcHoneyPotRequest(TeaModel):
    def __init__(self, vpc_id=None):
        # The ID of the virtual private cloud (VPC) in which you want to create a honeypot.
        # 
        # >  You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to obtain the VPC ID. The VPC ID is the value of the InstanceId parameter.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddVpcHoneyPotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AddVpcHoneyPotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddVpcHoneyPotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddVpcHoneyPotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddVpcHoneyPotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddVpcHoneyPotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AdvanceSecurityEventOperationsRequest(TeaModel):
    def __init__(self, event_name=None, event_type=None, resource_owner_id=None, rule_id=None):
        self.event_name = event_name  # type: str
        self.event_type = event_type  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.rule_id = rule_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(TeaModel):
    def __init__(self, filed_alias_name=None, filed_name=None, mark_mis_type=None, mark_mis_value=None,
                 supported_mis_type=None):
        self.filed_alias_name = filed_alias_name  # type: str
        self.filed_name = filed_name  # type: str
        self.mark_mis_type = mark_mis_type  # type: str
        self.mark_mis_value = mark_mis_value  # type: str
        self.supported_mis_type = supported_mis_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_type is not None:
            result['MarkMisType'] = self.mark_mis_type
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisType') is not None:
            self.mark_mis_type = m.get('MarkMisType')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(TeaModel):
    def __init__(self, filed_alias_name=None, filed_name=None, mark_mis_value=None, supported_mis_type=None):
        self.filed_alias_name = filed_alias_name  # type: str
        self.filed_name = filed_name  # type: str
        self.mark_mis_value = mark_mis_value  # type: str
        self.supported_mis_type = supported_mis_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse(TeaModel):
    def __init__(self, mark_field=None, mark_fields_source=None, operation_code=None, operation_params=None,
                 user_can_operate=None):
        self.mark_field = mark_field  # type: list[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField]
        self.mark_fields_source = mark_fields_source  # type: list[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource]
        self.operation_code = operation_code  # type: str
        self.operation_params = operation_params  # type: str
        self.user_can_operate = user_can_operate  # type: bool

    def validate(self):
        if self.mark_field:
            for k in self.mark_field:
                if k:
                    k.validate()
        if self.mark_fields_source:
            for k in self.mark_fields_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MarkField'] = []
        if self.mark_field is not None:
            for k in self.mark_field:
                result['MarkField'].append(k.to_map() if k else None)
        result['MarkFieldsSource'] = []
        if self.mark_fields_source is not None:
            for k in self.mark_fields_source:
                result['MarkFieldsSource'].append(k.to_map() if k else None)
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.user_can_operate is not None:
            result['UserCanOperate'] = self.user_can_operate
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.mark_field = []
        if m.get('MarkField') is not None:
            for k in m.get('MarkField'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField()
                self.mark_field.append(temp_model.from_map(k))
        self.mark_fields_source = []
        if m.get('MarkFieldsSource') is not None:
            for k in m.get('MarkFieldsSource'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource()
                self.mark_fields_source.append(temp_model.from_map(k))
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('UserCanOperate') is not None:
            self.user_can_operate = m.get('UserCanOperate')
        return self


class AdvanceSecurityEventOperationsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_operations_response=None):
        self.request_id = request_id  # type: str
        self.security_event_operations_response = security_event_operations_response  # type: list[AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse]

    def validate(self):
        if self.security_event_operations_response:
            for k in self.security_event_operations_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperationsResponse'] = []
        if self.security_event_operations_response is not None:
            for k in self.security_event_operations_response:
                result['SecurityEventOperationsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operations_response = []
        if m.get('SecurityEventOperationsResponse') is not None:
            for k in m.get('SecurityEventOperationsResponse'):
                temp_model = AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse()
                self.security_event_operations_response.append(temp_model.from_map(k))
        return self


class AdvanceSecurityEventOperationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AdvanceSecurityEventOperationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AdvanceSecurityEventOperationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AdvanceSecurityEventOperationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchOperateCommonOverallConfigRequest(TeaModel):
    def __init__(self, config=None, type_list=None):
        self.config = config  # type: str
        self.type_list = type_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchOperateCommonOverallConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class BatchOperateCommonOverallConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchOperateCommonOverallConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchOperateCommonOverallConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BatchOperateCommonOverallConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BatchOperateCommonOverallConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchOperateCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindAuthToMachineRequest(TeaModel):
    def __init__(self, auth_version=None, auto_bind=None, bind=None, bind_all=None, criteria=None, logical_exp=None,
                 un_bind=None):
        # The edition of Security Center. Valid values:
        # 
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version  # type: int
        # Specifies whether to automatically bind servers to Security Center. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.auto_bind = auto_bind  # type: int
        # The UUIDs of the servers that you want to bind to Security Center.
        # 
        # >  You must specify at least one of the **Bind** and **UnBind** parameters.
        self.bind = bind  # type: list[str]
        # Specifies whether to bind all servers to Security Center. Default value: **false**. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind_all = bind_all  # type: bool
        # The search conditions that are used to filter servers. The value of this parameter is in the JSON format and is case-sensitive.
        # 
        # >  A search condition can be an instance ID, instance name, virtual private cloud (VPC) ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria  # type: str
        # The logical relationship among multiple search conditions. Valid values:
        # 
        # *   **OR**: Search conditions are evaluated by using a logical **OR**.
        # *   **AND**: Search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp  # type: str
        # The UUIDs of the servers that you want to unbind from Security Center.
        # 
        # >  You must specify at least one of the **Bind** and **UnBind** parameters.
        self.un_bind = un_bind  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(BindAuthToMachineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.auto_bind is not None:
            result['AutoBind'] = self.auto_bind
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.bind_all is not None:
            result['BindAll'] = self.bind_all
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.un_bind is not None:
            result['UnBind'] = self.un_bind
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('AutoBind') is not None:
            self.auto_bind = m.get('AutoBind')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('BindAll') is not None:
            self.bind_all = m.get('BindAll')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('UnBind') is not None:
            self.un_bind = m.get('UnBind')
        return self


class BindAuthToMachineResponseBody(TeaModel):
    def __init__(self, bind_count=None, insufficient_core_count=None, insufficient_ecs_count=None, request_id=None,
                 result_code=None, un_bind_count=None):
        # The number of bound servers.
        self.bind_count = bind_count  # type: int
        # The shortage in the quota for cores of servers that can be protected.
        self.insufficient_core_count = insufficient_core_count  # type: int
        # The shortage in the quota for servers that can be protected.
        self.insufficient_ecs_count = insufficient_ecs_count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The status code that indicates the result. Valid values:
        # 
        # *   **0**: The servers are bound to or unbound from Security Center.
        # *   **1**: The values that you specified for the parameters are invalid.
        # *   **2**: The quota for servers that can be protected is insufficient.
        # *   **3**: The quota for cores of servers that can be protected is insufficient.
        self.result_code = result_code  # type: int
        # The number of unbound servers.
        self.un_bind_count = un_bind_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(BindAuthToMachineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.insufficient_core_count is not None:
            result['InsufficientCoreCount'] = self.insufficient_core_count
        if self.insufficient_ecs_count is not None:
            result['InsufficientEcsCount'] = self.insufficient_ecs_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.un_bind_count is not None:
            result['UnBindCount'] = self.un_bind_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('InsufficientCoreCount') is not None:
            self.insufficient_core_count = m.get('InsufficientCoreCount')
        if m.get('InsufficientEcsCount') is not None:
            self.insufficient_ecs_count = m.get('InsufficientEcsCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('UnBindCount') is not None:
            self.un_bind_count = m.get('UnBindCount')
        return self


class BindAuthToMachineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BindAuthToMachineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BindAuthToMachineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindAuthToMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelOnceTaskRequest(TeaModel):
    def __init__(self, task_id=None):
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelOnceTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CancelOnceTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelOnceTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelOnceTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelOnceTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelOnceTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeCheckConfigRequest(TeaModel):
    def __init__(self, cycle_days=None, end_time=None, standard_ids=None, start_time=None):
        self.cycle_days = cycle_days  # type: list[int]
        self.end_time = end_time  # type: int
        self.standard_ids = standard_ids  # type: list[long]
        self.start_time = start_time  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeCheckConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.standard_ids is not None:
            result['StandardIds'] = self.standard_ids
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StandardIds') is not None:
            self.standard_ids = m.get('StandardIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ChangeCheckConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ChangeCheckConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeCheckConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ChangeCheckConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ChangeCheckConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeCheckConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckQuaraFileIdRequest(TeaModel):
    def __init__(self, quara_file_ids=None, uuid=None):
        # The IDs of quarantined files that you want to check.
        # 
        # >  You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.
        self.quara_file_ids = quara_file_ids  # type: list[str]
        # The UUID of the server on which you want to check quarantined files.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckQuaraFileIdRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quara_file_ids is not None:
            result['QuaraFileIds'] = self.quara_file_ids
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuaraFileIds') is not None:
            self.quara_file_ids = m.get('QuaraFileIds')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CheckQuaraFileIdResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # Indicates whether the ID of the quarantined file is valid. Valid values:
        # 
        # *   **true**: The ID of the quarantined file is valid.
        # *   **false**: The ID of the quarantined file is invalid.
        self.data = data  # type: bool
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckQuaraFileIdResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckQuaraFileIdResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CheckQuaraFileIdResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CheckQuaraFileIdResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckQuaraFileIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckSecurityEventIdRequest(TeaModel):
    def __init__(self, security_event_ids=None, uuid=None):
        # The IDs of alert events. You can specify up to 100 IDs. If you do not specify this parameter, the value of the response parameter **Data** is **false**. The value false indicates that no alert events are generated on the server.
        # 
        # >  You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the IDs of alert events.
        self.security_event_ids = security_event_ids  # type: list[str]
        # The UUID of the server.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckSecurityEventIdRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CheckSecurityEventIdResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # Indicates whether the alert events are generated on the server. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.data = data  # type: bool
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckSecurityEventIdResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckSecurityEventIdResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CheckSecurityEventIdResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CheckSecurityEventIdResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckSecurityEventIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckUserHasEcsRequest(TeaModel):
    def __init__(self, lang=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckUserHasEcsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class CheckUserHasEcsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # Indicates whether ECS instances exist. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.data = data  # type: bool
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The status of the request. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CheckUserHasEcsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CheckUserHasEcsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CheckUserHasEcsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CheckUserHasEcsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckUserHasEcsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmVirusEventsRequest(TeaModel):
    def __init__(self, operation_all=None, operation_code=None, operation_range=None):
        self.operation_all = operation_all  # type: int
        self.operation_code = operation_code  # type: str
        self.operation_range = operation_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfirmVirusEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_all is not None:
            result['OperationAll'] = self.operation_all
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_range is not None:
            result['OperationRange'] = self.operation_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationAll') is not None:
            self.operation_all = m.get('OperationAll')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationRange') is not None:
            self.operation_range = m.get('OperationRange')
        return self


class ConfirmVirusEventsResponseBody(TeaModel):
    def __init__(self, request_id=None, result=None):
        self.request_id = request_id  # type: str
        self.result = result  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfirmVirusEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class ConfirmVirusEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ConfirmVirusEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ConfirmVirusEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmVirusEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAntiBruteForceRuleRequest(TeaModel):
    def __init__(self, default_rule=None, fail_count=None, forbidden_time=None, name=None, resource_owner_id=None,
                 source_ip=None, span=None, uuid_list=None):
        # Specifies whether to set the defense rule as the default rule. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  If no defense rule is created for a server, the default rule is applied to the server.
        self.default_rule = default_rule  # type: bool
        # The maximum number of failed logon attempts from an account. Valid values: 2, 3, 4, 5, 10, 50, 80, and 100.
        self.fail_count = fail_count  # type: int
        # The period of time during which logons from an account are not allowed. Unit: minutes. Valid values:
        # 
        # *   **5**: 5 minutes
        # *   **15**: 15 minutes
        # *   **30**: 30 minutes
        # *   **60**: 1 hour
        # *   **120**: 2 hours
        # *   **360**: 6 hours
        # *   **720**: 12 hours
        # *   **1440**: 24 hours
        # *   **10080**: 7 days
        # *   **52560000**: permanent
        self.forbidden_time = forbidden_time  # type: int
        # The name of the defense rule.
        self.name = name  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The maximum period of time during which failed logon attempts from an account can occur. Unit: minutes. Valid values:
        # 
        # *   **1**\
        # *   **2**\
        # *   **5**\
        # *   **10**\
        # *   **15**\
        # 
        # >  To configure a defense rule, you must specify the Span, FailCount, and ForbiddenTime parameters. If the number of failed logon attempts from an account within the minutes specified by Span exceeds the value specified by FailCount, the account cannot be used for logons within the minutes specified by ForbiddenTime.
        self.span = span  # type: int
        # The UUIDs of the servers to which you want to apply the defense rule.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAntiBruteForceRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.name is not None:
            result['Name'] = self.name
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule(TeaModel):
    def __init__(self, rule_id=None):
        # The ID of the defense rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class CreateAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(self, create_anti_brute_force_rule=None, request_id=None):
        # The information about the defense rule.
        self.create_anti_brute_force_rule = create_anti_brute_force_rule  # type: CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.create_anti_brute_force_rule:
            self.create_anti_brute_force_rule.validate()

    def to_map(self):
        _map = super(CreateAntiBruteForceRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_anti_brute_force_rule is not None:
            result['CreateAntiBruteForceRule'] = self.create_anti_brute_force_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateAntiBruteForceRule') is not None:
            temp_model = CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule()
            self.create_anti_brute_force_rule = temp_model.from_map(m['CreateAntiBruteForceRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAntiBruteForceRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAntiBruteForceRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAntiBruteForceRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateBackupPolicyRequest(TeaModel):
    def __init__(self, name=None, policy=None, policy_region_id=None, policy_version=None, uuid_list=None):
        # The name of the anti-ransomware policy.
        self.name = name  # type: str
        # *   **IsDefault**: the type of the anti-ransomware policy. Valid values:
        # 
        #     *   **1**: recommended policy
        #     *   **0**: custom policy
        # 
        # *   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to \[].
        # 
        # *   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to \[].
        # 
        # *   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.
        # 
        # *   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to \[].
        # 
        # *   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:
        # 
        #     *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
        #     *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.
        # 
        # *   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.
        # 
        # *   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.
        # 
        # *   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:
        # 
        #     *   **true**: yes
        #     *   **false**: no
        # 
        # >  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.
        self.policy = policy  # type: dict[str, any]
        # The region ID of the server that is not deployed on Alibaba Cloud.
        # 
        # >  We recommend that you specify the ID of the supported region that is the nearest to the location of the server. You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the supported regions of the anti-ransomware feature.
        self.policy_region_id = policy_region_id  # type: str
        # The version of the anti-ransomware policy. Set the value to **2.0.0**.
        self.policy_version = policy_version  # type: str
        # The UUIDs of the servers that you want to protect.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateBackupPolicyShrinkRequest(TeaModel):
    def __init__(self, name=None, policy_shrink=None, policy_region_id=None, policy_version=None, uuid_list=None):
        # The name of the anti-ransomware policy.
        self.name = name  # type: str
        # *   **IsDefault**: the type of the anti-ransomware policy. Valid values:
        # 
        #     *   **1**: recommended policy
        #     *   **0**: custom policy
        # 
        # *   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to \[].
        # 
        # *   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to \[].
        # 
        # *   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.
        # 
        # *   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to \[].
        # 
        # *   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:
        # 
        #     *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
        #     *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.
        # 
        # *   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.
        # 
        # *   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.
        # 
        # *   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:
        # 
        #     *   **true**: yes
        #     *   **false**: no
        # 
        # >  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.
        self.policy_shrink = policy_shrink  # type: str
        # The region ID of the server that is not deployed on Alibaba Cloud.
        # 
        # >  We recommend that you specify the ID of the supported region that is the nearest to the location of the server. You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the supported regions of the anti-ransomware feature.
        self.policy_region_id = policy_region_id  # type: str
        # The version of the anti-ransomware policy. Set the value to **2.0.0**.
        self.policy_version = policy_version  # type: str
        # The UUIDs of the servers that you want to protect.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateBackupPolicyShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.policy_shrink is not None:
            result['Policy'] = self.policy_shrink
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy_shrink = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class CreateBackupPolicyResponseBodyBackupPolicy(TeaModel):
    def __init__(self, id=None, status=None):
        # The ID of the anti-ransomware policy.
        self.id = id  # type: str
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**\
        # *   **disabled**\
        # 
        # >  After you create an anti-ransomware policy, the policy is enabled by default.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateBackupPolicyResponseBodyBackupPolicy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreateBackupPolicyResponseBody(TeaModel):
    def __init__(self, backup_policy=None, request_id=None):
        # The information about the anti-ransomware policy.
        self.backup_policy = backup_policy  # type: CreateBackupPolicyResponseBodyBackupPolicy
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_policy:
            self.backup_policy.validate()

    def to_map(self):
        _map = super(CreateBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_policy is not None:
            result['BackupPolicy'] = self.backup_policy.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupPolicy') is not None:
            temp_model = CreateBackupPolicyResponseBodyBackupPolicy()
            self.backup_policy = temp_model.from_map(m['BackupPolicy'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateContainerScanTaskRequest(TeaModel):
    def __init__(self, cluster_id=None, container_ids=None, lang=None):
        self.cluster_id = cluster_id  # type: str
        self.container_ids = container_ids  # type: str
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateContainerScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_ids is not None:
            result['ContainerIds'] = self.container_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerIds') is not None:
            self.container_ids = m.get('ContainerIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class CreateContainerScanTaskResponseBodyData(TeaModel):
    def __init__(self, can_create=None, collect_time=None, exec_time=None, finish_count=None, progress=None,
                 result=None, status=None, task_id=None, total_count=None):
        self.can_create = can_create  # type: bool
        self.collect_time = collect_time  # type: long
        self.exec_time = exec_time  # type: long
        self.finish_count = finish_count  # type: int
        self.progress = progress  # type: int
        self.result = result  # type: str
        self.status = status  # type: str
        self.task_id = task_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateContainerScanTaskResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class CreateContainerScanTaskResponseBody(TeaModel):
    def __init__(self, data=None, http_status_code=None, request_id=None):
        self.data = data  # type: CreateContainerScanTaskResponseBodyData
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateContainerScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateContainerScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateContainerScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateContainerScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateContainerScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateContainerScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomBlockRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, expire_time=None, resource_owner_id=None, uuids=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.expire_time = expire_time  # type: long
        self.resource_owner_id = resource_owner_id  # type: long
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCustomBlockRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class CreateCustomBlockRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCustomBlockRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomBlockRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCustomBlockRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCustomBlockRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCycleTaskRequest(TeaModel):
    def __init__(self, enable=None, first_date_str=None, interval_period=None, param=None, period_unit=None,
                 source=None, target_end_time=None, target_start_time=None, task_name=None, task_type=None):
        self.enable = enable  # type: int
        self.first_date_str = first_date_str  # type: long
        self.interval_period = interval_period  # type: int
        self.param = param  # type: str
        self.period_unit = period_unit  # type: str
        self.source = source  # type: str
        self.target_end_time = target_end_time  # type: int
        self.target_start_time = target_start_time  # type: int
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCycleTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.source is not None:
            result['Source'] = self.source
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateCycleTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCycleTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCycleTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCycleTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCycleTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileDetectRequest(TeaModel):
    def __init__(self, hash_key=None, oss_key=None, source_ip=None, type=None):
        # The identifier of the file. Only MD5 hash values are supported.
        self.hash_key = hash_key  # type: str
        # The key of the file that is stored in the Object Storage Service (OSS) bucket. You can call the [CreateFileDetectUploadUrl](~~CreateFileDetectUploadUrl~~) operation to query the keys of files.
        self.oss_key = oss_key  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the file. Valid values:
        # 
        # *   **0**: unknown files
        # *   **1**: binary files
        # *   **2**: webshell files
        # *   **4**: script files
        # 
        # >  If you do not know the type of the file, set this parameter to 0.
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFileDetectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateFileDetectResponseBody(TeaModel):
    def __init__(self, hash_key=None, request_id=None):
        # The identifier of the file.
        self.hash_key = hash_key  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFileDetectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateFileDetectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateFileDetectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateFileDetectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileDetectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileDetectUploadUrlRequestHashKeyContextList(TeaModel):
    def __init__(self, file_size=None, hash_key=None):
        # The size of the file. Unit: bytes.
        self.file_size = file_size  # type: int
        # The hash value of the file.
        self.hash_key = hash_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlRequestHashKeyContextList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        return self


class CreateFileDetectUploadUrlRequest(TeaModel):
    def __init__(self, hash_key_context_list=None, hash_key_list=None, type=None):
        # The hash values of files.
        # 
        # >  You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.
        self.hash_key_context_list = hash_key_context_list  # type: list[CreateFileDetectUploadUrlRequestHashKeyContextList]
        # The identifier of the file. Only MD5 hash values are supported.
        # 
        # >  You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.
        self.hash_key_list = hash_key_list  # type: list[str]
        # The type of the file. Valid values:
        # 
        # *   **0**: unknown files
        # *   **1**: binary files
        # *   **2**: webshell files
        # *   **4**: script files
        # 
        # >  If you do not know the type of the file, set this parameter to **0**.
        self.type = type  # type: int

    def validate(self):
        if self.hash_key_context_list:
            for k in self.hash_key_context_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HashKeyContextList'] = []
        if self.hash_key_context_list is not None:
            for k in self.hash_key_context_list:
                result['HashKeyContextList'].append(k.to_map() if k else None)
        if self.hash_key_list is not None:
            result['HashKeyList'] = self.hash_key_list
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.hash_key_context_list = []
        if m.get('HashKeyContextList') is not None:
            for k in m.get('HashKeyContextList'):
                temp_model = CreateFileDetectUploadUrlRequestHashKeyContextList()
                self.hash_key_context_list.append(temp_model.from_map(k))
        if m.get('HashKeyList') is not None:
            self.hash_key_list = m.get('HashKeyList')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateFileDetectUploadUrlResponseBodyUploadUrlListContext(TeaModel):
    def __init__(self, access_id=None, oss_key=None, policy=None, signature=None):
        # The AccessKey ID that is used to access the OSS bucket.
        self.access_id = access_id  # type: str
        # The key of the file that is used after the file is uploaded to the OSS bucket.
        self.oss_key = oss_key  # type: str
        # The policy that poses limits on file upload. For example, the policy limits the size of the file.
        self.policy = policy  # type: str
        # The signature that is used to upload the file.
        self.signature = signature  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlResponseBodyUploadUrlListContext, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.oss_key is not None:
            result['OssKey'] = self.oss_key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('OssKey') is not None:
            self.oss_key = m.get('OssKey')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class CreateFileDetectUploadUrlResponseBodyUploadUrlList(TeaModel):
    def __init__(self, code=None, context=None, expire=None, file_exist=None, hash_key=None, internal_url=None,
                 message=None, public_url=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The signature information.
        self.context = context  # type: CreateFileDetectUploadUrlResponseBodyUploadUrlListContext
        # The timestamp when the values of the parameters expire. Unit: milliseconds.
        self.expire = expire  # type: str
        # Indicates whether the file exists in the cloud. Valid values:
        # 
        # *   **true**: The file exists in the cloud. You do not need to upload the file.
        # *   **false**: The file does not exist in the cloud. You must upload the file.
        self.file_exist = file_exist  # type: bool
        # The identifier of the file.
        self.hash_key = hash_key  # type: str
        # The internal endpoint of the URL to which the file is uploaded.
        self.internal_url = internal_url  # type: str
        # The error message returned.
        self.message = message  # type: str
        # The public endpoint of the URL to which the file is uploaded.
        self.public_url = public_url  # type: str

    def validate(self):
        if self.context:
            self.context.validate()

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlResponseBodyUploadUrlList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.context is not None:
            result['Context'] = self.context.to_map()
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.file_exist is not None:
            result['FileExist'] = self.file_exist
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.internal_url is not None:
            result['InternalUrl'] = self.internal_url
        if self.message is not None:
            result['Message'] = self.message
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Context') is not None:
            temp_model = CreateFileDetectUploadUrlResponseBodyUploadUrlListContext()
            self.context = temp_model.from_map(m['Context'])
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('FileExist') is not None:
            self.file_exist = m.get('FileExist')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('InternalUrl') is not None:
            self.internal_url = m.get('InternalUrl')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        return self


class CreateFileDetectUploadUrlResponseBody(TeaModel):
    def __init__(self, request_id=None, upload_url_list=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the parameters that are required to upload a file.
        self.upload_url_list = upload_url_list  # type: list[CreateFileDetectUploadUrlResponseBodyUploadUrlList]

    def validate(self):
        if self.upload_url_list:
            for k in self.upload_url_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UploadUrlList'] = []
        if self.upload_url_list is not None:
            for k in self.upload_url_list:
                result['UploadUrlList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.upload_url_list = []
        if m.get('UploadUrlList') is not None:
            for k in m.get('UploadUrlList'):
                temp_model = CreateFileDetectUploadUrlResponseBodyUploadUrlList()
                self.upload_url_list.append(temp_model.from_map(k))
        return self


class CreateFileDetectUploadUrlResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateFileDetectUploadUrlResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateFileDetectUploadUrlResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileDetectUploadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotRequest(TeaModel):
    def __init__(self, honeypot_image_id=None, honeypot_image_name=None, honeypot_name=None, meta=None,
                 node_id=None):
        # The ID of the image that is used for the honeypot.
        # 
        # >  You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to obtain the IDs of images from the **HoneypotImageId** response parameter.
        self.honeypot_image_id = honeypot_image_id  # type: str
        # The name of the image that is used for the honeypot.
        # 
        # >  You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to obtain the names of images from the **HoneypotImageName** response parameter.
        self.honeypot_image_name = honeypot_image_name  # type: str
        # The custom name of the honeypot.
        self.honeypot_name = honeypot_name  # type: str
        # The custom configuration of the honeypot in the JSON format. The value contains the following fields:
        # 
        # *   **trojan_git**: Git-specific Defense. Valid values:
        # 
        #     *   **zip**: Git Source Code Package
        #     *   **web**: Git Directory Leak
        #     *   **close**: Disabled
        # 
        # *   **trojan\_git_addr**: Git Trojan Address.
        # 
        # *   **trojan_git.zip**: Git Trojan.
        # 
        # *   **burp**: Burp-specific Defense. Valid values:
        # 
        #     *   **open**: Enabled
        #     *   **close**: Disabled
        # 
        # *   **portrait_option**: Source Tracing Configuration. Valid values:
        # 
        #     *   **false**: Disable
        #     *   **true**: Enable
        self.meta = meta  # type: str
        # The ID of the management node to which you want to deploy the honeypot.
        # 
        # >  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the IDs of management nodes.
        self.node_id = node_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class CreateHoneypotResponseBodyData(TeaModel):
    def __init__(self, control_node_name=None, honeypot_id=None, honeypot_image_display_name=None,
                 honeypot_image_name=None, honeypot_name=None, node_id=None, preset_id=None, state=None):
        # The name of the management node to which the honeypot is deployed.
        self.control_node_name = control_node_name  # type: str
        # The ID of the honeypot.
        self.honeypot_id = honeypot_id  # type: str
        # The display name of the image that is used for the honeypot.
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        # The name of the image that is used for the honeypot.
        self.honeypot_image_name = honeypot_image_name  # type: str
        # The custom name of the honeypot.
        self.honeypot_name = honeypot_name  # type: str
        # The ID of the management node.
        self.node_id = node_id  # type: str
        # The ID of the custom configuration for the honeypot.
        self.preset_id = preset_id  # type: str
        # The status of the honeypot.
        self.state = state  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class CreateHoneypotResponseBody(TeaModel):
    def __init__(self, code=None, data=None, http_status_code=None, message=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request was is successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The information about the honeypot.
        self.data = data  # type: CreateHoneypotResponseBodyData
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateHoneypotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateHoneypotResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHoneypotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHoneypotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotNodeRequest(TeaModel):
    def __init__(self, allow_honeypot_access_internet=None, available_probe_num=None, node_name=None,
                 security_group_probe_ip_list=None):
        # Specifies whether to allow the honeypots to access the Internet. Valid values:
        # 
        # *   **true**: allows the honeypots to access the Internet.
        # *   **false**: does not allow the honeypots to access the Internet.
        self.allow_honeypot_access_internet = allow_honeypot_access_internet  # type: bool
        # The number of probes that you want to allocate for the management node.
        self.available_probe_num = available_probe_num  # type: int
        # The name of the management node.
        self.node_name = node_name  # type: str
        # The CIDR blocks that are allowed to access the management node.
        self.security_group_probe_ip_list = security_group_probe_ip_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.available_probe_num is not None:
            result['AvailableProbeNum'] = self.available_probe_num
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('AvailableProbeNum') is not None:
            self.available_probe_num = m.get('AvailableProbeNum')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        return self


class CreateHoneypotNodeResponseBodyHoneypotNode(TeaModel):
    def __init__(self, node_id=None):
        self.node_id = node_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotNodeResponseBodyHoneypotNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class CreateHoneypotNodeResponseBody(TeaModel):
    def __init__(self, code=None, honeypot_node=None, http_status_code=None, message=None, request_id=None,
                 success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        self.honeypot_node = honeypot_node  # type: CreateHoneypotNodeResponseBodyHoneypotNode
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.honeypot_node:
            self.honeypot_node.validate()

    def to_map(self):
        _map = super(CreateHoneypotNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_node is not None:
            result['HoneypotNode'] = self.honeypot_node.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotNode') is not None:
            temp_model = CreateHoneypotNodeResponseBodyHoneypotNode()
            self.honeypot_node = temp_model.from_map(m['HoneypotNode'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHoneypotNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHoneypotNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotPresetRequest(TeaModel):
    def __init__(self, honeypot_image_name=None, meta=None, node_id=None, preset_name=None):
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.meta = meta  # type: str
        self.node_id = node_id  # type: str
        self.preset_name = preset_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotPresetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class CreateHoneypotPresetResponseBodyHoneypotPreset(TeaModel):
    def __init__(self, honeypot_preset_id=None):
        self.honeypot_preset_id = honeypot_preset_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotPresetResponseBodyHoneypotPreset, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        return self


class CreateHoneypotPresetResponseBody(TeaModel):
    def __init__(self, code=None, honeypot_preset=None, http_status_code=None, message=None, request_id=None,
                 success=None):
        self.code = code  # type: str
        self.honeypot_preset = honeypot_preset  # type: CreateHoneypotPresetResponseBodyHoneypotPreset
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.honeypot_preset:
            self.honeypot_preset.validate()

    def to_map(self):
        _map = super(CreateHoneypotPresetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_preset is not None:
            result['HoneypotPreset'] = self.honeypot_preset.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotPreset') is not None:
            temp_model = CreateHoneypotPresetResponseBodyHoneypotPreset()
            self.honeypot_preset = temp_model.from_map(m['HoneypotPreset'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotPresetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHoneypotPresetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHoneypotPresetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHoneypotProbeRequestHoneypotBindListBindPortList(TeaModel):
    def __init__(self, bind_port=None, end_port=None, fixed=None, start_port=None, target_port=None):
        # Specifies whether to bind a port. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind_port = bind_port  # type: bool
        # The end of the port range.
        self.end_port = end_port  # type: int
        # Specifies whether the port is fixed. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.fixed = fixed  # type: bool
        # The start of the port range.
        self.start_port = start_port  # type: int
        # The destination port.
        # 
        # >  If **HoneypotId** is specified, this parameter is required.
        self.target_port = target_port  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotProbeRequestHoneypotBindListBindPortList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_port is not None:
            result['BindPort'] = self.bind_port
        if self.end_port is not None:
            result['EndPort'] = self.end_port
        if self.fixed is not None:
            result['Fixed'] = self.fixed
        if self.start_port is not None:
            result['StartPort'] = self.start_port
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindPort') is not None:
            self.bind_port = m.get('BindPort')
        if m.get('EndPort') is not None:
            self.end_port = m.get('EndPort')
        if m.get('Fixed') is not None:
            self.fixed = m.get('Fixed')
        if m.get('StartPort') is not None:
            self.start_port = m.get('StartPort')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class CreateHoneypotProbeRequestHoneypotBindList(TeaModel):
    def __init__(self, bind_port_list=None, honeypot_id=None):
        # The listener ports.
        self.bind_port_list = bind_port_list  # type: list[CreateHoneypotProbeRequestHoneypotBindListBindPortList]
        # The ID of the honeypot.
        # 
        # >  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.
        self.honeypot_id = honeypot_id  # type: str

    def validate(self):
        if self.bind_port_list:
            for k in self.bind_port_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHoneypotProbeRequestHoneypotBindList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BindPortList'] = []
        if self.bind_port_list is not None:
            for k in self.bind_port_list:
                result['BindPortList'].append(k.to_map() if k else None)
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bind_port_list = []
        if m.get('BindPortList') is not None:
            for k in m.get('BindPortList'):
                temp_model = CreateHoneypotProbeRequestHoneypotBindListBindPortList()
                self.bind_port_list.append(temp_model.from_map(k))
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        return self


class CreateHoneypotProbeRequest(TeaModel):
    def __init__(self, arp=None, business_group_id=None, control_node_id=None, display_name=None,
                 honeypot_bind_list=None, ping=None, probe_type=None, probe_version=None, proxy_ip=None, uuid=None, vpc_id=None):
        # Specifies whether to enable Address Resolution Protocol (ARP) spoofing. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.arp = arp  # type: bool
        # The ID of the business group.
        self.business_group_id = business_group_id  # type: str
        # The ID of the management node.
        # 
        # >  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.
        self.control_node_id = control_node_id  # type: str
        # The name of the probe.
        self.display_name = display_name  # type: str
        # The honeypot configurations.
        self.honeypot_bind_list = honeypot_bind_list  # type: list[CreateHoneypotProbeRequestHoneypotBindList]
        # Specifies whether to enable ping scan. Valid values:
        # 
        # *   **false**: yes
        # *   **false**: no
        self.ping = ping  # type: bool
        # The type of the probe. Valid values:
        # 
        # *   **host_probe**: host probe
        # *   **vpc_black_hole_probe**: virtual private cloud (VPC) probe
        self.probe_type = probe_type  # type: str
        # The version of the probe.
        self.probe_version = probe_version  # type: str
        # The IP address of the proxy.
        self.proxy_ip = proxy_ip  # type: str
        # The UUID of the instance.
        # 
        # >  If **ProbeType** is set to **host_probe**, this parameter is required.
        self.uuid = uuid  # type: str
        # The ID of the VPC.
        # 
        # >  If **ProbeType** is set to **vpc_black_hole_probe**, this parameter is required. You can call the DescribeVpcHoneyPotList operation to query the IDs of VPCs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.honeypot_bind_list:
            for k in self.honeypot_bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHoneypotProbeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.business_group_id is not None:
            result['BusinessGroupId'] = self.business_group_id
        if self.control_node_id is not None:
            result['ControlNodeId'] = self.control_node_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        result['HoneypotBindList'] = []
        if self.honeypot_bind_list is not None:
            for k in self.honeypot_bind_list:
                result['HoneypotBindList'].append(k.to_map() if k else None)
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.proxy_ip is not None:
            result['ProxyIp'] = self.proxy_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('BusinessGroupId') is not None:
            self.business_group_id = m.get('BusinessGroupId')
        if m.get('ControlNodeId') is not None:
            self.control_node_id = m.get('ControlNodeId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        self.honeypot_bind_list = []
        if m.get('HoneypotBindList') is not None:
            for k in m.get('HoneypotBindList'):
                temp_model = CreateHoneypotProbeRequestHoneypotBindList()
                self.honeypot_bind_list.append(temp_model.from_map(k))
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('ProxyIp') is not None:
            self.proxy_ip = m.get('ProxyIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateHoneypotProbeResponseBodyHoneypotProbe(TeaModel):
    def __init__(self, probe_id=None):
        self.probe_id = probe_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHoneypotProbeResponseBodyHoneypotProbe, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class CreateHoneypotProbeResponseBody(TeaModel):
    def __init__(self, code=None, honeypot_probe=None, http_status_code=None, message=None, request_id=None,
                 success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        self.honeypot_probe = honeypot_probe  # type: CreateHoneypotProbeResponseBodyHoneypotProbe
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.honeypot_probe:
            self.honeypot_probe.validate()

    def to_map(self):
        _map = super(CreateHoneypotProbeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_probe is not None:
            result['HoneypotProbe'] = self.honeypot_probe.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotProbe') is not None:
            temp_model = CreateHoneypotProbeResponseBodyHoneypotProbe()
            self.honeypot_probe = temp_model.from_map(m['HoneypotProbe'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHoneypotProbeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHoneypotProbeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHoneypotProbeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateJenkinsImageRegistryRequest(TeaModel):
    def __init__(self, domain_name=None, extra_param=None, net_type=None, password=None, persistence_day=None,
                 protocol_type=None, region_id=None, registry_host_ip=None, registry_name=None, registry_type=None,
                 registry_version=None, source_ip=None, trans_per_hour=None, user_name=None, vpc_id=None, white_list=None):
        self.domain_name = domain_name  # type: str
        self.extra_param = extra_param  # type: str
        self.net_type = net_type  # type: int
        self.password = password  # type: str
        self.persistence_day = persistence_day  # type: int
        self.protocol_type = protocol_type  # type: int
        self.region_id = region_id  # type: str
        self.registry_host_ip = registry_host_ip  # type: str
        self.registry_name = registry_name  # type: str
        self.registry_type = registry_type  # type: str
        self.registry_version = registry_version  # type: str
        self.source_ip = source_ip  # type: str
        self.trans_per_hour = trans_per_hour  # type: int
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.white_list = white_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateJenkinsImageRegistryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.extra_param is not None:
            result['ExtraParam'] = self.extra_param
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExtraParam') is not None:
            self.extra_param = m.get('ExtraParam')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateJenkinsImageRegistryResponseBodyData(TeaModel):
    def __init__(self, black_list=None, domain_name=None, gmt_create=None, gmt_modified=None, id=None, net_type=None,
                 password=None, persistence_day=None, protocol_type=None, region_id=None, registry_host_ip=None,
                 registry_name=None, registry_type=None, token=None, trans_per_hour=None, user_name=None, vpc_id=None,
                 white_list=None):
        self.black_list = black_list  # type: str
        self.domain_name = domain_name  # type: str
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.id = id  # type: long
        self.net_type = net_type  # type: int
        self.password = password  # type: str
        self.persistence_day = persistence_day  # type: int
        self.protocol_type = protocol_type  # type: int
        self.region_id = region_id  # type: str
        self.registry_host_ip = registry_host_ip  # type: str
        self.registry_name = registry_name  # type: str
        self.registry_type = registry_type  # type: str
        self.token = token  # type: str
        self.trans_per_hour = trans_per_hour  # type: int
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.white_list = white_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateJenkinsImageRegistryResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_list is not None:
            result['BlackList'] = self.black_list
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlackList') is not None:
            self.black_list = m.get('BlackList')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateJenkinsImageRegistryResponseBody(TeaModel):
    def __init__(self, data=None, http_status_code=None, request_id=None, time_cost=None):
        self.data = data  # type: CreateJenkinsImageRegistryResponseBodyData
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str
        self.time_cost = time_cost  # type: long

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateJenkinsImageRegistryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CreateJenkinsImageRegistryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class CreateJenkinsImageRegistryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateJenkinsImageRegistryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateJenkinsImageRegistryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateJenkinsImageRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateAssetGroupRequest(TeaModel):
    def __init__(self, group_id=None, group_name=None, uuids=None):
        # The ID of the server group for which you want to add to or remove servers.
        # 
        # >  To modify the mapping between an asset and an asset group, you must provide the ID of the asset group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) to query the IDs of asset groups. If you do not configure this parameter when you call this operation, an asset group is created.
        self.group_id = group_id  # type: long
        # The name of the server group that you want to create or the server group for which you want to add or remove a server.
        # 
        # >  To modify the mapping between a server and a server group, you must provide the name of the server group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the names of server groups. If you do not configure GroupID when you call this operation, a server group is created. In this case, you must configure GroupName.
        self.group_name = group_name  # type: str
        # The UUID of the server in the server group that you want to create or the server group for which you want to add or remove servers. Separate multiple UUIDs with commas (,).
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOrUpdateAssetGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class CreateOrUpdateAssetGroupResponseBody(TeaModel):
    def __init__(self, group_id=None, request_id=None):
        # The ID of the server group.
        self.group_id = group_id  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateOrUpdateAssetGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateAssetGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateOrUpdateAssetGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateOrUpdateAssetGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateAssetGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRestoreJobRequest(TeaModel):
    def __init__(self, includes=None, snapshot_hash=None, snapshot_id=None, snapshot_version=None, source_type=None,
                 target=None, uuid=None, vault_id=None):
        self.includes = includes  # type: str
        self.snapshot_hash = snapshot_hash  # type: str
        self.snapshot_id = snapshot_id  # type: str
        self.snapshot_version = snapshot_version  # type: str
        self.source_type = source_type  # type: str
        self.target = target  # type: str
        self.uuid = uuid  # type: str
        self.vault_id = vault_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRestoreJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.includes is not None:
            result['Includes'] = self.includes
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_version is not None:
            result['SnapshotVersion'] = self.snapshot_version
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target is not None:
            result['Target'] = self.target
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Includes') is not None:
            self.includes = m.get('Includes')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotVersion') is not None:
            self.snapshot_version = m.get('SnapshotVersion')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class CreateRestoreJobResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRestoreJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRestoreJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateRestoreJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateRestoreJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRestoreJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateServiceLinkedRoleRequest(TeaModel):
    def __init__(self, service_linked_role=None):
        # The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:
        # 
        # *   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
        # *   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.
        self.service_linked_role = service_linked_role  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateServiceLinkedRoleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_linked_role is not None:
            result['ServiceLinkedRole'] = self.service_linked_role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ServiceLinkedRole') is not None:
            self.service_linked_role = m.get('ServiceLinkedRole')
        return self


class CreateServiceLinkedRoleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateServiceLinkedRoleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateServiceLinkedRoleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateServiceLinkedRoleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateServiceLinkedRoleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateServiceLinkedRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimilarSecurityEventsQueryTaskRequest(TeaModel):
    def __init__(self, resource_owner_id=None, security_event_id=None, similar_event_scenario_code=None,
                 source_ip=None):
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the alert event.
        # 
        # >  You must specify at least one of the SecurityEventId and SimilarEventScenarioCode parameters.
        self.security_event_id = security_event_id  # type: long
        # The codes of alert events that are triggered by the same rule or of the same alert type.
        # 
        # >  You must specify at least one of the SecurityEventId and SimilarEventScenarioCode parameters.
        self.similar_event_scenario_code = similar_event_scenario_code  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimilarSecurityEventsQueryTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.similar_event_scenario_code is not None:
            result['SimilarEventScenarioCode'] = self.similar_event_scenario_code
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SimilarEventScenarioCode') is not None:
            self.similar_event_scenario_code = m.get('SimilarEventScenarioCode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse(TeaModel):
    def __init__(self, status=None, task_id=None):
        # The status of the task. Valid values:
        # 
        # *   **New**: The task is created.
        # *   **RetrievingData**: Data is being retrieved.
        # *   **DataRetrieved**: Data is retrieved.
        # *   **Processing**: The task is running.
        # *   **Success**: The task is successful.
        # *   **Failed**: The task failed.
        # *   **PartialFailed**: The task partially failed.
        self.status = status  # type: str
        # The ID of the task.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateSimilarSecurityEventsQueryTaskResponseBody(TeaModel):
    def __init__(self, create_similar_security_events_query_task_response=None, request_id=None):
        # The information about the task that queries alert events of the same alert type.
        self.create_similar_security_events_query_task_response = create_similar_security_events_query_task_response  # type: CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.create_similar_security_events_query_task_response:
            self.create_similar_security_events_query_task_response.validate()

    def to_map(self):
        _map = super(CreateSimilarSecurityEventsQueryTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_similar_security_events_query_task_response is not None:
            result['CreateSimilarSecurityEventsQueryTaskResponse'] = self.create_similar_security_events_query_task_response.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateSimilarSecurityEventsQueryTaskResponse') is not None:
            temp_model = CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse()
            self.create_similar_security_events_query_task_response = temp_model.from_map(m['CreateSimilarSecurityEventsQueryTaskResponse'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSimilarSecurityEventsQueryTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSimilarSecurityEventsQueryTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSimilarSecurityEventsQueryTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSimilarSecurityEventsQueryTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSuspEventNoteRequest(TeaModel):
    def __init__(self, event_id=None, note=None):
        # The ID of the alert event to which you want to add remarks. You can call the [DescribeSuspEvents](~~251497~~) operation to query the IDs of alert events.
        self.event_id = event_id  # type: long
        # The remarks that you want to add.
        self.note = note  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSuspEventNoteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.note is not None:
            result['Note'] = self.note
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('Note') is not None:
            self.note = m.get('Note')
        return self


class CreateSuspEventNoteResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether exceptions are handled. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSuspEventNoteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSuspEventNoteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSuspEventNoteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSuspEventNoteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSuspEventNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUniBackupPolicyRequest(TeaModel):
    def __init__(self, account_name=None, account_password=None, database_add_by_user=None, database_type=None,
                 full_plan=None, inc_plan=None, instance_id=None, policy_name=None, retention=None, speed_limiter=None,
                 uni_region_id=None, uuid=None):
        self.account_name = account_name  # type: str
        self.account_password = account_password  # type: str
        self.database_add_by_user = database_add_by_user  # type: str
        self.database_type = database_type  # type: str
        self.full_plan = full_plan  # type: dict[str, any]
        self.inc_plan = inc_plan  # type: dict[str, any]
        self.instance_id = instance_id  # type: str
        self.policy_name = policy_name  # type: str
        self.retention = retention  # type: int
        self.speed_limiter = speed_limiter  # type: long
        self.uni_region_id = uni_region_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUniBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.database_add_by_user is not None:
            result['DatabaseAddByUser'] = self.database_add_by_user
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('DatabaseAddByUser') is not None:
            self.database_add_by_user = m.get('DatabaseAddByUser')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            self.full_plan = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan = m.get('IncPlan')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateUniBackupPolicyShrinkRequest(TeaModel):
    def __init__(self, account_name=None, account_password=None, database_add_by_user=None, database_type=None,
                 full_plan_shrink=None, inc_plan_shrink=None, instance_id=None, policy_name=None, retention=None, speed_limiter=None,
                 uni_region_id=None, uuid=None):
        self.account_name = account_name  # type: str
        self.account_password = account_password  # type: str
        self.database_add_by_user = database_add_by_user  # type: str
        self.database_type = database_type  # type: str
        self.full_plan_shrink = full_plan_shrink  # type: str
        self.inc_plan_shrink = inc_plan_shrink  # type: str
        self.instance_id = instance_id  # type: str
        self.policy_name = policy_name  # type: str
        self.retention = retention  # type: int
        self.speed_limiter = speed_limiter  # type: long
        self.uni_region_id = uni_region_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUniBackupPolicyShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.database_add_by_user is not None:
            result['DatabaseAddByUser'] = self.database_add_by_user
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan_shrink is not None:
            result['FullPlan'] = self.full_plan_shrink
        if self.inc_plan_shrink is not None:
            result['IncPlan'] = self.inc_plan_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('DatabaseAddByUser') is not None:
            self.database_add_by_user = m.get('DatabaseAddByUser')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            self.full_plan_shrink = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan_shrink = m.get('IncPlan')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateUniBackupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUniBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUniBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUniBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUniBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUniRestorePlanRequest(TeaModel):
    def __init__(self, database=None, instance_uuid=None, policy_id=None, reset_scn=None, reset_time=None,
                 restore_info=None, time_point=None):
        self.database = database  # type: str
        self.instance_uuid = instance_uuid  # type: str
        self.policy_id = policy_id  # type: long
        self.reset_scn = reset_scn  # type: str
        self.reset_time = reset_time  # type: str
        self.restore_info = restore_info  # type: str
        self.time_point = time_point  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUniRestorePlanRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.reset_scn is not None:
            result['ResetScn'] = self.reset_scn
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.restore_info is not None:
            result['RestoreInfo'] = self.restore_info
        if self.time_point is not None:
            result['TimePoint'] = self.time_point
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('ResetScn') is not None:
            self.reset_scn = m.get('ResetScn')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('RestoreInfo') is not None:
            self.restore_info = m.get('RestoreInfo')
        if m.get('TimePoint') is not None:
            self.time_point = m.get('TimePoint')
        return self


class CreateUniRestorePlanResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUniRestorePlanResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUniRestorePlanResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUniRestorePlanResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUniRestorePlanResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUniRestorePlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVulAutoRepairConfigRequestVulAutoRepairConfigList(TeaModel):
    def __init__(self, alias_name=None, name=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVulAutoRepairConfigRequestVulAutoRepairConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateVulAutoRepairConfigRequest(TeaModel):
    def __init__(self, reason=None, type=None, vul_auto_repair_config_list=None):
        # The reason why the vulnerability can be automatically fixed.
        self.reason = reason  # type: str
        # The type of the vulnerability. Valid values: 
        # - **cve**: Linux software vulnerability. 
        # - **sys**: Windows system vulnerability.
        self.type = type  # type: str
        # The vulnerabilities that can be automatically fixed.
        self.vul_auto_repair_config_list = vul_auto_repair_config_list  # type: list[CreateVulAutoRepairConfigRequestVulAutoRepairConfigList]

    def validate(self):
        if self.vul_auto_repair_config_list:
            for k in self.vul_auto_repair_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateVulAutoRepairConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        result['VulAutoRepairConfigList'] = []
        if self.vul_auto_repair_config_list is not None:
            for k in self.vul_auto_repair_config_list:
                result['VulAutoRepairConfigList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.vul_auto_repair_config_list = []
        if m.get('VulAutoRepairConfigList') is not None:
            for k in m.get('VulAutoRepairConfigList'):
                temp_model = CreateVulAutoRepairConfigRequestVulAutoRepairConfigList()
                self.vul_auto_repair_config_list.append(temp_model.from_map(k))
        return self


class CreateVulAutoRepairConfigResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request was is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVulAutoRepairConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateVulAutoRepairConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateVulAutoRepairConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateVulAutoRepairConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVulAutoRepairConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAntiBruteForceRuleRequest(TeaModel):
    def __init__(self, ids=None):
        # An array that consists of the IDs of the defense rules against brute-force attacks to delete.
        self.ids = ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAntiBruteForceRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class DeleteAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAntiBruteForceRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAntiBruteForceRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteAntiBruteForceRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteAntiBruteForceRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBackupPolicyRequest(TeaModel):
    def __init__(self, id=None, policy_version=None):
        # The ID of the anti-ransomware policy that you want to delete.
        self.id = id  # type: long
        # The version of the anti-ransomware policy that you want to delete. You can call the [DescribeBackupPolicies](~~322795~~) operation to query the versions of anti-ransomware policies. Valid values:
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        self.policy_version = policy_version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        return self


class DeleteBackupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBackupPolicyMachineRequest(TeaModel):
    def __init__(self, policy_id=None, policy_version=None, uuid=None, uuid_list=None):
        # The ID of the anti-ransomware policy.
        # >  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the **Id** of anti-ransomware policies.
        self.policy_id = policy_id  # type: long
        # The version of the anti-ransomware policy. Valid values:
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        # 
        # >  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies.
        self.policy_version = policy_version  # type: str
        # The UUID of the server to which the anti-ransomware policy is applied.
        # 
        # >  You must specify at least one of the `UuidList` and `Uuid` parameters.
        self.uuid = uuid  # type: str
        # The UUIDs of the servers to which the anti-ransomware policy is applied.
        # 
        # >  You must specify at least one of the `UuidList` and `Uuid` parameters.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBackupPolicyMachineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DeleteBackupPolicyMachineResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBackupPolicyMachineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBackupPolicyMachineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteBackupPolicyMachineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteBackupPolicyMachineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBackupPolicyMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClientUserDefineRuleRequest(TeaModel):
    def __init__(self, id_list=None):
        self.id_list = id_list  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteClientUserDefineRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id_list is not None:
            result['IdList'] = self.id_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IdList') is not None:
            self.id_list = m.get('IdList')
        return self


class DeleteClientUserDefineRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteClientUserDefineRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteClientUserDefineRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteClientUserDefineRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteClientUserDefineRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomBlockRecordRequest(TeaModel):
    def __init__(self, id=None, resource_owner_id=None):
        self.id = id  # type: long
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomBlockRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCustomBlockRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomBlockRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomBlockRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCustomBlockRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCustomBlockRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCycleTaskRequest(TeaModel):
    def __init__(self, config_id=None):
        self.config_id = config_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCycleTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        return self


class DeleteCycleTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCycleTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCycleTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCycleTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCycleTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGroupRequest(TeaModel):
    def __init__(self, group_id=None, source_ip=None):
        # The ID of the server group that you want to delete.
        # 
        # >  To delete a server group, you must provide the ID of the server group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the ID.
        self.group_id = group_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DeleteGroupResponseBody(TeaModel):
    def __init__(self, code=None, request_id=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotRequest(TeaModel):
    def __init__(self, honeypot_id=None):
        self.honeypot_id = honeypot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        return self


class DeleteHoneypotResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHoneypotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHoneypotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotNodeRequest(TeaModel):
    def __init__(self, node_id=None):
        self.node_id = node_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class DeleteHoneypotNodeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHoneypotNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHoneypotNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotPresetRequest(TeaModel):
    def __init__(self, honeypot_preset_id=None):
        self.honeypot_preset_id = honeypot_preset_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotPresetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        return self


class DeleteHoneypotPresetResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotPresetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotPresetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHoneypotPresetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHoneypotPresetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHoneypotProbeRequest(TeaModel):
    def __init__(self, probe_id=None):
        self.probe_id = probe_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotProbeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class DeleteHoneypotProbeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHoneypotProbeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHoneypotProbeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHoneypotProbeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHoneypotProbeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstallCodeRequest(TeaModel):
    def __init__(self, captcha_code=None):
        self.captcha_code = captcha_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstallCodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        return self


class DeleteInstallCodeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstallCodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstallCodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInstallCodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInstallCodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInterceptionRuleRequest(TeaModel):
    def __init__(self, cluster_id=None, rule_ids=None):
        self.cluster_id = cluster_id  # type: str
        self.rule_ids = rule_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInterceptionRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        return self


class DeleteInterceptionRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInterceptionRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInterceptionRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInterceptionRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInterceptionRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInterceptionRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInterceptionTargetRequest(TeaModel):
    def __init__(self, target_ids=None):
        self.target_ids = target_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInterceptionTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_ids is not None:
            result['TargetIds'] = self.target_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetIds') is not None:
            self.target_ids = m.get('TargetIds')
        return self


class DeleteInterceptionTargetResponseBody(TeaModel):
    def __init__(self, request_id=None, result=None):
        self.request_id = request_id  # type: str
        self.result = result  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInterceptionTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DeleteInterceptionTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInterceptionTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInterceptionTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInterceptionTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLoginBaseConfigRequest(TeaModel):
    def __init__(self, config=None, target=None, type=None):
        # The configuration item that you want to delete. The items vary based on the type of logon configurations. Valid values:
        # 
        # *   **login\_common_ip**: approved logon IP addresses
        # 
        # Example: {"ip":"10.23.23.23"}.
        # 
        # *   **login\_common_time**: approved logon time ranges
        # 
        # Example: {"startTime":"06:00:00","endTime":"16:00:00"}.
        # 
        # *   **login\_common_account**: approved logon accounts
        # 
        # Example: {"account":"test_account\_001"}.
        # 
        # *   **login\_common_location**: approved logon locations
        # 
        # Example: {"location":"Shanghai"}.
        self.config = config  # type: str
        # The UUID of the server whose logon configurations you want to delete.
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.target = target  # type: str
        # The type of logon configurations to delete. Valid values:
        # 
        # *   **login\_common_ip**: approved logon IP addresses
        # *   **login\_common_time**: approved logon time ranges
        # *   **login\_common_account**: approved logon accounts
        # *   **login\_common_location**: approved logon locations
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLoginBaseConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteLoginBaseConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLoginBaseConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLoginBaseConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLoginBaseConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLoginBaseConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLoginBaseConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecurityEventMarkMissListRequest(TeaModel):
    def __init__(self, ids=None, resource_owner_id=None):
        self.ids = ids  # type: list[long]
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityEventMarkMissListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteSecurityEventMarkMissListResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityEventMarkMissListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSecurityEventMarkMissListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSecurityEventMarkMissListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSecurityEventMarkMissListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecurityEventMarkMissListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStrategyRequest(TeaModel):
    def __init__(self, id=None, lang=None, source_ip=None):
        # The ID of the baseline check policy that you want to delete.
        self.id = id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DeleteStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSuspEventNodeRequest(TeaModel):
    def __init__(self, note_id=None):
        self.note_id = note_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSuspEventNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        return self


class DeleteSuspEventNodeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSuspEventNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSuspEventNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSuspEventNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSuspEventNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSuspEventNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTagWithUuidRequest(TeaModel):
    def __init__(self, tag_name=None, uuid_list=None):
        # The name of the tag.
        self.tag_name = tag_name  # type: str
        # The list of server UUIDs.
        # 
        # >  If the UuidList parameter is configured, Security Center removes the tag only from the servers whose UUIDs are specified by UuidList. If the UuidList parameter is not configured, Security Center removes the tag from all servers.
        self.uuid_list = uuid_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTagWithUuidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DeleteTagWithUuidResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTagWithUuidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTagWithUuidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTagWithUuidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTagWithUuidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUniBackupPolicyRequest(TeaModel):
    def __init__(self, policy_id=None, policy_ids=None):
        self.policy_id = policy_id  # type: long
        self.policy_ids = policy_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteUniBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_ids is not None:
            result['PolicyIds'] = self.policy_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyIds') is not None:
            self.policy_ids = m.get('PolicyIds')
        return self


class DeleteUniBackupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteUniBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteUniBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteUniBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteUniBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVpcHoneyPotRequest(TeaModel):
    def __init__(self, vpc_id=None):
        # The ID of the virtual private cloud (VPC) on which the honeypot is deployed.
        # 
        # >  You can call the [DescribeVpcHoneyPotList](~~DescribeVpcHoneyPotList~~) operation to query the IDs of VPCs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVpcHoneyPotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DeleteVpcHoneyPotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVpcHoneyPotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVpcHoneyPotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVpcHoneyPotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVpcHoneyPotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVulWhitelistRequest(TeaModel):
    def __init__(self, id=None, whitelist=None):
        # The ID of the whitelist.
        # 
        # >  To delete a vulnerability whitelist, you must provide the ID of the whitelist. You can call the [DescribeVulWhitelist](~~DescribeVulWhitelist~~) operation to query the IDs of whitelists.
        self.id = id  # type: str
        # The information about the whitelist. The value is a JSON string that contains the following fields:
        # 
        # *   **Name**: the name of the vulnerability.
        # 
        # *   **Type**: the type of the vulnerability. Valid values:
        # 
        #     *   **cve**: Linux software vulnerability
        #     *   **sys**: Windows system vulnerability
        #     *   **cms**: Web-CMS vulnerability
        #     *   **app**: application vulnerability
        #     *   **emg**: urgent vulnerability
        # 
        # *   **AliasName**: the alias of the vulnerability.
        self.whitelist = whitelist  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVulWhitelistRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class DeleteVulWhitelistResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVulWhitelistResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVulWhitelistResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVulWhitelistResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVulWhitelistResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccessKeyLeakDetailRequest(TeaModel):
    def __init__(self, id=None):
        # The ID of the AccessKey pair leak.
        self.id = id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccessKeyLeakDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeAccessKeyLeakDetailResponseBody(TeaModel):
    def __init__(self, accesskey_id=None, asset=None, code=None, deal_time=None, deal_type=None,
                 github_file_name=None, github_file_type=None, github_file_update_time=None, github_file_url=None,
                 github_repo_name=None, github_repo_url=None, github_user=None, github_user_pic_url=None, gmt_create=None,
                 gmt_modified=None, remark=None, request_id=None, source=None, type=None, whitelist_status=None):
        # The ID of the AccessKey pair that is leaked.
        self.accesskey_id = accesskey_id  # type: str
        # The platform to which the asset belongs. The value is fixed as **Cloud platform**.
        self.asset = asset  # type: str
        # The code snippet that is leaked.
        self.code = code  # type: str
        # The time when the AccessKey pair leak was handled.
        self.deal_time = deal_time  # type: str
        # The solution to the AccessKey pair leak. Valid values:
        # 
        # *   **manual**: manually deleted
        # *   **disable**: manually disabled
        # *   **add-whitelist**: added to the whitelist
        # *   **pending**: unhandled
        self.deal_type = deal_type  # type: str
        # The name of the GitHub file.
        self.github_file_name = github_file_name  # type: str
        # The type of the GitHub file. Valid values:
        # 
        # *   Python
        # *   XML
        # *   GO
        # *   Javascript
        # *   INI
        # *   JSON
        # *   C++\
        self.github_file_type = github_file_type  # type: str
        # The time when the GitHub file was updated.
        self.github_file_update_time = github_file_update_time  # type: str
        # The URL of the GitHub file.
        self.github_file_url = github_file_url  # type: str
        # The name of the GitHub repository.
        self.github_repo_name = github_repo_name  # type: str
        # The URL of the GitHub repository.
        self.github_repo_url = github_repo_url  # type: str
        # The username of the GitHub user.
        self.github_user = github_user  # type: str
        # The URL of the profile picture for the GitHub user.
        self.github_user_pic_url = github_user_pic_url  # type: str
        # The first time when the AccessKey pair leak was detected.
        self.gmt_create = gmt_create  # type: str
        # The last time when the AccessKey pair leak was detected.
        self.gmt_modified = gmt_modified  # type: str
        # The remarks of the AccessKey pair leak.
        self.remark = remark  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The platform on which the AccessKey pair leak is detected.
        self.source = source  # type: str
        # The type of the leak. The value is fixed as **AccessKey**.
        self.type = type  # type: str
        # Indicates whether the AccessKey pair leak is added to the whitelist. Valid values:
        # 
        # *   **no**: The AccessKey pair leak is not added to the whitelist.
        # *   **yes**: The AccessKey pair leak is added to the whitelist.
        self.whitelist_status = whitelist_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccessKeyLeakDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accesskey_id is not None:
            result['AccesskeyId'] = self.accesskey_id
        if self.asset is not None:
            result['Asset'] = self.asset
        if self.code is not None:
            result['Code'] = self.code
        if self.deal_time is not None:
            result['DealTime'] = self.deal_time
        if self.deal_type is not None:
            result['DealType'] = self.deal_type
        if self.github_file_name is not None:
            result['GithubFileName'] = self.github_file_name
        if self.github_file_type is not None:
            result['GithubFileType'] = self.github_file_type
        if self.github_file_update_time is not None:
            result['GithubFileUpdateTime'] = self.github_file_update_time
        if self.github_file_url is not None:
            result['GithubFileUrl'] = self.github_file_url
        if self.github_repo_name is not None:
            result['GithubRepoName'] = self.github_repo_name
        if self.github_repo_url is not None:
            result['GithubRepoUrl'] = self.github_repo_url
        if self.github_user is not None:
            result['GithubUser'] = self.github_user
        if self.github_user_pic_url is not None:
            result['GithubUserPicUrl'] = self.github_user_pic_url
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist_status is not None:
            result['WhitelistStatus'] = self.whitelist_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccesskeyId') is not None:
            self.accesskey_id = m.get('AccesskeyId')
        if m.get('Asset') is not None:
            self.asset = m.get('Asset')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DealTime') is not None:
            self.deal_time = m.get('DealTime')
        if m.get('DealType') is not None:
            self.deal_type = m.get('DealType')
        if m.get('GithubFileName') is not None:
            self.github_file_name = m.get('GithubFileName')
        if m.get('GithubFileType') is not None:
            self.github_file_type = m.get('GithubFileType')
        if m.get('GithubFileUpdateTime') is not None:
            self.github_file_update_time = m.get('GithubFileUpdateTime')
        if m.get('GithubFileUrl') is not None:
            self.github_file_url = m.get('GithubFileUrl')
        if m.get('GithubRepoName') is not None:
            self.github_repo_name = m.get('GithubRepoName')
        if m.get('GithubRepoUrl') is not None:
            self.github_repo_url = m.get('GithubRepoUrl')
        if m.get('GithubUser') is not None:
            self.github_user = m.get('GithubUser')
        if m.get('GithubUserPicUrl') is not None:
            self.github_user_pic_url = m.get('GithubUserPicUrl')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WhitelistStatus') is not None:
            self.whitelist_status = m.get('WhitelistStatus')
        return self


class DescribeAccessKeyLeakDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAccessKeyLeakDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAccessKeyLeakDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccessKeyLeakDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccesskeyLeakListRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, query=None, start_ts=None, status=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page.\
        # Maximum value: 100. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # > : We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        # The AccessKey ID that you want to query. Only exact match is supported.
        self.query = query  # type: str
        # The beginning of the time range to query. You can query all AccessKey pair leaks that are detected later than this time point. The value of this parameter is a UNIX timestamp. Unit: milliseconds.
        self.start_ts = start_ts  # type: long
        # Specifies whether an AccessKey pair leak is handled. Valid values:
        # 
        # *   **pending**: unhandled
        # *   **dealed**: handled
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccesskeyLeakListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList(TeaModel):
    def __init__(self, accesskey_id=None, ali_user_name=None, asset=None, deal_time=None, deal_type=None,
                 gmt_modified=None, id=None, status=None, type=None, url=None, user_type=None):
        # The ID of the AccessKey pair that is leaked.
        self.accesskey_id = accesskey_id  # type: str
        # The name of the Alibaba Cloud account that is affected.
        self.ali_user_name = ali_user_name  # type: str
        # The platform to which the asset belongs. The value is fixed as **Cloud platform**.
        self.asset = asset  # type: str
        # The time when the AccessKey pair leak is handled.
        self.deal_time = deal_time  # type: str
        # The method to handle the AccessKey pair leak. Valid values:
        # 
        # *   **pending**: The AccessKey pair leak is unhandled.
        # *   **manual**: The AccessKey pair leak is manually handled.
        # *   **disable**: The AccessKey pair leak is disabled.
        # *   **add-whitelist**: The AccessKey pair leak is added to the whitelist.
        self.deal_type = deal_type  # type: str
        # The time when the AccessKey pair leak is first detected. The value of this parameter is a UNIX timestamp. Unit: milliseconds.
        self.gmt_modified = gmt_modified  # type: long
        # The primary key ID of the database.
        self.id = id  # type: long
        # Indicates whether the AccessKey pair leak is handled. Valid values:
        # 
        # *   **pending**: unhandled
        # *   **dealed**: handled
        self.status = status  # type: str
        # The type of the leak. The value is fixed as **AccessKey**.
        self.type = type  # type: str
        # The URL of the platform on which the AccessKey pair leak is detected.
        self.url = url  # type: str
        # The type of the account to which the leaked AccessKey pair belongs. Valid values:
        # 
        # *   **master**: Alibaba Cloud account
        # *   **ram**: RAM user
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accesskey_id is not None:
            result['AccesskeyId'] = self.accesskey_id
        if self.ali_user_name is not None:
            result['AliUserName'] = self.ali_user_name
        if self.asset is not None:
            result['Asset'] = self.asset
        if self.deal_time is not None:
            result['DealTime'] = self.deal_time
        if self.deal_type is not None:
            result['DealType'] = self.deal_type
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccesskeyId') is not None:
            self.accesskey_id = m.get('AccesskeyId')
        if m.get('AliUserName') is not None:
            self.ali_user_name = m.get('AliUserName')
        if m.get('Asset') is not None:
            self.asset = m.get('Asset')
        if m.get('DealTime') is not None:
            self.deal_time = m.get('DealTime')
        if m.get('DealType') is not None:
            self.deal_type = m.get('DealType')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeAccesskeyLeakListResponseBody(TeaModel):
    def __init__(self, access_key_leak_list=None, ak_leak_count=None, current_page=None, gmt_last=None,
                 page_size=None, request_id=None, total_count=None):
        # An array that consists of the details about AccessKey pair leaks.
        self.access_key_leak_list = access_key_leak_list  # type: list[DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList]
        # The number of AccessKey pair leaks that are unhandled.
        self.ak_leak_count = ak_leak_count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # This parameter is deprecated.
        self.gmt_last = gmt_last  # type: long
        # The number of entries returned on each page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of AccessKey pair leaks.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.access_key_leak_list:
            for k in self.access_key_leak_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAccesskeyLeakListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccessKeyLeakList'] = []
        if self.access_key_leak_list is not None:
            for k in self.access_key_leak_list:
                result['AccessKeyLeakList'].append(k.to_map() if k else None)
        if self.ak_leak_count is not None:
            result['AkLeakCount'] = self.ak_leak_count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.access_key_leak_list = []
        if m.get('AccessKeyLeakList') is not None:
            for k in m.get('AccessKeyLeakList'):
                temp_model = DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList()
                self.access_key_leak_list.append(temp_model.from_map(k))
        if m.get('AkLeakCount') is not None:
            self.ak_leak_count = m.get('AkLeakCount')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAccesskeyLeakListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAccesskeyLeakListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAccesskeyLeakListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccesskeyLeakListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAffectedAssetsRequest(TeaModel):
    def __init__(self, current=None, levels=None, page_size=None):
        self.current = current  # type: str
        self.levels = levels  # type: str
        self.page_size = page_size  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedAssetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAffectedAssetsResponseBodyAssetList(TeaModel):
    def __init__(self, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None, risk_num=None,
                 uuid=None):
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.risk_num = risk_num  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedAssetsResponseBodyAssetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.risk_num is not None:
            result['RiskNum'] = self.risk_num
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('RiskNum') is not None:
            self.risk_num = m.get('RiskNum')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAffectedAssetsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedAssetsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAffectedAssetsResponseBody(TeaModel):
    def __init__(self, asset_list=None, page_info=None, request_id=None):
        self.asset_list = asset_list  # type: list[DescribeAffectedAssetsResponseBodyAssetList]
        self.page_info = page_info  # type: DescribeAffectedAssetsResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.asset_list:
            for k in self.asset_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeAffectedAssetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AssetList'] = []
        if self.asset_list is not None:
            for k in self.asset_list:
                result['AssetList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.asset_list = []
        if m.get('AssetList') is not None:
            for k in m.get('AssetList'):
                temp_model = DescribeAffectedAssetsResponseBodyAssetList()
                self.asset_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeAffectedAssetsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAffectedAssetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAffectedAssetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAffectedAssetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAffectedAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAffectedMaliciousFileImagesRequest(TeaModel):
    def __init__(self, cluster_id=None, cluster_name=None, container_id=None, current_page=None, image=None,
                 image_digest=None, image_layer=None, image_tag=None, lang=None, levels=None, malicious_md_5=None, namespace=None,
                 page_size=None, pod=None, repo_id=None, repo_instance_id=None, repo_name=None, repo_namespace=None,
                 repo_region_id=None, scan_range=None):
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # The name of the container image.
        self.image = image  # type: str
        # The image digest.
        self.image_digest = image_digest  # type: str
        # The image layer.
        self.image_layer = image_layer  # type: str
        # The tag that is added to the image.
        self.image_tag = image_tag  # type: str
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The severity of the malicious image sample. Separate multiple severities with commas (,). Valid values: serious suspicious remind
        self.levels = levels  # type: str
        # The MD5 hash value of the malicious image sample.
        # 
        # >  You can call the [DescribeGroupedMaliciousFiles](~~DescribeGroupedMaliciousFiles~~) operation to query the MD5 hash values of malicious image samples.
        self.malicious_md_5 = malicious_md_5  # type: str
        # The namespace.
        self.namespace = namespace  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: str
        # The pod.
        self.pod = pod  # type: str
        # The ID of the image repository.
        # 
        # >  You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.
        self.repo_id = repo_id  # type: str
        # The ID of the container image.
        # 
        # >  You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of container images from the value of the **InstanceId** response parameter.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        # 
        # >  Fuzzy match is supported.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        # 
        # >  Fuzzy match is supported.
        self.repo_namespace = repo_namespace  # type: str
        # The region ID of the image repository. Valid values:
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-zhangjiakou**: China (Zhangjiakou)
        # *   **cn-hangzhou**: China (Hangzhou)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **cn-hongkong**: China (Hong Kong)
        # *   **ap-southeast-1**: Singapore
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        # *   **us-east-1**: US (Virginia)
        # *   **us-west-1**: US (Silicon Valley)
        # *   **eu-central-1**: Germany (Frankfurt)
        # *   **eu-west-1**: UK (London)
        # *   **ap-south-1**: India (Mumbai)
        self.repo_region_id = repo_region_id  # type: str
        # The types of the assets that you want to scan.
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedMaliciousFileImagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse(TeaModel):
    def __init__(self, cluster_id=None, cluster_name=None, container_id=None, digest=None, download_url=None,
                 file_path=None, first_scan_timestamp=None, high_light=None, image=None, image_uuid=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, latest_scan_timestamp=None, latest_verify_timestamp=None, layer=None,
                 level=None, malicious_md_5=None, namespace=None, pod=None, repo_id=None, repo_instance_id=None,
                 repo_name=None, repo_region_id=None, status=None, tag=None, target_id=None, target_name=None,
                 target_type=None, uuid=None):
        # The ID of the cluster.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The image digest.
        self.digest = digest  # type: str
        # The URL to download the malicious image sample.
        self.download_url = download_url  # type: str
        # The path to the image file.
        self.file_path = file_path  # type: str
        # The timestamp of the first scan.
        self.first_scan_timestamp = first_scan_timestamp  # type: long
        # The text that is highlighted.
        self.high_light = high_light  # type: str
        # The name of the image.
        self.image = image  # type: str
        # The UUID of the image.
        self.image_uuid = image_uuid  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        # The timestamp of the last scan.
        self.latest_scan_timestamp = latest_scan_timestamp  # type: long
        # The timestamp of the last verification.
        self.latest_verify_timestamp = latest_verify_timestamp  # type: long
        # The image layer.
        self.layer = layer  # type: str
        # The severity of the malicious image sample. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level  # type: str
        # The MD5 hash value of the malicious image sample.
        self.malicious_md_5 = malicious_md_5  # type: str
        # The namespace to which the image repository belongs.
        self.namespace = namespace  # type: str
        # The pod.
        self.pod = pod  # type: str
        # The ID of the image repository.
        self.repo_id = repo_id  # type: str
        # The ID of the container image.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id  # type: str
        # The handling status of the malicious image sample. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: verifying
        # *   **3**: added to the whitelist
        self.status = status  # type: int
        # The tag that is added to the image.
        self.tag = tag  # type: str
        self.target_id = target_id  # type: str
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.first_scan_timestamp is not None:
            result['FirstScanTimestamp'] = self.first_scan_timestamp
        if self.high_light is not None:
            result['HighLight'] = self.high_light
        if self.image is not None:
            result['Image'] = self.image
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.latest_scan_timestamp is not None:
            result['LatestScanTimestamp'] = self.latest_scan_timestamp
        if self.latest_verify_timestamp is not None:
            result['LatestVerifyTimestamp'] = self.latest_verify_timestamp
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FirstScanTimestamp') is not None:
            self.first_scan_timestamp = m.get('FirstScanTimestamp')
        if m.get('HighLight') is not None:
            self.high_light = m.get('HighLight')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LatestScanTimestamp') is not None:
            self.latest_scan_timestamp = m.get('LatestScanTimestamp')
        if m.get('LatestVerifyTimestamp') is not None:
            self.latest_verify_timestamp = m.get('LatestVerifyTimestamp')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAffectedMaliciousFileImagesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of images that have malicious image samples returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of images that have malicious image samples.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAffectedMaliciousFileImagesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAffectedMaliciousFileImagesResponseBody(TeaModel):
    def __init__(self, affected_malicious_file_images_response=None, page_info=None, request_id=None):
        # An array consisting of the images that have malicious image samples.
        self.affected_malicious_file_images_response = affected_malicious_file_images_response  # type: list[DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse]
        # The pagination information.
        self.page_info = page_info  # type: DescribeAffectedMaliciousFileImagesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.affected_malicious_file_images_response:
            for k in self.affected_malicious_file_images_response:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeAffectedMaliciousFileImagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AffectedMaliciousFileImagesResponse'] = []
        if self.affected_malicious_file_images_response is not None:
            for k in self.affected_malicious_file_images_response:
                result['AffectedMaliciousFileImagesResponse'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.affected_malicious_file_images_response = []
        if m.get('AffectedMaliciousFileImagesResponse') is not None:
            for k in m.get('AffectedMaliciousFileImagesResponse'):
                temp_model = DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse()
                self.affected_malicious_file_images_response.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeAffectedMaliciousFileImagesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAffectedMaliciousFileImagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAffectedMaliciousFileImagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAffectedMaliciousFileImagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAffectedMaliciousFileImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAgentInstallStatusRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, uuids=None):
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAgentInstallStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList(TeaModel):
    def __init__(self, message=None, resule_code=None, result=None, uuid=None):
        self.message = message  # type: str
        self.resule_code = resule_code  # type: str
        self.result = result  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.resule_code is not None:
            result['ResuleCode'] = self.resule_code
        if self.result is not None:
            result['Result'] = self.result
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ResuleCode') is not None:
            self.resule_code = m.get('ResuleCode')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAgentInstallStatusResponseBody(TeaModel):
    def __init__(self, aegis_client_invoke_status_response_list=None, request_id=None):
        self.aegis_client_invoke_status_response_list = aegis_client_invoke_status_response_list  # type: list[DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.aegis_client_invoke_status_response_list:
            for k in self.aegis_client_invoke_status_response_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAgentInstallStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisClientInvokeStatusResponseList'] = []
        if self.aegis_client_invoke_status_response_list is not None:
            for k in self.aegis_client_invoke_status_response_list:
                result['AegisClientInvokeStatusResponseList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aegis_client_invoke_status_response_list = []
        if m.get('AegisClientInvokeStatusResponseList') is not None:
            for k in m.get('AegisClientInvokeStatusResponseList'):
                temp_model = DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList()
                self.aegis_client_invoke_status_response_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAgentInstallStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAgentInstallStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAgentInstallStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAgentInstallStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventDetailRequest(TeaModel):
    def __init__(self, alarm_unique_info=None, from_=None, lang=None, source_ip=None):
        # The unique ID of the alert event.
        # 
        # >  To query the details of an alert event, you must specify the unique ID of the alert event. You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the unique IDs of alert events.
        self.alarm_unique_info = alarm_unique_info  # type: str
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue(TeaModel):
    def __init__(self, name=None, type=None, value=None):
        # The name of the field that displays tracing information.
        self.name = name  # type: str
        # The type of the field that displays tracing information. Valid values:
        # 
        # *   **text**\
        # *   **html**\
        self.type = type  # type: str
        # The value of the field that displays tracing information.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlarmEventDetailResponseBodyDataCauseDetails(TeaModel):
    def __init__(self, key=None, value=None):
        # The key that is used to trace the alert event.
        self.key = key  # type: str
        # An array consisting of the value that is used to trace the alert event.
        self.value = value  # type: list[DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue]

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventDetailResponseBodyDataCauseDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        result['Value'] = []
        if self.value is not None:
            for k in self.value:
                result['Value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        self.value = []
        if m.get('Value') is not None:
            for k in m.get('Value'):
                temp_model = DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue()
                self.value.append(temp_model.from_map(k))
        return self


class DescribeAlarmEventDetailResponseBodyData(TeaModel):
    def __init__(self, alarm_event_alias_name=None, alarm_event_desc=None, alarm_unique_info=None, app_name=None,
                 can_be_deal_on_line=None, can_cancel_fault=None, cause_details=None, contain_hw_mode=None, container_id=None,
                 container_image_id=None, container_image_name=None, data_source=None, end_time=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, k_8s_cluster_id=None, k_8s_cluster_name=None, k_8s_namespace=None,
                 k_8s_node_id=None, k_8s_node_name=None, k_8s_pod_name=None, level=None, solution=None, start_time=None,
                 type=None, uuid=None):
        # The name of the alert event.
        self.alarm_event_alias_name = alarm_event_alias_name  # type: str
        # The description of the alert event.
        self.alarm_event_desc = alarm_event_desc  # type: str
        # The unique ID of the alert event.
        # 
        # >  To query the details about an alert event, you must specify the unique ID of the alert event. You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the unique IDs of alert events.
        self.alarm_unique_info = alarm_unique_info  # type: str
        # The name of the container application.
        self.app_name = app_name  # type: str
        # Indicates whether the online handling of the alert event is supported. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_be_deal_on_line = can_be_deal_on_line  # type: bool
        # Indicates whether you can cancel marking the alert event as a false positive. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_cancel_fault = can_cancel_fault  # type: bool
        # An array consisting of the cause of the alert event, which can be used to trace the alert event.
        self.cause_details = cause_details  # type: list[DescribeAlarmEventDetailResponseBodyDataCauseDetails]
        # Indicates whether the Safeguard Mode For Major Activities mode is enabled.
        self.contain_hw_mode = contain_hw_mode  # type: bool
        # The ID of the container application.
        self.container_id = container_id  # type: str
        # The ID of the image to which the container belongs.
        self.container_image_id = container_image_id  # type: str
        # The name of the image to which the container belongs.
        self.container_image_name = container_image_name  # type: str
        # The data source of the alert event.
        self.data_source = data_source  # type: str
        # The timestamp when the alert event ends. Unit: milliseconds.
        self.end_time = end_time  # type: long
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The public IP address of the associated instance.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the associated instance.
        self.intranet_ip = intranet_ip  # type: str
        # The ID of the Kubernetes cluster.
        self.k_8s_cluster_id = k_8s_cluster_id  # type: str
        # The name of the Kubernetes cluster.
        self.k_8s_cluster_name = k_8s_cluster_name  # type: str
        # The namespace of the Kubernetes cluster.
        self.k_8s_namespace = k_8s_namespace  # type: str
        # The ID of the Kubernetes cluster node.
        self.k_8s_node_id = k_8s_node_id  # type: str
        # The name of the Kubernetes cluster node.
        self.k_8s_node_name = k_8s_node_name  # type: str
        # The name of the Kubernetes pod.
        self.k_8s_pod_name = k_8s_pod_name  # type: str
        # The severity of the alert event. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level  # type: str
        # The solution to the alert event.
        self.solution = solution  # type: str
        # The timestamp when the alert event starts. Unit: milliseconds.
        self.start_time = start_time  # type: long
        # The alert type of the alert event. Valid values:
        # 
        # *   Suspicious process
        # *   Webshell
        # *   Unusual logon
        # *   Exception
        # *   Sensitive file tampering
        # *   Malicious process (cloud threat detection)
        # *   Suspicious network connection
        # *   Other
        # *   Abnormal account
        # *   Application intrusion event
        # *   Cloud threat detection
        # *   Precise defense
        # *   Application whitelist
        # *   Persistent webshell
        # *   Web application threat detection
        # *   Malicious script
        # *   Threat intelligence
        # *   Malicious network activity
        # *   Cluster exception
        # *   Webshell (on-premises threat detection)
        # *   Vulnerability exploitation
        # *   Malicious process (on-premises threat detection)
        # *   Trusted exception
        self.type = type  # type: str
        # The instance UUID of the asset.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.cause_details:
            for k in self.cause_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventDetailResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_alias_name is not None:
            result['AlarmEventAliasName'] = self.alarm_event_alias_name
        if self.alarm_event_desc is not None:
            result['AlarmEventDesc'] = self.alarm_event_desc
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        result['CauseDetails'] = []
        if self.cause_details is not None:
            for k in self.cause_details:
                result['CauseDetails'].append(k.to_map() if k else None)
        if self.contain_hw_mode is not None:
            result['ContainHwMode'] = self.contain_hw_mode
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_image_id is not None:
            result['ContainerImageId'] = self.container_image_id
        if self.container_image_name is not None:
            result['ContainerImageName'] = self.container_image_name
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.k_8s_cluster_id is not None:
            result['K8sClusterId'] = self.k_8s_cluster_id
        if self.k_8s_cluster_name is not None:
            result['K8sClusterName'] = self.k_8s_cluster_name
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.k_8s_node_id is not None:
            result['K8sNodeId'] = self.k_8s_node_id
        if self.k_8s_node_name is not None:
            result['K8sNodeName'] = self.k_8s_node_name
        if self.k_8s_pod_name is not None:
            result['K8sPodName'] = self.k_8s_pod_name
        if self.level is not None:
            result['Level'] = self.level
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmEventAliasName') is not None:
            self.alarm_event_alias_name = m.get('AlarmEventAliasName')
        if m.get('AlarmEventDesc') is not None:
            self.alarm_event_desc = m.get('AlarmEventDesc')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        self.cause_details = []
        if m.get('CauseDetails') is not None:
            for k in m.get('CauseDetails'):
                temp_model = DescribeAlarmEventDetailResponseBodyDataCauseDetails()
                self.cause_details.append(temp_model.from_map(k))
        if m.get('ContainHwMode') is not None:
            self.contain_hw_mode = m.get('ContainHwMode')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerImageId') is not None:
            self.container_image_id = m.get('ContainerImageId')
        if m.get('ContainerImageName') is not None:
            self.container_image_name = m.get('ContainerImageName')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('K8sClusterId') is not None:
            self.k_8s_cluster_id = m.get('K8sClusterId')
        if m.get('K8sClusterName') is not None:
            self.k_8s_cluster_name = m.get('K8sClusterName')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('K8sNodeId') is not None:
            self.k_8s_node_id = m.get('K8sNodeId')
        if m.get('K8sNodeName') is not None:
            self.k_8s_node_name = m.get('K8sNodeName')
        if m.get('K8sPodName') is not None:
            self.k_8s_pod_name = m.get('K8sPodName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAlarmEventDetailResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The details about the alert event.
        self.data = data  # type: DescribeAlarmEventDetailResponseBodyData
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeAlarmEventDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAlarmEventDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlarmEventDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventListRequest(TeaModel):
    def __init__(self, alarm_event_name=None, alarm_event_type=None, current_page=None, dealed=None, from_=None,
                 group_id=None, id=None, lang=None, levels=None, operate_error_code_list=None, operate_time_end=None,
                 operate_time_start=None, page_size=None, remark=None, sort_column=None, sort_type=None, source_ip=None, tactic_id=None,
                 time_end=None, time_start=None, unique_info=None, uuids=None):
        # The name of the alert event.
        # 
        # >  You can call the [DescribeNsasSuspEventType](~~DescribeNsasSuspEventType~~) operation to query the names of alert events.
        self.alarm_event_name = alarm_event_name  # type: str
        # The type of the alert event.
        # 
        # >  You can call the [DescribeNsasSuspEventType](~~DescribeNsasSuspEventType~~) operation to query the types of alert events.
        self.alarm_event_type = alarm_event_type  # type: str
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the alert event is handled. Valid values:
        # 
        # *   **N**: unhandled
        # *   **Y**: handled
        self.dealed = dealed  # type: str
        # The ID of the request source. Set the value to **sas**, which indicates that the request is sent from Security Center.
        self.from_ = from_  # type: str
        # The ID of the asset group to which the affected asset belongs.
        self.group_id = group_id  # type: str
        # The ID of the alert event.
        self.id = id  # type: long
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The severity of the alert event. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.levels = levels  # type: str
        # An array that consists of the handling result codes of alert events.
        self.operate_error_code_list = operate_error_code_list  # type: list[str]
        # The time when the handling operation ends.
        self.operate_time_end = operate_time_end  # type: str
        # The time when the handing operation starts.
        self.operate_time_start = operate_time_start  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: str
        # The name of the alert or the information about the asset.
        self.remark = remark  # type: str
        # The custom sorting field. Default value: **operateTime**. Valid values:
        # 
        # *   **lastTime**: the latest occurrence time
        # *   **operateTime**: the handling time
        # 
        # >  This parameter takes effect if you set the **Dealed** parameter to Y.
        self.sort_column = sort_column  # type: str
        # The custom sorting order. Default value: **desc**. Valid values:
        # 
        # *   **asc**: the ascending order
        # *   **desc**: the descending order
        # 
        # >  This parameter takes effect if you set the **Dealed** parameter to Y.
        self.sort_type = sort_type  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The tactic ID of ATT\&CK.
        self.tactic_id = tactic_id  # type: str
        # The end time when the alert event was last detected.
        self.time_end = time_end  # type: str
        # The start time when the alert event was last detected.
        self.time_start = time_start  # type: str
        # The ID of the alert event.
        self.unique_info = unique_info  # type: str
        # The UUIDs of the assets. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.operate_error_code_list is not None:
            result['OperateErrorCodeList'] = self.operate_error_code_list
        if self.operate_time_end is not None:
            result['OperateTimeEnd'] = self.operate_time_end
        if self.operate_time_start is not None:
            result['OperateTimeStart'] = self.operate_time_start
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        if self.time_end is not None:
            result['TimeEnd'] = self.time_end
        if self.time_start is not None:
            result['TimeStart'] = self.time_start
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('OperateErrorCodeList') is not None:
            self.operate_error_code_list = m.get('OperateErrorCodeList')
        if m.get('OperateTimeEnd') is not None:
            self.operate_time_end = m.get('OperateTimeEnd')
        if m.get('OperateTimeStart') is not None:
            self.operate_time_start = m.get('OperateTimeStart')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        if m.get('TimeEnd') is not None:
            self.time_end = m.get('TimeEnd')
        if m.get('TimeStart') is not None:
            self.time_start = m.get('TimeStart')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeAlarmEventListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned per page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAlarmEventListResponseBodySuspEventsTacticItems(TeaModel):
    def __init__(self, tactic_display_name=None, tactic_id=None):
        # The tactic name of ATT\&CK.
        self.tactic_display_name = tactic_display_name  # type: str
        # The tactic ID of ATT\&CK.
        self.tactic_id = tactic_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventListResponseBodySuspEventsTacticItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tactic_display_name is not None:
            result['TacticDisplayName'] = self.tactic_display_name
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TacticDisplayName') is not None:
            self.tactic_display_name = m.get('TacticDisplayName')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        return self


class DescribeAlarmEventListResponseBodySuspEvents(TeaModel):
    def __init__(self, alarm_event_name=None, alarm_event_name_original=None, alarm_event_type=None,
                 alarm_unique_info=None, can_be_deal_on_line=None, can_cancel_fault=None, data_source=None, dealed=None,
                 description=None, end_time=None, gmt_modified=None, has_trace_info=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, level=None, operate_error_code=None, operate_time=None, sale_version=None,
                 security_event_ids=None, solution=None, stages=None, start_time=None, suspicious_event_count=None, tactic_items=None,
                 uuid=None):
        # The name of the alert event.
        self.alarm_event_name = alarm_event_name  # type: str
        # The original parent name of the alert event.
        self.alarm_event_name_original = alarm_event_name_original  # type: str
        # The type of the alert event.
        self.alarm_event_type = alarm_event_type  # type: str
        # The ID of the alert event.
        self.alarm_unique_info = alarm_unique_info  # type: str
        # Indicates whether the online processing of the alert event is supported, such as quarantining the source file of the malicious process, adding the alert event to the whitelist, and ignoring the alert event. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_be_deal_on_line = can_be_deal_on_line  # type: bool
        # Indicates whether you can cancel marking the alert event as a false positive. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_cancel_fault = can_cancel_fault  # type: bool
        # The data source of the alert event.
        self.data_source = data_source  # type: str
        # Indicates whether the alert event is handled. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.dealed = dealed  # type: bool
        # The description of the alert event.
        self.description = description  # type: str
        # The timestamp when the alert event was last detected. Unit: milliseconds.
        self.end_time = end_time  # type: long
        # The timestamp when the alert event was last modified. Unit: milliseconds.
        self.gmt_modified = gmt_modified  # type: long
        # Indicates whether the alert event has tracing information. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.has_trace_info = has_trace_info  # type: bool
        # The ID of the affected asset.
        self.instance_id = instance_id  # type: str
        # The name of the affected asset.
        self.instance_name = instance_name  # type: str
        # The public IP address of the affected asset.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the affected asset.
        self.intranet_ip = intranet_ip  # type: str
        # The risk level of the alert event. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level  # type: str
        # The handling result code of the alert event.
        self.operate_error_code = operate_error_code  # type: str
        # The timestamp when the alert event was handled. Unit: milliseconds.
        self.operate_time = operate_time  # type: long
        # The edition of Security Center in which the alert event can be detected. Valid values:
        # 
        # *   **0**: Basic edition
        # *   **1**: Advanced edition
        # *   **2**: Enterprise edition
        self.sale_version = sale_version  # type: str
        # The IDs of the associated exceptions.
        self.security_event_ids = security_event_ids  # type: str
        # The solution to the alert event.
        self.solution = solution  # type: str
        # The stage at which the attack or intrusion is detected.
        self.stages = stages  # type: str
        # The timestamp when the alert event starts. Unit: milliseconds.
        self.start_time = start_time  # type: long
        # The number of associated exceptions.
        self.suspicious_event_count = suspicious_event_count  # type: int
        # An array that consists of the stage information about ATT\&CK.
        self.tactic_items = tactic_items  # type: list[DescribeAlarmEventListResponseBodySuspEventsTacticItems]
        # The ID of the associated instance.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.tactic_items:
            for k in self.tactic_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventListResponseBodySuspEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_name_original is not None:
            result['AlarmEventNameOriginal'] = self.alarm_event_name_original
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.has_trace_info is not None:
            result['HasTraceInfo'] = self.has_trace_info
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.level is not None:
            result['Level'] = self.level
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.stages is not None:
            result['Stages'] = self.stages
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.suspicious_event_count is not None:
            result['SuspiciousEventCount'] = self.suspicious_event_count
        result['TacticItems'] = []
        if self.tactic_items is not None:
            for k in self.tactic_items:
                result['TacticItems'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventNameOriginal') is not None:
            self.alarm_event_name_original = m.get('AlarmEventNameOriginal')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HasTraceInfo') is not None:
            self.has_trace_info = m.get('HasTraceInfo')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('Stages') is not None:
            self.stages = m.get('Stages')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SuspiciousEventCount') is not None:
            self.suspicious_event_count = m.get('SuspiciousEventCount')
        self.tactic_items = []
        if m.get('TacticItems') is not None:
            for k in m.get('TacticItems'):
                temp_model = DescribeAlarmEventListResponseBodySuspEventsTacticItems()
                self.tactic_items.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAlarmEventListResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, susp_events=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeAlarmEventListResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the alert events.
        self.susp_events = susp_events  # type: list[DescribeAlarmEventListResponseBodySuspEvents]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.susp_events:
            for k in self.susp_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspEvents'] = []
        if self.susp_events is not None:
            for k in self.susp_events:
                result['SuspEvents'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeAlarmEventListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_events = []
        if m.get('SuspEvents') is not None:
            for k in m.get('SuspEvents'):
                temp_model = DescribeAlarmEventListResponseBodySuspEvents()
                self.susp_events.append(temp_model.from_map(k))
        return self


class DescribeAlarmEventListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlarmEventListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventStackInfoRequest(TeaModel):
    def __init__(self, event_name=None, lang=None, source_ip=None, unique_info=None, uuid=None):
        # The name of the event.
        # 
        # >  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of events.
        self.event_name = event_name  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the alert event.
        self.unique_info = unique_info  # type: str
        # The UUID of the server to query.
        # 
        # >  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAlarmEventStackInfoResponseBody(TeaModel):
    def __init__(self, request_id=None, stack_info=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The stack information of the alert details.
        self.stack_info = stack_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stack_info is not None:
            result['StackInfo'] = self.stack_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StackInfo') is not None:
            self.stack_info = m.get('StackInfo')
        return self


class DescribeAlarmEventStackInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlarmEventStackInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventStackInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllEntityResponseBodyEntityList(TeaModel):
    def __init__(self, group_id=None, instance_name=None, internet_ip=None, intranet_ip=None, ip=None, os=None,
                 uuid=None):
        # The ID of the asset group.
        self.group_id = group_id  # type: int
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The IP address of the server.
        self.ip = ip  # type: str
        # The operating system of the server. Valid values:
        # 
        # *   **linux**\
        # *   **windows**\
        self.os = os  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAllEntityResponseBodyEntityList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.os is not None:
            result['Os'] = self.os
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAllEntityResponseBody(TeaModel):
    def __init__(self, entity_list=None, request_id=None):
        # An array that consists of servers.
        self.entity_list = entity_list  # type: list[DescribeAllEntityResponseBodyEntityList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.entity_list:
            for k in self.entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAllEntityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EntityList'] = []
        if self.entity_list is not None:
            for k in self.entity_list:
                result['EntityList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.entity_list = []
        if m.get('EntityList') is not None:
            for k in m.get('EntityList'):
                temp_model = DescribeAllEntityResponseBodyEntityList()
                self.entity_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllEntityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAllEntityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAllEntityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllGroupsRequest(TeaModel):
    def __init__(self, lang=None):
        # The language of the content within the request and the response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAllGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeAllGroupsResponseBodyGroups(TeaModel):
    def __init__(self, group_flag=None, group_id=None, group_name=None):
        # The type of the server group. Valid values:
        # 
        # *   **0**: the default group
        # *   **1**: other groups
        self.group_flag = group_flag  # type: int
        # The ID of the server group.
        self.group_id = group_id  # type: int
        # The name of the server group.
        self.group_name = group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAllGroupsResponseBodyGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_flag is not None:
            result['GroupFlag'] = self.group_flag
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupFlag') is not None:
            self.group_flag = m.get('GroupFlag')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DescribeAllGroupsResponseBody(TeaModel):
    def __init__(self, count=None, groups=None, request_id=None):
        # The total number of server groups.
        self.count = count  # type: int
        # An array that consists of the information about server groups.
        self.groups = groups  # type: list[DescribeAllGroupsResponseBodyGroups]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAllGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = DescribeAllGroupsResponseBodyGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAllGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAllGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllImageBaselineRequest(TeaModel):
    def __init__(self, lang=None):
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAllImageBaselineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList(TeaModel):
    def __init__(self, alias=None, class_key=None, item_key=None, name_key=None):
        self.alias = alias  # type: str
        self.class_key = class_key  # type: str
        self.item_key = item_key  # type: str
        self.name_key = name_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.item_key is not None:
            result['ItemKey'] = self.item_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('ItemKey') is not None:
            self.item_key = m.get('ItemKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList(TeaModel):
    def __init__(self, alias=None, baseline_item_list=None, class_key=None, name_key=None):
        self.alias = alias  # type: str
        self.baseline_item_list = baseline_item_list  # type: list[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList]
        self.class_key = class_key  # type: str
        self.name_key = name_key  # type: str

    def validate(self):
        if self.baseline_item_list:
            for k in self.baseline_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['BaselineItemList'] = []
        if self.baseline_item_list is not None:
            for k in self.baseline_item_list:
                result['BaselineItemList'].append(k.to_map() if k else None)
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.baseline_item_list = []
        if m.get('BaselineItemList') is not None:
            for k in m.get('BaselineItemList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList()
                self.baseline_item_list.append(temp_model.from_map(k))
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList(TeaModel):
    def __init__(self, alias=None, baseline_name_list=None, class_key=None):
        self.alias = alias  # type: str
        self.baseline_name_list = baseline_name_list  # type: list[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList]
        self.class_key = class_key  # type: str

    def validate(self):
        if self.baseline_name_list:
            for k in self.baseline_name_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['BaselineNameList'] = []
        if self.baseline_name_list is not None:
            for k in self.baseline_name_list:
                result['BaselineNameList'].append(k.to_map() if k else None)
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.baseline_name_list = []
        if m.get('BaselineNameList') is not None:
            for k in m.get('BaselineNameList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList()
                self.baseline_name_list.append(temp_model.from_map(k))
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        return self


class DescribeAllImageBaselineResponseBodyImageBaselines(TeaModel):
    def __init__(self, baseline_class_list=None):
        self.baseline_class_list = baseline_class_list  # type: list[DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList]

    def validate(self):
        if self.baseline_class_list:
            for k in self.baseline_class_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponseBodyImageBaselines, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineClassList'] = []
        if self.baseline_class_list is not None:
            for k in self.baseline_class_list:
                result['BaselineClassList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.baseline_class_list = []
        if m.get('BaselineClassList') is not None:
            for k in m.get('BaselineClassList'):
                temp_model = DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList()
                self.baseline_class_list.append(temp_model.from_map(k))
        return self


class DescribeAllImageBaselineResponseBody(TeaModel):
    def __init__(self, image_baselines=None, request_id=None):
        self.image_baselines = image_baselines  # type: DescribeAllImageBaselineResponseBodyImageBaselines
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_baselines:
            self.image_baselines.validate()

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_baselines is not None:
            result['ImageBaselines'] = self.image_baselines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageBaselines') is not None:
            temp_model = DescribeAllImageBaselineResponseBodyImageBaselines()
            self.image_baselines = temp_model.from_map(m['ImageBaselines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllImageBaselineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAllImageBaselineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAllImageBaselineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllImageBaselineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAntiBruteForceRulesRequest(TeaModel):
    def __init__(self, id=None, resource_owner_id=None, source_ip=None):
        self.id = id  # type: long
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAntiBruteForceRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeAntiBruteForceRulesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAntiBruteForceRulesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAntiBruteForceRulesResponseBodyRules(TeaModel):
    def __init__(self, default_rule=None, enable_smart_rule=None, fail_count=None, forbidden_time=None, id=None,
                 machine_count=None, name=None, span=None, uuid_list=None):
        # Indicates whether the defense rule is the default rule. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  The default rule takes effect on all servers that are not protected by defense rules against brute-force attacks.
        self.default_rule = default_rule  # type: bool
        # This parameter is deprecated.
        self.enable_smart_rule = enable_smart_rule  # type: bool
        # The threshold of logon failures that you specify.
        self.fail_count = fail_count  # type: int
        # The period of time during which logons from an account are not allowed. Unit: minutes.
        self.forbidden_time = forbidden_time  # type: int
        # The ID of the defense rule.
        self.id = id  # type: long
        # The number of servers to which the defense rule is applied.
        self.machine_count = machine_count  # type: int
        # The name of the defense rule.
        self.name = name  # type: str
        # The period of time during which logon failures from an account are measured. Unit: minutes. If **Span** is set to 10, the defense rule takes effect when the logon failures measured within 10 minutes reaches the specified threshold. The IP address of attackers cannot be used to log on to the server in the specified period of time.
        self.span = span  # type: int
        # An array consisting of the UUIDs of servers to which the defense rule is applied.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAntiBruteForceRulesResponseBodyRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.enable_smart_rule is not None:
            result['EnableSmartRule'] = self.enable_smart_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.id is not None:
            result['Id'] = self.id
        if self.machine_count is not None:
            result['MachineCount'] = self.machine_count
        if self.name is not None:
            result['Name'] = self.name
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('EnableSmartRule') is not None:
            self.enable_smart_rule = m.get('EnableSmartRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MachineCount') is not None:
            self.machine_count = m.get('MachineCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeAntiBruteForceRulesResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, rules=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeAntiBruteForceRulesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the defense rules returned.
        self.rules = rules  # type: list[DescribeAntiBruteForceRulesResponseBodyRules]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAntiBruteForceRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeAntiBruteForceRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeAntiBruteForceRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeAntiBruteForceRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAntiBruteForceRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAntiBruteForceRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAntiBruteForceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppVulScanCycleResponseBody(TeaModel):
    def __init__(self, cycle=None, request_id=None):
        self.cycle = cycle  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAppVulScanCycleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle is not None:
            result['Cycle'] = self.cycle
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cycle') is not None:
            self.cycle = m.get('Cycle')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAppVulScanCycleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAppVulScanCycleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAppVulScanCycleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppVulScanCycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetDetailByUuidRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, uuid=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the server to query.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeAssetDetailByUuidResponseBodyAssetDetail(TeaModel):
    def __init__(self, asset_type=None, auth_modify_time=None, auth_version=None, bind=None, client_status=None,
                 client_version=None, cpu=None, cpu_info=None, create_time=None, disk_info_list=None, flag=None, group_trace=None,
                 host_name=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None, ip=None,
                 ip_list=None, kernel=None, mac_list=None, mem=None, memory=None, os=None, os_detail=None, os_name=None,
                 region=None, region_id=None, region_name=None, sys_info=None, tag=None, uuid=None, vpc_instance_id=None):
        # The type of the asset. Valid values:
        # 
        # *   **0**: ECS instance
        # *   **1**: Server Load Balancer (SLB) instance
        # *   **2**: NAT gateway
        # *   **3**: ApsaraDB RDS database
        # *   **4**: ApsaraDB for MongoDB database
        # *   **5**: ApsaraDB for Redis database
        # *   **6**: image
        # *   **7**: container
        self.asset_type = asset_type  # type: str
        # The timestamp when Security Center is authorized to protect the asset. Unit: milliseconds.
        self.auth_modify_time = auth_modify_time  # type: long
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition (Unauthorized)
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version  # type: int
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind  # type: bool
        # The status of the Security Center agent. Valid values:
        # 
        # *   **pause**: The Security Center agent suspends protection for your server.
        # *   **online**: The Security Center agent is protecting your server.
        # *   **offline**: The Security Center agent does not protect your server.
        self.client_status = client_status  # type: str
        # The version of the Security Center agent.
        self.client_version = client_version  # type: str
        # The number of CPU cores.
        self.cpu = cpu  # type: int
        # The details of the CPU.
        self.cpu_info = cpu_info  # type: str
        # The timestamp when Security Center records the details of the server. Unit: milliseconds.
        self.create_time = create_time  # type: long
        # An array that consists of the information about the disk.
        self.disk_info_list = disk_info_list  # type: list[str]
        # Indicates whether the asset is provided by Alibaba Cloud. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.flag = flag  # type: int
        # The group to which the server belongs. By default, the servers that are not grouped belong to the **Default** group.
        self.group_trace = group_trace  # type: str
        # The name of the host.
        self.host_name = host_name  # type: str
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The IP address that is assigned to the Elastic Compute Service (ECS) instance.
        self.ip = ip  # type: str
        # The IP addresses of the server.
        self.ip_list = ip_list  # type: list[str]
        # The kernel version of the operating system.
        self.kernel = kernel  # type: str
        # The media access control (MAC) addresses of the server.
        self.mac_list = mac_list  # type: list[str]
        # The memory size of the server. Unit: GB.
        self.mem = mem  # type: int
        # The memory size of the server. Unit: MB.
        self.memory = memory  # type: long
        # The operating system type of the server.
        self.os = os  # type: str
        # The operating system version of the server.
        self.os_detail = os_detail  # type: str
        # The name of the operating system.
        self.os_name = os_name  # type: str
        # The region in which the server resides.
        self.region = region  # type: str
        # The ID of the region in which the asset resides.
        self.region_id = region_id  # type: str
        # The name of the region in which the server resides.
        self.region_name = region_name  # type: str
        # The operating system information about the server.
        self.sys_info = sys_info  # type: str
        # The tag that is added to the server.
        self.tag = tag  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str
        # The ID of the virtual private cloud (VPC) in which the server resides.
        self.vpc_instance_id = vpc_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidResponseBodyAssetDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.auth_modify_time is not None:
            result['AuthModifyTime'] = self.auth_modify_time
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_info is not None:
            result['CpuInfo'] = self.cpu_info
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.disk_info_list is not None:
            result['DiskInfoList'] = self.disk_info_list
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.group_trace is not None:
            result['GroupTrace'] = self.group_trace
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_list is not None:
            result['IpList'] = self.ip_list
        if self.kernel is not None:
            result['Kernel'] = self.kernel
        if self.mac_list is not None:
            result['MacList'] = self.mac_list
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.os is not None:
            result['Os'] = self.os
        if self.os_detail is not None:
            result['OsDetail'] = self.os_detail
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.sys_info is not None:
            result['SysInfo'] = self.sys_info
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AuthModifyTime') is not None:
            self.auth_modify_time = m.get('AuthModifyTime')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuInfo') is not None:
            self.cpu_info = m.get('CpuInfo')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DiskInfoList') is not None:
            self.disk_info_list = m.get('DiskInfoList')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('GroupTrace') is not None:
            self.group_trace = m.get('GroupTrace')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpList') is not None:
            self.ip_list = m.get('IpList')
        if m.get('Kernel') is not None:
            self.kernel = m.get('Kernel')
        if m.get('MacList') is not None:
            self.mac_list = m.get('MacList')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsDetail') is not None:
            self.os_detail = m.get('OsDetail')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('SysInfo') is not None:
            self.sys_info = m.get('SysInfo')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        return self


class DescribeAssetDetailByUuidResponseBody(TeaModel):
    def __init__(self, asset_detail=None, request_id=None):
        # The details of the server.
        self.asset_detail = asset_detail  # type: DescribeAssetDetailByUuidResponseBodyAssetDetail
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.asset_detail:
            self.asset_detail.validate()

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_detail is not None:
            result['AssetDetail'] = self.asset_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetDetail') is not None:
            temp_model = DescribeAssetDetailByUuidResponseBodyAssetDetail()
            self.asset_detail = temp_model.from_map(m['AssetDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetDetailByUuidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAssetDetailByUuidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetDetailByUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetDetailByUuidsRequest(TeaModel):
    def __init__(self, lang=None, uuids=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The UUIDs of the ECS instances. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeAssetDetailByUuidsResponseBodyAssetList(TeaModel):
    def __init__(self, asset_type=None, client_status=None, flag=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, ip=None, os=None, os_name=None, region=None, region_id=None,
                 region_name=None, uuid=None, vpc_instance_id=None):
        # The type of the asset.
        # 
        # The value is fixed as **0**, which indicates ECS instances.
        self.asset_type = asset_type  # type: str
        # The status of the Security Center agent. Valid values:
        # 
        # *   **online**\
        # *   **offline**\
        self.client_status = client_status  # type: str
        # The type of the asset by source. Valid values:
        # 
        # *   **0**: The asset is provided by Alibaba Cloud.
        # *   **1**: The asset is not provided by Alibaba Cloud.
        # *   **2**: The asset resides in a data center.
        # *   **3**, **4**, **5**, and **7**: other cloud asset.
        # *   **8**: light-weight assets.
        self.flag = flag  # type: int
        # The ID of the ECS instance.
        self.instance_id = instance_id  # type: str
        # The name of the ECS instance.
        self.instance_name = instance_name  # type: str
        # The public IP address of the ECS instance.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the ECS instance.
        self.intranet_ip = intranet_ip  # type: str
        # The IP address of the ECS instance.
        # 
        # >  If the ECS instance has a public IP address, the value of this parameter is the public IP address of the ECS instance. If the ECS instance does not have a public IP address, the value of this parameter is the private IP address of the ECS instance.
        self.ip = ip  # type: str
        # The operating system of the ECS instance.
        self.os = os  # type: str
        # The name of the operating system run by the ECS instance.
        self.os_name = os_name  # type: str
        # The region in which the ECS instance resides.
        self.region = region  # type: str
        # The region in which the ECS instance resides.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id  # type: str
        # The name of the region in which the ECS instance resides.
        self.region_name = region_name  # type: str
        # The UUID of the ECS instance.
        self.uuid = uuid  # type: str
        # The ID of the virtual private cloud (VPC).
        self.vpc_instance_id = vpc_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidsResponseBodyAssetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.os is not None:
            result['Os'] = self.os
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        return self


class DescribeAssetDetailByUuidsResponseBody(TeaModel):
    def __init__(self, asset_list=None, request_id=None):
        # An array that consists of the details of the ECS instances.
        self.asset_list = asset_list  # type: list[DescribeAssetDetailByUuidsResponseBodyAssetList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.asset_list:
            for k in self.asset_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AssetList'] = []
        if self.asset_list is not None:
            for k in self.asset_list:
                result['AssetList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.asset_list = []
        if m.get('AssetList') is not None:
            for k in m.get('AssetList'):
                temp_model = DescribeAssetDetailByUuidsResponseBodyAssetList()
                self.asset_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetDetailByUuidsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAssetDetailByUuidsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAssetDetailByUuidsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetDetailByUuidsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAssetSummaryResponseBodyAssetsSummary(TeaModel):
    def __init__(self, total_asset_all_region=None, total_core_all_region=None, total_core_num=None):
        # The total number of protected assets in all regions.
        self.total_asset_all_region = total_asset_all_region  # type: int
        # The total number of cores of protected assets in all regions.
        self.total_core_all_region = total_core_all_region  # type: int
        # The total number of cores of protected assets in the current region.
        self.total_core_num = total_core_num  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAssetSummaryResponseBodyAssetsSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_asset_all_region is not None:
            result['TotalAssetAllRegion'] = self.total_asset_all_region
        if self.total_core_all_region is not None:
            result['TotalCoreAllRegion'] = self.total_core_all_region
        if self.total_core_num is not None:
            result['TotalCoreNum'] = self.total_core_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TotalAssetAllRegion') is not None:
            self.total_asset_all_region = m.get('TotalAssetAllRegion')
        if m.get('TotalCoreAllRegion') is not None:
            self.total_core_all_region = m.get('TotalCoreAllRegion')
        if m.get('TotalCoreNum') is not None:
            self.total_core_num = m.get('TotalCoreNum')
        return self


class DescribeAssetSummaryResponseBody(TeaModel):
    def __init__(self, assets_summary=None, request_id=None):
        # The statistical information about the assets.
        self.assets_summary = assets_summary  # type: DescribeAssetSummaryResponseBodyAssetsSummary
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.assets_summary:
            self.assets_summary.validate()

    def to_map(self):
        _map = super(DescribeAssetSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_summary is not None:
            result['AssetsSummary'] = self.assets_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetsSummary') is not None:
            temp_model = DescribeAssetSummaryResponseBodyAssetsSummary()
            self.assets_summary = temp_model.from_map(m['AssetsSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAssetSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAssetSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAssetSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAssetSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAttackAnalysisDataRequest(TeaModel):
    def __init__(self, base_64=None, current_page=None, data=None, end_time=None, lang=None, page_size=None,
                 start_time=None, type=None):
        # Specifies whether to encode the value of the **client_url** field in the query results by using the Base64 algorithm. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.base_64 = base_64  # type: str
        # The number of the page to return. Pages start from page **1**.
        # 
        # >  If the Type parameter is set to **DETAILS**, you must specify the CurrentPage parameter.
        self.current_page = current_page  # type: int
        # The condition that is used to filter attack events.
        # 
        # >  The following list describes the valid values of crack_type:
        # 
        # *   3: brute-force attack on MySQL
        # 
        # *   4: FTP brute-force attack
        # 
        # *   5: SSH brute-force attack
        # 
        # *   6: RDP brute-force attack
        # 
        # *   9: brute-force attack on Microsoft SQL Server
        # 
        # *   101: intercepted attack on Java Struts 2
        # 
        # *   102: intercepted attack on Redis
        # 
        # *   103: communication with AntSword Webshell
        # 
        # *   104: communication with China Chopper Webshell
        # 
        # *   133: communication with XISE Webshell
        # 
        # *   sqli: SQL injection
        # 
        # *   codei: code execution
        # 
        # *   xss: cross-site scripting (XSS)
        # 
        # *   lfi: local file inclusion
        # 
        # *   rfi: remote file inclusion
        # 
        # *   webshell: trojan script
        # 
        # *   upload: vulnerability upload
        # 
        # *   path: directory traversal
        # 
        # *   bypass: unauthorized access
        # 
        # *   csrf: cross-site request forgery (CSRF)
        # 
        # *   crlf: carriage return line feed (CRLF)
        # 
        # *   other: others
        self.data = data  # type: str
        # The timestamp when the attack stops. Unit: seconds.
        self.end_time = end_time  # type: long
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page.
        # 
        # >  If the Type parameter is set to **DETAILS**, you must specify the PageSize parameter.
        self.page_size = page_size  # type: int
        # The timestamp at which the attack starts. By default, the statistics of the previous seven days are queried. Unit: seconds.
        # 
        # >  The start time that you specify must be within the previous 40 days.
        self.start_time = start_time  # type: long
        # The details of attack analysis. Valid values:
        # 
        # *   **TOTAL**: number of attacks
        # *   **TREND**: attack trend
        # *   **PIE_CHART**: distribution of attacks by type
        # *   **SOURCE_TOP**: top 5 attack sources
        # *   **CLIENT_TOP**: top 5 attacked assets
        # *   **DETAILS**: attack details
        # 
        # >  If the Type parameter is set to **DETAILS**, you must specify the CurrentPage and PageSize parameters.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAttackAnalysisDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_64 is not None:
            result['Base64'] = self.base_64
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Base64') is not None:
            self.base_64 = m.get('Base64')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAttackAnalysisDataResponseBody(TeaModel):
    def __init__(self, data=None, page=None, page_size=None, request_id=None, total=None):
        # The attack events. The value contains the following fields:
        # 
        # *   **client_url**: the URL of the attack request.
        # 
        # *   **internetIp**: the IP address of the asset.
        # 
        # *   **instanceName**: the name of the asset.
        # 
        # *   **table_src**: the source of data.
        # 
        # *   **uuid**: the UUID of the asset.
        # 
        # *   **crack_method**: the method of the attack request.
        # 
        # *   **crack_hour**: the attack time.
        # 
        # *   **crack_src_ip**: the IP address from which the attack is launched.
        # 
        # *   **instanceId**: the ID of the asset.
        # 
        # *   **dst_port**: the attacked port.
        # 
        # *   **client_ip**: the attacked IP address.
        # 
        # *   **location**: the region from which the attack is launched.
        # 
        # *   **aliuid**: the ID of the Alibaba Cloud account.
        # 
        # *   **crack_cnt**: the number of times that the attack is launched.
        # 
        # *   **crack_type**: the type of the attack. Valid values:
        # 
        #     *   **113**: improper authorization
        #     *   **112**: redirection attack
        #     *   **upload**: vulnerability upload
        #     *   **other**: others
        #     *   **webshell**: trojan script
        #     *   **201**: suspicious connection
        #     *   **9**: brute-force attack on Microsoft SQL Server
        #     *   **5**: SSH brute-force attack
        #     *   **6**: RDP brute-force attack
        #     *   **lfi**: local file inclusion
        #     *   **7**: code execution
        #     *   **sqli**: SQL injection
        #     *   **209**: web attack
        #     *   **31**: buffer overflow
        #     *   **3**: brute-force attack on MySQL
        #     *   **30**: clickjacking
        #     *   **4**: FTP brute-force attack
        #     *   **bypass**: unauthorized access
        #     *   **33**: format string
        #     *   **deeplearning**: others
        #     *   **32**: integer overflow
        #     *   **203**: brute-force attack
        #     *   **34**: race condition
        #     *   **rfi**: remote file inclusion
        #     *   **0**: SQL injection
        #     *   **212**: mining behavior
        #     *   **213**: reverse shell
        #     *   **211**: worm
        #     *   **61**: session timeout
        #     *   **20**: directory traversal
        #     *   **xss**: XSS
        #     *   **22**: unauthorized access
        #     *   **21**: scan attack
        #     *   **24**: file modification
        #     *   **26**: file deletion
        #     *   **25**: file reading
        #     *   **28**: CRLF injection
        #     *   **27**: logic error
        #     *   **29**: template injection
        #     *   **csrf**: CSRF
        #     *   **path**: directory traversal
        #     *   **crlf**: CRLF
        #     *   **102**: CSRF
        #     *   **103**: server-side request forgery (SSRF)
        #     *   **101**: XSS
        #     *   **11**: file inclusion
        #     *   **10**: file upload
        #     *   **12**: vulnerability upload
        #     *   **15**: unauthorized access
        #     *   **14**: information leakage
        #     *   **17**: XML entity injection
        #     *   **16**: insecure configuration
        #     *   **19**: Lightweight Directory Access Protocol (LDAP) injection
        #     *   **18**: XPath injection
        #     *   **codei**: code execution
        self.data = data  # type: str
        # The page number of the returned page.
        self.page = page  # type: int
        # The number of entries returned per page. Default value: 10.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of attack events returned.
        self.total = total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAttackAnalysisDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeAttackAnalysisDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAttackAnalysisDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAttackAnalysisDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAttackAnalysisDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoDelConfigResponseBody(TeaModel):
    def __init__(self, days=None, request_id=None):
        # The number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
        self.days = days  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoDelConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAutoDelConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoDelConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoDelConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoDelConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackUpExportInfoRequest(TeaModel):
    def __init__(self, current_page=None, export_type=None, lang=None, page_size=None):
        self.current_page = current_page  # type: int
        self.export_type = export_type  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackUpExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeBackUpExportInfoResponseBodyData(TeaModel):
    def __init__(self, current_count=None, file_name=None, gmt_create=None, id=None, link=None, message=None,
                 progress=None, status=None, total_count=None):
        self.current_count = current_count  # type: int
        self.file_name = file_name  # type: str
        self.gmt_create = gmt_create  # type: long
        self.id = id  # type: long
        self.link = link  # type: str
        self.message = message  # type: str
        self.progress = progress  # type: int
        self.status = status  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackUpExportInfoResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackUpExportInfoResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackUpExportInfoResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackUpExportInfoResponseBody(TeaModel):
    def __init__(self, data=None, page_info=None, request_id=None):
        self.data = data  # type: list[DescribeBackUpExportInfoResponseBodyData]
        self.page_info = page_info  # type: DescribeBackUpExportInfoResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeBackUpExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeBackUpExportInfoResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackUpExportInfoResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackUpExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackUpExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackUpExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackUpExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupClientsRequest(TeaModel):
    def __init__(self, support_region_id=None):
        # The region in which the anti-ransomware feature is supported.
        # > You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.
        self.support_region_id = support_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupClientsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.support_region_id is not None:
            result['SupportRegionId'] = self.support_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportRegionId') is not None:
            self.support_region_id = m.get('SupportRegionId')
        return self


class DescribeBackupClientsResponseBodyClients(TeaModel):
    def __init__(self, client_id=None, client_status=None, client_version=None, instance_id=None, uuid=None):
        # The ID of the anti-ransomware agent.
        self.client_id = client_id  # type: str
        # The status of the anti-ransomware agent.
        # 
        # Valid values:
        # 
        # *   **INSTALLING**: The agent is being installed.
        # *   **ONLINE**: The agent is online.
        # *   **UNINSTALLING**: The agent is being uninstalled.
        # *   **NOT_INSTALLED**: The agent is not installed.
        # *   **ACTIVATED**: The agent is enabled.
        # *   **CLIENT\_CONNECTION_ERROR**: A connection error occurs on the agent.
        self.client_status = client_status  # type: str
        # The version of the anti-ransomware agent.
        self.client_version = client_version  # type: str
        # The ID of the ECS instance on which the anti-ransomware agent is installed.
        self.instance_id = instance_id  # type: str
        # The UUID of the Elastic Compute Service (ECS) instance on which the anti-ransomware agent is installed.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupClientsResponseBodyClients, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupClientsResponseBody(TeaModel):
    def __init__(self, clients=None, request_id=None):
        # An array that consists of the information about the anti-ransomware agent.
        self.clients = clients  # type: list[DescribeBackupClientsResponseBodyClients]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.clients:
            for k in self.clients:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBackupClientsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clients'] = []
        if self.clients is not None:
            for k in self.clients:
                result['Clients'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.clients = []
        if m.get('Clients') is not None:
            for k in m.get('Clients'):
                temp_model = DescribeBackupClientsResponseBodyClients()
                self.clients.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupClientsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupClientsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupClientsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupClientsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupFilesRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, path=None, snapshot_hash=None, uuid=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: str
        # The path to the backup file.
        self.path = path  # type: str
        # The hash value of the backup file.
        self.snapshot_hash = snapshot_hash  # type: str
        # The UUID of the server to which an anti-ransomware policy is applied.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.path is not None:
            result['Path'] = self.path
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupFilesResponseBodyBackupFiles(TeaModel):
    def __init__(self, name=None, size=None, subtree=None, type=None):
        # The name of the anti-ransomware policy.
        self.name = name  # type: str
        # The size of the backup file. Unit: bytes.
        self.size = size  # type: long
        # The path to the subdirectory of the backup file.
        self.subtree = subtree  # type: str
        # The type of the protected file. Valid values:
        # 
        # *   **file**: files
        # *   **dir**: folders
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupFilesResponseBodyBackupFiles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.size is not None:
            result['Size'] = self.size
        if self.subtree is not None:
            result['Subtree'] = self.subtree
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Subtree') is not None:
            self.subtree = m.get('Subtree')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeBackupFilesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of backup files returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of backup files returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupFilesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackupFilesResponseBody(TeaModel):
    def __init__(self, backup_files=None, page_info=None, request_id=None):
        # An array that consists of the backup files returned.
        self.backup_files = backup_files  # type: list[DescribeBackupFilesResponseBodyBackupFiles]
        # The pagination information.
        self.page_info = page_info  # type: DescribeBackupFilesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_files:
            for k in self.backup_files:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeBackupFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackupFiles'] = []
        if self.backup_files is not None:
            for k in self.backup_files:
                result['BackupFiles'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.backup_files = []
        if m.get('BackupFiles') is not None:
            for k in m.get('BackupFiles'):
                temp_model = DescribeBackupFilesResponseBodyBackupFiles()
                self.backup_files.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackupFilesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupMachineStatusRequest(TeaModel):
    def __init__(self, policy_id=None, policy_version=None, uuid=None):
        self.policy_id = policy_id  # type: long
        self.policy_version = policy_version  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupMachineStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList(TeaModel):
    def __init__(self, error_code=None, error_status=None):
        self.error_code = error_code  # type: str
        self.error_status = error_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_status is not None:
            result['ErrorStatus'] = self.error_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorStatus') is not None:
            self.error_status = m.get('ErrorStatus')
        return self


class DescribeBackupMachineStatusResponseBodyBackupMachineStatus(TeaModel):
    def __init__(self, client_id=None, client_status=None, client_version=None, error_code=None, error_list=None,
                 instance_id=None, region_id=None, saved_backup_count=None, status=None, uuid=None, vault_id=None):
        self.client_id = client_id  # type: str
        self.client_status = client_status  # type: str
        self.client_version = client_version  # type: str
        self.error_code = error_code  # type: str
        self.error_list = error_list  # type: list[DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList]
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str
        self.saved_backup_count = saved_backup_count  # type: int
        self.status = status  # type: str
        self.uuid = uuid  # type: str
        self.vault_id = vault_id  # type: str

    def validate(self):
        if self.error_list:
            for k in self.error_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBackupMachineStatusResponseBodyBackupMachineStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        result['ErrorList'] = []
        if self.error_list is not None:
            for k in self.error_list:
                result['ErrorList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.saved_backup_count is not None:
            result['SavedBackupCount'] = self.saved_backup_count
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        self.error_list = []
        if m.get('ErrorList') is not None:
            for k in m.get('ErrorList'):
                temp_model = DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList()
                self.error_list.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SavedBackupCount') is not None:
            self.saved_backup_count = m.get('SavedBackupCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeBackupMachineStatusResponseBody(TeaModel):
    def __init__(self, backup_machine_status=None, request_id=None):
        self.backup_machine_status = backup_machine_status  # type: DescribeBackupMachineStatusResponseBodyBackupMachineStatus
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_machine_status:
            self.backup_machine_status.validate()

    def to_map(self):
        _map = super(DescribeBackupMachineStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_machine_status is not None:
            result['BackupMachineStatus'] = self.backup_machine_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupMachineStatus') is not None:
            temp_model = DescribeBackupMachineStatusResponseBodyBackupMachineStatus()
            self.backup_machine_status = temp_model.from_map(m['BackupMachineStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupMachineStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupMachineStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupMachineStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupMachineStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupPoliciesRequest(TeaModel):
    def __init__(self, current_page=None, machine_remark=None, name=None, page_size=None, status=None):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page  # type: int
        # The information that you want to use to identify the servers protected by the anti-ransomware policy. You can enter the IP address or ID of a server.
        self.machine_remark = machine_remark  # type: str
        # The name of the anti-ransomware policy that you want to query.
        self.name = name  # type: str
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: The anti-ransomware policy is manually enabled.
        # *   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
        # *   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupPoliciesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeBackupPoliciesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: 10.
        self.page_size = page_size  # type: int
        # The total number of anti-ransomware policies returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupPoliciesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBackupPoliciesResponseBodyPolicies(TeaModel):
    def __init__(self, client_error_count=None, client_error_uuid_list=None, client_status=None,
                 health_client_count=None, health_client_uuid_list=None, id=None, name=None, policy=None, policy_region_id=None,
                 policy_version=None, remarked_uuid_list=None, server_type=None, service_error_count=None,
                 service_error_uuid_list=None, status=None, upgrade_status=None, uuid_list=None):
        # The number of the servers on which the anti-ransomware agent is in an abnormal state.
        self.client_error_count = client_error_count  # type: int
        # The UUIDs of the servers on which the anti-ransomware agent is in an **abnormal** state.
        self.client_error_uuid_list = client_error_uuid_list  # type: list[str]
        # The status of the anti-ransomware agent. Valid values:
        # 
        # *   **running**: normal
        # *   **exception**: abnormal
        self.client_status = client_status  # type: str
        # The number of the servers on which the anti-ransomware agent is in a normal state.
        self.health_client_count = health_client_count  # type: int
        # The UUIDs of the servers on which the anti-ransomware agent is in a **normal** state.
        self.health_client_uuid_list = health_client_uuid_list  # type: list[str]
        # The ID of the anti-ransomware policy.
        self.id = id  # type: long
        # The name of the anti-ransomware policy.
        self.name = name  # type: str
        # The configurations of the anti-ransomware policy. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **IsDefault**: the type of the anti-ransomware policy. Valid values:
        # 
        #     *   **1**: recommended policy
        #     *   **0**: custom policy
        # 
        # *   **Include**: the format of the files that are protected. If the value of this field is \[], all formats of files are protected.
        # 
        # *   **Source**: the directory that is protected. If the value of this field is \[], all directories are protected.
        # 
        # *   **ExcludeSystemPath**: indicates whether a specified directory is excluded from the anti-ransomware policy. If the value of this field is **true**, the directory is excluded. If this field is left empty, no directories are excluded.
        # 
        # *   **Exclude**: the directory that is excluded from the anti-ransomware policy. If no directory is specified, the value of this field is \[].
        # 
        # *   **Schedule**: the start time and interval of a data backup task. A start time that begins during off-peak hours but does not start on the hour is recommended. Examples:
        # 
        #     *   If the value of this field is I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
        #     *   If the value of this field is I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.
        # 
        # *   **Retention**: the period during which backup data is retained. Unit: days. If the value of this field is 7, backup data is retained for a week. If the value of this field is 365, backup data is retained for a year. If the value of this field is -1, backup data is permanently retained.
        # 
        # *   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If the value of this field is 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.
        # 
        # *   **UseVss**: indicates whether the VSS feature is enabled. The feature is available only for Windows servers. Valid values:
        # 
        #     *   **true**: yes
        #     *   **false**: no
        # 
        # >  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.
        self.policy = policy  # type: str
        # The ID of the region that you specified for data backup when you installed the anti-ransomware agent for the server not deployed on Alibaba Cloud.
        self.policy_region_id = policy_region_id  # type: str
        # The version of the anti-ransomware policy. Valid values:
        # 
        # *   1.0.0
        # *   2.0.0
        self.policy_version = policy_version  # type: str
        # The UUIDs that are returned based on the value of the MachineRemark request parameter.
        self.remarked_uuid_list = remarked_uuid_list  # type: list[str]
        # The type of the server. Valid values:
        # 
        # *   **OUT_CLOUD**: server not deployed on Alibaba Cloud
        # *   **ALIYUN**: Elastic Compute Service (ECS) instance
        # *   **TRIPARTITE**: simple application server
        self.server_type = server_type  # type: str
        # The number of servers on which data backup is exceptional.
        self.service_error_count = service_error_count  # type: int
        # The UUIDs of the servers on which data backup is exceptional.
        self.service_error_uuid_list = service_error_uuid_list  # type: list[str]
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: The anti-ransomware policy is manually enabled.
        # *   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
        # *   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.
        self.status = status  # type: str
        # The upgrade status of the anti-ransomware policy. Valid values:
        # 
        # *   **NotUpgraded**\
        # *   **Upgrading**\
        # *   **UpgradeFailed**\
        # *   **UpgradeSuccess**\
        self.upgrade_status = upgrade_status  # type: str
        # The UUIDs of the servers to which the anti-ransomware policy is applied.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupPoliciesResponseBodyPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_error_count is not None:
            result['ClientErrorCount'] = self.client_error_count
        if self.client_error_uuid_list is not None:
            result['ClientErrorUuidList'] = self.client_error_uuid_list
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.health_client_count is not None:
            result['HealthClientCount'] = self.health_client_count
        if self.health_client_uuid_list is not None:
            result['HealthClientUuidList'] = self.health_client_uuid_list
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.remarked_uuid_list is not None:
            result['RemarkedUuidList'] = self.remarked_uuid_list
        if self.server_type is not None:
            result['ServerType'] = self.server_type
        if self.service_error_count is not None:
            result['ServiceErrorCount'] = self.service_error_count
        if self.service_error_uuid_list is not None:
            result['ServiceErrorUuidList'] = self.service_error_uuid_list
        if self.status is not None:
            result['Status'] = self.status
        if self.upgrade_status is not None:
            result['UpgradeStatus'] = self.upgrade_status
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientErrorCount') is not None:
            self.client_error_count = m.get('ClientErrorCount')
        if m.get('ClientErrorUuidList') is not None:
            self.client_error_uuid_list = m.get('ClientErrorUuidList')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('HealthClientCount') is not None:
            self.health_client_count = m.get('HealthClientCount')
        if m.get('HealthClientUuidList') is not None:
            self.health_client_uuid_list = m.get('HealthClientUuidList')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('RemarkedUuidList') is not None:
            self.remarked_uuid_list = m.get('RemarkedUuidList')
        if m.get('ServerType') is not None:
            self.server_type = m.get('ServerType')
        if m.get('ServiceErrorCount') is not None:
            self.service_error_count = m.get('ServiceErrorCount')
        if m.get('ServiceErrorUuidList') is not None:
            self.service_error_uuid_list = m.get('ServiceErrorUuidList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpgradeStatus') is not None:
            self.upgrade_status = m.get('UpgradeStatus')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeBackupPoliciesResponseBody(TeaModel):
    def __init__(self, page_info=None, policies=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeBackupPoliciesResponseBodyPageInfo
        # An array that consists of the anti-ransomware policies returned.
        self.policies = policies  # type: list[DescribeBackupPoliciesResponseBodyPolicies]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBackupPoliciesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeBackupPoliciesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = DescribeBackupPoliciesResponseBodyPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupPoliciesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupPoliciesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupPoliciesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupPolicyRequest(TeaModel):
    def __init__(self, id=None):
        # The ID of the anti-ransomware policy.
        # 
        # >  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.
        self.id = id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeBackupPolicyResponseBodyBackupPolicyDetail(TeaModel):
    def __init__(self, client_status=None, id=None, name=None, policy=None, policy_version=None, region_id=None,
                 status=None, uuid_list=None):
        # The status of the anti-ransomware agent. Valid values:
        # 
        # *   **running**: normal
        # *   **exception**: abnormal
        self.client_status = client_status  # type: str
        # The ID of the anti-ransomware policy.
        self.id = id  # type: long
        # The name of the anti-ransomware policy.
        self.name = name  # type: str
        # *   **IsDefault**: the type of the anti-ransomware policy. Valid values:
        # 
        #     *   **1**: recommended policy
        #     *   **0**: custom policy
        # 
        # *   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to \[].
        # 
        # *   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to \[].
        # 
        # *   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.
        # 
        # *   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to \[].
        # 
        # *   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:
        # 
        #     *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
        #     *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.
        # 
        # *   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.
        # 
        # *   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.
        # 
        # *   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:
        # 
        #     *   **true**: yes
        #     *   **false**: no
        # 
        # >  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.
        self.policy = policy  # type: str
        # The version of the anti-ransomware policy.
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        self.policy_version = policy_version  # type: str
        # The ID of the region in which backup data is stored.
        self.region_id = region_id  # type: str
        # The status of the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: The anti-ransomware policy is manually enabled.
        # *   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
        # *   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.
        self.status = status  # type: str
        # An array consisting of the UUIDs of the servers to which the anti-ransomware policy is applied.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupPolicyResponseBodyBackupPolicyDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeBackupPolicyResponseBody(TeaModel):
    def __init__(self, backup_policy_detail=None, request_id=None):
        # The details of the anti-ransomware policy.
        self.backup_policy_detail = backup_policy_detail  # type: DescribeBackupPolicyResponseBodyBackupPolicyDetail
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_policy_detail:
            self.backup_policy_detail.validate()

    def to_map(self):
        _map = super(DescribeBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_policy_detail is not None:
            result['BackupPolicyDetail'] = self.backup_policy_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupPolicyDetail') is not None:
            temp_model = DescribeBackupPolicyResponseBodyBackupPolicyDetail()
            self.backup_policy_detail = temp_model.from_map(m['BackupPolicyDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBackupRestoreCountResponseBodyBackupRestoreCount(TeaModel):
    def __init__(self, recovering=None, total=None):
        # The number of the restoration tasks that are in the **being restored** state.
        self.recovering = recovering  # type: int
        # The total number of the restoration tasks that you create.
        self.total = total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBackupRestoreCountResponseBodyBackupRestoreCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recovering is not None:
            result['Recovering'] = self.recovering
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Recovering') is not None:
            self.recovering = m.get('Recovering')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeBackupRestoreCountResponseBody(TeaModel):
    def __init__(self, backup_restore_count=None, request_id=None):
        # The statistics of restoration tasks.
        self.backup_restore_count = backup_restore_count  # type: DescribeBackupRestoreCountResponseBodyBackupRestoreCount
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_restore_count:
            self.backup_restore_count.validate()

    def to_map(self):
        _map = super(DescribeBackupRestoreCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_restore_count is not None:
            result['BackupRestoreCount'] = self.backup_restore_count.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupRestoreCount') is not None:
            temp_model = DescribeBackupRestoreCountResponseBodyBackupRestoreCount()
            self.backup_restore_count = temp_model.from_map(m['BackupRestoreCount'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBackupRestoreCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBackupRestoreCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBackupRestoreCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBackupRestoreCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBruteForceRecordsRequest(TeaModel):
    def __init__(self, block_ip=None, current_page=None, page_size=None, resource_owner_id=None, status=None):
        self.block_ip = block_ip  # type: str
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBruteForceRecordsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeBruteForceRecordsResponseBodyMachineList(TeaModel):
    def __init__(self, block_expire_date=None, block_ip=None, error_code=None, id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, port=None, rule_name=None, source=None, status=None, uuid=None):
        self.block_expire_date = block_expire_date  # type: long
        self.block_ip = block_ip  # type: str
        self.error_code = error_code  # type: str
        self.id = id  # type: long
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.port = port  # type: str
        self.rule_name = rule_name  # type: str
        self.source = source  # type: str
        self.status = status  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBruteForceRecordsResponseBodyMachineList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_expire_date is not None:
            result['BlockExpireDate'] = self.block_expire_date
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.port is not None:
            result['Port'] = self.port
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockExpireDate') is not None:
            self.block_expire_date = m.get('BlockExpireDate')
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeBruteForceRecordsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBruteForceRecordsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBruteForceRecordsResponseBody(TeaModel):
    def __init__(self, machine_list=None, page_info=None, request_id=None):
        self.machine_list = machine_list  # type: list[DescribeBruteForceRecordsResponseBodyMachineList]
        self.page_info = page_info  # type: DescribeBruteForceRecordsResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeBruteForceRecordsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = DescribeBruteForceRecordsResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeBruteForceRecordsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBruteForceRecordsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBruteForceRecordsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBruteForceRecordsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBruteForceRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBruteForceSummaryRequest(TeaModel):
    def __init__(self, resource_owner_id=None, source_ip=None):
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBruteForceSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeBruteForceSummaryResponseBodyBruteForceSummary(TeaModel):
    def __init__(self, all_strategy_count=None, effective_count=None):
        # The total number of IP address blocking policies.
        self.all_strategy_count = all_strategy_count  # type: int
        # The number of enabled IP address blocking policies.
        self.effective_count = effective_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBruteForceSummaryResponseBodyBruteForceSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_strategy_count is not None:
            result['AllStrategyCount'] = self.all_strategy_count
        if self.effective_count is not None:
            result['EffectiveCount'] = self.effective_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllStrategyCount') is not None:
            self.all_strategy_count = m.get('AllStrategyCount')
        if m.get('EffectiveCount') is not None:
            self.effective_count = m.get('EffectiveCount')
        return self


class DescribeBruteForceSummaryResponseBody(TeaModel):
    def __init__(self, brute_force_summary=None, request_id=None):
        # The statistics of IP address blocking policies.
        self.brute_force_summary = brute_force_summary  # type: DescribeBruteForceSummaryResponseBodyBruteForceSummary
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.brute_force_summary:
            self.brute_force_summary.validate()

    def to_map(self):
        _map = super(DescribeBruteForceSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.brute_force_summary is not None:
            result['BruteForceSummary'] = self.brute_force_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BruteForceSummary') is not None:
            temp_model = DescribeBruteForceSummaryResponseBodyBruteForceSummary()
            self.brute_force_summary = temp_model.from_map(m['BruteForceSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBruteForceSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBruteForceSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBruteForceSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBruteForceSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckEcsWarningsRequest(TeaModel):
    def __init__(self, source_ip=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckEcsWarningsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeCheckEcsWarningsResponseBody(TeaModel):
    def __init__(self, can_try=None, request_id=None, sas_version=None, weak_password_count=None):
        # Indicates whether you use the free trial of Security Center. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.can_try = can_try  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The edition of Security Center that you use. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **2** or **3**: Enterprise edition
        # *   **5**: Advanced edition
        # *   **6**: Anti-virus edition
        # 
        # >  Both the value 2 and the value 3 indicate the Enterprise edition.
        self.sas_version = sas_version  # type: str
        # The number of weak passwords that can cause high risks to your assets.
        self.weak_password_count = weak_password_count  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckEcsWarningsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_try is not None:
            result['CanTry'] = self.can_try
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sas_version is not None:
            result['SasVersion'] = self.sas_version
        if self.weak_password_count is not None:
            result['WeakPasswordCount'] = self.weak_password_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanTry') is not None:
            self.can_try = m.get('CanTry')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SasVersion') is not None:
            self.sas_version = m.get('SasVersion')
        if m.get('WeakPasswordCount') is not None:
            self.weak_password_count = m.get('WeakPasswordCount')
        return self


class DescribeCheckEcsWarningsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckEcsWarningsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckEcsWarningsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckEcsWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckFixDetailsRequest(TeaModel):
    def __init__(self, check_ids=None, lang=None, risk_id=None):
        self.check_ids = check_ids  # type: str
        self.lang = lang  # type: str
        self.risk_id = risk_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckFixDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList(TeaModel):
    def __init__(self, enum_value=None, max_value=None, min_value=None, param_default_value=None, param_desc=None,
                 param_name=None, param_type=None, rule_id=None, value=None):
        self.enum_value = enum_value  # type: str
        self.max_value = max_value  # type: int
        self.min_value = min_value  # type: int
        self.param_default_value = param_default_value  # type: str
        self.param_desc = param_desc  # type: str
        self.param_name = param_name  # type: str
        self.param_type = param_type  # type: int
        self.rule_id = rule_id  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules(TeaModel):
    def __init__(self, check_id=None, default_value=None, optional=None, param_list=None, rule_desc=None,
                 rule_id=None, value=None, var_name=None):
        self.check_id = check_id  # type: long
        self.default_value = default_value  # type: int
        self.optional = optional  # type: int
        self.param_list = param_list  # type: list[DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList]
        self.rule_desc = rule_desc  # type: str
        self.rule_id = rule_id  # type: str
        self.value = value  # type: int
        self.var_name = var_name  # type: str

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.value is not None:
            result['Value'] = self.value
        if self.var_name is not None:
            result['VarName'] = self.var_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('VarName') is not None:
            self.var_name = m.get('VarName')
        return self


class DescribeCheckFixDetailsResponseBodyCheckFixDetails(TeaModel):
    def __init__(self, check_desc=None, check_id=None, check_item=None, rules=None):
        self.check_desc = check_desc  # type: str
        self.check_id = check_id  # type: long
        self.check_item = check_item  # type: str
        self.rules = rules  # type: list[DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules]

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckFixDetailsResponseBodyCheckFixDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeCheckFixDetailsResponseBody(TeaModel):
    def __init__(self, check_fix_details=None, count=None, request_id=None):
        self.check_fix_details = check_fix_details  # type: list[DescribeCheckFixDetailsResponseBodyCheckFixDetails]
        self.count = count  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        if self.check_fix_details:
            for k in self.check_fix_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckFixDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckFixDetails'] = []
        if self.check_fix_details is not None:
            for k in self.check_fix_details:
                result['CheckFixDetails'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.check_fix_details = []
        if m.get('CheckFixDetails') is not None:
            for k in m.get('CheckFixDetails'):
                temp_model = DescribeCheckFixDetailsResponseBodyCheckFixDetails()
                self.check_fix_details.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCheckFixDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckFixDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckFixDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckFixDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningDetailRequest(TeaModel):
    def __init__(self, check_warning_id=None, lang=None, source_ip=None):
        # The ID of the alert that is triggered by the check item.
        # 
        # >  To query the details about a specified check item, you must provide the ID of the alert that is triggered by the check item. You can call the [DescribeCheckWarnings](~~DescribeCheckWarnings~~) operation to query the IDs of alerts.
        self.check_warning_id = check_warning_id  # type: long
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_warning_id is not None:
            result['CheckWarningId'] = self.check_warning_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckWarningId') is not None:
            self.check_warning_id = m.get('CheckWarningId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeCheckWarningDetailResponseBody(TeaModel):
    def __init__(self, advice=None, check_id=None, description=None, item=None, level=None, prompt=None,
                 request_id=None, type=None):
        # The suggestion for the management of the risk item.
        self.advice = advice  # type: str
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The additional information about the risk item.
        self.description = description  # type: str
        # The name of the check item.
        self.item = item  # type: str
        # The risk level of the check item. Valid values:
        # 
        # *   **high**: The item is a high-risk item and is highlighted in red.
        # *   **medium**: The item is a medium-risk item and is highlighted in orange.
        # *   **low**: The item is a low-risk item and is highlighted in gray.
        self.level = level  # type: str
        # The prompt for the risk item.
        self.prompt = prompt  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The type of the check item. Valid values:
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.description is not None:
            result['Description'] = self.description
        if self.item is not None:
            result['Item'] = self.item
        if self.level is not None:
            result['Level'] = self.level
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCheckWarningDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckWarningDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningMachinesRequest(TeaModel):
    def __init__(self, check_id=None, lang=None, risk_id=None, status=None):
        self.check_id = check_id  # type: long
        self.lang = lang  # type: str
        self.risk_id = risk_id  # type: long
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningMachinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCheckWarningMachinesResponseBodyMachines(TeaModel):
    def __init__(self, bind=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 region_id=None, uuid=None):
        self.bind = bind  # type: bool
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.region_id = region_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningMachinesResponseBodyMachines, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningMachinesResponseBody(TeaModel):
    def __init__(self, count=None, machines=None, request_id=None):
        self.count = count  # type: int
        self.machines = machines  # type: list[DescribeCheckWarningMachinesResponseBodyMachines]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.machines:
            for k in self.machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningMachinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Machines'] = []
        if self.machines is not None:
            for k in self.machines:
                result['Machines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.machines = []
        if m.get('Machines') is not None:
            for k in m.get('Machines'):
                temp_model = DescribeCheckWarningMachinesResponseBodyMachines()
                self.machines.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCheckWarningMachinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckWarningMachinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningMachinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningSummaryRequest(TeaModel):
    def __init__(self, cluster_id=None, container_field_name=None, container_field_value=None, current_page=None,
                 group_id=None, lang=None, page_size=None, risk_name=None, risk_status=None, source_ip=None, status=None,
                 strategy_id=None, target_type=None, type_name=None, uuids=None):
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str
        # The name of the container field. Valid values:
        # 
        # *   **clusterId**: the ID of the cluster
        # *   **image**: the name of the image
        # *   **imageId**: the ID of the image
        # *   **namespace**: the namespace
        self.container_field_name = container_field_name  # type: str
        # The value of the container field.
        self.container_field_value = container_field_value  # type: str
        # The number of the page to return.
        self.current_page = current_page  # type: int
        self.group_id = group_id  # type: long
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The name of the risk item.
        self.risk_name = risk_name  # type: str
        # The status of the baseline check. Valid values:
        # 
        # *   **1**: failed
        # *   **3**: passed
        self.risk_status = risk_status  # type: int
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The status of the check item. Valid values:
        # 
        # *   **1**: failed
        # *   **2**: verifying
        # *   **3**: passed
        # *   **5**: expired
        # *   **6**: ignored
        self.status = status  # type: str
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id  # type: long
        # The type of the query condition. Valid values:
        # 
        # *   **uuid**: the ID of an asset
        self.target_type = target_type  # type: str
        # The level-1 type of check items.
        # 
        # >  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the level-1 types of check items.
        self.type_name = type_name  # type: str
        # The UUID of the asset.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeCheckWarningSummaryResponseBodyWarningSummarys(TeaModel):
    def __init__(self, check_count=None, check_exploit=None, database_risk=None, high_warning_count=None,
                 last_found_time=None, level=None, low_warning_count=None, medium_warning_count=None, risk_id=None, risk_name=None,
                 sub_type_alias=None, type_alias=None, warning_machine_count=None):
        # The number of check items.
        self.check_count = check_count  # type: int
        # Indicates whether the risk item can be exploited. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.check_exploit = check_exploit  # type: bool
        # Indicates whether the risk item is a database risk item. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.database_risk = database_risk  # type: bool
        # The number of high-risk items.
        self.high_warning_count = high_warning_count  # type: int
        # The time when the last baseline check was performed.
        self.last_found_time = last_found_time  # type: str
        # The risk level of the risk item. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.level = level  # type: str
        # The number of low-risk items.
        self.low_warning_count = low_warning_count  # type: int
        # The number of medium-risk items.
        self.medium_warning_count = medium_warning_count  # type: int
        # The ID of the risk item.
        self.risk_id = risk_id  # type: long
        # The name of the risk item.
        self.risk_name = risk_name  # type: str
        # The level-2 type of the risk item.
        self.sub_type_alias = sub_type_alias  # type: str
        # The level-1 type of the check item. Examples: database, system, weak password, and middleware.
        self.type_alias = type_alias  # type: str
        # The number of assets on which risk items are detected.
        self.warning_machine_count = warning_machine_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningSummaryResponseBodyWarningSummarys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_count is not None:
            result['CheckCount'] = self.check_count
        if self.check_exploit is not None:
            result['CheckExploit'] = self.check_exploit
        if self.database_risk is not None:
            result['DatabaseRisk'] = self.database_risk
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.last_found_time is not None:
            result['LastFoundTime'] = self.last_found_time
        if self.level is not None:
            result['Level'] = self.level
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        if self.warning_machine_count is not None:
            result['WarningMachineCount'] = self.warning_machine_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckCount') is not None:
            self.check_count = m.get('CheckCount')
        if m.get('CheckExploit') is not None:
            self.check_exploit = m.get('CheckExploit')
        if m.get('DatabaseRisk') is not None:
            self.database_risk = m.get('DatabaseRisk')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LastFoundTime') is not None:
            self.last_found_time = m.get('LastFoundTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        if m.get('WarningMachineCount') is not None:
            self.warning_machine_count = m.get('WarningMachineCount')
        return self


class DescribeCheckWarningSummaryResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, request_id=None, total_count=None,
                 warning_summarys=None):
        # The number of check items returned on the current page.
        self.count = count  # type: int
        # The page number of the current page.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of check items.
        self.total_count = total_count  # type: int
        # The statistics of check items.
        self.warning_summarys = warning_summarys  # type: list[DescribeCheckWarningSummaryResponseBodyWarningSummarys]

    def validate(self):
        if self.warning_summarys:
            for k in self.warning_summarys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WarningSummarys'] = []
        if self.warning_summarys is not None:
            for k in self.warning_summarys:
                result['WarningSummarys'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.warning_summarys = []
        if m.get('WarningSummarys') is not None:
            for k in m.get('WarningSummarys'):
                temp_model = DescribeCheckWarningSummaryResponseBodyWarningSummarys()
                self.warning_summarys.append(temp_model.from_map(k))
        return self


class DescribeCheckWarningSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckWarningSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCheckWarningsRequest(TeaModel):
    def __init__(self, check_id=None, check_type=None, current_page=None, lang=None, page_size=None, risk_id=None,
                 risk_status=None, source_ip=None, uuid=None):
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The type of the check item. Valid values:
        # 
        # *   **hc.check.type.identity_auth**: identity authentication
        # *   **hc.check.type.access_control**: access control
        # *   **hc.check.type.network_service**: network and service
        # *   **hc.check.type.service_conf**: service configuration
        # *   **hc.check.type.file_rights**: file permission
        # *   **hc.check.type.security_audit**: security audit
        # *   **hc.check.type.attack_defense**: intrusion prevention
        # *   **hc.check.type.others**: others
        self.check_type = check_type  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the risk item.
        # 
        # >  To query specified risk items and the check items of a specified server, you must provide the IDs of the risk items. You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.
        self.risk_id = risk_id  # type: long
        # The status of the check item. Valid values:
        # 
        # *   **1**: failed
        # *   **2**: verifying
        # *   **3**: passed
        # *   **5**: expired
        # *   **6**: ignored
        self.risk_status = risk_status  # type: int
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the server on which the baseline check is performed.
        # 
        # >  To query specified risk items and the check items of a specified server, you must provide the ID of the server on which the baseline check is performed. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the IDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningsResponseBodyCheckWarnings(TeaModel):
    def __init__(self, check_id=None, check_warning_id=None, exec_error_message=None, fix_status=None, item=None,
                 level=None, reason=None, status=None, type=None, uuid=None):
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The ID of the alert that is triggered by the check item.
        self.check_warning_id = check_warning_id  # type: long
        self.exec_error_message = exec_error_message  # type: str
        # The fixing status of the check item. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.fix_status = fix_status  # type: int
        # The name of the check item.
        self.item = item  # type: str
        # The risk level of the risk item. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.level = level  # type: str
        # The remarks.
        self.reason = reason  # type: str
        # The status of the check item. Valid values:
        # 
        # *   **1**: failed
        # *   **2**: verifying
        # *   **3**: passed
        # *   **5**: expired
        # *   **6**: ignored
        self.status = status  # type: int
        # The type of the check item.
        self.type = type  # type: str
        # The UUID of the server on which the baseline check is performed.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCheckWarningsResponseBodyCheckWarnings, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_warning_id is not None:
            result['CheckWarningId'] = self.check_warning_id
        if self.exec_error_message is not None:
            result['ExecErrorMessage'] = self.exec_error_message
        if self.fix_status is not None:
            result['FixStatus'] = self.fix_status
        if self.item is not None:
            result['Item'] = self.item
        if self.level is not None:
            result['Level'] = self.level
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckWarningId') is not None:
            self.check_warning_id = m.get('CheckWarningId')
        if m.get('ExecErrorMessage') is not None:
            self.exec_error_message = m.get('ExecErrorMessage')
        if m.get('FixStatus') is not None:
            self.fix_status = m.get('FixStatus')
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeCheckWarningsResponseBody(TeaModel):
    def __init__(self, check_warnings=None, count=None, current_page=None, page_size=None, request_id=None,
                 total_count=None):
        # An array that consists of the check items.
        self.check_warnings = check_warnings  # type: list[DescribeCheckWarningsResponseBodyCheckWarnings]
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.check_warnings:
            for k in self.check_warnings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckWarnings'] = []
        if self.check_warnings is not None:
            for k in self.check_warnings:
                result['CheckWarnings'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.check_warnings = []
        if m.get('CheckWarnings') is not None:
            for k in m.get('CheckWarnings'):
                temp_model = DescribeCheckWarningsResponseBodyCheckWarnings()
                self.check_warnings.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCheckWarningsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCheckWarningsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCheckWarningsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClientConfSetupRequest(TeaModel):
    def __init__(self, strategy_tag=None, strategy_tag_value=None):
        self.strategy_tag = strategy_tag  # type: str
        self.strategy_tag_value = strategy_tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientConfSetupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class DescribeClientConfSetupResponseBodyClientConf(TeaModel):
    def __init__(self, config=None, strategy_tag=None, strategy_tag_value=None):
        self.config = config  # type: str
        self.strategy_tag = strategy_tag  # type: str
        self.strategy_tag_value = strategy_tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientConfSetupResponseBodyClientConf, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class DescribeClientConfSetupResponseBody(TeaModel):
    def __init__(self, client_conf=None, request_id=None):
        self.client_conf = client_conf  # type: DescribeClientConfSetupResponseBodyClientConf
        self.request_id = request_id  # type: str

    def validate(self):
        if self.client_conf:
            self.client_conf.validate()

    def to_map(self):
        _map = super(DescribeClientConfSetupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_conf is not None:
            result['ClientConf'] = self.client_conf.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientConf') is not None:
            temp_model = DescribeClientConfSetupResponseBodyClientConf()
            self.client_conf = temp_model.from_map(m['ClientConf'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClientConfSetupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClientConfSetupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClientConfSetupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClientConfSetupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClientConfStrategyRequest(TeaModel):
    def __init__(self, tag=None, tag_value=None):
        self.tag = tag  # type: str
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientConfStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeClientConfStrategyResponseBodyTargetList(TeaModel):
    def __init__(self, uuid=None):
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientConfStrategyResponseBodyTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeClientConfStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None, target_list=None, total_count=None):
        self.request_id = request_id  # type: str
        self.target_list = target_list  # type: list[DescribeClientConfStrategyResponseBodyTargetList]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClientConfStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeClientConfStrategyResponseBodyTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeClientConfStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClientConfStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClientConfStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClientConfStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudCenterInstancesRequest(TeaModel):
    def __init__(self, criteria=None, current_page=None, importance=None, lang=None, logical_exp=None,
                 machine_types=None, no_group_trace=None, page_size=None, region_id=None):
        # The search conditions that are used to filter assets. The value of this parameter is in the JSON format and is case-sensitive.
        # 
        # >  A search condition can be an instance ID, instance name, VPC ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The importance of the asset. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.importance = importance  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The logical relationship among multiple search conditions. Valid values:
        # 
        # *   **OR**: The search conditions are evaluated by using a logical **OR**.
        # *   **AND**: The search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp  # type: str
        # The type of the assets that you want to query. Valid values:
        # 
        # *   **ecs**: servers
        # *   **cloud_product**: Alibaba Cloud services
        self.machine_types = machine_types  # type: str
        # Specifies whether to internationalize the name of the default group. Default value: **false** . Valid values:
        # 
        # *   **true**: The system returns the Chinese name of the default group for the GroupTrace response parameter.************\
        # *   **false**: The system returns default for the GroupTrace response parameter.
        self.no_group_trace = no_group_trace  # type: bool
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the region in which the asset resides.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudCenterInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.no_group_trace is not None:
            result['NoGroupTrace'] = self.no_group_trace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('NoGroupTrace') is not None:
            self.no_group_trace = m.get('NoGroupTrace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCloudCenterInstancesResponseBodyInstances(TeaModel):
    def __init__(self, alarm_status=None, asset_type=None, auth_modify_time=None, auth_version=None,
                 auth_version_name=None, bind=None, client_status=None, cluster_id=None, cluster_name=None, cores=None, cpu_info=None,
                 created_time=None, exposed_status=None, flag=None, group_id=None, group_trace=None, hc_status=None,
                 health_check_count=None, importance=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 ip=None, ip_list_string=None, kernel=None, last_login_timestamp=None, mac_list_string=None, mem=None,
                 os=None, os_name=None, pod_count=None, region=None, region_id=None, region_name=None, risk_count=None,
                 risk_status=None, safe_event_count=None, status=None, tag=None, tag_id=None, uuid=None, vendor=None,
                 vendor_name=None, vpc_instance_id=None, vul_count=None, vul_status=None):
        # Indicates whether alerts are generated on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.alarm_status = alarm_status  # type: str
        # The type of the asset. Valid values:
        # 
        # *   **0**: an ECS instance
        # *   **1**: a Server Load Balancer (SLB) instance
        # *   **2**: a NAT gateway
        # *   **3**: an ApsaraDB RDS instance
        # *   **4**: an ApsaraDB for MongoDB instance
        # *   **5**: an ApsaraDB for Redis instance
        # *   **6**: a container image
        # *   **7**: a container
        self.asset_type = asset_type  # type: str
        # The timestamp when Security Center is authorized to scan the asset.
        self.auth_modify_time = auth_modify_time  # type: long
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        self.auth_version = auth_version  # type: int
        # The name of the Security Center edition that is authorized to scan the asset. Valid values:
        # 
        # *   Basic edition
        # *   Anti-virus edition
        # *   Advanced edition
        # *   Enterprise edition
        # *   Ultimate edition
        # *   Value-added Plan edition
        self.auth_version_name = auth_version_name  # type: str
        # Indicates whether Security Center is authorized to scan the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind  # type: bool
        # The status of the Security Center agent installed on the asset. Valid values:
        # 
        # *   **online**: The Security Center agent is **enabled**.
        # *   **offline**: The Security Center agent is **disabled**.
        # *   **pause**: The Security Center agent is **suspended**.
        self.client_status = client_status  # type: str
        # The ID of the cluster.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The number of the CPU cores used by the asset.
        self.cores = cores  # type: int
        # The CPU information about the asset.
        self.cpu_info = cpu_info  # type: str
        # The timestamp when the cluster was created. Unit: milliseconds.
        self.created_time = created_time  # type: long
        # Indicates whether the asset is exposed. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.exposed_status = exposed_status  # type: int
        # Indicates whether the asset is an Alibaba Cloud asset. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.flag = flag  # type: int
        # The ID of the asset group to which the asset belongs.
        self.group_id = group_id  # type: long
        # The name of the group to which the asset belongs.
        self.group_trace = group_trace  # type: str
        # Indicates whether baseline risks are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.hc_status = hc_status  # type: str
        # The number of baseline risks that are detected on the asset.
        self.health_check_count = health_check_count  # type: int
        # The importance of the asset. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.importance = importance  # type: int
        # The ID of the asset.
        self.instance_id = instance_id  # type: str
        # The name of the asset.
        self.instance_name = instance_name  # type: str
        # The public IP address of the asset.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip  # type: str
        # The public IP address of the asset.
        self.ip = ip  # type: str
        # The IP addresses of the system.
        self.ip_list_string = ip_list_string  # type: str
        # The version of the kernel.
        self.kernel = kernel  # type: str
        # The timestamp when the Security Center agent was last online. Unit: milliseconds.
        self.last_login_timestamp = last_login_timestamp  # type: long
        # The MAC address of the system.
        self.mac_list_string = mac_list_string  # type: str
        # The size of the memory. Unit: MB.
        self.mem = mem  # type: int
        # The operating system of the asset.
        self.os = os  # type: str
        # The kernel version of the asset.
        self.os_name = os_name  # type: str
        # The number of pods.
        self.pod_count = pod_count  # type: int
        # The region ID of the asset.
        self.region = region  # type: str
        # The ID of the region in which the asset resides.
        self.region_id = region_id  # type: str
        # The name of the region in which the asset resides.
        self.region_name = region_name  # type: str
        # The total number of baseline risks that are detected on the asset. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **account**: the number of accounts that are used to log on from unapproved logon locations and whose passwords are cracked
        # *   **appNum**: the number of scanners
        # *   **asapVulCount**: the total number of high-risk vulnerabilities
        # *   **baselineHigh**: the number of high-risk baseline risks
        # *   **baselineLow**: the number of low-risk baseline risks
        # *   **baselineMedium**: the number of medium-risk baseline risks
        # *   **baselineNum**: the total number of baseline risks
        # *   **cmsNum**: the number of Web-CMS vulnerabilities
        # *   **containerAsap**: the number of high-risk vulnerabilities that are detected on containers
        # *   **containerLater**: the number of medium-risk vulnerabilities that are detected on containers
        # *   **containerNntf**: the number of low-risk vulnerabilities that are detected on containers
        # *   **containerRemind**: the number of alerts whose Emergency level is Reminder on containers
        # *   **containerSerious**: the number of alerts whose Emergency level is Urgent on containers
        # *   **containerSuspicious**: the number of alerts whose Emergency level is Suspicious on containers
        # *   **cveNum**: the number of Linux software vulnerabilities
        # *   **emgNum**: the number of urgent vulnerabilities
        # *   **health**: the number of baseline alerts that are unhandled
        # *   **imageBaselineHigh**: the number of high-risk baseline risks that are detected on images
        # *   **imageBaselineLow**: the number of low-risk baseline risks that are detected on images
        # *   **imageBaselineMedium**: the number of medium-risk baseline risks that are detected on images
        # *   **imageBaselineNum**: the total number of baseline risks that are detected on images
        # *   **imageMaliciousFileRemind**: the number of malicious files that are detected on images and have the Emergency level of Reminder
        # *   **imageMaliciousFileSerious**: the number of malicious files that are detected on images and have the Emergency level of Urgent
        # *   **imageMaliciousFileSuspicious**: the number of malicious files that are detected on images and have the Emergency level of Suspicious
        # *   **imageVulAsap**: the number of high-risk vulnerabilities that are detected on images
        # *   **imageVulLater**: the number of medium-risk vulnerabilities that are detected on an image
        # *   **imageVulNntf**: the number of low-risk vulnerabilities that are detected on an image
        # *   **laterVulCount**: the number of medium-risk vulnerabilities
        # *   **newSuspicious**: the number of alerts
        # *   **nntfVulCount**: the number of low-risk vulnerabilities.
        # *   **remindNum**: the number of alerts whose Emergency level is Reminder
        # *   **scaNum**: the number of vulnerabilities that are detected based on software component analysis
        # *   **seriousNum**: the number of alerts whose Emergency level is Urgent
        # *   **suspNum**: the number of alerts whose Emergency level is Suspicious
        # *   **suspicious**: the total number of alerts
        # *   **sysNum**: the number of Windows system vulnerabilities
        # *   **trojan**: the number of trojans
        # *   **uuid**: the UUIDs of assets
        # *   **vul**: the number of vulnerabilities
        # *   **weakPWNum**: the number of weak passwords
        self.risk_count = risk_count  # type: str
        # Indicates whether risks are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.risk_status = risk_status  # type: str
        # The number of alerts that are generated on the asset.
        self.safe_event_count = safe_event_count  # type: int
        # The status of the asset. Valid values:
        # 
        # *   **Running**: running
        # *   **notRunning**: stopped
        self.status = status  # type: str
        # The name of the asset tag.
        self.tag = tag  # type: str
        # The ID of the asset tag.
        self.tag_id = tag_id  # type: str
        # The UUID of the asset.
        self.uuid = uuid  # type: str
        # The type of the asset by source. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int
        # The name of the service provider (SP) for the asset.
        # 
        # Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        # *   **OUT**: a third-party service provider
        # *   **IDC**: a data center
        # *   **TENCENT**: Tencent Cloud
        # *   **HUAWEICLOUD**: Huawei Cloud
        # *   **Microsoft**: Microsoft
        # *   **AWS**: Amazon Web Services (AWS)
        # *   **TRIPARTITE**: a lightweight server
        self.vendor_name = vendor_name  # type: str
        # The ID of the VPC to which the asset belongs.
        self.vpc_instance_id = vpc_instance_id  # type: str
        # The number of vulnerabilities that are detected on the asset.
        self.vul_count = vul_count  # type: int
        # Indicates whether vulnerabilities are detected on the asset. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.vul_status = vul_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudCenterInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.auth_modify_time is not None:
            result['AuthModifyTime'] = self.auth_modify_time
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.auth_version_name is not None:
            result['AuthVersionName'] = self.auth_version_name
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.client_status is not None:
            result['ClientStatus'] = self.client_status
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.cpu_info is not None:
            result['CpuInfo'] = self.cpu_info
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.exposed_status is not None:
            result['ExposedStatus'] = self.exposed_status
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_trace is not None:
            result['GroupTrace'] = self.group_trace
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.health_check_count is not None:
            result['HealthCheckCount'] = self.health_check_count
        if self.importance is not None:
            result['Importance'] = self.importance
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_list_string is not None:
            result['IpListString'] = self.ip_list_string
        if self.kernel is not None:
            result['Kernel'] = self.kernel
        if self.last_login_timestamp is not None:
            result['LastLoginTimestamp'] = self.last_login_timestamp
        if self.mac_list_string is not None:
            result['MacListString'] = self.mac_list_string
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.os is not None:
            result['Os'] = self.os
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.pod_count is not None:
            result['PodCount'] = self.pod_count
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.safe_event_count is not None:
            result['SafeEventCount'] = self.safe_event_count
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AuthModifyTime') is not None:
            self.auth_modify_time = m.get('AuthModifyTime')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('AuthVersionName') is not None:
            self.auth_version_name = m.get('AuthVersionName')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ClientStatus') is not None:
            self.client_status = m.get('ClientStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('CpuInfo') is not None:
            self.cpu_info = m.get('CpuInfo')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('ExposedStatus') is not None:
            self.exposed_status = m.get('ExposedStatus')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupTrace') is not None:
            self.group_trace = m.get('GroupTrace')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('HealthCheckCount') is not None:
            self.health_check_count = m.get('HealthCheckCount')
        if m.get('Importance') is not None:
            self.importance = m.get('Importance')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpListString') is not None:
            self.ip_list_string = m.get('IpListString')
        if m.get('Kernel') is not None:
            self.kernel = m.get('Kernel')
        if m.get('LastLoginTimestamp') is not None:
            self.last_login_timestamp = m.get('LastLoginTimestamp')
        if m.get('MacListString') is not None:
            self.mac_list_string = m.get('MacListString')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('PodCount') is not None:
            self.pod_count = m.get('PodCount')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SafeEventCount') is not None:
            self.safe_event_count = m.get('SafeEventCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeCloudCenterInstancesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudCenterInstancesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCloudCenterInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, page_info=None, request_id=None, success=None):
        # An array that consists of the details about the assets.
        self.instances = instances  # type: list[DescribeCloudCenterInstancesResponseBodyInstances]
        # The pagination information.
        self.page_info = page_info  # type: DescribeCloudCenterInstancesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeCloudCenterInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeCloudCenterInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeCloudCenterInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCloudCenterInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCloudCenterInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCloudCenterInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudCenterInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudProductFieldStatisticsResponseBodyGroupedFields(TeaModel):
    def __init__(self, category_count=None, instance_count=None, risk_instance_count=None):
        # The statistics of the numbers of assets of different types. **MachineType** indicates the type of the assets. **Count** indicates the number of assets that belong to the type.
        # Valid values of **MachineType**:
        # 
        # *   **1**: a Server Load Balancer (SLB) instance
        # *   **2**: a Network Address Translation (NAT) gateway
        # *   **3**: an ApsaraDB RDS instance
        # *   **4**: an ApsaraDB for MongoDB instance
        self.category_count = category_count  # type: str
        # The total number of cloud services that are protected by Security Center.
        self.instance_count = instance_count  # type: int
        # The number of cloud services that are at risk.
        self.risk_instance_count = risk_instance_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudProductFieldStatisticsResponseBodyGroupedFields, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_count is not None:
            result['CategoryCount'] = self.category_count
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CategoryCount') is not None:
            self.category_count = m.get('CategoryCount')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        return self


class DescribeCloudProductFieldStatisticsResponseBody(TeaModel):
    def __init__(self, grouped_fields=None, request_id=None):
        # The statistics of cloud services.
        self.grouped_fields = grouped_fields  # type: DescribeCloudProductFieldStatisticsResponseBodyGroupedFields
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super(DescribeCloudProductFieldStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = DescribeCloudProductFieldStatisticsResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudProductFieldStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCloudProductFieldStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCloudProductFieldStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudProductFieldStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterBasicInfoRequest(TeaModel):
    def __init__(self, cluster_id=None, target_type=None, type=None):
        self.cluster_id = cluster_id  # type: str
        self.target_type = target_type  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterBasicInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterBasicInfoResponseBodyClusterInfo(TeaModel):
    def __init__(self, cluster_id=None, cluster_name=None, cluster_type=None, create_time=None,
                 current_version=None, instance_count=None, region_id=None, state=None, target_result=None):
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.cluster_type = cluster_type  # type: str
        self.create_time = create_time  # type: long
        self.current_version = current_version  # type: str
        self.instance_count = instance_count  # type: int
        self.region_id = region_id  # type: str
        self.state = state  # type: str
        self.target_result = target_result  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterBasicInfoResponseBodyClusterInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state is not None:
            result['State'] = self.state
        if self.target_result is not None:
            result['TargetResult'] = self.target_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TargetResult') is not None:
            self.target_result = m.get('TargetResult')
        return self


class DescribeClusterBasicInfoResponseBody(TeaModel):
    def __init__(self, cluster_info=None, request_id=None):
        self.cluster_info = cluster_info  # type: DescribeClusterBasicInfoResponseBodyClusterInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cluster_info:
            self.cluster_info.validate()

    def to_map(self):
        _map = super(DescribeClusterBasicInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_info is not None:
            result['ClusterInfo'] = self.cluster_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterInfo') is not None:
            temp_model = DescribeClusterBasicInfoResponseBodyClusterInfo()
            self.cluster_info = temp_model.from_map(m['ClusterInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterBasicInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClusterBasicInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClusterBasicInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterBasicInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterInfoListRequest(TeaModel):
    def __init__(self, target=None, target_type=None, type=None):
        self.target = target  # type: str
        self.target_type = target_type  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterInfoListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterInfoListResponseBodyClusterList(TeaModel):
    def __init__(self, cluster_id=None, cluster_name=None, cluster_type=None, region_id=None, state=None,
                 target_result=None):
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.cluster_type = cluster_type  # type: str
        self.region_id = region_id  # type: str
        self.state = state  # type: str
        self.target_result = target_result  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterInfoListResponseBodyClusterList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state is not None:
            result['State'] = self.state
        if self.target_result is not None:
            result['TargetResult'] = self.target_result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TargetResult') is not None:
            self.target_result = m.get('TargetResult')
        return self


class DescribeClusterInfoListResponseBody(TeaModel):
    def __init__(self, cluster_list=None, request_id=None):
        self.cluster_list = cluster_list  # type: list[DescribeClusterInfoListResponseBodyClusterList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cluster_list:
            for k in self.cluster_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClusterInfoListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterList'] = []
        if self.cluster_list is not None:
            for k in self.cluster_list:
                result['ClusterList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cluster_list = []
        if m.get('ClusterList') is not None:
            for k in m.get('ClusterList'):
                temp_model = DescribeClusterInfoListResponseBodyClusterList()
                self.cluster_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterInfoListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClusterInfoListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClusterInfoListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterInfoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterNetworkRequest(TeaModel):
    def __init__(self, end_time=None, start_time=None):
        self.end_time = end_time  # type: long
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterNetworkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeClusterNetworkResponseBodyClusterNetworkEdge(TeaModel):
    def __init__(self, dst_node_id=None, dst_node_type=None, id=None, port=None, src_node_id=None,
                 src_node_type=None):
        self.dst_node_id = dst_node_id  # type: str
        self.dst_node_type = dst_node_type  # type: str
        self.id = id  # type: str
        self.port = port  # type: str
        self.src_node_id = src_node_id  # type: str
        self.src_node_type = src_node_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterNetworkResponseBodyClusterNetworkEdge, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_node_id is not None:
            result['DstNodeId'] = self.dst_node_id
        if self.dst_node_type is not None:
            result['DstNodeType'] = self.dst_node_type
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.src_node_id is not None:
            result['SrcNodeId'] = self.src_node_id
        if self.src_node_type is not None:
            result['SrcNodeType'] = self.src_node_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DstNodeId') is not None:
            self.dst_node_id = m.get('DstNodeId')
        if m.get('DstNodeType') is not None:
            self.dst_node_type = m.get('DstNodeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SrcNodeId') is not None:
            self.src_node_id = m.get('SrcNodeId')
        if m.get('SrcNodeType') is not None:
            self.src_node_type = m.get('SrcNodeType')
        return self


class DescribeClusterNetworkResponseBodyClusterNetworkNode(TeaModel):
    def __init__(self, cnnf_switch=None, id=None, interception_type=None, name=None, net_topo_switch=None,
                 risk_level=None, type=None):
        self.cnnf_switch = cnnf_switch  # type: int
        self.id = id  # type: str
        self.interception_type = interception_type  # type: int
        self.name = name  # type: str
        self.net_topo_switch = net_topo_switch  # type: str
        self.risk_level = risk_level  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterNetworkResponseBodyClusterNetworkNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cnnf_switch is not None:
            result['CnnfSwitch'] = self.cnnf_switch
        if self.id is not None:
            result['Id'] = self.id
        if self.interception_type is not None:
            result['InterceptionType'] = self.interception_type
        if self.name is not None:
            result['Name'] = self.name
        if self.net_topo_switch is not None:
            result['NetTopoSwitch'] = self.net_topo_switch
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CnnfSwitch') is not None:
            self.cnnf_switch = m.get('CnnfSwitch')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterceptionType') is not None:
            self.interception_type = m.get('InterceptionType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetTopoSwitch') is not None:
            self.net_topo_switch = m.get('NetTopoSwitch')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeClusterNetworkResponseBodyClusterNetwork(TeaModel):
    def __init__(self, edge=None, node=None):
        self.edge = edge  # type: list[DescribeClusterNetworkResponseBodyClusterNetworkEdge]
        self.node = node  # type: list[DescribeClusterNetworkResponseBodyClusterNetworkNode]

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClusterNetworkResponseBodyClusterNetwork, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = DescribeClusterNetworkResponseBodyClusterNetworkEdge()
                self.edge.append(temp_model.from_map(k))
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = DescribeClusterNetworkResponseBodyClusterNetworkNode()
                self.node.append(temp_model.from_map(k))
        return self


class DescribeClusterNetworkResponseBody(TeaModel):
    def __init__(self, cluster_network=None, request_id=None):
        self.cluster_network = cluster_network  # type: DescribeClusterNetworkResponseBodyClusterNetwork
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cluster_network:
            self.cluster_network.validate()

    def to_map(self):
        _map = super(DescribeClusterNetworkResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_network is not None:
            result['ClusterNetwork'] = self.cluster_network.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterNetwork') is not None:
            temp_model = DescribeClusterNetworkResponseBodyClusterNetwork()
            self.cluster_network = temp_model.from_map(m['ClusterNetwork'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterNetworkResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClusterNetworkResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClusterNetworkResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterVulStatisticsRequest(TeaModel):
    def __init__(self, cluster_id=None, types=None):
        self.cluster_id = cluster_id  # type: str
        self.types = types  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterVulStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class DescribeClusterVulStatisticsResponseBodyVulStat(TeaModel):
    def __init__(self, asap_count=None, later_count=None, nntf_count=None):
        self.asap_count = asap_count  # type: str
        self.later_count = later_count  # type: str
        self.nntf_count = nntf_count  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClusterVulStatisticsResponseBodyVulStat, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        return self


class DescribeClusterVulStatisticsResponseBody(TeaModel):
    def __init__(self, request_id=None, vul_stat=None):
        self.request_id = request_id  # type: str
        self.vul_stat = vul_stat  # type: DescribeClusterVulStatisticsResponseBodyVulStat

    def validate(self):
        if self.vul_stat:
            self.vul_stat.validate()

    def to_map(self):
        _map = super(DescribeClusterVulStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_stat is not None:
            result['VulStat'] = self.vul_stat.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulStat') is not None:
            temp_model = DescribeClusterVulStatisticsResponseBodyVulStat()
            self.vul_stat = temp_model.from_map(m['VulStat'])
        return self


class DescribeClusterVulStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClusterVulStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClusterVulStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterVulStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonOverallConfigRequest(TeaModel):
    def __init__(self, source_ip=None, type=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the feature. Valid values:
        # 
        # *   **kdump_switch**: Active defense experience optimization
        # *   **threat_detect**: Dynamic adaptive threat detection capability
        # *   **suspicious_aggregation**: Alert Association
        # *   **alidetect**: File Test
        # *   **USER-ENABLE-SWITCH-TYPE\_3277**: Suspicious process startup
        # *   **USER-ENABLE-SWITCH-TYPE\_5507**: malicious drivers
        # *   **USER-ENABLE-SWITCH-TYPE\_38857**: Entrance service execution high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_50858**: Web service performs high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_50859**: Entrance service execution suspicious operation
        # *   **USER-ENABLE-SWITCH-TYPE\_50861**: Information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_50862**: Cloud Assistant Advanced Protection
        # *   **USER-ENABLE-SWITCH-TYPE\_50867**: Create malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_50868**: Create suspicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_50869**: Unauthorized execution of high-risk orders
        # *   **USER-ENABLE-SWITCH-TYPE\_50870**: Rebound Shell
        # *   **USER-ENABLE-SWITCH-TYPE\_50873**: WebShell execute command
        # *   **USER-ENABLE-SWITCH-TYPE\_50876**: Against security software
        # *   **USER-ENABLE-SWITCH-TYPE\_50877**: Malicious soft communication
        # *   **USER-ENABLE-SWITCH-TYPE\_50884**: Suspicious worm script behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_50885**: malicious script behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_50983**: obfuscated command
        # *   **USER-ENABLE-SWITCH-TYPE\_51200**: Command line download and run malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_51201**: ransomware
        # *   **USER-ENABLE-SWITCH-TYPE\_51202**: Suspected Extortion
        # *   **USER-ENABLE-SWITCH-TYPE\_53168**: process debugging
        # *   **USER-ENABLE-SWITCH-TYPE\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
        # *   **USER-ENABLE-SWITCH-TYPE\_54034**: Intranet scan
        # *   **USER-ENABLE-SWITCH-TYPE\_54265**: Hijacking the PAM Module
        # *   **USER-ENABLE-SWITCH-TYPE\_54395**: Unauthorized reading and writing of sensitive files
        # *   **USER-ENABLE-SWITCH-TYPE\_54699**: Hijack dynamic link library
        # *   **USER-ENABLE-SWITCH-TYPE\_54953**: Hashdump Attack
        # *   **USER-ENABLE-SWITCH-TYPE\_57897**: suspected privilege escalation
        # *   **USER-ENABLE-SWITCH-TYPE\_62981**: Bypassing security monitoring
        # *   **USER-ENABLE-SWITCH-TYPE\_64025**: Ingress service execute command \[enhanced mode]
        # *   **USER-ENABLE-SWITCH-TYPE\_39659**: Sensitive Registry Key Protection
        # *   **USER-ENABLE-SWITCH-TYPE\_51225**: Powershell executes high-risk commands
        # *   **USER-ENABLE-SWITCH-TYPE\_51226**: Powershell execute suspicious command
        # *   **USER-ENABLE-SWITCH-TYPE\_51228**: High-risk lateral penetration tools
        # *   **USER-ENABLE-SWITCH-TYPE\_51229**: Browser service execution a high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_51230**: Entrance service execution suspicious operation
        # *   **USER-ENABLE-SWITCH-TYPE\_51232**: System processes execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51233**: Java service execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51234**: Office components execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51235**: Web service performs high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51236**: Rebound shells
        # *   **USER-ENABLE-SWITCH-TYPE\_52815**: Load high-risk drivers
        # *   **USER-ENABLE-SWITCH-TYPE\_52816**: high-risk account manipulation behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_52818**: Information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_52820**: Create malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_52821**: Suspicious process startup
        # *   **USER-ENABLE-SWITCH-TYPE\_52823**: Running high-risk ARK tools
        # *   **USER-ENABLE-SWITCH-TYPE\_52825**: Unauthorized execution of high-risk orders
        # *   **USER-ENABLE-SWITCH-TYPE\_52826**: Entrance service execution high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_52827**: Ransomware
        # *   **USER-ENABLE-SWITCH-TYPE\_52828**: Suspected Extortion
        # *   **USER-ENABLE-SWITCH-TYPE\_52829**: delete system backup behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_54168**: LSA security permission service protection
        # *   **USER-ENABLE-SWITCH-TYPE\_54365**: Create service autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54366**: Create high-risk autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54367**: Create scheduled task autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54368**: Create registry autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54369**: Create WMI autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54373**: Against security software
        # *   **USER-ENABLE-SWITCH-TYPE\_54374**: Intrusion trace cleanup
        # *   **USER-ENABLE-SWITCH-TYPE\_54384**: Hashdump Attack
        # *   **USER-ENABLE-SWITCH-TYPE\_55251**: Database services execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_57242**: Malicious command execution
        # *   **USER-ENABLE-SWITCH-TYPE\_57340**: Command line download and run malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_62357**: Cloud Assistant service information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_63725**: Ingress service implants suspicious script/binary file
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonOverallConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigResponseBodyOverallConfig(TeaModel):
    def __init__(self, config=None, type=None):
        # The status of the feature. Valid values:
        # 
        # *   **on**: enabled
        # *   **off**: disabled
        self.config = config  # type: str
        # The type of the feature. Valid values:
        # 
        # *   **kdump_switch**: Active defense experience optimization
        # *   **threat_detect**: Dynamic adaptive threat detection capability
        # *   **suspicious_aggregation**: Alert Association
        # *   **alidetect**: File Test
        # *   **USER-ENABLE-SWITCH-TYPE\_3277**: Suspicious process startup
        # *   **USER-ENABLE-SWITCH-TYPE\_5507**: malicious drivers
        # *   **USER-ENABLE-SWITCH-TYPE\_38857**: Entrance service execution high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_50858**: Web service performs high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_50859**: Entrance service execution suspicious operation
        # *   **USER-ENABLE-SWITCH-TYPE\_50861**: Information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_50862**: Cloud Assistant Advanced Protection
        # *   **USER-ENABLE-SWITCH-TYPE\_50867**: Create malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_50868**: Create suspicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_50869**: Unauthorized execution of high-risk orders
        # *   **USER-ENABLE-SWITCH-TYPE\_50870**: Rebound Shell
        # *   **USER-ENABLE-SWITCH-TYPE\_50873**: WebShell execute command
        # *   **USER-ENABLE-SWITCH-TYPE\_50876**: Against security software
        # *   **USER-ENABLE-SWITCH-TYPE\_50877**: Malicious soft communication
        # *   **USER-ENABLE-SWITCH-TYPE\_50884**: Suspicious worm script behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_50885**: malicious script behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_50983**: obfuscated command
        # *   **USER-ENABLE-SWITCH-TYPE\_51200**: Command line download and run malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_51201**: ransomware
        # *   **USER-ENABLE-SWITCH-TYPE\_51202**: Suspected Extortion
        # *   **USER-ENABLE-SWITCH-TYPE\_53168**: process debugging
        # *   **USER-ENABLE-SWITCH-TYPE\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
        # *   **USER-ENABLE-SWITCH-TYPE\_54034**: Intranet scan
        # *   **USER-ENABLE-SWITCH-TYPE\_54265**: Hijacking the PAM Module
        # *   **USER-ENABLE-SWITCH-TYPE\_54395**: Unauthorized reading and writing of sensitive files
        # *   **USER-ENABLE-SWITCH-TYPE\_54699**: Hijack dynamic link library
        # *   **USER-ENABLE-SWITCH-TYPE\_54953**: Hashdump Attack
        # *   **USER-ENABLE-SWITCH-TYPE\_57897**: suspected privilege escalation
        # *   **USER-ENABLE-SWITCH-TYPE\_62981**: Bypassing security monitoring
        # *   **USER-ENABLE-SWITCH-TYPE\_64025**: Ingress service execute command \[enhanced mode]
        # *   **USER-ENABLE-SWITCH-TYPE\_39659**: Sensitive Registry Key Protection
        # *   **USER-ENABLE-SWITCH-TYPE\_51225**: Powershell executes high-risk commands
        # *   **USER-ENABLE-SWITCH-TYPE\_51226**: Powershell execute suspicious command
        # *   **USER-ENABLE-SWITCH-TYPE\_51228**: High-risk lateral penetration tools
        # *   **USER-ENABLE-SWITCH-TYPE\_51229**: Browser service execution a high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_51230**: Entrance service execution suspicious operation
        # *   **USER-ENABLE-SWITCH-TYPE\_51232**: System processes execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51233**: Java service execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51234**: Office components execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51235**: Web service performs high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_51236**: Rebound shells
        # *   **USER-ENABLE-SWITCH-TYPE\_52815**: Load high-risk drivers
        # *   **USER-ENABLE-SWITCH-TYPE\_52816**: high-risk account manipulation behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_52818**: Information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_52820**: Create malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_52821**: Suspicious process startup
        # *   **USER-ENABLE-SWITCH-TYPE\_52823**: Running high-risk ARK tools
        # *   **USER-ENABLE-SWITCH-TYPE\_52825**: Unauthorized execution of high-risk orders
        # *   **USER-ENABLE-SWITCH-TYPE\_52826**: Entrance service execution high-risk operation
        # *   **USER-ENABLE-SWITCH-TYPE\_52827**: Ransomware
        # *   **USER-ENABLE-SWITCH-TYPE\_52828**: Suspected Extortion
        # *   **USER-ENABLE-SWITCH-TYPE\_52829**: delete system backup behavior
        # *   **USER-ENABLE-SWITCH-TYPE\_54168**: LSA security permission service protection
        # *   **USER-ENABLE-SWITCH-TYPE\_54365**: Create service autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54366**: Create high-risk autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54367**: Create scheduled task autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54368**: Create registry autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54369**: Create WMI autorun item
        # *   **USER-ENABLE-SWITCH-TYPE\_54373**: Against security software
        # *   **USER-ENABLE-SWITCH-TYPE\_54374**: Intrusion trace cleanup
        # *   **USER-ENABLE-SWITCH-TYPE\_54384**: Hashdump Attack
        # *   **USER-ENABLE-SWITCH-TYPE\_55251**: Database services execution high-risk operations
        # *   **USER-ENABLE-SWITCH-TYPE\_57242**: Malicious command execution
        # *   **USER-ENABLE-SWITCH-TYPE\_57340**: Command line download and run malicious files
        # *   **USER-ENABLE-SWITCH-TYPE\_62357**: Cloud Assistant service information detection
        # *   **USER-ENABLE-SWITCH-TYPE\_63725**: Ingress service implants suspicious script/binary file
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonOverallConfigResponseBodyOverallConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigResponseBody(TeaModel):
    def __init__(self, overall_config=None, request_id=None):
        # The information about the feature.
        self.overall_config = overall_config  # type: DescribeCommonOverallConfigResponseBodyOverallConfig
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.overall_config:
            self.overall_config.validate()

    def to_map(self):
        _map = super(DescribeCommonOverallConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverallConfig') is not None:
            temp_model = DescribeCommonOverallConfigResponseBodyOverallConfig()
            self.overall_config = temp_model.from_map(m['OverallConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCommonOverallConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCommonOverallConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCommonOverallConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonOverallConfigListRequest(TeaModel):
    def __init__(self, source_ip=None, type_list=None):
        self.source_ip = source_ip  # type: str
        self.type_list = type_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonOverallConfigListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class DescribeCommonOverallConfigListResponseBodyOverallList(TeaModel):
    def __init__(self, config=None, total_count=None, type=None):
        self.config = config  # type: str
        self.total_count = total_count  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonOverallConfigListResponseBodyOverallList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonOverallConfigListResponseBody(TeaModel):
    def __init__(self, overall_list=None, request_id=None):
        self.overall_list = overall_list  # type: list[DescribeCommonOverallConfigListResponseBodyOverallList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.overall_list:
            for k in self.overall_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommonOverallConfigListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OverallList'] = []
        if self.overall_list is not None:
            for k in self.overall_list:
                result['OverallList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.overall_list = []
        if m.get('OverallList') is not None:
            for k in m.get('OverallList'):
                temp_model = DescribeCommonOverallConfigListResponseBodyOverallList()
                self.overall_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCommonOverallConfigListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCommonOverallConfigListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCommonOverallConfigListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonOverallConfigListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonTargetConfigRequest(TeaModel):
    def __init__(self, type=None):
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonTargetConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetConfigResponseBodyTargetList(TeaModel):
    def __init__(self, flag=None, target=None, target_type=None):
        self.flag = flag  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonTargetConfigResponseBodyTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeCommonTargetConfigResponseBody(TeaModel):
    def __init__(self, request_id=None, target_list=None):
        self.request_id = request_id  # type: str
        self.target_list = target_list  # type: list[DescribeCommonTargetConfigResponseBodyTargetList]

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommonTargetConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeCommonTargetConfigResponseBodyTargetList()
                self.target_list.append(temp_model.from_map(k))
        return self


class DescribeCommonTargetConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCommonTargetConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCommonTargetConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonTargetResultListRequest(TeaModel):
    def __init__(self, source_ip=None, type=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the configuration item. Valid values:
        # 
        # *   **webshell_timescan**: webshell detection and removal
        # *   **aliscriptengine**: in-depth detection engine
        # *   **alidetect**: installation scope of local file detection
        # *   **alidetect-scan-enable**: detection scope of local file detection
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonTargetResultListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetResultListResponseBodyTargetConfig(TeaModel):
    def __init__(self, flag=None, target_default=None, target_list=None, target_type=None, total_count=None,
                 type=None):
        # The identifier that indicates whether the configuration item is applied to the server. Valid values:
        # 
        # *   **add**: applied
        # *   **del**: not applied
        self.flag = flag  # type: str
        # The default identifier.
        self.target_default = target_default  # type: str
        # An array that consists of the IDs of the server groups or the UUIDs of the servers.
        # 
        # >  If **uuid** is returned for the **TargetType** parameter, **UUIDs** of the servers are returned. If **groupId** is returned for the **TargetType** parameter, IDs of the server groups are returned.
        self.target_list = target_list  # type: list[str]
        # The type of the server to which the configuration item is applied. Valid values:
        # 
        # *   **uuid**: a server
        # *   **groupId**: a server group
        self.target_type = target_type  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: str
        # The type of the configuration item. Valid values:
        # 
        # *   **webshell_timescan**: webshell detection and removal
        # *   **aliscriptengine**: in-depth detection engine
        # *   **alidetect**: installation scope of local file detection
        # *   **alidetect-scan-enable**: detection scope of local file detection
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommonTargetResultListResponseBodyTargetConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target_default is not None:
            result['TargetDefault'] = self.target_default
        if self.target_list is not None:
            result['TargetList'] = self.target_list
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('TargetDefault') is not None:
            self.target_default = m.get('TargetDefault')
        if m.get('TargetList') is not None:
            self.target_list = m.get('TargetList')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommonTargetResultListResponseBody(TeaModel):
    def __init__(self, request_id=None, target_config=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The information about the configuration item.
        self.target_config = target_config  # type: DescribeCommonTargetResultListResponseBodyTargetConfig

    def validate(self):
        if self.target_config:
            self.target_config.validate()

    def to_map(self):
        _map = super(DescribeCommonTargetResultListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.target_config is not None:
            result['TargetConfig'] = self.target_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TargetConfig') is not None:
            temp_model = DescribeCommonTargetResultListResponseBodyTargetConfig()
            self.target_config = temp_model.from_map(m['TargetConfig'])
        return self


class DescribeCommonTargetResultListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCommonTargetResultListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCommonTargetResultListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonTargetResultListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConcernNecessityRequest(TeaModel):
    def __init__(self, lang=None):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeConcernNecessityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeConcernNecessityResponseBody(TeaModel):
    def __init__(self, concern_necessity=None, request_id=None):
        # The priorities to fix the vulnerabilities. Valid values:
        # 
        # *   asap: high
        # *   later: medium
        # *   nntf: low
        self.concern_necessity = concern_necessity  # type: list[str]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeConcernNecessityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.concern_necessity is not None:
            result['ConcernNecessity'] = self.concern_necessity
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConcernNecessity') is not None:
            self.concern_necessity = m.get('ConcernNecessity')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeConcernNecessityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeConcernNecessityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeConcernNecessityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConcernNecessityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerCriteriaRequest(TeaModel):
    def __init__(self, group_field=None, value=None):
        self.group_field = group_field  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerCriteriaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeContainerCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, name=None, type=None, values=None):
        self.name = name  # type: str
        self.type = type  # type: str
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeContainerCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        self.criteria_list = criteria_list  # type: list[DescribeContainerCriteriaResponseBodyCriteriaList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeContainerCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeContainerCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContainerCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContainerCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerInstancesRequest(TeaModel):
    def __init__(self, criteria=None, current_page=None, logical_exp=None, page_size=None):
        self.criteria = criteria  # type: str
        self.current_page = current_page  # type: int
        self.logical_exp = logical_exp  # type: str
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeContainerInstancesResponseBodyContainerInstanceList(TeaModel):
    def __init__(self, alarm_count=None, alarm_status=None, app_name=None, cluster_id=None, cluster_name=None,
                 container_id=None, create_timestamp=None, hc_count=None, hc_status=None, host_ip=None, image=None,
                 image_digest=None, image_id=None, image_repo_name=None, image_repo_namespace=None, image_repo_tag=None,
                 image_uuid=None, instance_id=None, namespace=None, node_info=None, node_name=None, pod=None, pod_ip=None,
                 region_id=None, risk_count=None, risk_status=None, update_mark=None, vul_count=None, vul_status=None):
        self.alarm_count = alarm_count  # type: int
        self.alarm_status = alarm_status  # type: str
        self.app_name = app_name  # type: str
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.container_id = container_id  # type: str
        self.create_timestamp = create_timestamp  # type: long
        self.hc_count = hc_count  # type: int
        self.hc_status = hc_status  # type: str
        self.host_ip = host_ip  # type: str
        self.image = image  # type: str
        self.image_digest = image_digest  # type: str
        self.image_id = image_id  # type: str
        self.image_repo_name = image_repo_name  # type: str
        self.image_repo_namespace = image_repo_namespace  # type: str
        self.image_repo_tag = image_repo_tag  # type: str
        self.image_uuid = image_uuid  # type: str
        self.instance_id = instance_id  # type: str
        self.namespace = namespace  # type: str
        self.node_info = node_info  # type: str
        self.node_name = node_name  # type: str
        self.pod = pod  # type: str
        self.pod_ip = pod_ip  # type: str
        self.region_id = region_id  # type: str
        self.risk_count = risk_count  # type: str
        self.risk_status = risk_status  # type: str
        self.update_mark = update_mark  # type: str
        self.vul_count = vul_count  # type: int
        self.vul_status = vul_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerInstancesResponseBodyContainerInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_repo_name is not None:
            result['ImageRepoName'] = self.image_repo_name
        if self.image_repo_namespace is not None:
            result['ImageRepoNamespace'] = self.image_repo_namespace
        if self.image_repo_tag is not None:
            result['ImageRepoTag'] = self.image_repo_tag
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_info is not None:
            result['NodeInfo'] = self.node_info
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.update_mark is not None:
            result['UpdateMark'] = self.update_mark
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageRepoName') is not None:
            self.image_repo_name = m.get('ImageRepoName')
        if m.get('ImageRepoNamespace') is not None:
            self.image_repo_namespace = m.get('ImageRepoNamespace')
        if m.get('ImageRepoTag') is not None:
            self.image_repo_tag = m.get('ImageRepoTag')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeInfo') is not None:
            self.node_info = m.get('NodeInfo')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('UpdateMark') is not None:
            self.update_mark = m.get('UpdateMark')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeContainerInstancesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerInstancesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeContainerInstancesResponseBody(TeaModel):
    def __init__(self, container_instance_list=None, page_info=None, request_id=None):
        self.container_instance_list = container_instance_list  # type: list[DescribeContainerInstancesResponseBodyContainerInstanceList]
        self.page_info = page_info  # type: DescribeContainerInstancesResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.container_instance_list:
            for k in self.container_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeContainerInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContainerInstanceList'] = []
        if self.container_instance_list is not None:
            for k in self.container_instance_list:
                result['ContainerInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.container_instance_list = []
        if m.get('ContainerInstanceList') is not None:
            for k in m.get('ContainerInstanceList'):
                temp_model = DescribeContainerInstancesResponseBodyContainerInstanceList()
                self.container_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeContainerInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContainerInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContainerInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContainerStatisticsRequest(TeaModel):
    def __init__(self, cluster_id=None):
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribeContainerStatisticsResponseBodyData(TeaModel):
    def __init__(self, remind_alarm_count=None, serious_alarm_count=None, suspicious_alarm_count=None,
                 total_alarm_count=None, total_node=None, has_risk_node=None):
        # The number of alerts whose risk level is **Reminder**.
        self.remind_alarm_count = remind_alarm_count  # type: int
        # The number of alerts whose risk level is **Urgent**.
        self.serious_alarm_count = serious_alarm_count  # type: int
        # The number of alerts whose risk level is **Suspicious**.
        self.suspicious_alarm_count = suspicious_alarm_count  # type: int
        # The total number of alerts that are generated in the current container cluster.
        self.total_alarm_count = total_alarm_count  # type: int
        # The total number of nodes in the current container cluster.
        self.total_node = total_node  # type: int
        # The number of nodes on which alerts are generated in the current container cluster.
        self.has_risk_node = has_risk_node  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContainerStatisticsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind_alarm_count is not None:
            result['RemindAlarmCount'] = self.remind_alarm_count
        if self.serious_alarm_count is not None:
            result['SeriousAlarmCount'] = self.serious_alarm_count
        if self.suspicious_alarm_count is not None:
            result['SuspiciousAlarmCount'] = self.suspicious_alarm_count
        if self.total_alarm_count is not None:
            result['TotalAlarmCount'] = self.total_alarm_count
        if self.total_node is not None:
            result['TotalNode'] = self.total_node
        if self.has_risk_node is not None:
            result['hasRiskNode'] = self.has_risk_node
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RemindAlarmCount') is not None:
            self.remind_alarm_count = m.get('RemindAlarmCount')
        if m.get('SeriousAlarmCount') is not None:
            self.serious_alarm_count = m.get('SeriousAlarmCount')
        if m.get('SuspiciousAlarmCount') is not None:
            self.suspicious_alarm_count = m.get('SuspiciousAlarmCount')
        if m.get('TotalAlarmCount') is not None:
            self.total_alarm_count = m.get('TotalAlarmCount')
        if m.get('TotalNode') is not None:
            self.total_node = m.get('TotalNode')
        if m.get('hasRiskNode') is not None:
            self.has_risk_node = m.get('hasRiskNode')
        return self


class DescribeContainerStatisticsResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The alert statistics of container assets.
        self.data = data  # type: DescribeContainerStatisticsResponseBodyData
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeContainerStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeContainerStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContainerStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContainerStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContainerStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContainerStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCountNotScannedImageResponseBody(TeaModel):
    def __init__(self, not_scanned_cnt=None, request_id=None):
        self.not_scanned_cnt = not_scanned_cnt  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCountNotScannedImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.not_scanned_cnt is not None:
            result['NotScannedCnt'] = self.not_scanned_cnt
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NotScannedCnt') is not None:
            self.not_scanned_cnt = m.get('NotScannedCnt')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCountNotScannedImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCountNotScannedImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCountNotScannedImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCountNotScannedImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCountScannedImageResponseBody(TeaModel):
    def __init__(self, request_id=None, scanned_count=None):
        self.request_id = request_id  # type: str
        self.scanned_count = scanned_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCountScannedImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scanned_count is not None:
            result['ScannedCount'] = self.scanned_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScannedCount') is not None:
            self.scanned_count = m.get('ScannedCount')
        return self


class DescribeCountScannedImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCountScannedImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCountScannedImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCountScannedImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCriteriaRequest(TeaModel):
    def __init__(self, machine_types=None, support_auto_tag=None, value=None):
        # The type of the asset. Valid values:
        # 
        # *   **ecs**: Elastic Compute Service (ECS) instance
        self.machine_types = machine_types  # type: str
        # Specifies whether the keyword that you specify for fuzzy search can be automatically matched. default **false**, Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.support_auto_tag = support_auto_tag  # type: bool
        # The keyword that you specify for fuzzy search when you query the asset.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCriteriaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.support_auto_tag is not None:
            result['SupportAutoTag'] = self.support_auto_tag
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('SupportAutoTag') is not None:
            self.support_auto_tag = m.get('SupportAutoTag')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, multi_values=None, name=None, type=None, values=None):
        # The structured attribute values of the assets that match the keyword. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **vendor**: providers
        # *   **regionIds**: IDs of supported regions
        self.multi_values = multi_values  # type: str
        # The name of the filter condition.
        self.name = name  # type: str
        # The type of the filter condition. Valid values:
        # 
        # *   **input**: The filter condition needs to be specified.
        # *   **select**: The filter condition is an option that can be selected from the drop-down list.
        self.type = type  # type: str
        # The attribute values of the assets that match the keyword.
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.multi_values is not None:
            result['MultiValues'] = self.multi_values
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MultiValues') is not None:
            self.multi_values = m.get('MultiValues')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        # An array that consists of the filter conditions.
        self.criteria_list = criteria_list  # type: list[DescribeCriteriaResponseBodyCriteriaList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomBlockRecordsRequest(TeaModel):
    def __init__(self, block_ip=None, current_page=None, page_size=None, resource_owner_id=None, status=None):
        self.block_ip = block_ip  # type: str
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCustomBlockRecordsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCustomBlockRecordsResponseBodyRecordListTargetList(TeaModel):
    def __init__(self, target=None, target_type=None):
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsResponseBodyRecordListTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeCustomBlockRecordsResponseBodyRecordList(TeaModel):
    def __init__(self, block_expire_date=None, block_ip=None, bound=None, enable_count=None, id=None,
                 server_count=None, source=None, status=None, target_list=None):
        self.block_expire_date = block_expire_date  # type: long
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.enable_count = enable_count  # type: int
        self.id = id  # type: long
        self.server_count = server_count  # type: int
        self.source = source  # type: str
        self.status = status  # type: int
        self.target_list = target_list  # type: list[DescribeCustomBlockRecordsResponseBodyRecordListTargetList]

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsResponseBodyRecordList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_expire_date is not None:
            result['BlockExpireDate'] = self.block_expire_date
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.enable_count is not None:
            result['EnableCount'] = self.enable_count
        if self.id is not None:
            result['Id'] = self.id
        if self.server_count is not None:
            result['ServerCount'] = self.server_count
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockExpireDate') is not None:
            self.block_expire_date = m.get('BlockExpireDate')
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('EnableCount') is not None:
            self.enable_count = m.get('EnableCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ServerCount') is not None:
            self.server_count = m.get('ServerCount')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeCustomBlockRecordsResponseBodyRecordListTargetList()
                self.target_list.append(temp_model.from_map(k))
        return self


class DescribeCustomBlockRecordsResponseBody(TeaModel):
    def __init__(self, page_info=None, record_list=None, request_id=None):
        self.page_info = page_info  # type: DescribeCustomBlockRecordsResponseBodyPageInfo
        self.record_list = record_list  # type: list[DescribeCustomBlockRecordsResponseBodyRecordList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.record_list:
            for k in self.record_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['RecordList'] = []
        if self.record_list is not None:
            for k in self.record_list:
                result['RecordList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeCustomBlockRecordsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.record_list = []
        if m.get('RecordList') is not None:
            for k in m.get('RecordList'):
                temp_model = DescribeCustomBlockRecordsResponseBodyRecordList()
                self.record_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCustomBlockRecordsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomBlockRecordsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomBlockRecordsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomBlockRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCycleTaskListRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, task_name=None, task_type=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCycleTaskListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeCycleTaskListResponseBodyCycleScheduleResponseList(TeaModel):
    def __init__(self, config_id=None, enable=None, first_date_str=None, interval_period=None, last_task_id=None,
                 next_start_time_str=None, param=None, period_unit=None, target_end_time=None, target_start_time=None, task_name=None,
                 task_type=None):
        self.config_id = config_id  # type: str
        self.enable = enable  # type: int
        self.first_date_str = first_date_str  # type: long
        self.interval_period = interval_period  # type: int
        self.last_task_id = last_task_id  # type: str
        self.next_start_time_str = next_start_time_str  # type: long
        self.param = param  # type: str
        self.period_unit = period_unit  # type: str
        self.target_end_time = target_end_time  # type: int
        self.target_start_time = target_start_time  # type: int
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCycleTaskListResponseBodyCycleScheduleResponseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.last_task_id is not None:
            result['LastTaskId'] = self.last_task_id
        if self.next_start_time_str is not None:
            result['NextStartTimeStr'] = self.next_start_time_str
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('LastTaskId') is not None:
            self.last_task_id = m.get('LastTaskId')
        if m.get('NextStartTimeStr') is not None:
            self.next_start_time_str = m.get('NextStartTimeStr')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeCycleTaskListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCycleTaskListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCycleTaskListResponseBody(TeaModel):
    def __init__(self, cycle_schedule_response_list=None, page_info=None, request_id=None):
        self.cycle_schedule_response_list = cycle_schedule_response_list  # type: list[DescribeCycleTaskListResponseBodyCycleScheduleResponseList]
        self.page_info = page_info  # type: DescribeCycleTaskListResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cycle_schedule_response_list:
            for k in self.cycle_schedule_response_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeCycleTaskListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleScheduleResponseList'] = []
        if self.cycle_schedule_response_list is not None:
            for k in self.cycle_schedule_response_list:
                result['CycleScheduleResponseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cycle_schedule_response_list = []
        if m.get('CycleScheduleResponseList') is not None:
            for k in m.get('CycleScheduleResponseList'):
                temp_model = DescribeCycleTaskListResponseBodyCycleScheduleResponseList()
                self.cycle_schedule_response_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeCycleTaskListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCycleTaskListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCycleTaskListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCycleTaskListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCycleTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDingTalkRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, rule_action_name=None):
        # The number of the page to return.Default value: 1.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page.Default value: 20.
        self.page_size = page_size  # type: int
        # The name of the notification.
        self.rule_action_name = rule_action_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDingTalkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_action_name is not None:
            result['RuleActionName'] = self.rule_action_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleActionName') is not None:
            self.rule_action_name = m.get('RuleActionName')
        return self


class DescribeDingTalkResponseBodyActionList(TeaModel):
    def __init__(self, action_name=None, ali_uid=None, config_list=None, ding_talk_lang=None, gmt_create=None,
                 gmt_modified=None, group_id_list=None, id=None, interval_time=None, status=None, url=None):
        # The name of the notification.
        self.action_name = action_name  # type: str
        # The UID of the user.
        self.ali_uid = ali_uid  # type: long
        # The list of notification settings.
        self.config_list = config_list  # type: str
        # The language of the content within notifications. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.ding_talk_lang = ding_talk_lang  # type: str
        # The creation time. unit:millisecond.
        self.gmt_create = gmt_create  # type: long
        # The modification time.
        self.gmt_modified = gmt_modified  # type: long
        # The group IDs.
        self.group_id_list = group_id_list  # type: str
        # The ID of the notification.
        self.id = id  # type: int
        # The interval at which the notifications are sent.unit:minute.
        self.interval_time = interval_time  # type: int
        # The status of the notification. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.status = status  # type: int
        # The parameters of the notification.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDingTalkResponseBodyActionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_name is not None:
            result['ActionName'] = self.action_name
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.config_list is not None:
            result['ConfigList'] = self.config_list
        if self.ding_talk_lang is not None:
            result['DingTalkLang'] = self.ding_talk_lang
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_time is not None:
            result['IntervalTime'] = self.interval_time
        if self.status is not None:
            result['Status'] = self.status
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionName') is not None:
            self.action_name = m.get('ActionName')
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('ConfigList') is not None:
            self.config_list = m.get('ConfigList')
        if m.get('DingTalkLang') is not None:
            self.ding_talk_lang = m.get('DingTalkLang')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalTime') is not None:
            self.interval_time = m.get('IntervalTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeDingTalkResponseBodyPageInfo(TeaModel):
    def __init__(self, current_page=None, page_size=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of messages.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDingTalkResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDingTalkResponseBody(TeaModel):
    def __init__(self, action_list=None, page_info=None, request_id=None):
        # An array that consists of details of notifications.
        self.action_list = action_list  # type: list[DescribeDingTalkResponseBodyActionList]
        # The pagination information.
        self.page_info = page_info  # type: DescribeDingTalkResponseBodyPageInfo
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeDingTalkResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionList'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['ActionList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.action_list = []
        if m.get('ActionList') is not None:
            for k in m.get('ActionList'):
                temp_model = DescribeDingTalkResponseBodyActionList()
                self.action_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeDingTalkResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDingTalkResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDingTalkResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDingTalkResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDingTalkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainCountRequest(TeaModel):
    def __init__(self, source_ip=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainCountResponseBody(TeaModel):
    def __init__(self, request_id=None, root_domains_count=None, sub_domains_count=None, total_domains_count=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The number of root domains.
        self.root_domains_count = root_domains_count  # type: int
        # The number of subdomains.
        self.sub_domains_count = sub_domains_count  # type: int
        # The total number of entries returned.
        self.total_domains_count = total_domains_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root_domains_count is not None:
            result['RootDomainsCount'] = self.root_domains_count
        if self.sub_domains_count is not None:
            result['SubDomainsCount'] = self.sub_domains_count
        if self.total_domains_count is not None:
            result['TotalDomainsCount'] = self.total_domains_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RootDomainsCount') is not None:
            self.root_domains_count = m.get('RootDomainsCount')
        if m.get('SubDomainsCount') is not None:
            self.sub_domains_count = m.get('SubDomainsCount')
        if m.get('TotalDomainsCount') is not None:
            self.total_domains_count = m.get('TotalDomainsCount')
        return self


class DescribeDomainCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDomainCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDomainCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainDetailRequest(TeaModel):
    def __init__(self, domain_name=None, source_ip=None):
        # The domain name or the name of website that you want to query.
        # 
        # >  Fuzzy match is not supported. You must enter a complete domain name or a website.
        self.domain_name = domain_name  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainDetailResponseBodyDomainDetailItems(TeaModel):
    def __init__(self, asset_type=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 uuid=None):
        # The type of the domain asset. Valid values:
        # 
        # *   **0**: an Elastic Compute Service (ECS) instance
        # *   **1**: a Server Load Balancer (SLB) instance
        # *   **2**: a Network Address Translation (NAT) gateway
        # *   **3**: an ApsaraDB RDS instance
        # *   **4**: an ApsaraDB for MongoDB instance
        self.asset_type = asset_type  # type: str
        # The instance ID of the asset.
        self.instance_id = instance_id  # type: str
        # The name of the asset.
        self.instance_name = instance_name  # type: str
        # The public IP address of the asset.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip  # type: str
        # The instance UUID of the domain asset.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainDetailResponseBodyDomainDetailItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeDomainDetailResponseBody(TeaModel):
    def __init__(self, alarm_count=None, domain=None, domain_detail_items=None, request_id=None, root_domain=None,
                 vul_count=None):
        # The total number of alerts in your website assets.
        self.alarm_count = alarm_count  # type: int
        # The domain name.
        self.domain = domain  # type: str
        # An array that consists of the details about the domain asset.
        self.domain_detail_items = domain_detail_items  # type: list[DescribeDomainDetailResponseBodyDomainDetailItems]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The name of the root domain that corresponds to the domain.
        self.root_domain = root_domain  # type: str
        # The total number of vulnerabilities in your website assets.
        self.vul_count = vul_count  # type: int

    def validate(self):
        if self.domain_detail_items:
            for k in self.domain_detail_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDomainDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.domain is not None:
            result['Domain'] = self.domain
        result['DomainDetailItems'] = []
        if self.domain_detail_items is not None:
            for k in self.domain_detail_items:
                result['DomainDetailItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root_domain is not None:
            result['RootDomain'] = self.root_domain
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        self.domain_detail_items = []
        if m.get('DomainDetailItems') is not None:
            for k in m.get('DomainDetailItems'):
                temp_model = DescribeDomainDetailResponseBodyDomainDetailItems()
                self.domain_detail_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RootDomain') is not None:
            self.root_domain = m.get('RootDomain')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        return self


class DescribeDomainDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDomainDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDomainDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainListRequest(TeaModel):
    def __init__(self, current_page=None, domain_type=None, fuzzy_domain=None, page_size=None, source_ip=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The type of the domain name that you want to query. Valid values:
        # 
        # *   **root**: root domain name
        # *   **sub**: subdomain name
        self.domain_type = domain_type  # type: str
        # The keyword that is used to query domain names. Fuzzy match is supported.
        self.fuzzy_domain = fuzzy_domain  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.fuzzy_domain is not None:
            result['FuzzyDomain'] = self.fuzzy_domain
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('FuzzyDomain') is not None:
            self.fuzzy_domain = m.get('FuzzyDomain')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeDomainListResponseBodyDomainListResponseList(TeaModel):
    def __init__(self, domain=None, ip_list=None):
        # The name of the domain or website.
        self.domain = domain  # type: str
        # The IP addresses of the domain name.
        self.ip_list = ip_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainListResponseBodyDomainListResponseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_list is not None:
            result['IpList'] = self.ip_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpList') is not None:
            self.ip_list = m.get('IpList')
        return self


class DescribeDomainListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDomainListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainListResponseBody(TeaModel):
    def __init__(self, domain_list_response_list=None, page_info=None, request_id=None):
        # An array that consists of the information about domain names.
        self.domain_list_response_list = domain_list_response_list  # type: list[DescribeDomainListResponseBodyDomainListResponseList]
        # The pagination information.
        self.page_info = page_info  # type: DescribeDomainListResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.domain_list_response_list:
            for k in self.domain_list_response_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeDomainListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainListResponseList'] = []
        if self.domain_list_response_list is not None:
            for k in self.domain_list_response_list:
                result['DomainListResponseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.domain_list_response_list = []
        if m.get('DomainListResponseList') is not None:
            for k in m.get('DomainListResponseList'):
                temp_model = DescribeDomainListResponseBodyDomainListResponseList()
                self.domain_list_response_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeDomainListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDomainListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDomainListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDomainListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEmgUserAgreementResponseBody(TeaModel):
    def __init__(self, auth=None, request_id=None):
        self.auth = auth  # type: bool
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEmgUserAgreementResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth is not None:
            result['Auth'] = self.auth
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Auth') is not None:
            self.auth = m.get('Auth')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEmgUserAgreementResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEmgUserAgreementResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEmgUserAgreementResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEmgUserAgreementResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEmgVulItemRequest(TeaModel):
    def __init__(self, check_type=None, current_page=None, lang=None, page_size=None, risk_status=None,
                 scan_type=None, vul_name=None):
        # The check method. Valid values:
        # 
        # *   **0**: proof of concept (POC) verification
        # *   **1**: version comparison
        self.check_type = check_type  # type: int
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # Specifies whether the vulnerability poses risks.\
        # If you do not specify this parameter, all vulnerabilities are queried regardless of whether the vulnerabilities pose risks. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.risk_status = risk_status  # type: str
        # The method that is used to detect the vulnerability.\
        # If you do not specify this parameter, all vulnerabilities are queried regardless of which method is used. Valid values:
        # 
        # *   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
        # *   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.
        self.scan_type = scan_type  # type: str
        # The name of the urgent vulnerability.
        self.vul_name = vul_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEmgVulItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.scan_type is not None:
            result['ScanType'] = self.scan_type
        if self.vul_name is not None:
            result['VulName'] = self.vul_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('ScanType') is not None:
            self.scan_type = m.get('ScanType')
        if m.get('VulName') is not None:
            self.vul_name = m.get('VulName')
        return self


class DescribeEmgVulItemResponseBodyGroupedVulItems(TeaModel):
    def __init__(self, alias_name=None, check_type=None, gmt_last_check=None, gmt_publish=None, name=None,
                 pending_count=None, progress=None, status=None, type=None):
        # The name of the urgent vulnerability.
        self.alias_name = alias_name  # type: str
        # The check method.
        self.check_type = check_type  # type: int
        # The timestamp when the urgent vulnerability was last detected. Unit: milliseconds.
        self.gmt_last_check = gmt_last_check  # type: long
        # The timestamp when the vulnerability was disclosed. Unit: milliseconds.
        self.gmt_publish = gmt_publish  # type: long
        # The name of the detection rule.
        self.name = name  # type: str
        # The number of unhandled urgent vulnerabilities.
        self.pending_count = pending_count  # type: int
        # The progress of the urgent vulnerability detection task. Valid values: 0 to 100.
        # 
        # >  This parameter is returned only when an urgent vulnerability is being detected.
        self.progress = progress  # type: int
        # The detection status of the urgent vulnerability. Valid values:
        # 
        # *   **10**: The urgent vulnerability is not detected.
        # *   **20**: The urgent vulnerability is being detected.
        # *   **30**: The urgent vulnerability detection is complete.
        self.status = status  # type: int
        # The method that is used to detect the urgent vulnerability. Valid values:
        # 
        # *   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
        # *   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEmgVulItemResponseBodyGroupedVulItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.gmt_last_check is not None:
            result['GmtLastCheck'] = self.gmt_last_check
        if self.gmt_publish is not None:
            result['GmtPublish'] = self.gmt_publish
        if self.name is not None:
            result['Name'] = self.name
        if self.pending_count is not None:
            result['PendingCount'] = self.pending_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('GmtLastCheck') is not None:
            self.gmt_last_check = m.get('GmtLastCheck')
        if m.get('GmtPublish') is not None:
            self.gmt_publish = m.get('GmtPublish')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PendingCount') is not None:
            self.pending_count = m.get('PendingCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeEmgVulItemResponseBody(TeaModel):
    def __init__(self, current_page=None, grouped_vul_items=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # An array that consists of the urgent vulnerabilities returned.
        self.grouped_vul_items = grouped_vul_items  # type: list[DescribeEmgVulItemResponseBodyGroupedVulItems]
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of the urgent vulnerabilities returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEmgVulItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeEmgVulItemResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEmgVulItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEmgVulItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEmgVulItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEmgVulItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventLevelCountRequest(TeaModel):
    def __init__(self, cluster_id=None, container_field_name=None, container_field_value=None, container_ids=None,
                 from_=None, target_type=None):
        self.cluster_id = cluster_id  # type: str
        self.container_field_name = container_field_name  # type: str
        self.container_field_value = container_field_value  # type: str
        self.container_ids = container_ids  # type: str
        self.from_ = from_  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventLevelCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.container_ids is not None:
            result['ContainerIds'] = self.container_ids
        if self.from_ is not None:
            result['From'] = self.from_
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('ContainerIds') is not None:
            self.container_ids = m.get('ContainerIds')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeEventLevelCountResponseBodyEventLevels(TeaModel):
    def __init__(self, remind=None, serious=None, suspicious=None):
        self.remind = remind  # type: int
        self.serious = serious  # type: int
        self.suspicious = suspicious  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventLevelCountResponseBodyEventLevels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind is not None:
            result['Remind'] = self.remind
        if self.serious is not None:
            result['Serious'] = self.serious
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Remind') is not None:
            self.remind = m.get('Remind')
        if m.get('Serious') is not None:
            self.serious = m.get('Serious')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        return self


class DescribeEventLevelCountResponseBody(TeaModel):
    def __init__(self, code=None, event_levels=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.event_levels = event_levels  # type: DescribeEventLevelCountResponseBodyEventLevels
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.event_levels:
            self.event_levels.validate()

    def to_map(self):
        _map = super(DescribeEventLevelCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.event_levels is not None:
            result['EventLevels'] = self.event_levels.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EventLevels') is not None:
            temp_model = DescribeEventLevelCountResponseBodyEventLevels()
            self.event_levels = temp_model.from_map(m['EventLevels'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeEventLevelCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEventLevelCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEventLevelCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventLevelCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventOnStageRequest(TeaModel):
    def __init__(self, lang=None):
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventOnStageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeEventOnStageResponseBodySecurityEventStageResponse(TeaModel):
    def __init__(self, security_event_on_stag=None):
        self.security_event_on_stag = security_event_on_stag  # type: dict[str, any]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventOnStageResponseBodySecurityEventStageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_on_stag is not None:
            result['SecurityEventOnStag'] = self.security_event_on_stag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityEventOnStag') is not None:
            self.security_event_on_stag = m.get('SecurityEventOnStag')
        return self


class DescribeEventOnStageResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_stage_response=None):
        self.request_id = request_id  # type: str
        self.security_event_stage_response = security_event_stage_response  # type: DescribeEventOnStageResponseBodySecurityEventStageResponse

    def validate(self):
        if self.security_event_stage_response:
            self.security_event_stage_response.validate()

    def to_map(self):
        _map = super(DescribeEventOnStageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event_stage_response is not None:
            result['SecurityEventStageResponse'] = self.security_event_stage_response.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEventStageResponse') is not None:
            temp_model = DescribeEventOnStageResponseBodySecurityEventStageResponse()
            self.security_event_stage_response = temp_model.from_map(m['SecurityEventStageResponse'])
        return self


class DescribeEventOnStageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEventOnStageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEventOnStageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventOnStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExcludeSystemPathRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExcludeSystemPathRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeExcludeSystemPathResponseBodyExcludePaths(TeaModel):
    def __init__(self, os=None, path=None):
        self.os = os  # type: str
        self.path = path  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExcludeSystemPathResponseBodyExcludePaths, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.os is not None:
            result['Os'] = self.os
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class DescribeExcludeSystemPathResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExcludeSystemPathResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExcludeSystemPathResponseBody(TeaModel):
    def __init__(self, exclude_paths=None, page_info=None, request_id=None):
        self.exclude_paths = exclude_paths  # type: list[DescribeExcludeSystemPathResponseBodyExcludePaths]
        self.page_info = page_info  # type: DescribeExcludeSystemPathResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.exclude_paths:
            for k in self.exclude_paths:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeExcludeSystemPathResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExcludePaths'] = []
        if self.exclude_paths is not None:
            for k in self.exclude_paths:
                result['ExcludePaths'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.exclude_paths = []
        if m.get('ExcludePaths') is not None:
            for k in m.get('ExcludePaths'):
                temp_model = DescribeExcludeSystemPathResponseBodyExcludePaths()
                self.exclude_paths.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeExcludeSystemPathResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExcludeSystemPathResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExcludeSystemPathResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExcludeSystemPathResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExcludeSystemPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExportInfoRequest(TeaModel):
    def __init__(self, export_id=None):
        # The ID of the export task.
        self.export_id = export_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeExportInfoResponseBody(TeaModel):
    def __init__(self, current_count=None, export_status=None, file_name=None, id=None, link=None, message=None,
                 progress=None, request_id=None, total_count=None):
        # The number of exported entries.
        self.current_count = current_count  # type: int
        # The status of the export task.
        # 
        # Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **exporting**: The task is in progress.
        # *   **success**: The task is complete.
        self.export_status = export_status  # type: str
        # The name of the exported Excel file.
        self.file_name = file_name  # type: str
        # The ID of the export task.
        self.id = id  # type: long
        # The URL at which you can download the exported Excel file.
        self.link = link  # type: str
        # The message that shows the task result.
        # 
        # The value is fixed as success, which indicates that the export task is complete.
        self.message = message  # type: str
        # The progress percentage of the export task.
        self.progress = progress  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries in the exported Excel file.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedCheckWarningRequest(TeaModel):
    def __init__(self, lang=None, type_name=None, uuids=None):
        self.lang = lang  # type: str
        self.type_name = type_name  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedCheckWarningRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeExposedCheckWarningResponseBodyWarningList(TeaModel):
    def __init__(self, risk_id=None, risk_name=None, sub_type_alias=None, type_alias=None, uuid=None):
        self.risk_id = risk_id  # type: long
        self.risk_name = risk_name  # type: str
        self.sub_type_alias = sub_type_alias  # type: str
        self.type_alias = type_alias  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedCheckWarningResponseBodyWarningList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedCheckWarningResponseBody(TeaModel):
    def __init__(self, count=None, request_id=None, warning_list=None):
        self.count = count  # type: int
        self.request_id = request_id  # type: str
        self.warning_list = warning_list  # type: list[DescribeExposedCheckWarningResponseBodyWarningList]

    def validate(self):
        if self.warning_list:
            for k in self.warning_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExposedCheckWarningResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['WarningList'] = []
        if self.warning_list is not None:
            for k in self.warning_list:
                result['WarningList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.warning_list = []
        if m.get('WarningList') is not None:
            for k in m.get('WarningList'):
                temp_model = DescribeExposedCheckWarningResponseBodyWarningList()
                self.warning_list.append(temp_model.from_map(k))
        return self


class DescribeExposedCheckWarningResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedCheckWarningResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedCheckWarningResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedCheckWarningResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceCriteriaRequest(TeaModel):
    def __init__(self, value=None):
        # The value of the search condition. Fuzzy match is supported.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceCriteriaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeExposedInstanceCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, name=None, type=None, values=None):
        # The name of the search condition.
        self.name = name  # type: str
        # The type of the search condition. Valid values:
        # 
        # *   **input**: You must configure the search condition.
        # *   **select**: You must select a search condition from the **Values** list.
        self.type = type  # type: str
        # The value of the search condition. This parameter is returned only when the value of the **Type** parameter is **select**.
        # 
        # >  If the value of the **Type** parameter is **input**, this parameter is empty.
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeExposedInstanceCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        # The search conditions that are used to search for exposed assets.
        self.criteria_list = criteria_list  # type: list[DescribeExposedInstanceCriteriaResponseBodyCriteriaList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeExposedInstanceCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedInstanceCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceDetailRequest(TeaModel):
    def __init__(self, uuid=None):
        # The UUID of the server that is exposed on the Internet.
        # 
        # >  You can call the [DescribeExposedInstanceList](~~DescribeExposedInstanceList~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList(TeaModel):
    def __init__(self, alias_name=None, name=None, necessity=None, type=None, uuid=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        # 
        # >  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.
        self.necessity = necessity  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerabilities
        # *   **sys**: Windows system vulnerabilities
        # *   **cms**: Web-CMS vulnerabilities
        # *   **app**: application vulnerabilities
        # *   **emg**: urgent vulnerabilities
        # *   **sca**: middleware vulnerabilities
        self.type = type  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList(TeaModel):
    def __init__(self, alias_name=None, name=None, necessity=None, type=None, uuid=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        # 
        # >  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.
        self.necessity = necessity  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerabilities
        # *   **sys**: Windows system vulnerabilities
        # *   **cms**: Web-CMS vulnerabilities
        # *   **app**: application vulnerabilities
        # *   **emg**: urgent vulnerabilities
        # *   **sca**: middleware vulnerabilities
        self.type = type  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBodyExposedChains(TeaModel):
    def __init__(self, all_vul_list=None, exposure_component=None, exposure_ip=None, exposure_port=None,
                 exposure_type=None, exposure_type_id=None, group_no=None, instance_id=None, instance_name=None, internet_ip=None,
                 intranet_ip=None, real_vul_list=None, region_id=None, uuid=None):
        # The information about all vulnerabilities on the server.
        self.all_vul_list = all_vul_list  # type: list[DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList]
        # The server component that is exposed on the Internet.
        self.exposure_component = exposure_component  # type: str
        # The public IP address.
        self.exposure_ip = exposure_ip  # type: str
        # The port that is exposed on the Internet.
        self.exposure_port = exposure_port  # type: str
        # The resource from which the server is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the public IP address of an Elastic Compute Service (ECS) instance
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **EIP**: an elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.exposure_type = exposure_type  # type: str
        # The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.
        # 
        # *   If the value of the ExposureType parameter is **INTERNET_IP**, the value of this parameter is an empty string.
        # *   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the Internet-facing SLB instance.
        # *   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
        # *   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
        self.exposure_type_id = exposure_type_id  # type: str
        # The server group to which the server belongs.
        self.group_no = group_no  # type: str
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The information about the vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.real_vul_list = real_vul_list  # type: list[DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList]
        # The region in which the server resides.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.all_vul_list:
            for k in self.all_vul_list:
                if k:
                    k.validate()
        if self.real_vul_list:
            for k in self.real_vul_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailResponseBodyExposedChains, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllVulList'] = []
        if self.all_vul_list is not None:
            for k in self.all_vul_list:
                result['AllVulList'].append(k.to_map() if k else None)
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.group_no is not None:
            result['GroupNo'] = self.group_no
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        result['RealVulList'] = []
        if self.real_vul_list is not None:
            for k in self.real_vul_list:
                result['RealVulList'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.all_vul_list = []
        if m.get('AllVulList') is not None:
            for k in m.get('AllVulList'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList()
                self.all_vul_list.append(temp_model.from_map(k))
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('GroupNo') is not None:
            self.group_no = m.get('GroupNo')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        self.real_vul_list = []
        if m.get('RealVulList') is not None:
            for k in m.get('RealVulList'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList()
                self.real_vul_list.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceDetailResponseBody(TeaModel):
    def __init__(self, exposed_chains=None, request_id=None):
        # The exposure details about the server.
        self.exposed_chains = exposed_chains  # type: list[DescribeExposedInstanceDetailResponseBodyExposedChains]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.exposed_chains:
            for k in self.exposed_chains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExposedChains'] = []
        if self.exposed_chains is not None:
            for k in self.exposed_chains:
                result['ExposedChains'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.exposed_chains = []
        if m.get('ExposedChains') is not None:
            for k in m.get('ExposedChains'):
                temp_model = DescribeExposedInstanceDetailResponseBodyExposedChains()
                self.exposed_chains.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedInstanceDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedInstanceListRequest(TeaModel):
    def __init__(self, current_page=None, exposure_component=None, exposure_ip=None, exposure_port=None,
                 group_id=None, health_status=None, instance_id=None, instance_name=None, page_size=None, vul_status=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The server component that is exposed on the Internet.
        self.exposure_component = exposure_component  # type: str
        # The public IP address of the server.
        self.exposure_ip = exposure_ip  # type: str
        # The port that is exposed on the Internet.
        self.exposure_port = exposure_port  # type: str
        # The ID of the server group.
        # 
        # > You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.
        self.group_id = group_id  # type: long
        # The health status of the Elastic Compute Service (ECS) instance in the scaling group. ECS instances that are not in the Running state are considered unhealthy. Valid values:
        # 
        # *   Healthy
        # *   Unhealthy
        # 
        # Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.
        # 
        # Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycle. If the lifecycle of the ECS instances is not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release them. If the lifecycle of the ECS instances is managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases them.
        # 
        # >  Make sure that you have sufficient balance within your account. If you have overdue payments in your account, pay-as-you-go and preemptible instances are stopped or released. For information about how the status of ECS instances changes when you have overdue payments in your account, see [Overdue payments](~~170589~~).
        self.health_status = health_status  # type: bool
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        # Specifies whether the server has vulnerabilities. Valid values:
        # 
        # *   **true**: The server has vulnerabilities.
        # *   **false**: The server does not have vulnerabilities.
        self.vul_status = vul_status  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeExposedInstanceListResponseBodyExposedInstances(TeaModel):
    def __init__(self, asap_vul_count=None, exploit_health_count=None, exposure_component=None, exposure_ip=None,
                 exposure_port=None, exposure_type=None, exposure_type_id=None, group_id=None, group_name=None, instance_id=None,
                 instance_name=None, internet_ip=None, intranet_ip=None, later_vul_count=None, nntf_vul_count=None,
                 region_id=None, total_vul_count=None, uuid=None):
        # The number of high-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.asap_vul_count = asap_vul_count  # type: int
        # The total number of servers that are exposed on the Internet.
        self.exploit_health_count = exploit_health_count  # type: int
        # The server component that is exposed on the Internet.
        self.exposure_component = exposure_component  # type: str
        # The public IP address that is exposed on the Internet.
        self.exposure_ip = exposure_ip  # type: str
        # The port that is exposed on the Internet.
        self.exposure_port = exposure_port  # type: str
        # The resource from which the asset is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the public IP address of an ECS instance
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **EIP**: an elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.exposure_type = exposure_type  # type: str
        # The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the ExposureType parameter.
        # 
        # *   If the value of the ExposureType parameter is **INTERNET_IP**, this parameter is empty.
        # *   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the SLB instance.
        # *   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
        # *   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
        self.exposure_type_id = exposure_type_id  # type: str
        # The ID of the server group.
        self.group_id = group_id  # type: long
        # The name of the server group.
        self.group_name = group_name  # type: str
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The number of medium-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.later_vul_count = later_vul_count  # type: int
        # The number of low-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.nntf_vul_count = nntf_vul_count  # type: int
        # The ID of the region where the server resides.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.region_id = region_id  # type: str
        # The total number of vulnerabilities that are exposed on the Internet and can be exploited by attackers.
        self.total_vul_count = total_vul_count  # type: int
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceListResponseBodyExposedInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_vul_count is not None:
            result['AsapVulCount'] = self.asap_vul_count
        if self.exploit_health_count is not None:
            result['ExploitHealthCount'] = self.exploit_health_count
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.later_vul_count is not None:
            result['LaterVulCount'] = self.later_vul_count
        if self.nntf_vul_count is not None:
            result['NntfVulCount'] = self.nntf_vul_count
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.total_vul_count is not None:
            result['TotalVulCount'] = self.total_vul_count
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsapVulCount') is not None:
            self.asap_vul_count = m.get('AsapVulCount')
        if m.get('ExploitHealthCount') is not None:
            self.exploit_health_count = m.get('ExploitHealthCount')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LaterVulCount') is not None:
            self.later_vul_count = m.get('LaterVulCount')
        if m.get('NntfVulCount') is not None:
            self.nntf_vul_count = m.get('NntfVulCount')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TotalVulCount') is not None:
            self.total_vul_count = m.get('TotalVulCount')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeExposedInstanceListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries about the servers that are exposed on the Internet.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedInstanceListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExposedInstanceListResponseBody(TeaModel):
    def __init__(self, exposed_instances=None, page_info=None, request_id=None):
        # An array that consists of the details about the exposed asset.
        self.exposed_instances = exposed_instances  # type: list[DescribeExposedInstanceListResponseBodyExposedInstances]
        # The pagination information.
        self.page_info = page_info  # type: DescribeExposedInstanceListResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.exposed_instances:
            for k in self.exposed_instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExposedInstances'] = []
        if self.exposed_instances is not None:
            for k in self.exposed_instances:
                result['ExposedInstances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.exposed_instances = []
        if m.get('ExposedInstances') is not None:
            for k in m.get('ExposedInstances'):
                temp_model = DescribeExposedInstanceListResponseBodyExposedInstances()
                self.exposed_instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeExposedInstanceListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedInstanceListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedInstanceListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedInstanceListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedInstanceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedStatisticsResponseBody(TeaModel):
    def __init__(self, exposed_asap_vul_count=None, exposed_component_count=None, exposed_instance_count=None,
                 exposed_ip_count=None, exposed_later_vul_count=None, exposed_nntf_vul_count=None, exposed_port_count=None,
                 exposed_week_password_machine_count=None, gateway_asset_count=None, request_id=None):
        self.exposed_asap_vul_count = exposed_asap_vul_count  # type: int
        self.exposed_component_count = exposed_component_count  # type: int
        self.exposed_instance_count = exposed_instance_count  # type: int
        self.exposed_ip_count = exposed_ip_count  # type: int
        self.exposed_later_vul_count = exposed_later_vul_count  # type: int
        self.exposed_nntf_vul_count = exposed_nntf_vul_count  # type: int
        self.exposed_port_count = exposed_port_count  # type: int
        self.exposed_week_password_machine_count = exposed_week_password_machine_count  # type: int
        self.gateway_asset_count = gateway_asset_count  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exposed_asap_vul_count is not None:
            result['ExposedAsapVulCount'] = self.exposed_asap_vul_count
        if self.exposed_component_count is not None:
            result['ExposedComponentCount'] = self.exposed_component_count
        if self.exposed_instance_count is not None:
            result['ExposedInstanceCount'] = self.exposed_instance_count
        if self.exposed_ip_count is not None:
            result['ExposedIpCount'] = self.exposed_ip_count
        if self.exposed_later_vul_count is not None:
            result['ExposedLaterVulCount'] = self.exposed_later_vul_count
        if self.exposed_nntf_vul_count is not None:
            result['ExposedNntfVulCount'] = self.exposed_nntf_vul_count
        if self.exposed_port_count is not None:
            result['ExposedPortCount'] = self.exposed_port_count
        if self.exposed_week_password_machine_count is not None:
            result['ExposedWeekPasswordMachineCount'] = self.exposed_week_password_machine_count
        if self.gateway_asset_count is not None:
            result['GatewayAssetCount'] = self.gateway_asset_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExposedAsapVulCount') is not None:
            self.exposed_asap_vul_count = m.get('ExposedAsapVulCount')
        if m.get('ExposedComponentCount') is not None:
            self.exposed_component_count = m.get('ExposedComponentCount')
        if m.get('ExposedInstanceCount') is not None:
            self.exposed_instance_count = m.get('ExposedInstanceCount')
        if m.get('ExposedIpCount') is not None:
            self.exposed_ip_count = m.get('ExposedIpCount')
        if m.get('ExposedLaterVulCount') is not None:
            self.exposed_later_vul_count = m.get('ExposedLaterVulCount')
        if m.get('ExposedNntfVulCount') is not None:
            self.exposed_nntf_vul_count = m.get('ExposedNntfVulCount')
        if m.get('ExposedPortCount') is not None:
            self.exposed_port_count = m.get('ExposedPortCount')
        if m.get('ExposedWeekPasswordMachineCount') is not None:
            self.exposed_week_password_machine_count = m.get('ExposedWeekPasswordMachineCount')
        if m.get('GatewayAssetCount') is not None:
            self.gateway_asset_count = m.get('GatewayAssetCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExposedStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExposedStatisticsDetailRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, statistics_type=None, statistics_type_gateway_type=None,
                 statistics_type_instance_value=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        # The type of the exposed asset. Valid values:
        # 
        # *   **exposureType**: gateway assets
        # *   **exposurePort**: ports
        # *   **exposureComponent**: system components
        # *   **exposureIp**: IP addresses
        self.statistics_type = statistics_type  # type: str
        # The type of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**. Valid values:
        # 
        # *   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.statistics_type_gateway_type = statistics_type_gateway_type  # type: str
        # The ID of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**.
        self.statistics_type_instance_value = statistics_type_instance_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedStatisticsDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.statistics_type is not None:
            result['StatisticsType'] = self.statistics_type
        if self.statistics_type_gateway_type is not None:
            result['StatisticsTypeGatewayType'] = self.statistics_type_gateway_type
        if self.statistics_type_instance_value is not None:
            result['StatisticsTypeInstanceValue'] = self.statistics_type_instance_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StatisticsType') is not None:
            self.statistics_type = m.get('StatisticsType')
        if m.get('StatisticsTypeGatewayType') is not None:
            self.statistics_type_gateway_type = m.get('StatisticsTypeGatewayType')
        if m.get('StatisticsTypeInstanceValue') is not None:
            self.statistics_type_instance_value = m.get('StatisticsTypeInstanceValue')
        return self


class DescribeExposedStatisticsDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedStatisticsDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExposedStatisticsDetailResponseBodyStatisticsDetails(TeaModel):
    def __init__(self, exposed_count=None, exposure_component=None, exposure_ip=None, exposure_port=None,
                 exposure_type=None, exposure_type_id=None, exposure_type_instance_name=None, region_id=None):
        # The total number of system vulnerabilities that are detected on your server and are exposed on the Internet.
        self.exposed_count = exposed_count  # type: int
        # The system component that is exposed on the Internet.
        self.exposure_component = exposure_component  # type: str
        # The public IP address that is exposed on the Internet.
        self.exposure_ip = exposure_ip  # type: str
        # The port that is exposed on the Internet.
        self.exposure_port = exposure_port  # type: str
        # The resource from which the asset is exposed. Valid values:
        # 
        # *   **INTERNET_IP**: the IP address of the Elastic Compute Service (ECS) instance
        # *   **SLB**: the public IP address of the SLB instance
        # *   **EIP**: the elastic IP address (EIP)
        # *   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature
        self.exposure_type = exposure_type  # type: str
        # The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.
        # 
        # *   If the value of the **ExposureType** parameter is **INTERNET_IP**, the value of this parameter is an empty string.
        # *   If the value of the **ExposureType** parameter is **SLB**, the value of this parameter is the ID of the Internet-facing SLB instance.
        # *   If the value of the **ExposureType** parameter is **EIP**, the value of this parameter is the ID of the EIP.
        # *   If the value of the **ExposureType** parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
        self.exposure_type_id = exposure_type_id  # type: str
        # The name of the gateway asset that is exposed on the Internet.
        self.exposure_type_instance_name = exposure_type_instance_name  # type: str
        # The region ID of the asset.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExposedStatisticsDetailResponseBodyStatisticsDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exposed_count is not None:
            result['ExposedCount'] = self.exposed_count
        if self.exposure_component is not None:
            result['ExposureComponent'] = self.exposure_component
        if self.exposure_ip is not None:
            result['ExposureIp'] = self.exposure_ip
        if self.exposure_port is not None:
            result['ExposurePort'] = self.exposure_port
        if self.exposure_type is not None:
            result['ExposureType'] = self.exposure_type
        if self.exposure_type_id is not None:
            result['ExposureTypeId'] = self.exposure_type_id
        if self.exposure_type_instance_name is not None:
            result['ExposureTypeInstanceName'] = self.exposure_type_instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExposedCount') is not None:
            self.exposed_count = m.get('ExposedCount')
        if m.get('ExposureComponent') is not None:
            self.exposure_component = m.get('ExposureComponent')
        if m.get('ExposureIp') is not None:
            self.exposure_ip = m.get('ExposureIp')
        if m.get('ExposurePort') is not None:
            self.exposure_port = m.get('ExposurePort')
        if m.get('ExposureType') is not None:
            self.exposure_type = m.get('ExposureType')
        if m.get('ExposureTypeId') is not None:
            self.exposure_type_id = m.get('ExposureTypeId')
        if m.get('ExposureTypeInstanceName') is not None:
            self.exposure_type_instance_name = m.get('ExposureTypeInstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeExposedStatisticsDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, statistics_details=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeExposedStatisticsDetailResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet and are returned.
        self.statistics_details = statistics_details  # type: list[DescribeExposedStatisticsDetailResponseBodyStatisticsDetails]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.statistics_details:
            for k in self.statistics_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExposedStatisticsDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StatisticsDetails'] = []
        if self.statistics_details is not None:
            for k in self.statistics_details:
                result['StatisticsDetails'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeExposedStatisticsDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics_details = []
        if m.get('StatisticsDetails') is not None:
            for k in m.get('StatisticsDetails'):
                temp_model = DescribeExposedStatisticsDetailResponseBodyStatisticsDetails()
                self.statistics_details.append(temp_model.from_map(k))
        return self


class DescribeExposedStatisticsDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExposedStatisticsDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExposedStatisticsDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExposedStatisticsDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFieldStatisticsRequest(TeaModel):
    def __init__(self, machine_types=None, region_id=None):
        # The type of the asset to query. If no asset types are specified, all types of assets are returned. Valid values:
        # 
        # *   **ecs**: server
        # *   **cloud_product**: Alibaba Cloud service
        self.machine_types = machine_types  # type: str
        # The ID of the region in which the asset resides.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFieldStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeFieldStatisticsResponseBodyGroupedFields(TeaModel):
    def __init__(self, ali_yun_instance_count=None, aws_instance_count=None, exposed_instance_count=None,
                 general_asset_count=None, group_count=None, huawei_instance_count=None, idc_instance_count=None,
                 important_asset_count=None, instance_count=None, instance_sync_task_count=None, new_instance_count=None,
                 no_risk_instance_count=None, not_running_status_count=None, offline_instance_count=None,
                 out_machine_instance_count=None, pause_instance_count=None, region_count=None, risk_instance_count=None,
                 tencent_instance_count=None, test_asset_count=None, tripartite_instance_count=None, un_know_status_instance_count=None,
                 unprotected_instance_count=None, vpc_count=None):
        # The number of assets that are deployed on Alibaba Cloud.
        self.ali_yun_instance_count = ali_yun_instance_count  # type: int
        # The number of servers.
        self.aws_instance_count = aws_instance_count  # type: int
        # The number of exposed servers.
        self.exposed_instance_count = exposed_instance_count  # type: int
        # The number of assets whose importance is common.
        self.general_asset_count = general_asset_count  # type: int
        # The number of server groups.
        self.group_count = group_count  # type: int
        # The number of instances that are provisioned by third-party providers.
        self.huawei_instance_count = huawei_instance_count  # type: int
        # The number of assets that can be protected by Security Center.
        self.idc_instance_count = idc_instance_count  # type: int
        # The number of assets whose importance is important.
        self.important_asset_count = important_asset_count  # type: int
        # The total number of assets of the specified type. If no asset types are specified, this parameter indicates the total number of all servers and Alibaba Cloud services within your account.
        self.instance_count = instance_count  # type: int
        # The total number of tasks for the specified type of assets. If no asset types are specified, this parameter indicates the total number of all servers and Alibaba Cloud services within your account.
        self.instance_sync_task_count = instance_sync_task_count  # type: int
        # The number of newly added servers.
        self.new_instance_count = new_instance_count  # type: int
        # The number of assets that do not pose risks.
        self.no_risk_instance_count = no_risk_instance_count  # type: int
        # The number of servers that are shut down.
        self.not_running_status_count = not_running_status_count  # type: int
        # The number of servers whose Security Center agent status is Offline.
        self.offline_instance_count = offline_instance_count  # type: int
        # The number of servers outside the cloud.
        self.out_machine_instance_count = out_machine_instance_count  # type: int
        # The number of servers for which the Security Center agent suspends protection.
        self.pause_instance_count = pause_instance_count  # type: int
        # The number of regions to which the servers belong.
        self.region_count = region_count  # type: int
        # The number of assets that are at risk.
        self.risk_instance_count = risk_instance_count  # type: int
        # The total number of cloud services that are protected by Security Center.
        self.tencent_instance_count = tencent_instance_count  # type: int
        # The number of assets whose importance is test.
        self.test_asset_count = test_asset_count  # type: int
        # The number of simple application servers.
        self.tripartite_instance_count = tripartite_instance_count  # type: int
        # The number of assets whose statuses are unknown.
        self.un_know_status_instance_count = un_know_status_instance_count  # type: int
        # The number of unprotected assets.
        self.unprotected_instance_count = unprotected_instance_count  # type: int
        # The number of virtual private clouds (VPCs).
        self.vpc_count = vpc_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFieldStatisticsResponseBodyGroupedFields, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_yun_instance_count is not None:
            result['AliYunInstanceCount'] = self.ali_yun_instance_count
        if self.aws_instance_count is not None:
            result['AwsInstanceCount'] = self.aws_instance_count
        if self.exposed_instance_count is not None:
            result['ExposedInstanceCount'] = self.exposed_instance_count
        if self.general_asset_count is not None:
            result['GeneralAssetCount'] = self.general_asset_count
        if self.group_count is not None:
            result['GroupCount'] = self.group_count
        if self.huawei_instance_count is not None:
            result['HuaweiInstanceCount'] = self.huawei_instance_count
        if self.idc_instance_count is not None:
            result['IdcInstanceCount'] = self.idc_instance_count
        if self.important_asset_count is not None:
            result['ImportantAssetCount'] = self.important_asset_count
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_sync_task_count is not None:
            result['InstanceSyncTaskCount'] = self.instance_sync_task_count
        if self.new_instance_count is not None:
            result['NewInstanceCount'] = self.new_instance_count
        if self.no_risk_instance_count is not None:
            result['NoRiskInstanceCount'] = self.no_risk_instance_count
        if self.not_running_status_count is not None:
            result['NotRunningStatusCount'] = self.not_running_status_count
        if self.offline_instance_count is not None:
            result['OfflineInstanceCount'] = self.offline_instance_count
        if self.out_machine_instance_count is not None:
            result['OutMachineInstanceCount'] = self.out_machine_instance_count
        if self.pause_instance_count is not None:
            result['PauseInstanceCount'] = self.pause_instance_count
        if self.region_count is not None:
            result['RegionCount'] = self.region_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.tencent_instance_count is not None:
            result['TencentInstanceCount'] = self.tencent_instance_count
        if self.test_asset_count is not None:
            result['TestAssetCount'] = self.test_asset_count
        if self.tripartite_instance_count is not None:
            result['TripartiteInstanceCount'] = self.tripartite_instance_count
        if self.un_know_status_instance_count is not None:
            result['UnKnowStatusInstanceCount'] = self.un_know_status_instance_count
        if self.unprotected_instance_count is not None:
            result['UnprotectedInstanceCount'] = self.unprotected_instance_count
        if self.vpc_count is not None:
            result['VpcCount'] = self.vpc_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliYunInstanceCount') is not None:
            self.ali_yun_instance_count = m.get('AliYunInstanceCount')
        if m.get('AwsInstanceCount') is not None:
            self.aws_instance_count = m.get('AwsInstanceCount')
        if m.get('ExposedInstanceCount') is not None:
            self.exposed_instance_count = m.get('ExposedInstanceCount')
        if m.get('GeneralAssetCount') is not None:
            self.general_asset_count = m.get('GeneralAssetCount')
        if m.get('GroupCount') is not None:
            self.group_count = m.get('GroupCount')
        if m.get('HuaweiInstanceCount') is not None:
            self.huawei_instance_count = m.get('HuaweiInstanceCount')
        if m.get('IdcInstanceCount') is not None:
            self.idc_instance_count = m.get('IdcInstanceCount')
        if m.get('ImportantAssetCount') is not None:
            self.important_asset_count = m.get('ImportantAssetCount')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceSyncTaskCount') is not None:
            self.instance_sync_task_count = m.get('InstanceSyncTaskCount')
        if m.get('NewInstanceCount') is not None:
            self.new_instance_count = m.get('NewInstanceCount')
        if m.get('NoRiskInstanceCount') is not None:
            self.no_risk_instance_count = m.get('NoRiskInstanceCount')
        if m.get('NotRunningStatusCount') is not None:
            self.not_running_status_count = m.get('NotRunningStatusCount')
        if m.get('OfflineInstanceCount') is not None:
            self.offline_instance_count = m.get('OfflineInstanceCount')
        if m.get('OutMachineInstanceCount') is not None:
            self.out_machine_instance_count = m.get('OutMachineInstanceCount')
        if m.get('PauseInstanceCount') is not None:
            self.pause_instance_count = m.get('PauseInstanceCount')
        if m.get('RegionCount') is not None:
            self.region_count = m.get('RegionCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('TencentInstanceCount') is not None:
            self.tencent_instance_count = m.get('TencentInstanceCount')
        if m.get('TestAssetCount') is not None:
            self.test_asset_count = m.get('TestAssetCount')
        if m.get('TripartiteInstanceCount') is not None:
            self.tripartite_instance_count = m.get('TripartiteInstanceCount')
        if m.get('UnKnowStatusInstanceCount') is not None:
            self.un_know_status_instance_count = m.get('UnKnowStatusInstanceCount')
        if m.get('UnprotectedInstanceCount') is not None:
            self.unprotected_instance_count = m.get('UnprotectedInstanceCount')
        if m.get('VpcCount') is not None:
            self.vpc_count = m.get('VpcCount')
        return self


class DescribeFieldStatisticsResponseBody(TeaModel):
    def __init__(self, grouped_fields=None, request_id=None):
        # The information about servers that are returned.
        self.grouped_fields = grouped_fields  # type: DescribeFieldStatisticsResponseBodyGroupedFields
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super(DescribeFieldStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = DescribeFieldStatisticsResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFieldStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFieldStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFieldStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFieldStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFrontVulPatchListRequest(TeaModel):
    def __init__(self, info=None, lang=None, operate_type=None, type=None):
        # The information about the Windows system vulnerability. The value is a JSON string that contains the following fields:
        # 
        # *   **name**: the name of the vulnerability.
        # *   **uuid**: the UUID of the server on which the vulnerability is detected.
        # *   **tag**: the tag that is added to the vulnerability. Set this field to **system**, which indicates Windows system vulnerabilities.
        self.info = info  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The operation that you want to perform on the vulnerability. Set the value to **vul_fix**, which indicates vulnerability fixing.
        self.operate_type = operate_type  # type: str
        # The type of the vulnerability. Set the value to **sys**, which indicates Windows system vulnerabilities.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFrontVulPatchListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList(TeaModel):
    def __init__(self, alias_name=None, name=None):
        # The name of the Windows system vulnerability.
        self.alias_name = alias_name  # type: str
        # The version number of the pre-patch that is required to fix the Windows system vulnerability.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchList(TeaModel):
    def __init__(self, patch_list=None, uuid=None):
        # An array consisting of the pre-patches that are required to fix the specified Windows system vulnerability on the server.
        self.patch_list = patch_list  # type: list[DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList]
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.patch_list:
            for k in self.patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBodyFrontPatchList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PatchList'] = []
        if self.patch_list is not None:
            for k in self.patch_list:
                result['PatchList'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.patch_list = []
        if m.get('PatchList') is not None:
            for k in m.get('PatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList()
                self.patch_list.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeFrontVulPatchListResponseBody(TeaModel):
    def __init__(self, front_patch_list=None, request_id=None):
        # An array consisting of the information about the pre-patches that are required to fix the specified Windows system vulnerability.
        self.front_patch_list = front_patch_list  # type: list[DescribeFrontVulPatchListResponseBodyFrontPatchList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.front_patch_list:
            for k in self.front_patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrontPatchList'] = []
        if self.front_patch_list is not None:
            for k in self.front_patch_list:
                result['FrontPatchList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.front_patch_list = []
        if m.get('FrontPatchList') is not None:
            for k in m.get('FrontPatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchList()
                self.front_patch_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFrontVulPatchListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFrontVulPatchListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFrontVulPatchListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedContainerInstancesRequest(TeaModel):
    def __init__(self, criteria=None, current_page=None, field_value=None, group_field=None, logical_exp=None,
                 page_size=None):
        # The search conditions for assets. Specify the value in the JSON format. Separate multiple search conditions with commas (,). Example: `[{"name":"riskStatus","value":"YES"},{"name":"riskLevel","value":"2"}]`.
        # 
        # >  Supported search conditions include the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.
        self.criteria = criteria  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The keyword that you want to use to query containers. You must specify this parameter based on the value of the GroupField parameter.
        # 
        # *   If the **GroupField** parameter is set to **pod**, set this parameter to the name of the pod that you want to query.
        # *   If the **GroupField** parameter is set to **appName**, set this parameter to the name of the application that you want to query.
        # *   If the **GroupField** parameter is set to **namespace**, set this parameter to the namespace that you want to query.
        # *   If the **GroupField** parameter is set to **clusterId**, set this parameter to the ID of the cluster that you want to query.
        # 
        # >  Fuzzy match is supported.
        self.field_value = field_value  # type: str
        # The group type that you want to use to query containers. Valid values:
        # 
        # *   **pod**\
        # *   **appName**\
        # *   **namespace**\
        # *   **clusterId**\
        self.group_field = group_field  # type: str
        # The logical relationship that you want to use to evaluate multiple search conditions. Valid values:
        # 
        # *   **OR**: Search conditions are evaluated by using a logical **OR**.
        # *   **AND**: Search conditions are evaluated by using a logical **AND**.
        self.logical_exp = logical_exp  # type: str
        # The number of entries to return on each page. Default value: **20**.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedContainerInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList(TeaModel):
    def __init__(self, alarm_count=None, app_name=None, cluster_id=None, cluster_name=None, cluster_type=None,
                 create_time=None, custer_state=None, hc_count=None, host_ip=None, image=None, image_digest=None,
                 image_repo_name=None, image_repo_namespace=None, image_repo_tag=None, image_uuid=None, instance_count=None,
                 instance_id=None, namespace=None, pod=None, pod_ip=None, region_id=None, risk_instance_count=None,
                 risk_level=None, risk_status=None, vul_count=None):
        # The number of alerts that are generated on the current pod, application, namespace, or cluster.
        self.alarm_count = alarm_count  # type: int
        # The name of the application.
        self.app_name = app_name  # type: str
        # The ID of cluster.
        self.cluster_id = cluster_id  # type: str
        # The name of the instance.
        self.cluster_name = cluster_name  # type: str
        # The type of the cluster. Valid values:
        # 
        # *   **Kubernetes**: dedicated Kubernetes cluster
        # *   **ManagedKubernetes**: standard managed cluster (edge cluster)
        # *   **Ask**: standard serverless cluster
        self.cluster_type = cluster_type  # type: str
        # The timestamp when the cluster was created. Unit: milliseconds.
        self.create_time = create_time  # type: long
        # The status of the cluster. Valid values:
        # 
        # *   **running**: The cluster is running.
        # *   **stopped**: The cluster is stopped.
        # *   **deleted**: The cluster is deleted.
        # *   **delete_failed**: The cluster fails to be deleted.
        # *   **failed**: The cluster fails to be created.
        self.custer_state = custer_state  # type: str
        # The number of baseline risks that are detected on the current pod, application, namespace, or cluster.
        self.hc_count = hc_count  # type: int
        # The IP address of the host in the container cluster.
        self.host_ip = host_ip  # type: str
        # The image of the container.
        self.image = image  # type: str
        # The digest value of the image.
        self.image_digest = image_digest  # type: str
        # The name of the image repository.
        self.image_repo_name = image_repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.image_repo_namespace = image_repo_namespace  # type: str
        # The tag that is added to the image repository.
        self.image_repo_tag = image_repo_tag  # type: str
        # The UUID of the image.
        self.image_uuid = image_uuid  # type: str
        # The number of queried pods, applications, clusters, or namespaces.
        self.instance_count = instance_count  # type: int
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The namespace of the cluster.
        self.namespace = namespace  # type: str
        # The name of the pod.
        self.pod = pod  # type: str
        # The IP address of the pod.
        self.pod_ip = pod_ip  # type: str
        # The ID of the region in which the server resides.
        self.region_id = region_id  # type: str
        # The number of at-risk instances.
        self.risk_instance_count = risk_instance_count  # type: int
        # The risk level. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # Indicates whether risks were detected. Valid values:
        # 
        # *   **NO**: No risks were detected.
        # *   **YES**: Risks were detected.
        self.risk_status = risk_status  # type: str
        # The number of vulnerabilities that are detected on the current pod, application, namespace, or cluster.
        self.vul_count = vul_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.custer_state is not None:
            result['CusterState'] = self.custer_state
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_repo_name is not None:
            result['ImageRepoName'] = self.image_repo_name
        if self.image_repo_namespace is not None:
            result['ImageRepoNamespace'] = self.image_repo_namespace
        if self.image_repo_tag is not None:
            result['ImageRepoTag'] = self.image_repo_tag
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CusterState') is not None:
            self.custer_state = m.get('CusterState')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageRepoName') is not None:
            self.image_repo_name = m.get('ImageRepoName')
        if m.get('ImageRepoNamespace') is not None:
            self.image_repo_namespace = m.get('ImageRepoNamespace')
        if m.get('ImageRepoTag') is not None:
            self.image_repo_tag = m.get('ImageRepoTag')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        return self


class DescribeGroupedContainerInstancesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of container assets returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of container assets returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedContainerInstancesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedContainerInstancesResponseBody(TeaModel):
    def __init__(self, grouped_container_instance_list=None, page_info=None, request_id=None):
        # An array that consists of the container assets returned.
        self.grouped_container_instance_list = grouped_container_instance_list  # type: list[DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList]
        # The pagination information.
        self.page_info = page_info  # type: DescribeGroupedContainerInstancesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.grouped_container_instance_list:
            for k in self.grouped_container_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeGroupedContainerInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupedContainerInstanceList'] = []
        if self.grouped_container_instance_list is not None:
            for k in self.grouped_container_instance_list:
                result['GroupedContainerInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.grouped_container_instance_list = []
        if m.get('GroupedContainerInstanceList') is not None:
            for k in m.get('GroupedContainerInstanceList'):
                temp_model = DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList()
                self.grouped_container_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedContainerInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedContainerInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedContainerInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedContainerInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedContainerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedInstancesRequest(TeaModel):
    def __init__(self, current_page=None, field_value=None, group_field=None, lang=None, machine_types=None,
                 no_page=None, page_size=None, vendor=None, vendors=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The name of the group to which the assets belong. Fuzzy search is supported.
        self.field_value = field_value  # type: str
        # The filter condition that you want to use to query the assets. Valid values:
        # 
        # *   **groupId**: the group to which the assets belong
        # *   **regionId**: the region in which the assets reside
        # *   **vpcInstanceId**: the virtual private cloud (VPC) in which the assets reside
        self.group_field = group_field  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The type of the assets that you want to query. Set the value to **ecs**, which indicates Elastic Compute Service (ECS) instances.
        self.machine_types = machine_types  # type: str
        # Specifies whether to enable paged query. Default value: **true**. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.no_page = no_page  # type: bool
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The source of the server. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int
        # The source of the server. Separate multiple sources with commas (,).Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendors = vendors  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_field is not None:
            result['GroupField'] = self.group_field
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.no_page is not None:
            result['NoPage'] = self.no_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupField') is not None:
            self.group_field = m.get('GroupField')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('NoPage') is not None:
            self.no_page = m.get('NoPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class DescribeGroupedInstancesResponseBodyInstances(TeaModel):
    def __init__(self, asap_vul_instance_count=None, field_alias_name=None, group_flag=None, instance_count=None,
                 risk_instance_count=None, un_protected_instance_count=None):
        # The number of assets on which high-risk vulnerabilities are detected.
        self.asap_vul_instance_count = asap_vul_instance_count  # type: long
        # The name of the server group.
        self.field_alias_name = field_alias_name  # type: str
        # The type of the server group. Valid values:
        # 
        # *   **0**: the default group
        # *   **1**: other group
        self.group_flag = group_flag  # type: int
        # The total number of assets that belong to the specified type.
        # 
        # >  If the **MachineTypes** request parameter is not specified, the value of the InstanceCount parameter is the total number of your assets.
        self.instance_count = instance_count  # type: str
        # The number of assets that are at risk.
        self.risk_instance_count = risk_instance_count  # type: str
        # The number of assets that are not protected by Security Center.
        self.un_protected_instance_count = un_protected_instance_count  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_vul_instance_count is not None:
            result['AsapVulInstanceCount'] = self.asap_vul_instance_count
        if self.field_alias_name is not None:
            result['FieldAliasName'] = self.field_alias_name
        if self.group_flag is not None:
            result['GroupFlag'] = self.group_flag
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        if self.un_protected_instance_count is not None:
            result['UnProtectedInstanceCount'] = self.un_protected_instance_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsapVulInstanceCount') is not None:
            self.asap_vul_instance_count = m.get('AsapVulInstanceCount')
        if m.get('FieldAliasName') is not None:
            self.field_alias_name = m.get('FieldAliasName')
        if m.get('GroupFlag') is not None:
            self.group_flag = m.get('GroupFlag')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        if m.get('UnProtectedInstanceCount') is not None:
            self.un_protected_instance_count = m.get('UnProtectedInstanceCount')
        return self


class DescribeGroupedInstancesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedInstancesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, page_info=None, request_id=None):
        # An array that consists of the information about the assets.
        self.instances = instances  # type: list[DescribeGroupedInstancesResponseBodyInstances]
        # The pagination information.
        self.page_info = page_info  # type: DescribeGroupedInstancesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeGroupedInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeGroupedInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedMaliciousFilesRequest(TeaModel):
    def __init__(self, cluster_id=None, current_page=None, fuzzy_malicious_name=None, image_digest=None,
                 image_layer=None, image_tag=None, lang=None, levels=None, malicious_md_5=None, page_size=None, repo_id=None,
                 repo_instance_id=None, repo_name=None, repo_namespace=None, repo_region_id=None, scan_range=None):
        # The cluster ID of the container on which the malicious image sample is detected.
        self.cluster_id = cluster_id  # type: str
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # The name of the malicious image sample that you want to query.
        # 
        # >  Fuzzy match is supported.
        self.fuzzy_malicious_name = fuzzy_malicious_name  # type: str
        # The image digest.
        self.image_digest = image_digest  # type: str
        # The image layer.
        self.image_layer = image_layer  # type: str
        # The image tag.
        self.image_tag = image_tag  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The severity of the malicious image sample that you want to query. You can enter multiple severities. Separate the severities with commas (,). Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.levels = levels  # type: str
        self.malicious_md_5 = malicious_md_5  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: str
        # The ID of the image repository.
        # 
        # >  You can call the [ListRepository](~~145293~~) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.
        self.repo_id = repo_id  # type: str
        # The ID of the container image.
        # 
        # >  You can call the [ListRepository](~~145293~~) operation to query the IDs of container images from the value of the **InstanceId** response parameter.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        # 
        # >  Fuzzy match is supported.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        # 
        # >  Fuzzy match is supported.
        self.repo_namespace = repo_namespace  # type: str
        # The region ID of the image repository. Valid values:
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-zhangjiakou**: China (Zhangjiakou)
        # *   **cn-hangzhou**: China (Hangzhou)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **cn-hongkong**: China (Hong Kong)
        # *   **ap-southeast-1**: Singapore
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        # *   **us-east-1**: US (Virginia)
        # *   **us-west-1**: US (Silicon Valley)
        # *   **eu-central-1**: Germany (Frankfurt)
        # *   **eu-west-1**: UK (London)
        # *   **ap-south-1**: India (Mumbai)
        self.repo_region_id = repo_region_id  # type: str
        # The types of the assets that you want to scan.
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedMaliciousFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.fuzzy_malicious_name is not None:
            result['FuzzyMaliciousName'] = self.fuzzy_malicious_name
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FuzzyMaliciousName') is not None:
            self.fuzzy_malicious_name = m.get('FuzzyMaliciousName')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse(TeaModel):
    def __init__(self, first_scan_timestamp=None, image_count=None, latest_scan_timestamp=None, level=None,
                 malicious_md_5=None, malicious_name=None, status=None):
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.first_scan_timestamp = first_scan_timestamp  # type: long
        # The number of affected images.
        self.image_count = image_count  # type: long
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.latest_scan_timestamp = latest_scan_timestamp  # type: long
        # The severity of the malicious image sample. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level  # type: str
        # The MD5 hash value of the malicious image sample.
        self.malicious_md_5 = malicious_md_5  # type: str
        # The name of the malicious image sample.
        self.malicious_name = malicious_name  # type: str
        # The handling status of the malicious image sample. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: verifying
        # *   **3**: added to the whitelist
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_scan_timestamp is not None:
            result['FirstScanTimestamp'] = self.first_scan_timestamp
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.latest_scan_timestamp is not None:
            result['LatestScanTimestamp'] = self.latest_scan_timestamp
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_md_5 is not None:
            result['MaliciousMd5'] = self.malicious_md_5
        if self.malicious_name is not None:
            result['MaliciousName'] = self.malicious_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FirstScanTimestamp') is not None:
            self.first_scan_timestamp = m.get('FirstScanTimestamp')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('LatestScanTimestamp') is not None:
            self.latest_scan_timestamp = m.get('LatestScanTimestamp')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousMd5') is not None:
            self.malicious_md_5 = m.get('MaliciousMd5')
        if m.get('MaliciousName') is not None:
            self.malicious_name = m.get('MaliciousName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeGroupedMaliciousFilesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedMaliciousFilesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedMaliciousFilesResponseBody(TeaModel):
    def __init__(self, grouped_malicious_file_response=None, page_info=None, request_id=None):
        # An array that consists of the malicious image samples.
        self.grouped_malicious_file_response = grouped_malicious_file_response  # type: list[DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse]
        # The pagination information.
        self.page_info = page_info  # type: DescribeGroupedMaliciousFilesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.grouped_malicious_file_response:
            for k in self.grouped_malicious_file_response:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeGroupedMaliciousFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupedMaliciousFileResponse'] = []
        if self.grouped_malicious_file_response is not None:
            for k in self.grouped_malicious_file_response:
                result['GroupedMaliciousFileResponse'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.grouped_malicious_file_response = []
        if m.get('GroupedMaliciousFileResponse') is not None:
            for k in m.get('GroupedMaliciousFileResponse'):
                temp_model = DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse()
                self.grouped_malicious_file_response.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeGroupedMaliciousFilesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGroupedMaliciousFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedMaliciousFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedMaliciousFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedMaliciousFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedTagsRequest(TeaModel):
    def __init__(self, machine_types=None):
        # The type of the asset to query. If you do not specify this parameter, the tags of all asset types are queried. Valid values:
        # 
        # *   **ecs**: server
        # *   **cloud_product**: Alibaba Cloud service
        self.machine_types = machine_types  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        return self


class DescribeGroupedTagsResponseBodyGroupedFileds(TeaModel):
    def __init__(self, count=None, name=None, tag_id=None):
        # The number of assets to which the tag is added.
        self.count = count  # type: str
        # The name of the tag.
        self.name = name  # type: str
        # The ID of the tag.
        self.tag_id = tag_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedTagsResponseBodyGroupedFileds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        return self


class DescribeGroupedTagsResponseBody(TeaModel):
    def __init__(self, count=None, grouped_fileds=None, http_status_code=None, request_id=None, success=None):
        # This parameter is deprecated.
        self.count = count  # type: int
        # An array that consists of the statistics of the asset tags.
        self.grouped_fileds = grouped_fileds  # type: list[DescribeGroupedTagsResponseBodyGroupedFileds]
        # The HTTP status code of the request.
        self.http_status_code = http_status_code  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success  # type: bool

    def validate(self):
        if self.grouped_fileds:
            for k in self.grouped_fileds:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupedTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['GroupedFileds'] = []
        if self.grouped_fileds is not None:
            for k in self.grouped_fileds:
                result['GroupedFileds'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.grouped_fileds = []
        if m.get('GroupedFileds') is not None:
            for k in m.get('GroupedFileds'):
                temp_model = DescribeGroupedTagsResponseBodyGroupedFileds()
                self.grouped_fileds.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeGroupedTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedVulRequest(TeaModel):
    def __init__(self, alias_name=None, attach_types=None, current_page=None, dealed=None, group_id=None, lang=None,
                 necessity=None, page_size=None, search_tags=None, type=None, uuids=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The type of the vulnerability.
        # 
        # >  This parameter is valid only for application vulnerabilities and vulnerabilities that are detected based on software component analysis.
        self.attach_types = attach_types  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the vulnerability is handled. Valid values:
        # 
        # **y**: yes **n**: no
        self.dealed = dealed  # type: str
        # The ID of the asset group.
        self.group_id = group_id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity  # type: str
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        # The tag that is used to filter vulnerabilities. Valid values:
        # 
        # *   Restart required
        # *   Remote exploitation
        # *   Exploit exists
        # *   Exploitable
        # *   Privilege escalation
        # *   Code execution
        self.search_tags = search_tags  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        # *   **sca**: vulnerability that is detected based on software component analysis
        self.type = type  # type: str
        # The UUIDs of the servers. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeGroupedVulResponseBodyGroupedVulItems(TeaModel):
    def __init__(self, alias_name=None, asap_count=None, gmt_last=None, handled_count=None, later_count=None,
                 name=None, nntf_count=None, tags=None, total_fix_count=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The number of vulnerabilities that have the **high** priority.
        self.asap_count = asap_count  # type: int
        # The timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.gmt_last = gmt_last  # type: long
        # The number of handled vulnerabilities.
        self.handled_count = handled_count  # type: int
        # The number of vulnerabilities that have the **medium** priority.
        self.later_count = later_count  # type: int
        # The name of the vulnerability.
        self.name = name  # type: str
        # The number of vulnerabilities that have the **low** priority.
        self.nntf_count = nntf_count  # type: int
        # The tag that is added to the vulnerability. Valid values:
        # 
        # *   Restart required
        # *   Remote exploitation
        # *   Exploit exists
        # *   Exploitable
        # *   Privilege escalation
        # *   Code execution
        self.tags = tags  # type: str
        # The total number of fixed vulnerabilities.
        self.total_fix_count = total_fix_count  # type: long
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        # *   **sca**: vulnerability that is detected based on software component analysis
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedVulResponseBodyGroupedVulItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.handled_count is not None:
            result['HandledCount'] = self.handled_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.total_fix_count is not None:
            result['TotalFixCount'] = self.total_fix_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('HandledCount') is not None:
            self.handled_count = m.get('HandledCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TotalFixCount') is not None:
            self.total_fix_count = m.get('TotalFixCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeGroupedVulResponseBody(TeaModel):
    def __init__(self, current_page=None, grouped_vul_items=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of the vulnerabilities.
        self.grouped_vul_items = grouped_vul_items  # type: list[DescribeGroupedVulResponseBodyGroupedVulItems]
        # The number of entries returned per page. Default value: 10.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupedVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeGroupedVulResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHcExportInfoRequest(TeaModel):
    def __init__(self, export_id=None):
        self.export_id = export_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHcExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeHcExportInfoResponseBody(TeaModel):
    def __init__(self, current_count=None, file_name=None, gmt_create=None, id=None, link=None, progress=None,
                 request_id=None, result_status=None, total_count=None):
        self.current_count = current_count  # type: int
        self.file_name = file_name  # type: str
        self.gmt_create = gmt_create  # type: long
        self.id = id  # type: long
        self.link = link  # type: str
        self.progress = progress  # type: int
        self.request_id = request_id  # type: str
        self.result_status = result_status  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHcExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_status is not None:
            result['ResultStatus'] = self.result_status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultStatus') is not None:
            self.result_status = m.get('ResultStatus')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeHcExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHcExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHcExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHcExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHoneyPotAuthResponseBody(TeaModel):
    def __init__(self, honey_pot_auth_count=None, honey_pot_count=None, request_id=None):
        # The total quota.
        self.honey_pot_auth_count = honey_pot_auth_count  # type: long
        # The quota that is consumed.
        self.honey_pot_count = honey_pot_count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHoneyPotAuthResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honey_pot_auth_count is not None:
            result['HoneyPotAuthCount'] = self.honey_pot_auth_count
        if self.honey_pot_count is not None:
            result['HoneyPotCount'] = self.honey_pot_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneyPotAuthCount') is not None:
            self.honey_pot_auth_count = m.get('HoneyPotAuthCount')
        if m.get('HoneyPotCount') is not None:
            self.honey_pot_count = m.get('HoneyPotCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeHoneyPotAuthResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHoneyPotAuthResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHoneyPotAuthResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHoneyPotAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHoneyPotSuspStatisticsRequest(TeaModel):
    def __init__(self, from_=None, statistics_days=None, statistics_key_type=None):
        # The source of the request. Set the value to **honeypot**.
        self.from_ = from_  # type: str
        # The time range of the data to query. Unit: days.
        self.statistics_days = statistics_days  # type: int
        # The type of the asset to query. Valid values:
        # 
        # *   **vpcInstanceId**: VPC
        # *   **uuid**: server
        self.statistics_key_type = statistics_key_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHoneyPotSuspStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.statistics_days is not None:
            result['StatisticsDays'] = self.statistics_days
        if self.statistics_key_type is not None:
            result['StatisticsKeyType'] = self.statistics_key_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('StatisticsDays') is not None:
            self.statistics_days = m.get('StatisticsDays')
        if m.get('StatisticsKeyType') is not None:
            self.statistics_key_type = m.get('StatisticsKeyType')
        return self


class DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse(TeaModel):
    def __init__(self, count=None, instance_id=None, instance_name=None, type=None, vpc_id=None, vpc_name=None):
        # The total number of alerts that are generated for the asset.
        self.count = count  # type: int
        # The ID of the server.
        # 
        # >  This parameter is returned only if **StatisticsKeyType** is set to **uuid**.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        # 
        # >  This parameter is returned only if **StatisticsKeyType** is set to **uuid**.
        self.instance_name = instance_name  # type: str
        # The type of the asset. Valid values:
        # 
        # *   **vpcInstanceId**: VPC
        # *   **uuid**: server
        self.type = type  # type: str
        # The ID of the VPC.
        # 
        # >  This parameter is returned only if **StatisticsKeyType** is set to **vpcInstanceId**.
        self.vpc_id = vpc_id  # type: str
        # The name of the VPC.
        # 
        # >  This parameter is returned only if **StatisticsKeyType** is set to **vpcInstanceId**.
        self.vpc_name = vpc_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.type is not None:
            result['Type'] = self.type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class DescribeHoneyPotSuspStatisticsResponseBody(TeaModel):
    def __init__(self, request_id=None, susp_honey_pot_statistics_response=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the top 5 VPCs or assets for which alerts are most frequently generated.
        self.susp_honey_pot_statistics_response = susp_honey_pot_statistics_response  # type: list[DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse]

    def validate(self):
        if self.susp_honey_pot_statistics_response:
            for k in self.susp_honey_pot_statistics_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHoneyPotSuspStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspHoneyPotStatisticsResponse'] = []
        if self.susp_honey_pot_statistics_response is not None:
            for k in self.susp_honey_pot_statistics_response:
                result['SuspHoneyPotStatisticsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_honey_pot_statistics_response = []
        if m.get('SuspHoneyPotStatisticsResponse') is not None:
            for k in m.get('SuspHoneyPotStatisticsResponse'):
                temp_model = DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse()
                self.susp_honey_pot_statistics_response.append(temp_model.from_map(k))
        return self


class DescribeHoneyPotSuspStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHoneyPotSuspStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHoneyPotSuspStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHoneyPotSuspStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRequest(TeaModel):
    def __init__(self, image_instance_id=None, image_region_id=None, image_repo_id=None, image_tag=None):
        self.image_instance_id = image_instance_id  # type: str
        self.image_region_id = image_region_id  # type: str
        self.image_repo_id = image_repo_id  # type: str
        self.image_tag = image_tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_instance_id is not None:
            result['ImageInstanceId'] = self.image_instance_id
        if self.image_region_id is not None:
            result['ImageRegionId'] = self.image_region_id
        if self.image_repo_id is not None:
            result['ImageRepoId'] = self.image_repo_id
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageInstanceId') is not None:
            self.image_instance_id = m.get('ImageInstanceId')
        if m.get('ImageRegionId') is not None:
            self.image_region_id = m.get('ImageRegionId')
        if m.get('ImageRepoId') is not None:
            self.image_repo_id = m.get('ImageRepoId')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        return self


class DescribeImageResponseBodyData(TeaModel):
    def __init__(self, digest=None):
        self.digest = digest  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        return self


class DescribeImageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: DescribeImageResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeImageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineCheckResultRequest(TeaModel):
    def __init__(self, criteria=None, criteria_type=None, current_page=None, image_uuid=None, lang=None,
                 page_size=None, risk_level=None, scan_range=None):
        self.criteria = criteria  # type: str
        self.criteria_type = criteria_type  # type: str
        self.current_page = current_page  # type: int
        self.image_uuid = image_uuid  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.risk_level = risk_level  # type: str
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageBaselineCheckResultResponseBodyBaselineResult(TeaModel):
    def __init__(self, baseline_class_alias=None, baseline_item_count=None, baseline_name_alias=None,
                 baseline_name_key=None, baseline_name_level=None, first_scan_time=None, high_risk_item_count=None,
                 last_scan_time=None, low_risk_item_count=None, middle_risk_item_count=None, status=None):
        self.baseline_class_alias = baseline_class_alias  # type: str
        self.baseline_item_count = baseline_item_count  # type: int
        self.baseline_name_alias = baseline_name_alias  # type: str
        self.baseline_name_key = baseline_name_key  # type: str
        self.baseline_name_level = baseline_name_level  # type: str
        self.first_scan_time = first_scan_time  # type: long
        self.high_risk_item_count = high_risk_item_count  # type: int
        self.last_scan_time = last_scan_time  # type: long
        self.low_risk_item_count = low_risk_item_count  # type: int
        self.middle_risk_item_count = middle_risk_item_count  # type: int
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckResultResponseBodyBaselineResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_item_count is not None:
            result['BaselineItemCount'] = self.baseline_item_count
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.baseline_name_level is not None:
            result['BaselineNameLevel'] = self.baseline_name_level
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.high_risk_item_count is not None:
            result['HighRiskItemCount'] = self.high_risk_item_count
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_item_count is not None:
            result['LowRiskItemCount'] = self.low_risk_item_count
        if self.middle_risk_item_count is not None:
            result['MiddleRiskItemCount'] = self.middle_risk_item_count
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineItemCount') is not None:
            self.baseline_item_count = m.get('BaselineItemCount')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('BaselineNameLevel') is not None:
            self.baseline_name_level = m.get('BaselineNameLevel')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('HighRiskItemCount') is not None:
            self.high_risk_item_count = m.get('HighRiskItemCount')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskItemCount') is not None:
            self.low_risk_item_count = m.get('LowRiskItemCount')
        if m.get('MiddleRiskItemCount') is not None:
            self.middle_risk_item_count = m.get('MiddleRiskItemCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageBaselineCheckResultResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckResultResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineCheckResultResponseBody(TeaModel):
    def __init__(self, baseline_result=None, page_info=None, request_id=None):
        self.baseline_result = baseline_result  # type: list[DescribeImageBaselineCheckResultResponseBodyBaselineResult]
        self.page_info = page_info  # type: DescribeImageBaselineCheckResultResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.baseline_result:
            for k in self.baseline_result:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineCheckResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineResult'] = []
        if self.baseline_result is not None:
            for k in self.baseline_result:
                result['BaselineResult'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.baseline_result = []
        if m.get('BaselineResult') is not None:
            for k in m.get('BaselineResult'):
                temp_model = DescribeImageBaselineCheckResultResponseBodyBaselineResult()
                self.baseline_result.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineCheckResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineCheckResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageBaselineCheckResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineCheckResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineCheckSummaryRequest(TeaModel):
    def __init__(self, cluster_id=None, criteria=None, criteria_type=None, current_page=None, lang=None,
                 page_size=None, risk_level=None, scan_range=None):
        self.cluster_id = cluster_id  # type: str
        self.criteria = criteria  # type: str
        self.criteria_type = criteria_type  # type: str
        self.current_page = current_page  # type: int
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.risk_level = risk_level  # type: str
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary(TeaModel):
    def __init__(self, baseline_class_alias=None, baseline_class_key=None, baseline_name_alias=None,
                 baseline_name_key=None, baseline_name_level=None, first_scan_time=None, high_risk_image=None, last_scan_time=None,
                 low_risk_image=None, middle_risk_image=None, status=None):
        self.baseline_class_alias = baseline_class_alias  # type: str
        self.baseline_class_key = baseline_class_key  # type: str
        self.baseline_name_alias = baseline_name_alias  # type: str
        self.baseline_name_key = baseline_name_key  # type: str
        self.baseline_name_level = baseline_name_level  # type: str
        self.first_scan_time = first_scan_time  # type: long
        self.high_risk_image = high_risk_image  # type: int
        self.last_scan_time = last_scan_time  # type: long
        self.low_risk_image = low_risk_image  # type: int
        self.middle_risk_image = middle_risk_image  # type: int
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.baseline_name_level is not None:
            result['BaselineNameLevel'] = self.baseline_name_level
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.high_risk_image is not None:
            result['HighRiskImage'] = self.high_risk_image
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_image is not None:
            result['LowRiskImage'] = self.low_risk_image
        if self.middle_risk_image is not None:
            result['MiddleRiskImage'] = self.middle_risk_image
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('BaselineNameLevel') is not None:
            self.baseline_name_level = m.get('BaselineNameLevel')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('HighRiskImage') is not None:
            self.high_risk_image = m.get('HighRiskImage')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskImage') is not None:
            self.low_risk_image = m.get('LowRiskImage')
        if m.get('MiddleRiskImage') is not None:
            self.middle_risk_image = m.get('MiddleRiskImage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageBaselineCheckSummaryResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineCheckSummaryResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineCheckSummaryResponseBody(TeaModel):
    def __init__(self, baseline_result_summary=None, page_info=None, request_id=None):
        self.baseline_result_summary = baseline_result_summary  # type: list[DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary]
        self.page_info = page_info  # type: DescribeImageBaselineCheckSummaryResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.baseline_result_summary:
            for k in self.baseline_result_summary:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineCheckSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineResultSummary'] = []
        if self.baseline_result_summary is not None:
            for k in self.baseline_result_summary:
                result['BaselineResultSummary'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.baseline_result_summary = []
        if m.get('BaselineResultSummary') is not None:
            for k in m.get('BaselineResultSummary'):
                temp_model = DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary()
                self.baseline_result_summary.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineCheckSummaryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineCheckSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageBaselineCheckSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineCheckSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineDetailRequest(TeaModel):
    def __init__(self, baseline_item_key=None, image_uuid=None, lang=None):
        self.baseline_item_key = baseline_item_key  # type: str
        self.image_uuid = image_uuid  # type: str
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeImageBaselineDetailResponseBodyBaselineDetail(TeaModel):
    def __init__(self, advice=None, baseline_class_alias=None, baseline_item_alias=None, baseline_item_key=None,
                 baseline_name_alias=None, description=None, level=None, prompt=None, result_id=None):
        self.advice = advice  # type: str
        self.baseline_class_alias = baseline_class_alias  # type: str
        self.baseline_item_alias = baseline_item_alias  # type: str
        self.baseline_item_key = baseline_item_key  # type: str
        self.baseline_name_alias = baseline_name_alias  # type: str
        self.description = description  # type: str
        self.level = level  # type: str
        self.prompt = prompt  # type: str
        self.result_id = result_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineDetailResponseBodyBaselineDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_item_alias is not None:
            result['BaselineItemAlias'] = self.baseline_item_alias
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.description is not None:
            result['Description'] = self.description
        if self.level is not None:
            result['Level'] = self.level
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.result_id is not None:
            result['ResultId'] = self.result_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineItemAlias') is not None:
            self.baseline_item_alias = m.get('BaselineItemAlias')
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ResultId') is not None:
            self.result_id = m.get('ResultId')
        return self


class DescribeImageBaselineDetailResponseBody(TeaModel):
    def __init__(self, baseline_detail=None, request_id=None):
        self.baseline_detail = baseline_detail  # type: DescribeImageBaselineDetailResponseBodyBaselineDetail
        self.request_id = request_id  # type: str

    def validate(self):
        if self.baseline_detail:
            self.baseline_detail.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_detail is not None:
            result['BaselineDetail'] = self.baseline_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineDetail') is not None:
            temp_model = DescribeImageBaselineDetailResponseBodyBaselineDetail()
            self.baseline_detail = temp_model.from_map(m['BaselineDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageBaselineDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineItemListRequest(TeaModel):
    def __init__(self, baseline_class_key=None, baseline_name_key=None, current_page=None, image_uuid=None,
                 lang=None, page_size=None, scan_range=None, status=None, uuids=None):
        self.baseline_class_key = baseline_class_key  # type: str
        self.baseline_name_key = baseline_name_key  # type: str
        self.current_page = current_page  # type: int
        self.image_uuid = image_uuid  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.scan_range = scan_range  # type: list[str]
        self.status = status  # type: str
        self.uuids = uuids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineItemListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.status is not None:
            result['Status'] = self.status
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageBaselineItemListResponseBodyBaselineItemInfos(TeaModel):
    def __init__(self, baseline_class_alias=None, baseline_class_key=None, baseline_item_alias=None,
                 baseline_item_key=None, baseline_name_alias=None, baseline_name_key=None, status=None, white_list=None):
        self.baseline_class_alias = baseline_class_alias  # type: str
        self.baseline_class_key = baseline_class_key  # type: str
        self.baseline_item_alias = baseline_item_alias  # type: str
        self.baseline_item_key = baseline_item_key  # type: str
        self.baseline_name_alias = baseline_name_alias  # type: str
        self.baseline_name_key = baseline_name_key  # type: str
        self.status = status  # type: int
        self.white_list = white_list  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineItemListResponseBodyBaselineItemInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_class_alias is not None:
            result['BaselineClassAlias'] = self.baseline_class_alias
        if self.baseline_class_key is not None:
            result['BaselineClassKey'] = self.baseline_class_key
        if self.baseline_item_alias is not None:
            result['BaselineItemAlias'] = self.baseline_item_alias
        if self.baseline_item_key is not None:
            result['BaselineItemKey'] = self.baseline_item_key
        if self.baseline_name_alias is not None:
            result['BaselineNameAlias'] = self.baseline_name_alias
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.status is not None:
            result['Status'] = self.status
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineClassAlias') is not None:
            self.baseline_class_alias = m.get('BaselineClassAlias')
        if m.get('BaselineClassKey') is not None:
            self.baseline_class_key = m.get('BaselineClassKey')
        if m.get('BaselineItemAlias') is not None:
            self.baseline_item_alias = m.get('BaselineItemAlias')
        if m.get('BaselineItemKey') is not None:
            self.baseline_item_key = m.get('BaselineItemKey')
        if m.get('BaselineNameAlias') is not None:
            self.baseline_name_alias = m.get('BaselineNameAlias')
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class DescribeImageBaselineItemListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineItemListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageBaselineItemListResponseBody(TeaModel):
    def __init__(self, baseline_item_infos=None, page_info=None, request_id=None):
        self.baseline_item_infos = baseline_item_infos  # type: list[DescribeImageBaselineItemListResponseBodyBaselineItemInfos]
        self.page_info = page_info  # type: DescribeImageBaselineItemListResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.baseline_item_infos:
            for k in self.baseline_item_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineItemListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineItemInfos'] = []
        if self.baseline_item_infos is not None:
            for k in self.baseline_item_infos:
                result['BaselineItemInfos'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.baseline_item_infos = []
        if m.get('BaselineItemInfos') is not None:
            for k in m.get('BaselineItemInfos'):
                temp_model = DescribeImageBaselineItemListResponseBodyBaselineItemInfos()
                self.baseline_item_infos.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageBaselineItemListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageBaselineItemListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageBaselineItemListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineItemListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineItemListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageBaselineStrategyRequest(TeaModel):
    def __init__(self, lang=None, strategy_id=None):
        self.lang = lang  # type: str
        self.strategy_id = strategy_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList(TeaModel):
    def __init__(self, class_key=None, item_key=None, name_key=None):
        self.class_key = class_key  # type: str
        self.item_key = item_key  # type: str
        self.name_key = name_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_key is not None:
            result['ClassKey'] = self.class_key
        if self.item_key is not None:
            result['ItemKey'] = self.item_key
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClassKey') is not None:
            self.class_key = m.get('ClassKey')
        if m.get('ItemKey') is not None:
            self.item_key = m.get('ItemKey')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeImageBaselineStrategyResponseBodyStrategy(TeaModel):
    def __init__(self, baseline_item_list=None, selected_item_count=None, strategy_id=None, strategy_name=None,
                 total_item_count=None, type=None):
        self.baseline_item_list = baseline_item_list  # type: list[DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList]
        self.selected_item_count = selected_item_count  # type: int
        self.strategy_id = strategy_id  # type: long
        self.strategy_name = strategy_name  # type: str
        self.total_item_count = total_item_count  # type: int
        self.type = type  # type: str

    def validate(self):
        if self.baseline_item_list:
            for k in self.baseline_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineStrategyResponseBodyStrategy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaselineItemList'] = []
        if self.baseline_item_list is not None:
            for k in self.baseline_item_list:
                result['BaselineItemList'].append(k.to_map() if k else None)
        if self.selected_item_count is not None:
            result['SelectedItemCount'] = self.selected_item_count
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        if self.total_item_count is not None:
            result['TotalItemCount'] = self.total_item_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.baseline_item_list = []
        if m.get('BaselineItemList') is not None:
            for k in m.get('BaselineItemList'):
                temp_model = DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList()
                self.baseline_item_list.append(temp_model.from_map(k))
        if m.get('SelectedItemCount') is not None:
            self.selected_item_count = m.get('SelectedItemCount')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        if m.get('TotalItemCount') is not None:
            self.total_item_count = m.get('TotalItemCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageBaselineStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None, strategy=None):
        self.request_id = request_id  # type: str
        self.strategy = strategy  # type: DescribeImageBaselineStrategyResponseBodyStrategy

    def validate(self):
        if self.strategy:
            self.strategy.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategy') is not None:
            temp_model = DescribeImageBaselineStrategyResponseBodyStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        return self


class DescribeImageBaselineStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageBaselineStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageBaselineStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageBaselineStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageCriteriaRequest(TeaModel):
    def __init__(self, value=None):
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageCriteriaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, name=None, type=None, values=None):
        self.name = name  # type: str
        self.type = type  # type: str
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeImageCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        self.criteria_list = criteria_list  # type: list[DescribeImageCriteriaResponseBodyCriteriaList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeImageCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageFixTaskRequest(TeaModel):
    def __init__(self, current_page=None, end_time=None, page_size=None, start_time=None, status=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The timestamp when the task ends. Unit: milliseconds.
        self.end_time = end_time  # type: long
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The timestamp when the task starts. Unit: milliseconds.
        self.start_time = start_time  # type: long
        # The status of the task. Valid values:
        # 
        # *   **1**: The task is running.
        # *   **2**: The task is successful.
        # *   **3**: The task failed.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFixTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageFixTaskResponseBodyBuildTasks(TeaModel):
    def __init__(self, build_task_id=None, finish_time=None, fix_time=None, new_tag=None, new_uuid=None,
                 old_tag=None, old_uuid=None, region_id=None, repo_name=None, repo_namespace=None, status=None,
                 task_type=None):
        # The ID of the task.
        self.build_task_id = build_task_id  # type: str
        # The timestamp when the task starts. Unit: milliseconds.
        self.finish_time = finish_time  # type: str
        # The timestamp when the task ends. Unit: milliseconds.
        self.fix_time = fix_time  # type: str
        # The version of the image after image risks are fixed.
        self.new_tag = new_tag  # type: str
        # The UUID of the image after image risks are fixed.
        self.new_uuid = new_uuid  # type: str
        # The version of the image.
        self.old_tag = old_tag  # type: str
        # The UUID of the image.
        self.old_uuid = old_uuid  # type: str
        # The region of the image.
        self.region_id = region_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace of the image.
        self.repo_namespace = repo_namespace  # type: str
        # The status of the task. Valid values:
        # 
        # *   **1**: The task is running.
        # *   **2**: The task is successful.
        # *   **3**: The task failed.
        self.status = status  # type: int
        # The type of the task. The value is fixed as IMAGE_REPAIR, which indicates a task that fixes image risks.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFixTaskResponseBodyBuildTasks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_task_id is not None:
            result['BuildTaskId'] = self.build_task_id
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fix_time is not None:
            result['FixTime'] = self.fix_time
        if self.new_tag is not None:
            result['NewTag'] = self.new_tag
        if self.new_uuid is not None:
            result['NewUuid'] = self.new_uuid
        if self.old_tag is not None:
            result['OldTag'] = self.old_tag
        if self.old_uuid is not None:
            result['OldUuid'] = self.old_uuid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.status is not None:
            result['Status'] = self.status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuildTaskId') is not None:
            self.build_task_id = m.get('BuildTaskId')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FixTime') is not None:
            self.fix_time = m.get('FixTime')
        if m.get('NewTag') is not None:
            self.new_tag = m.get('NewTag')
        if m.get('NewUuid') is not None:
            self.new_uuid = m.get('NewUuid')
        if m.get('OldTag') is not None:
            self.old_tag = m.get('OldTag')
        if m.get('OldUuid') is not None:
            self.old_uuid = m.get('OldUuid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeImageFixTaskResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of tasks returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of tasks returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFixTaskResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageFixTaskResponseBody(TeaModel):
    def __init__(self, build_tasks=None, page_info=None, request_id=None):
        # An array that consists of the tasks returned.
        self.build_tasks = build_tasks  # type: list[DescribeImageFixTaskResponseBodyBuildTasks]
        # The pagination information.
        self.page_info = page_info  # type: DescribeImageFixTaskResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.build_tasks:
            for k in self.build_tasks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageFixTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BuildTasks'] = []
        if self.build_tasks is not None:
            for k in self.build_tasks:
                result['BuildTasks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.build_tasks = []
        if m.get('BuildTasks') is not None:
            for k in m.get('BuildTasks'):
                temp_model = DescribeImageFixTaskResponseBodyBuildTasks()
                self.build_tasks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageFixTaskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageFixTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageFixTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageFixTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageFixTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageGroupedVulListRequest(TeaModel):
    def __init__(self, alias_name=None, cluster_id=None, current_page=None, cve_id=None, group_id=None,
                 image_digest=None, image_layer=None, image_tag=None, is_latest=None, lang=None, name=None, necessity=None,
                 page_size=None, patch_id=None, repo_id=None, repo_instance_id=None, repo_name=None, repo_namespace=None,
                 repo_region_id=None, scan_range=None, type=None, uuids=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.
        self.cve_id = cve_id  # type: str
        # The ID of the asset group.
        self.group_id = group_id  # type: str
        # The SHA-256 value of the image digest.
        self.image_digest = image_digest  # type: str
        # The layer of the image.
        self.image_layer = image_layer  # type: str
        # The tag that is added to the image.
        self.image_tag = image_tag  # type: str
        # Specifies whether to query the vulnerabilities in the latest images. If you do not specify this parameter, the vulnerabilities in all images are queried. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_latest = is_latest  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the patch that is used to fix the vulnerability.
        self.patch_id = patch_id  # type: long
        # The ID of the image repository.
        self.repo_id = repo_id  # type: str
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace  # type: str
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id  # type: str
        # The types of the assets that you want to scan.
        self.scan_range = scan_range  # type: list[str]
        # The type of the vulnerability that you want to query. Valid values:
        # 
        # *   **cve**: image system vulnerability
        # *   **sca**: image application vulnerability
        self.type = type  # type: str
        # The UUIDs of the assets. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageGroupedVulListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.image_layer is not None:
            result['ImageLayer'] = self.image_layer
        if self.image_tag is not None:
            result['ImageTag'] = self.image_tag
        if self.is_latest is not None:
            result['IsLatest'] = self.is_latest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.patch_id is not None:
            result['PatchId'] = self.patch_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('ImageLayer') is not None:
            self.image_layer = m.get('ImageLayer')
        if m.get('ImageTag') is not None:
            self.image_tag = m.get('ImageTag')
        if m.get('IsLatest') is not None:
            self.is_latest = m.get('IsLatest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PatchId') is not None:
            self.patch_id = m.get('PatchId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageGroupedVulListResponseBodyGroupedVulItems(TeaModel):
    def __init__(self, alias_name=None, asap_count=None, gmt_last=None, last_scan_time=None, later_count=None,
                 name=None, nntf_count=None, status=None, tags=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The number of vulnerabilities that have the high priority.
        self.asap_count = asap_count  # type: int
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.gmt_last = gmt_last  # type: long
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_scan_time = last_scan_time  # type: long
        # The number of vulnerabilities that have the medium priority.
        self.later_count = later_count  # type: int
        # The name of the vulnerability.
        self.name = name  # type: str
        # The number of vulnerabilities that have the low priority.
        self.nntf_count = nntf_count  # type: int
        # The status of the vulnerability. Valid values:
        # 
        # *   **0**: unhandled
        # *   **1**: handled
        # *   **2**: verifying
        # *   **3**: added to the whitelist
        self.status = status  # type: int
        # The tag that is added to the vulnerability. Valid values:
        # 
        # *   Restart required
        # *   Remote exploitation
        # *   Exploit exists
        # *   Exploitable
        # *   Privilege escalation
        # *   Code execution
        self.tags = tags  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: image system vulnerability
        # *   **sca**: image application vulnerability
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageGroupedVulListResponseBodyGroupedVulItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageGroupedVulListResponseBody(TeaModel):
    def __init__(self, current_page=None, grouped_vul_items=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of the image vulnerabilities.
        self.grouped_vul_items = grouped_vul_items  # type: list[DescribeImageGroupedVulListResponseBodyGroupedVulItems]
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of image system vulnerabilities.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageGroupedVulListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeImageGroupedVulListResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageGroupedVulListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageGroupedVulListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageGroupedVulListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageGroupedVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageInfoListRequest(TeaModel):
    def __init__(self, uuids=None):
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageInfoListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageInfoListResponseBodyImageInfos(TeaModel):
    def __init__(self, alarm_count=None, alarm_status=None, digest=None, endpoints=None, image_create=None,
                 image_id=None, image_size=None, image_update=None, instance_id=None, region_id=None, registry_type=None,
                 repo_id=None, repo_name=None, repo_namespace=None, repo_type=None, risk_status=None, status=None, tag=None,
                 tag_immutable=None, uuid=None, vul_count=None, vul_status=None):
        self.alarm_count = alarm_count  # type: int
        self.alarm_status = alarm_status  # type: str
        self.digest = digest  # type: str
        self.endpoints = endpoints  # type: str
        self.image_create = image_create  # type: long
        self.image_id = image_id  # type: str
        self.image_size = image_size  # type: long
        self.image_update = image_update  # type: long
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str
        self.registry_type = registry_type  # type: str
        self.repo_id = repo_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.repo_type = repo_type  # type: str
        self.risk_status = risk_status  # type: str
        self.status = status  # type: str
        self.tag = tag  # type: str
        self.tag_immutable = tag_immutable  # type: int
        self.uuid = uuid  # type: str
        self.vul_count = vul_count  # type: int
        self.vul_status = vul_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageInfoListResponseBodyImageInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_immutable is not None:
            result['TagImmutable'] = self.tag_immutable
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagImmutable') is not None:
            self.tag_immutable = m.get('TagImmutable')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageInfoListResponseBody(TeaModel):
    def __init__(self, image_infos=None, request_id=None):
        self.image_infos = image_infos  # type: list[DescribeImageInfoListResponseBodyImageInfos]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageInfoListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageInfoListResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageInfoListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageInfoListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageInfoListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageInfoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageInstancesRequest(TeaModel):
    def __init__(self, criteria=None, current_page=None, logical_exp=None, page_size=None, scanned=None):
        self.criteria = criteria  # type: str
        self.current_page = current_page  # type: int
        self.logical_exp = logical_exp  # type: str
        self.page_size = page_size  # type: int
        self.scanned = scanned  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scanned is not None:
            result['Scanned'] = self.scanned
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Scanned') is not None:
            self.scanned = m.get('Scanned')
        return self


class DescribeImageInstancesResponseBodyImageInstanceList(TeaModel):
    def __init__(self, alarm_count=None, alarm_status=None, deployed=None, digest=None, endpoints=None,
                 hc_count=None, hc_status=None, image_create=None, image_id=None, image_size=None, image_update=None,
                 instance_id=None, region_id=None, registry_type=None, repo_id=None, repo_name=None, repo_namespace=None,
                 repo_type=None, risk_status=None, sca_progress=None, sca_result=None, sca_status=None, status=None, tag=None,
                 uuid=None, vul_count=None, vul_status=None):
        self.alarm_count = alarm_count  # type: int
        self.alarm_status = alarm_status  # type: str
        self.deployed = deployed  # type: int
        self.digest = digest  # type: str
        self.endpoints = endpoints  # type: str
        self.hc_count = hc_count  # type: int
        self.hc_status = hc_status  # type: str
        self.image_create = image_create  # type: str
        self.image_id = image_id  # type: str
        self.image_size = image_size  # type: str
        self.image_update = image_update  # type: str
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str
        self.registry_type = registry_type  # type: str
        self.repo_id = repo_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.repo_type = repo_type  # type: str
        self.risk_status = risk_status  # type: str
        self.sca_progress = sca_progress  # type: int
        self.sca_result = sca_result  # type: str
        self.sca_status = sca_status  # type: str
        self.status = status  # type: str
        self.tag = tag  # type: str
        self.uuid = uuid  # type: str
        self.vul_count = vul_count  # type: int
        self.vul_status = vul_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageInstancesResponseBodyImageInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.deployed is not None:
            result['Deployed'] = self.deployed
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.sca_progress is not None:
            result['ScaProgress'] = self.sca_progress
        if self.sca_result is not None:
            result['ScaResult'] = self.sca_result
        if self.sca_status is not None:
            result['ScaStatus'] = self.sca_status
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Deployed') is not None:
            self.deployed = m.get('Deployed')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('ScaProgress') is not None:
            self.sca_progress = m.get('ScaProgress')
        if m.get('ScaResult') is not None:
            self.sca_result = m.get('ScaResult')
        if m.get('ScaStatus') is not None:
            self.sca_status = m.get('ScaStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageInstancesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageInstancesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageInstancesResponseBody(TeaModel):
    def __init__(self, image_instance_list=None, page_info=None, request_id=None):
        self.image_instance_list = image_instance_list  # type: list[DescribeImageInstancesResponseBodyImageInstanceList]
        self.page_info = page_info  # type: DescribeImageInstancesResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_instance_list:
            for k in self.image_instance_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInstanceList'] = []
        if self.image_instance_list is not None:
            for k in self.image_instance_list:
                result['ImageInstanceList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_instance_list = []
        if m.get('ImageInstanceList') is not None:
            for k in m.get('ImageInstanceList'):
                temp_model = DescribeImageInstancesResponseBodyImageInstanceList()
                self.image_instance_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageInstancesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageLatestScanTaskRequest(TeaModel):
    def __init__(self, digest=None):
        self.digest = digest  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageLatestScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        return self


class DescribeImageLatestScanTaskResponseBodyTask(TeaModel):
    def __init__(self, create=None, finish=None, finish_time=None, id=None, modified=None, name=None, source=None,
                 start_time=None, status=None, target=None, target_type=None, task_id=None, task_type=None):
        self.create = create  # type: str
        self.finish = finish  # type: int
        self.finish_time = finish_time  # type: long
        self.id = id  # type: long
        self.modified = modified  # type: str
        self.name = name  # type: str
        self.source = source  # type: str
        self.start_time = start_time  # type: long
        self.status = status  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str
        self.task_id = task_id  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageLatestScanTaskResponseBodyTask, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create is not None:
            result['Create'] = self.create
        if self.finish is not None:
            result['Finish'] = self.finish
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modified is not None:
            result['Modified'] = self.modified
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Create') is not None:
            self.create = m.get('Create')
        if m.get('Finish') is not None:
            self.finish = m.get('Finish')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Modified') is not None:
            self.modified = m.get('Modified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeImageLatestScanTaskResponseBody(TeaModel):
    def __init__(self, request_id=None, task=None):
        self.request_id = request_id  # type: str
        self.task = task  # type: list[DescribeImageLatestScanTaskResponseBodyTask]

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageLatestScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = DescribeImageLatestScanTaskResponseBodyTask()
                self.task.append(temp_model.from_map(k))
        return self


class DescribeImageLatestScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageLatestScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageLatestScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageLatestScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageListBySensitiveFileRequest(TeaModel):
    def __init__(self, current_page=None, image_digest=None, lang=None, page_size=None, repo_instance_id=None,
                 repo_name=None, repo_namespace=None, risk_level=None, scan_range=None, sensitive_file_key=None):
        self.current_page = current_page  # type: int
        self.image_digest = image_digest  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.repo_instance_id = repo_instance_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.risk_level = risk_level  # type: str
        self.scan_range = scan_range  # type: list[str]
        self.sensitive_file_key = sensitive_file_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageListBySensitiveFileShrinkRequest(TeaModel):
    def __init__(self, current_page=None, image_digest=None, lang=None, page_size=None, repo_instance_id=None,
                 repo_name=None, repo_namespace=None, risk_level=None, scan_range_shrink=None, sensitive_file_key=None):
        self.current_page = current_page  # type: int
        self.image_digest = image_digest  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.repo_instance_id = repo_instance_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.risk_level = risk_level  # type: str
        self.scan_range_shrink = scan_range_shrink  # type: str
        self.sensitive_file_key = sensitive_file_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageListBySensitiveFileResponseBodyImageInfos(TeaModel):
    def __init__(self, digest=None, first_scan_time=None, instance_id=None, last_scan_time=None, region_id=None,
                 repo_name=None, repo_namespace=None, risk_level=None, tag=None, uuid=None):
        self.digest = digest  # type: str
        self.first_scan_time = first_scan_time  # type: long
        self.instance_id = instance_id  # type: str
        self.last_scan_time = last_scan_time  # type: long
        self.region_id = region_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.risk_level = risk_level  # type: str
        self.tag = tag  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileResponseBodyImageInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageListBySensitiveFileResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, last_row_key=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.last_row_key = last_row_key  # type: str
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageListBySensitiveFileResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, image_infos=None, message=None, page_info=None,
                 request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.image_infos = image_infos  # type: list[DescribeImageListBySensitiveFileResponseBodyImageInfos]
        self.message = message  # type: str
        self.page_info = page_info  # type: DescribeImageListBySensitiveFileResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageListBySensitiveFileResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageListBySensitiveFileResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageListBySensitiveFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageListBySensitiveFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageListBySensitiveFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageListBySensitiveFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageListWithBaselineNameRequest(TeaModel):
    def __init__(self, baseline_name_key=None, cluster_id=None, cluster_name=None, container_id=None, criteria=None,
                 criteria_type=None, current_page=None, image=None, image_digest=None, lang=None, namespace=None, page_size=None,
                 pod=None, repo_instance_id=None, repo_name=None, repo_namespace=None, scan_range=None):
        # The name of the image baseline.
        self.baseline_name_key = baseline_name_key  # type: str
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The search condition for the image baseline.
        self.criteria = criteria  # type: str
        # The type of the search condition. Valid values:
        # 
        # *   **BaselineNameAlias**: baseline name
        # *   **BaselineClassAlias**: baseline category
        self.criteria_type = criteria_type  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The name of the image to which the container belongs.
        self.image = image  # type: str
        # The SHA-256 value of the image digest.
        self.image_digest = image_digest  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The namespace.
        self.namespace = namespace  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The pod.
        self.pod = pod  # type: str
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace  # type: str
        # The types of the assets that you want to scan.
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListWithBaselineNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_name_key is not None:
            result['BaselineNameKey'] = self.baseline_name_key
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineNameKey') is not None:
            self.baseline_name_key = m.get('BaselineNameKey')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageListWithBaselineNameResponseBodyImageInfos(TeaModel):
    def __init__(self, cluster_id=None, cluster_name=None, container_id=None, digest=None, high_risk_image=None,
                 image=None, image_create=None, image_id=None, image_size=None, image_update=None, instance_id=None,
                 instance_name=None, internet_ip=None, intranet_ip=None, last_scan_time=None, low_risk_image=None,
                 middle_risk_image=None, namespace=None, no_risk_image=None, pod=None, region_id=None, repo_id=None, repo_name=None,
                 repo_namespace=None, repo_type=None, risk_status=None, tag=None, target_id=None, target_name=None,
                 target_type=None, total_item_count=None, uuid=None):
        # The ID of the cluster.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The SHA-256 value of the image digest.
        self.digest = digest  # type: str
        # The number of images on which **high** baseline risks are detected.
        self.high_risk_image = high_risk_image  # type: int
        # The name of the image.
        self.image = image  # type: str
        # The timestamp when the image was created. Unit: milliseconds.
        self.image_create = image_create  # type: long
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The size of the image.
        self.image_size = image_size  # type: int
        # The timestamp when the image was updated. Unit: milliseconds.
        self.image_update = image_update  # type: long
        # The ID of the image instance.
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.last_scan_time = last_scan_time  # type: long
        # The number of images on which **low** baseline risks are detected.
        self.low_risk_image = low_risk_image  # type: int
        # The number of images on which **medium** baseline risks are detected.
        self.middle_risk_image = middle_risk_image  # type: int
        # The namespace.
        self.namespace = namespace  # type: str
        # The number of images that do not have baseline risks.
        self.no_risk_image = no_risk_image  # type: int
        # The pod.
        self.pod = pod  # type: str
        # The region ID of the image instance.
        self.region_id = region_id  # type: str
        # The ID of the image repository.
        self.repo_id = repo_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace  # type: str
        # The type of the image repository.
        self.repo_type = repo_type  # type: str
        # Indicates whether the image is at risk. Valid values:
        # 
        # *   **YES**\
        # *   **NO**\
        self.risk_status = risk_status  # type: str
        # The version of the image.
        self.tag = tag  # type: str
        self.target_id = target_id  # type: str
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str
        # The total number of risk items that are detected on the image by using the baseline.
        self.total_item_count = total_item_count  # type: int
        # The UUID of the image.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListWithBaselineNameResponseBodyImageInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.high_risk_image is not None:
            result['HighRiskImage'] = self.high_risk_image
        if self.image is not None:
            result['Image'] = self.image
        if self.image_create is not None:
            result['ImageCreate'] = self.image_create
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_update is not None:
            result['ImageUpdate'] = self.image_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.low_risk_image is not None:
            result['LowRiskImage'] = self.low_risk_image
        if self.middle_risk_image is not None:
            result['MiddleRiskImage'] = self.middle_risk_image
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_risk_image is not None:
            result['NoRiskImage'] = self.no_risk_image
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.total_item_count is not None:
            result['TotalItemCount'] = self.total_item_count
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('HighRiskImage') is not None:
            self.high_risk_image = m.get('HighRiskImage')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageCreate') is not None:
            self.image_create = m.get('ImageCreate')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageUpdate') is not None:
            self.image_update = m.get('ImageUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LowRiskImage') is not None:
            self.low_risk_image = m.get('LowRiskImage')
        if m.get('MiddleRiskImage') is not None:
            self.middle_risk_image = m.get('MiddleRiskImage')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoRiskImage') is not None:
            self.no_risk_image = m.get('NoRiskImage')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TotalItemCount') is not None:
            self.total_item_count = m.get('TotalItemCount')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageListWithBaselineNameResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of the images returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of images on which baseline risks are detected.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageListWithBaselineNameResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageListWithBaselineNameResponseBody(TeaModel):
    def __init__(self, image_infos=None, page_info=None, request_id=None):
        # An array that consists of the images returned.
        self.image_infos = image_infos  # type: list[DescribeImageListWithBaselineNameResponseBodyImageInfos]
        # The pagination information.
        self.page_info = page_info  # type: DescribeImageListWithBaselineNameResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_infos:
            for k in self.image_infos:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageListWithBaselineNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageInfos'] = []
        if self.image_infos is not None:
            for k in self.image_infos:
                result['ImageInfos'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_infos = []
        if m.get('ImageInfos') is not None:
            for k in m.get('ImageInfos'):
                temp_model = DescribeImageListWithBaselineNameResponseBodyImageInfos()
                self.image_infos.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageListWithBaselineNameResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageListWithBaselineNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageListWithBaselineNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageListWithBaselineNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageListWithBaselineNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoCriteriaRequest(TeaModel):
    def __init__(self, value=None):
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoCriteriaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageRepoCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, name=None, type=None, values=None):
        self.name = name  # type: str
        self.type = type  # type: str
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeImageRepoCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        self.criteria_list = criteria_list  # type: list[DescribeImageRepoCriteriaResponseBodyCriteriaList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageRepoCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeImageRepoCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageRepoCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageRepoCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoDetailListRequest(TeaModel):
    def __init__(self, criteria=None, current_page=None, logical_exp=None, page_size=None):
        self.criteria = criteria  # type: str
        self.current_page = current_page  # type: int
        self.logical_exp = logical_exp  # type: str
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoDetailListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.logical_exp is not None:
            result['LogicalExp'] = self.logical_exp
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogicalExp') is not None:
            self.logical_exp = m.get('LogicalExp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeImageRepoDetailListResponseBodyImageRepoResponses(TeaModel):
    def __init__(self, alarm_count=None, alarm_status=None, endpoints=None, hc_count=None, hc_status=None,
                 image_count=None, instance_id=None, region_id=None, registry_type=None, repo_id=None, repo_name=None,
                 repo_namespace=None, risk_status=None, vul_count=None, vul_status=None):
        self.alarm_count = alarm_count  # type: int
        self.alarm_status = alarm_status  # type: str
        self.endpoints = endpoints  # type: str
        self.hc_count = hc_count  # type: int
        self.hc_status = hc_status  # type: str
        self.image_count = image_count  # type: int
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str
        self.registry_type = registry_type  # type: str
        self.repo_id = repo_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.risk_status = risk_status  # type: str
        self.vul_count = vul_count  # type: int
        self.vul_status = vul_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoDetailListResponseBodyImageRepoResponses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_count is not None:
            result['AlarmCount'] = self.alarm_count
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.endpoints is not None:
            result['Endpoints'] = self.endpoints
        if self.hc_count is not None:
            result['HcCount'] = self.hc_count
        if self.hc_status is not None:
            result['HcStatus'] = self.hc_status
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.vul_count is not None:
            result['VulCount'] = self.vul_count
        if self.vul_status is not None:
            result['VulStatus'] = self.vul_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmCount') is not None:
            self.alarm_count = m.get('AlarmCount')
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('Endpoints') is not None:
            self.endpoints = m.get('Endpoints')
        if m.get('HcCount') is not None:
            self.hc_count = m.get('HcCount')
        if m.get('HcStatus') is not None:
            self.hc_status = m.get('HcStatus')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('VulCount') is not None:
            self.vul_count = m.get('VulCount')
        if m.get('VulStatus') is not None:
            self.vul_status = m.get('VulStatus')
        return self


class DescribeImageRepoDetailListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoDetailListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageRepoDetailListResponseBody(TeaModel):
    def __init__(self, image_repo_responses=None, page_info=None, request_id=None):
        self.image_repo_responses = image_repo_responses  # type: list[DescribeImageRepoDetailListResponseBodyImageRepoResponses]
        self.page_info = page_info  # type: DescribeImageRepoDetailListResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_repo_responses:
            for k in self.image_repo_responses:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageRepoDetailListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageRepoResponses'] = []
        if self.image_repo_responses is not None:
            for k in self.image_repo_responses:
                result['ImageRepoResponses'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_repo_responses = []
        if m.get('ImageRepoResponses') is not None:
            for k in m.get('ImageRepoResponses'):
                temp_model = DescribeImageRepoDetailListResponseBodyImageRepoResponses()
                self.image_repo_responses.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageRepoDetailListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoDetailListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageRepoDetailListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageRepoDetailListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoDetailListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageRepoListRequest(TeaModel):
    def __init__(self, current_page=None, field_name=None, field_value=None, operate_type=None, page_size=None,
                 repo_name=None, repo_namespace=None, target_type=None, type=None):
        self.current_page = current_page  # type: int
        self.field_name = field_name  # type: str
        self.field_value = field_value  # type: str
        self.operate_type = operate_type  # type: str
        self.page_size = page_size  # type: int
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.target_type = target_type  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageRepoListResponseBodyImageRepoList(TeaModel):
    def __init__(self, flag=None, repo_name=None, repo_namespace=None):
        self.flag = flag  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoListResponseBodyImageRepoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        return self


class DescribeImageRepoListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageRepoListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageRepoListResponseBody(TeaModel):
    def __init__(self, add_target_count=None, all_target_count=None, del_target_count=None, image_repo_list=None,
                 page_info=None, request_id=None):
        self.add_target_count = add_target_count  # type: int
        self.all_target_count = all_target_count  # type: int
        self.del_target_count = del_target_count  # type: int
        self.image_repo_list = image_repo_list  # type: list[DescribeImageRepoListResponseBodyImageRepoList]
        self.page_info = page_info  # type: DescribeImageRepoListResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_repo_list:
            for k in self.image_repo_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeImageRepoListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_target_count is not None:
            result['AddTargetCount'] = self.add_target_count
        if self.all_target_count is not None:
            result['AllTargetCount'] = self.all_target_count
        if self.del_target_count is not None:
            result['DelTargetCount'] = self.del_target_count
        result['ImageRepoList'] = []
        if self.image_repo_list is not None:
            for k in self.image_repo_list:
                result['ImageRepoList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddTargetCount') is not None:
            self.add_target_count = m.get('AddTargetCount')
        if m.get('AllTargetCount') is not None:
            self.all_target_count = m.get('AllTargetCount')
        if m.get('DelTargetCount') is not None:
            self.del_target_count = m.get('DelTargetCount')
        self.image_repo_list = []
        if m.get('ImageRepoList') is not None:
            for k in m.get('ImageRepoList'):
                temp_model = DescribeImageRepoListResponseBodyImageRepoList()
                self.image_repo_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageRepoListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageRepoListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageRepoListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageRepoListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageRepoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageScanAuthCountResponseBodyImageScan(TeaModel):
    def __init__(self, image_scan_capacity=None, instance_id=None, scan_count=None):
        # The quota for container image scan.
        self.image_scan_capacity = image_scan_capacity  # type: long
        # The instance ID of Security Center.
        self.instance_id = instance_id  # type: str
        # The consumed quota for container image scan.
        self.scan_count = scan_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageScanAuthCountResponseBodyImageScan, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_capacity is not None:
            result['ImageScanCapacity'] = self.image_scan_capacity
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.scan_count is not None:
            result['ScanCount'] = self.scan_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageScanCapacity') is not None:
            self.image_scan_capacity = m.get('ImageScanCapacity')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ScanCount') is not None:
            self.scan_count = m.get('ScanCount')
        return self


class DescribeImageScanAuthCountResponseBody(TeaModel):
    def __init__(self, image_scan=None, request_id=None):
        # The details about the quota for container image scan.
        self.image_scan = image_scan  # type: DescribeImageScanAuthCountResponseBodyImageScan
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_scan:
            self.image_scan.validate()

    def to_map(self):
        _map = super(DescribeImageScanAuthCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan is not None:
            result['ImageScan'] = self.image_scan.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageScan') is not None:
            temp_model = DescribeImageScanAuthCountResponseBodyImageScan()
            self.image_scan = temp_model.from_map(m['ImageScan'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageScanAuthCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageScanAuthCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageScanAuthCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageScanAuthCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageScanAuthorizationResponseBodyAuthStatus(TeaModel):
    def __init__(self, status=None):
        self.status = status  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageScanAuthorizationResponseBodyAuthStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImageScanAuthorizationResponseBody(TeaModel):
    def __init__(self, auth_status=None, request_id=None):
        self.auth_status = auth_status  # type: DescribeImageScanAuthorizationResponseBodyAuthStatus
        self.request_id = request_id  # type: str

    def validate(self):
        if self.auth_status:
            self.auth_status.validate()

    def to_map(self):
        _map = super(DescribeImageScanAuthorizationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_status is not None:
            result['AuthStatus'] = self.auth_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthStatus') is not None:
            temp_model = DescribeImageScanAuthorizationResponseBodyAuthStatus()
            self.auth_status = temp_model.from_map(m['AuthStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageScanAuthorizationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageScanAuthorizationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageScanAuthorizationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageScanAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSensitiveFileByKeyRequest(TeaModel):
    def __init__(self, current_page=None, image_uuid=None, lang=None, page_size=None, scan_range=None,
                 sensitive_file_key=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The UUID of the image.
        self.image_uuid = image_uuid  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The type of the asset that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.scan_range = scan_range  # type: list[str]
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google\_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github\_ssh_key**: Github SSH Key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN Token
        # *   **ssh\_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel\_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord\_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws\_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker\_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec\_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s\_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh\_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common\_database_cfg**: Common Database Config
        # *   **wordpress\_database_cfg**: Wordpress Database Config
        # *   **googlecloud\_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful\_preview_token**: Contentful Preview Token
        # *   **php\_database_cfg**: PHP Database Config
        # *   **atom\_remote_sync**: Atom Remote Sync Config
        # *   **aws\_session_token**: AWS Session Token
        # *   **atom\_sftp_cfg**: Atom SFTP Config
        # *   **asana\_client\_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa\_private_key**: RSA Private Key
        # *   **github\_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver\_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github\_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: macOS Keychain
        # *   **amazon\_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes\_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp\_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github\_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs\_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab\_personal_token**: GitLab Personal Token
        # *   **rails\_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun\_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp\_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github\_app_token**: Github App Token
        # *   **hashicorp\_vault_token**: Hashicorp Vault Token
        # *   **pgp\_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common\_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix\_web_passwd**: Phoenix Web Credential
        # *   **puttygen\_private_key**: PuTTYgen Private Key
        # *   **google\_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob\_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr\_private_key**: OTR Private Key
        # *   **contentful\_delivery_token**: Contentful Delivery Token
        # *   **digital\_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa\_private_key**: DSA Private Key
        # *   **rails\_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic\_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.sensitive_file_key = sensitive_file_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageSensitiveFileByKeyShrinkRequest(TeaModel):
    def __init__(self, current_page=None, image_uuid=None, lang=None, page_size=None, scan_range_shrink=None,
                 sensitive_file_key=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The UUID of the image.
        self.image_uuid = image_uuid  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The type of the asset that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.scan_range_shrink = scan_range_shrink  # type: str
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google\_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github\_ssh_key**: Github SSH Key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN Token
        # *   **ssh\_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel\_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord\_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws\_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker\_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec\_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s\_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh\_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common\_database_cfg**: Common Database Config
        # *   **wordpress\_database_cfg**: Wordpress Database Config
        # *   **googlecloud\_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful\_preview_token**: Contentful Preview Token
        # *   **php\_database_cfg**: PHP Database Config
        # *   **atom\_remote_sync**: Atom Remote Sync Config
        # *   **aws\_session_token**: AWS Session Token
        # *   **atom\_sftp_cfg**: Atom SFTP Config
        # *   **asana\_client\_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa\_private_key**: RSA Private Key
        # *   **github\_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver\_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github\_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: macOS Keychain
        # *   **amazon\_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes\_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp\_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github\_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs\_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab\_personal_token**: GitLab Personal Token
        # *   **rails\_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun\_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp\_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github\_app_token**: Github App Token
        # *   **hashicorp\_vault_token**: Hashicorp Vault Token
        # *   **pgp\_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common\_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix\_web_passwd**: Phoenix Web Credential
        # *   **puttygen\_private_key**: PuTTYgen Private Key
        # *   **google\_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob\_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr\_private_key**: OTR Private Key
        # *   **contentful\_delivery_token**: Contentful Delivery Token
        # *   **digital\_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa\_private_key**: DSA Private Key
        # *   **rails\_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic\_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.sensitive_file_key = sensitive_file_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        return self


class DescribeImageSensitiveFileByKeyResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, last_row_key=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The key of the last data entry.
        self.last_row_key = last_row_key  # type: str
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList(TeaModel):
    def __init__(self, advice=None, file_path=None, first_scan_time=None, last_scan_time=None, layer_digest=None,
                 promt=None, risk_level=None, sensitive_file_key=None, sensitive_file_name=None):
        # The suggestion.
        self.advice = advice  # type: str
        # The file path.
        self.file_path = file_path  # type: str
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.first_scan_time = first_scan_time  # type: long
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_scan_time = last_scan_time  # type: long
        # The digest of the image layer.
        self.layer_digest = layer_digest  # type: str
        # The sensitive content.
        self.promt = promt  # type: str
        # The risk level of the sensitive file. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # The alert type of the sensitive file. Valid values:
        # 
        # *   **npm_token**: NPM Token
        # *   **ftp_cfg**: FTP Config
        # *   **google\_oauth_key**: Google OAuth Key
        # *   **planetscale_passwd**: Planetscale password
        # *   **github\_ssh_key**: Github SSH Key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN Token
        # *   **ssh\_private_key**: SSH Private Key
        # *   **aws_cli**: AWS CLI Credentials
        # *   **cpanel\_proftpd**: cPanel ProFTPd Credential
        # *   **postgresql_passwd**: PostgreSQl Passwd
        # *   **discord\_client_cred**: Discord Client Credential
        # *   **rails_database**: Rails Database Config
        # *   **aws\_access_key**: AWS Access Key
        # *   **esmtp_cfg**: ESMTP Config
        # *   **docker\_registry_cfg**: Docker Registry Config
        # *   **pem**: PEM
        # *   **common_cred**: Common Credential
        # *   **sftp_cfg**: SFTP Config
        # *   **grafana_token**: Grafana Token
        # *   **slack_token**: Slack Token
        # *   **ec\_private_key**: EC Private Key
        # *   **pypi_token**: PyPI Token
        # *   **finicity_token**: Finicity Token
        # *   **k8s\_client_key**: Kubernetes Client Key
        # *   **git_cfg**: Git Config
        # *   **django_key**: Django Key
        # *   **jenkins_ssh**: Jenkins SSH Config
        # *   **openssh\_private_key**: OPENSSH Private Key
        # *   **square_oauth**: Square OAuth Token
        # *   **typeform_token**: Typeform Token
        # *   **common\_database_cfg**: Common Database Config
        # *   **wordpress\_database_cfg**: Wordpress Database Config
        # *   **googlecloud\_api_key**: Google Cloud API Key
        # *   **vscode_sftp**: VSCode SFTP Config
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: Planetscale Token
        # *   **contentful\_preview_token**: Contentful Preview Token
        # *   **php\_database_cfg**: PHP Database Config
        # *   **atom\_remote_sync**: Atom Remote Sync Config
        # *   **aws\_session_token**: AWS Session Token
        # *   **atom\_sftp_cfg**: Atom SFTP Config
        # *   **asana\_client\_private_key**: Asana Client Private Key
        # *   **tencentcloud_ak**: Tencent Cloud SecretId
        # *   **rsa\_private_key**: RSA Private Key
        # *   **github\_personal_token**: Github Personal Token
        # *   **pgp**: PGP
        # *   **stripe_skpk**: Stripe Secret Key
        # *   **square_token**: Square Token
        # *   **rails_carrierwave**: Rails Carrierwave Credential
        # *   **dbeaver\_database_cfg**: DBeaver Database Config
        # *   **robomongo_cred**: Robomongo Credential
        # *   **github\_oauth_token**: Github OAuth Token
        # *   **pulumi_token**: Pulumi Token
        # *   **ventrilo_voip**: Ventrilo VoIP Server Config
        # *   **macos_keychain**: macOS Keychain
        # *   **amazon\_mws_token**: Amazon MWS Token
        # *   **dynatrace_token**: Dynatrace Token
        # *   **java_keystore**: Java Keystore
        # *   **microsoft_sdf**: Microsoft SDF
        # *   **kubernetes\_dashboard_cred**: Kubernetes Dashboard User Credential
        # *   **atlassian_token**: Atlassian Token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun Webhook Signing Key
        # *   **mailchimp\_api_key**: Mailchimp API Key
        # *   **netrc_cfg**: .netrc config
        # *   **openvpn_cfg**: OpenVPN Config
        # *   **github\_refresh_token**: Github Refresh Token
        # *   **salesforce**: Salesforce Credential
        # *   **sendinblue**: Sendinblue Token
        # *   **pkcs\_private_key**: PKCS Private Key
        # *   **rubyonrails_passwd**: Ruby on Rails Passwd
        # *   **filezilla_ftp**: FileZilla FTP Config
        # *   **databricks_token**: Databricks Token
        # *   **gitLab\_personal_token**: GitLab Personal Token
        # *   **rails\_master_key**: Rails Master Key
        # *   **sqlite**: SQLite3/SQLite Database
        # *   **firefox_logins**: Firefox Login Config
        # *   **mailgun\_private_token**: Mailgun Private Token
        # *   **joomla_cfg**: Joomla Config
        # *   **hashicorp\_terraform_token**: Hashicorp Terraform Token
        # *   **jetbrains_ides**: Jetbrains IDEs Config
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird Token
        # *   **github\_app_token**: Github App Token
        # *   **hashicorp\_vault_token**: Hashicorp Vault Token
        # *   **pgp\_private_key**: PGP Private Key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: Huaei Cloud Access Key
        # *   **aws_s3cmd**: AWS S3cmd Config
        # *   **php_config**: php Config
        # *   **common\_private_key**: Common Private Key Type
        # *   **microsoft_mdf**: Microsoft MDF
        # *   **mediawiki_cfg**: MediaWiki Config
        # *   **jenkins_cred**: Jenkins Credential
        # *   **rubygems_cred**: Rubygems Credential
        # *   **clojars_token**: Clojars Token
        # *   **phoenix\_web_passwd**: Phoenix Web Credential
        # *   **puttygen\_private_key**: PuTTYgen Private Key
        # *   **google\_oauth_token**: Google Oauth Token
        # *   **rubyonrails_cfg**: Ruby On Rails Database Config
        # *   **lob\_api_key**: Lob API Key
        # *   **pkcs_cred**: PKCS#12
        # *   **otr\_private_key**: OTR Private Key
        # *   **contentful\_delivery_token**: Contentful Delivery Token
        # *   **digital\_ocean_tugboat**: Digital Ocean Tugboat Config
        # *   **dsa\_private_key**: DSA Private Key
        # *   **rails\_app_token**: Rails App Token
        # *   **git_cred**: Git User Credential
        # *   **newrelic\_api_key**: New Relic User API Key
        # *   **github_hub**: Github Token
        # *   **rubygem**: Rubygem Token
        self.sensitive_file_key = sensitive_file_key  # type: str
        # The alert type name of the sensitive file.
        self.sensitive_file_name = sensitive_file_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.layer_digest is not None:
            result['LayerDigest'] = self.layer_digest
        if self.promt is not None:
            result['Promt'] = self.promt
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        if self.sensitive_file_name is not None:
            result['SensitiveFileName'] = self.sensitive_file_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('LayerDigest') is not None:
            self.layer_digest = m.get('LayerDigest')
        if m.get('Promt') is not None:
            self.promt = m.get('Promt')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        if m.get('SensitiveFileName') is not None:
            self.sensitive_file_name = m.get('SensitiveFileName')
        return self


class DescribeImageSensitiveFileByKeyResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, page_info=None, request_id=None,
                 sensitive_file_list=None, success=None):
        # The status code returned. If the 200 status code is returned, the request was successful.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The pagination information.
        self.page_info = page_info  # type: DescribeImageSensitiveFileByKeyResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the sensitive files.
        self.sensitive_file_list = sensitive_file_list  # type: list[DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.sensitive_file_list:
            for k in self.sensitive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveFileList'] = []
        if self.sensitive_file_list is not None:
            for k in self.sensitive_file_list:
                result['SensitiveFileList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageSensitiveFileByKeyResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_file_list = []
        if m.get('SensitiveFileList') is not None:
            for k in m.get('SensitiveFileList'):
                temp_model = DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList()
                self.sensitive_file_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageSensitiveFileByKeyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageSensitiveFileByKeyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageSensitiveFileByKeyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSensitiveFileByKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSensitiveFileListRequest(TeaModel):
    def __init__(self, criteria=None, criteria_type=None, current_page=None, image_uuid=None, lang=None,
                 page_size=None, risk_level=None, scan_range=None):
        # The value of the sensitive file type.
        self.criteria = criteria  # type: str
        # The query type of sensitive files. Valid values:
        # 
        # *   **SensitiveFileKey**: the alert type for sensitive files. Valid values:
        # 
        #     *   **npm_token**: npm access token
        #     *   **ftp_cfg**: FTP configuration
        #     *   **google\_oauth_key**: Google OAuth key
        #     *   **planetscale_passwd**: PlanetScale password
        #     *   **github\_ssh_key**: GitHub SSH key
        #     *   **msbuild\_publish_profile**: MSBuild publish profile
        #     *   **fastly\_cdn_token**: Fastly CDN token
        #     *   **ssh\_private_key**: SSH private key
        #     *   **aws_cli**: AWS CLI credential
        #     *   **cpanel_proftpd**: cPanel ProFTPD credential
        #     *   **postgresql_passwd**: PostgreSQL password file
        #     *   **discord\_client_cred**: Discord client credential
        #     *   **rails_database**: Rails database configuration
        #     *   **aws\_access_key**: AWS access key
        #     *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
        #     *   **docker\_registry_cfg**: configuration of a Docker image repository
        #     *   **pem**: Privacy-Enhanced Mail (PEM)
        #     *   **common_cred**: common credential
        #     *   **sftp_cfg**: SFTP connection configuration
        #     *   **grafana_token**: Grafana token
        #     *   **slack_token**: Slack token
        #     *   **ec\_private_key**: EC private key
        #     *   **pypi_token**: upload token for the Python Package Index (PyPI)
        #     *   **finicity_token**: Finicity token
        #     *   **k8s\_client_key**: Kubernetes private key
        #     *   **git_cfg**: Git configuration
        #     *   **django_key**: Django key
        #     *   **jenkins_ssh**: Jenkins SSH configuration file
        #     *   **openssh\_private_key**: OpenSSL private key
        #     *   **square_oauth**: OAuth credential for Square
        #     *   **typeform_token**: Typeform token
        #     *   **common\_database_cfg**: general database connection configuration
        #     *   **wordpress\_database_cfg**: WordPress database configuration
        #     *   **googlecloud\_api_key**: API key for Google Cloud
        #     *   **vscode_sftp**: VSCode SFTP configuration
        #     *   **apache_htpasswd**: Apache htpasswd
        #     *   **planetscale_token**: PlanetScale token
        #     *   **contentful\_preview_token**: preview token for Contentful
        #     *   **php\_database_cfg**: database password for a PHP application
        #     *   **atom\_remote_sync**: Atom remote synchronization configuration
        #     *   **aws\_session_token**: AWS session token
        #     *   **atom\_sftp_cfg**: Atom SFTP configuration
        #     *   **tencentcloud_ak**: Asana client key
        #     *   **tencentcloud_ak**: secret ID of a third-party cloud
        #     *   **rsa\_private_key**: RSA private key
        #     *   **github\_personal_token**: personal access token for GitHub
        #     *   **pgp**: Pretty Good Privacy (PGP) encrypted file
        #     *   **stripe_skpk**: Stripe secret key
        #     *   **square_token**: Square access token
        #     *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        #     *   **dbeaver\_database_cfg**: DBeaver database configuration
        #     *   **robomongo_cred**: credential for RoboMongo
        #     *   **github\_oauth_token**: OAuth access token for GitHub
        #     *   **pulumi_token**: Pulumi token
        #     *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        #     *   **macos_keychain**: macOS keychain
        #     *   **amazon\_mws_token**: Amazon MWS token
        #     *   **dynatrace_token**: Dynatrace token
        #     *   **java_keystore**: Java KeyStore (JKS)
        #     *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
        #     *   **kubernetes\_dashboard_cred**: user credential for Kubernetes Dashboard
        #     *   **atlassian_token**: Atlassian token
        #     *   **rdp**: remote desktop protocol (RDP)
        #     *   **mailgun_key**: Mailgun webhook signing key
        #     *   **mailchimp\_api_key**: API key for Mailchimp
        #     *   **netrc_cfg**: .netrc configuration file
        #     *   **openvpn_cfg**: OpenVPN configuration
        #     *   **github\_refresh_token**: GitHub refresh token
        #     *   **salesforce**: Salesforce credential
        #     *   **salesforce**: Sendinblue credential
        #     *   **pkcs\_private_key**: PKCS#12 key
        #     *   **rubyonrails_passwd**: Ruby on Rails password file
        #     *   **filezilla_ftp**: FileZilla FTP configuration
        #     *   **databricks_token**: Databricks token
        #     *   **gitLab\_personal_toke**: personal access token for GitLab
        #     *   **rails\_master_key**: Rails master key
        #     *   **sqlite**: SQLite3 or SQLite database
        #     *   **firefox_logins**: Firefox logon configuration
        #     *   **mailgun\_private_token**: Mailgun private token
        #     *   **joomla_cfg**: Joomla configuration
        #     *   **hashicorp\_terraform_token**: HashiCorp Terraform token
        #     *   **jetbrains_ides**: JetBrains IDEs configuration
        #     *   **heroku\_api_key**: Heroku API key
        #     *   **messagebird_token**: MessageBird token
        #     *   **messagebird_token**: MessageBird token
        #     *   **hashicorp\_vault_token**: HashiCorp Vault token
        #     *   **pgp\_private_key**: PGP private key
        #     *   **sshpasswd**: SSH password
        #     *   **huaweicloud_ak**: secret access key of a third-party cloud
        #     *   **aws_s3cmd**: AWS S3cmd configuration
        #     *   **php_config**: PHP configuration
        #     *   **common\_private_key**: private key of a common type
        #     *   **microsoft_mdf**: Microsoft SQL Server database
        #     *   **mediawiki_cfg**: MediaWiki configuration
        #     *   **jenkins_cred**: Jenkins credential
        #     *   **rubygems_cred**: RubyGems credential
        #     *   **clojars_token**: Clojars token
        #     *   **phoenix\_web_passwd**: Phoenix web credential
        #     *   **puttygen\_private_key**: PuTTYgen private key
        #     *   **google\_oauth_token**: Google OAuth access token
        #     *   **rubyonrails_cfg**: Ruby On Rails database configuration
        #     *   **lob\_api_key**: Lob API key
        #     *   **pkcs_cred**: PKCS#12 certificate
        #     *   **otr\_private_key**: Off-the-Record Messaging (OTR) private key
        #     *   **contentful\_delivery_token**: delivery token for Contentful
        #     *   **digital\_ocean_tugboat**: DigitalOcean Tugboat configuration
        #     *   **dsa\_private_key**: Digital Signature Algorithm (DSA) private key
        #     *   **rails\_app_token**: Rails app token
        #     *   **git_cred**: Git user credential
        #     *   **newrelic\_api_key**: User API key for New Relic
        #     *   **github_hub**: hub configuration for storing GitHub tokens
        #     *   **rubygem**: RubyGem token
        # 
        # *   **SensitiveFileName**: the name of the alert type for sensitive files.
        self.criteria_type = criteria_type  # type: str
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # The UUID of the image.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.
        self.image_uuid = image_uuid  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size  # type: int
        # The risk level. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # An array that consists of the types of the assets that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class DescribeImageSensitiveFileListShrinkRequest(TeaModel):
    def __init__(self, criteria=None, criteria_type=None, current_page=None, image_uuid=None, lang=None,
                 page_size=None, risk_level=None, scan_range_shrink=None):
        # The value of the sensitive file type.
        self.criteria = criteria  # type: str
        # The query type of sensitive files. Valid values:
        # 
        # *   **SensitiveFileKey**: the alert type for sensitive files. Valid values:
        # 
        #     *   **npm_token**: npm access token
        #     *   **ftp_cfg**: FTP configuration
        #     *   **google\_oauth_key**: Google OAuth key
        #     *   **planetscale_passwd**: PlanetScale password
        #     *   **github\_ssh_key**: GitHub SSH key
        #     *   **msbuild\_publish_profile**: MSBuild publish profile
        #     *   **fastly\_cdn_token**: Fastly CDN token
        #     *   **ssh\_private_key**: SSH private key
        #     *   **aws_cli**: AWS CLI credential
        #     *   **cpanel_proftpd**: cPanel ProFTPD credential
        #     *   **postgresql_passwd**: PostgreSQL password file
        #     *   **discord\_client_cred**: Discord client credential
        #     *   **rails_database**: Rails database configuration
        #     *   **aws\_access_key**: AWS access key
        #     *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
        #     *   **docker\_registry_cfg**: configuration of a Docker image repository
        #     *   **pem**: Privacy-Enhanced Mail (PEM)
        #     *   **common_cred**: common credential
        #     *   **sftp_cfg**: SFTP connection configuration
        #     *   **grafana_token**: Grafana token
        #     *   **slack_token**: Slack token
        #     *   **ec\_private_key**: EC private key
        #     *   **pypi_token**: upload token for the Python Package Index (PyPI)
        #     *   **finicity_token**: Finicity token
        #     *   **k8s\_client_key**: Kubernetes private key
        #     *   **git_cfg**: Git configuration
        #     *   **django_key**: Django key
        #     *   **jenkins_ssh**: Jenkins SSH configuration file
        #     *   **openssh\_private_key**: OpenSSL private key
        #     *   **square_oauth**: OAuth credential for Square
        #     *   **typeform_token**: Typeform token
        #     *   **common\_database_cfg**: general database connection configuration
        #     *   **wordpress\_database_cfg**: WordPress database configuration
        #     *   **googlecloud\_api_key**: API key for Google Cloud
        #     *   **vscode_sftp**: VSCode SFTP configuration
        #     *   **apache_htpasswd**: Apache htpasswd
        #     *   **planetscale_token**: PlanetScale token
        #     *   **contentful\_preview_token**: preview token for Contentful
        #     *   **php\_database_cfg**: database password for a PHP application
        #     *   **atom\_remote_sync**: Atom remote synchronization configuration
        #     *   **aws\_session_token**: AWS session token
        #     *   **atom\_sftp_cfg**: Atom SFTP configuration
        #     *   **tencentcloud_ak**: Asana client key
        #     *   **tencentcloud_ak**: secret ID of a third-party cloud
        #     *   **rsa\_private_key**: RSA private key
        #     *   **github\_personal_token**: personal access token for GitHub
        #     *   **pgp**: Pretty Good Privacy (PGP) encrypted file
        #     *   **stripe_skpk**: Stripe secret key
        #     *   **square_token**: Square access token
        #     *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        #     *   **dbeaver\_database_cfg**: DBeaver database configuration
        #     *   **robomongo_cred**: credential for RoboMongo
        #     *   **github\_oauth_token**: OAuth access token for GitHub
        #     *   **pulumi_token**: Pulumi token
        #     *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        #     *   **macos_keychain**: macOS keychain
        #     *   **amazon\_mws_token**: Amazon MWS token
        #     *   **dynatrace_token**: Dynatrace token
        #     *   **java_keystore**: Java KeyStore (JKS)
        #     *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
        #     *   **kubernetes\_dashboard_cred**: user credential for Kubernetes Dashboard
        #     *   **atlassian_token**: Atlassian token
        #     *   **rdp**: remote desktop protocol (RDP)
        #     *   **mailgun_key**: Mailgun webhook signing key
        #     *   **mailchimp\_api_key**: API key for Mailchimp
        #     *   **netrc_cfg**: .netrc configuration file
        #     *   **openvpn_cfg**: OpenVPN configuration
        #     *   **github\_refresh_token**: GitHub refresh token
        #     *   **salesforce**: Salesforce credential
        #     *   **salesforce**: Sendinblue credential
        #     *   **pkcs\_private_key**: PKCS#12 key
        #     *   **rubyonrails_passwd**: Ruby on Rails password file
        #     *   **filezilla_ftp**: FileZilla FTP configuration
        #     *   **databricks_token**: Databricks token
        #     *   **gitLab\_personal_toke**: personal access token for GitLab
        #     *   **rails\_master_key**: Rails master key
        #     *   **sqlite**: SQLite3 or SQLite database
        #     *   **firefox_logins**: Firefox logon configuration
        #     *   **mailgun\_private_token**: Mailgun private token
        #     *   **joomla_cfg**: Joomla configuration
        #     *   **hashicorp\_terraform_token**: HashiCorp Terraform token
        #     *   **jetbrains_ides**: JetBrains IDEs configuration
        #     *   **heroku\_api_key**: Heroku API key
        #     *   **messagebird_token**: MessageBird token
        #     *   **messagebird_token**: MessageBird token
        #     *   **hashicorp\_vault_token**: HashiCorp Vault token
        #     *   **pgp\_private_key**: PGP private key
        #     *   **sshpasswd**: SSH password
        #     *   **huaweicloud_ak**: secret access key of a third-party cloud
        #     *   **aws_s3cmd**: AWS S3cmd configuration
        #     *   **php_config**: PHP configuration
        #     *   **common\_private_key**: private key of a common type
        #     *   **microsoft_mdf**: Microsoft SQL Server database
        #     *   **mediawiki_cfg**: MediaWiki configuration
        #     *   **jenkins_cred**: Jenkins credential
        #     *   **rubygems_cred**: RubyGems credential
        #     *   **clojars_token**: Clojars token
        #     *   **phoenix\_web_passwd**: Phoenix web credential
        #     *   **puttygen\_private_key**: PuTTYgen private key
        #     *   **google\_oauth_token**: Google OAuth access token
        #     *   **rubyonrails_cfg**: Ruby On Rails database configuration
        #     *   **lob\_api_key**: Lob API key
        #     *   **pkcs_cred**: PKCS#12 certificate
        #     *   **otr\_private_key**: Off-the-Record Messaging (OTR) private key
        #     *   **contentful\_delivery_token**: delivery token for Contentful
        #     *   **digital\_ocean_tugboat**: DigitalOcean Tugboat configuration
        #     *   **dsa\_private_key**: Digital Signature Algorithm (DSA) private key
        #     *   **rails\_app_token**: Rails app token
        #     *   **git_cred**: Git user credential
        #     *   **newrelic\_api_key**: User API key for New Relic
        #     *   **github_hub**: hub configuration for storing GitHub tokens
        #     *   **rubygem**: RubyGem token
        # 
        # *   **SensitiveFileName**: the name of the alert type for sensitive files.
        self.criteria_type = criteria_type  # type: str
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.current_page = current_page  # type: int
        # The UUID of the image.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.
        self.image_uuid = image_uuid  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size  # type: int
        # The risk level. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # An array that consists of the types of the assets that you want to scan. Valid values:
        # 
        # *   **image**\
        # *   **container**\
        self.scan_range_shrink = scan_range_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.scan_range_shrink is not None:
            result['ScanRange'] = self.scan_range_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('ScanRange') is not None:
            self.scan_range_shrink = m.get('ScanRange')
        return self


class DescribeImageSensitiveFileListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, last_row_key=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The key of the last data entry.
        self.last_row_key = last_row_key  # type: str
        # The number of entries returned per page. Default value: 20.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.last_row_key is not None:
            result['LastRowKey'] = self.last_row_key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LastRowKey') is not None:
            self.last_row_key = m.get('LastRowKey')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSensitiveFileListResponseBodySensitiveFileList(TeaModel):
    def __init__(self, count=None, first_scan_time=None, last_scan_time=None, risk_level=None,
                 sensitive_file_key=None, sensitive_file_name=None):
        # The number of scans that are performed on the sensitive file.
        self.count = count  # type: int
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.first_scan_time = first_scan_time  # type: long
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_scan_time = last_scan_time  # type: long
        # The risk level. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # The alert type for the sensitive file. Valid values:
        # 
        # *   **npm_token**: npm access token
        # *   **ftp_cfg**: FTP configuration
        # *   **google\_oauth_key**: Google OAuth key
        # *   **planetscale_passwd**: PlanetScale password
        # *   **github\_ssh_key**: GitHub SSH key
        # *   **msbuild\_publish_profile**: MSBuild publish profile
        # *   **fastly\_cdn_token**: Fastly CDN token
        # *   **ssh\_private_key**: SSH private key
        # *   **aws_cli**: AWS CLI credential
        # *   **cpanel_proftpd**: cPanel ProFTPD credential
        # *   **postgresql_passwd**: PostgreSQL password file
        # *   **discord\_client_cred**: Discord client credential
        # *   **rails_database**: Rails database configuration
        # *   **aws\_access_key**: AWS access key
        # *   **esmtp_cfg** :configuration of ESMTP
        # *   **docker\_registry_cfg**: configuration of a Docker image repository
        # *   **pem**: PEM
        # *   **common_cred**: common credential
        # *   **sftp_cfg**: SFTP connection configuration
        # *   **grafana_token**: Grafana token
        # *   **slack_token**: Slack token
        # *   **ec\_private_key**: EC private key
        # *   **pypi_token**: upload token for the PyPI
        # *   **finicity_token**: Finicity token
        # *   **k8s\_client_key**: Kubernetes private key
        # *   **git_cfg**: Git configuration
        # *   **django_key**: Django key
        # *   **jenkins_ssh**: Jenkins SSH configuration file
        # *   **openssh\_private_key**: OpenSSL private key
        # *   **square_oauth**: OAuth credential for Square
        # *   **typeform_token**: Typeform token
        # *   **common\_database_cfg**: general database connection configuration
        # *   **wordpress\_database_cfg**: WordPress database configuration
        # *   **googlecloud\_api_key**: API key for Google Cloud
        # *   **vscode_sftp**: VSCode SFTP configuration
        # *   **apache_htpasswd**: Apache htpasswd
        # *   **planetscale_token**: PlanetScale token
        # *   **contentful\_preview_token**: preview token for Contentful
        # *   **php\_database_cfg**: database password for a PHP application
        # *   **atom\_remote_sync**: Atom remote synchronization configuration
        # *   **aws\_session_token**: AWS session token
        # *   **atom\_sftp_cfg**: Atom SFTP configuration
        # *   **tencentcloud_ak**: Asana client key
        # *   **tencentcloud_ak**: secret ID of a third-party cloud
        # *   **rsa\_private_key**: RSA private key
        # *   **github\_personal_token**: personal access token for GitHub
        # *   **pgp**: PGP encrypted file
        # *   **stripe_skpk**: Stripe secret key
        # *   **square_token**: Square access token
        # *   **rails_carrierwave**: file upload credential for Rails Carrierwave
        # *   **dbeaver\_database_cfg**: DBeaver database configuration
        # *   **robomongo_cred**: credential for RoboMongo
        # *   **github\_oauth_token**: OAuth access token for GitHub
        # *   **pulumi_token**: Pulumi token
        # *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
        # *   **macos_keychain**: macOS keychain
        # *   **amazon\_mws_token**: Amazon MWS token
        # *   **dynatrace_token**: Dynatrace token
        # *   **java_keystore**: JKS
        # *   **microsoft_sdf**: Microsoft SQL Server CE database
        # *   **kubernetes\_dashboard_cred**: user credential for Kubernetes Dashboard
        # *   **atlassian_token**: Atlassian token
        # *   **rdp**: RDP
        # *   **mailgun_key**: Mailgun webhook signing key
        # *   **mailchimp\_api_key**: API key for Mailchimp
        # *   **netrc_cfg**: .netrc configuration file
        # *   **openvpn_cfg**: OpenVPN configuration
        # *   **github\_refresh_token**: GitHub refresh token
        # *   **salesforce**: Salesforce credential
        # *   **salesforce**: Sendinblue credential
        # *   **pkcs\_private_key**: PKCS#12 key
        # *   **rubyonrails_passwd**: Ruby on Rails password file
        # *   **filezilla_ftp**: FileZilla FTP configuration
        # *   **databricks_token**: Databricks token
        # *   **gitLab\_personal_toke**: personal access token for GitLab
        # *   **rails\_master_key**: Rails master key
        # *   **sqlite**: SQLite3 or SQLite database
        # *   **firefox_logins**: Firefox logon configuration
        # *   **mailgun\_private_token**: Mailgun private token
        # *   **joomla_cfg**: Joomla configuration
        # *   **hashicorp\_terraform_token**: HashiCorp Terraform token
        # *   **jetbrains_ides**: JetBrains IDEs configuration
        # *   **heroku\_api_key**: Heroku API key
        # *   **messagebird_token**: MessageBird token
        # *   **messagebird_token**: MessageBird token
        # *   **hashicorp\_vault_token**: HashiCorp Vault token
        # *   **pgp\_private_key**: PGP private key
        # *   **sshpasswd**: SSH password
        # *   **huaweicloud_ak**: secret access key of a third-party cloud
        # *   **aws_s3cmd**: AWS S3cmd configuration
        # *   **php_config**: PHP configuration
        # *   **common\_private_key**: private key of a common type
        # *   **microsoft_mdf**: Microsoft SQL Server database
        # *   **mediawiki_cfg**: MediaWiki configuration
        # *   **jenkins_cred**: Jenkins credential
        # *   **rubygems_cred**: RubyGems credential
        # *   **clojars_token**: Clojars token
        # *   **phoenix\_web_passwd**: Phoenix web credential
        # *   **puttygen\_private_key**: PuTTYgen private key
        # *   **google\_oauth_token**: Google OAuth access token
        # *   **rubyonrails_cfg**: Ruby On Rails database configuration
        # *   **lob\_api_key**: Lob API key
        # *   **pkcs_cred**: PKCS#12 certificate
        # *   **otr\_private_key**: OTR private key
        # *   **contentful\_delivery_token**: delivery token for Contentful
        # *   **digital\_ocean_tugboat**: DigitalOcean Tugboat configuration
        # *   **dsa\_private_key**: Digital DSA private key
        # *   **rails\_app_token**: Rails app token
        # *   **git_cred**: Git user credential
        # *   **newrelic\_api_key**: User API key for New Relic
        # *   **github_hub**: hub configuration for storing GitHub tokens
        # *   **rubygem**: RubyGem token
        self.sensitive_file_key = sensitive_file_key  # type: str
        # The name of the alert type for the sensitive file.
        self.sensitive_file_name = sensitive_file_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListResponseBodySensitiveFileList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.first_scan_time is not None:
            result['FirstScanTime'] = self.first_scan_time
        if self.last_scan_time is not None:
            result['LastScanTime'] = self.last_scan_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sensitive_file_key is not None:
            result['SensitiveFileKey'] = self.sensitive_file_key
        if self.sensitive_file_name is not None:
            result['SensitiveFileName'] = self.sensitive_file_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FirstScanTime') is not None:
            self.first_scan_time = m.get('FirstScanTime')
        if m.get('LastScanTime') is not None:
            self.last_scan_time = m.get('LastScanTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SensitiveFileKey') is not None:
            self.sensitive_file_key = m.get('SensitiveFileKey')
        if m.get('SensitiveFileName') is not None:
            self.sensitive_file_name = m.get('SensitiveFileName')
        return self


class DescribeImageSensitiveFileListResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, page_info=None, request_id=None,
                 sensitive_file_list=None, success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The HTTP status code.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The pagination information.
        self.page_info = page_info  # type: DescribeImageSensitiveFileListResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the information about the sensitive files.
        self.sensitive_file_list = sensitive_file_list  # type: list[DescribeImageSensitiveFileListResponseBodySensitiveFileList]
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.sensitive_file_list:
            for k in self.sensitive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveFileList'] = []
        if self.sensitive_file_list is not None:
            for k in self.sensitive_file_list:
                result['SensitiveFileList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = DescribeImageSensitiveFileListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_file_list = []
        if m.get('SensitiveFileList') is not None:
            for k in m.get('SensitiveFileList'):
                temp_model = DescribeImageSensitiveFileListResponseBodySensitiveFileList()
                self.sensitive_file_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeImageSensitiveFileListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageSensitiveFileListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageSensitiveFileListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSensitiveFileListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageStatisticsResponseBody(TeaModel):
    def __init__(self, instance_count=None, request_id=None, risk_instance_count=None):
        # The number of container images in your assets. Only Container Registry Enterprise Edition instances are counted.
        self.instance_count = instance_count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The number of container images that have security risks. Only Container Registry Enterprise Edition instances are counted.
        self.risk_instance_count = risk_instance_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_instance_count is not None:
            result['RiskInstanceCount'] = self.risk_instance_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskInstanceCount') is not None:
            self.risk_instance_count = m.get('RiskInstanceCount')
        return self


class DescribeImageStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageVulListRequest(TeaModel):
    def __init__(self, alias_name=None, cluster_id=None, cluster_name=None, container_id=None, current_page=None,
                 dealed=None, digest=None, image=None, instance_id=None, lang=None, name=None, namespace=None,
                 necessity=None, page_size=None, pod=None, region_id=None, repo_id=None, repo_instance_id=None, repo_name=None,
                 repo_namespace=None, repo_region_id=None, scan_range=None, status_list=None, tag=None, type=None, uuids=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The ID of the cluster to which the container belongs.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the vulnerability is handled. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.dealed = dealed  # type: str
        # The digest of the image.
        self.digest = digest  # type: str
        # The name of the image.
        self.image = image  # type: str
        # The instance ID of the asset.
        self.instance_id = instance_id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The namespace.
        self.namespace = namespace  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The pod.
        self.pod = pod  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The ID of the image repository.
        self.repo_id = repo_id  # type: str
        # The instance ID of the image repository.
        self.repo_instance_id = repo_instance_id  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace  # type: str
        # The region ID of the image repository.
        self.repo_region_id = repo_region_id  # type: str
        # The types of the assets that you want to scan.
        self.scan_range = scan_range  # type: list[str]
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **4**: being fixed
        # *   **7**: fixed
        self.status_list = status_list  # type: str
        # The tag that is added to the image.
        self.tag = tag  # type: str
        # The type of the vulnerability. Set the value to **CVE**, which indicates image vulnerabilities.
        self.type = type  # type: str
        # The UUIDs of the assets. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageVulListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.image is not None:
            result['Image'] = self.image
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_instance_id is not None:
            result['RepoInstanceId'] = self.repo_instance_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoInstanceId') is not None:
            self.repo_instance_id = m.get('RepoInstanceId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(TeaModel):
    def __init__(self, full_version=None, layer=None, match_detail=None, match_list=None, name=None, path=None,
                 update_cmd=None, version=None):
        # The complete version number of the package.
        self.full_version = full_version  # type: str
        # The SHA-256 value of the digest of the image layer.
        self.layer = layer  # type: str
        # The reason why the vulnerability is detected.
        self.match_detail = match_detail  # type: str
        # The details of the rules that are used to detect the vulnerability.
        self.match_list = match_list  # type: list[str]
        # The name of the software package.
        self.name = name  # type: str
        # The path of the software that has the vulnerability.
        self.path = path  # type: str
        # The command that is used to fix the vulnerability.
        self.update_cmd = update_cmd  # type: str
        # The version number of the package.
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_version is not None:
            result['FullVersion'] = self.full_version
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.match_detail is not None:
            result['MatchDetail'] = self.match_detail
        if self.match_list is not None:
            result['MatchList'] = self.match_list
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.update_cmd is not None:
            result['UpdateCmd'] = self.update_cmd
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FullVersion') is not None:
            self.full_version = m.get('FullVersion')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('MatchDetail') is not None:
            self.match_detail = m.get('MatchDetail')
        if m.get('MatchList') is not None:
            self.match_list = m.get('MatchList')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('UpdateCmd') is not None:
            self.update_cmd = m.get('UpdateCmd')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeImageVulListResponseBodyVulRecordsExtendContentJson(TeaModel):
    def __init__(self, os=None, os_release=None, rpm_entity_list=None):
        # The name of the operating system.
        self.os = os  # type: str
        # The version of the operating system in the image.
        self.os_release = os_release  # type: str
        # The details of the packages of the software that has the vulnerability.
        self.rpm_entity_list = rpm_entity_list  # type: list[DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList]

    def validate(self):
        if self.rpm_entity_list:
            for k in self.rpm_entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageVulListResponseBodyVulRecordsExtendContentJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.os is not None:
            result['Os'] = self.os
        if self.os_release is not None:
            result['OsRelease'] = self.os_release
        result['RpmEntityList'] = []
        if self.rpm_entity_list is not None:
            for k in self.rpm_entity_list:
                result['RpmEntityList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsRelease') is not None:
            self.os_release = m.get('OsRelease')
        self.rpm_entity_list = []
        if m.get('RpmEntityList') is not None:
            for k in m.get('RpmEntityList'):
                temp_model = DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList()
                self.rpm_entity_list.append(temp_model.from_map(k))
        return self


class DescribeImageVulListResponseBodyVulRecords(TeaModel):
    def __init__(self, alias_name=None, can_fix=None, can_update=None, cluster_id=None, cluster_name=None,
                 container_id=None, extend_content_json=None, first_ts=None, image=None, image_digest=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, last_ts=None, layers=None, malicious_source=None, modify_ts=None, name=None,
                 namespace=None, necessity=None, pod=None, primary_id=None, related=None, repo_name=None, repo_namespace=None,
                 scan_time=None, status=None, tag=None, target_id=None, target_name=None, target_type=None, type=None,
                 uuid=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # Indicates whether the vulnerability can be fixed in the Security Center console. Valid values:
        # 
        # *   **yes**: yes
        # *   **no**: no
        self.can_fix = can_fix  # type: str
        # Indicates whether the package of the software that has the vulnerability can be upgraded by using Security Center. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_update = can_update  # type: bool
        # The ID of the cluster.
        self.cluster_id = cluster_id  # type: str
        # The name of the cluster.
        self.cluster_name = cluster_name  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The extended information about the vulnerability.
        self.extend_content_json = extend_content_json  # type: DescribeImageVulListResponseBodyVulRecordsExtendContentJson
        # The timestamp when the first scan was performed. Unit: milliseconds.
        self.first_ts = first_ts  # type: long
        # The name of the image.
        self.image = image  # type: str
        # The digest of the image.
        self.image_digest = image_digest  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        # The timestamp when the last scan was performed. Unit: milliseconds.
        self.last_ts = last_ts  # type: long
        # The image layers.
        self.layers = layers  # type: list[str]
        self.malicious_source = malicious_source  # type: str
        # The timestamp when the information about the vulnerability was updated. Unit: milliseconds.
        self.modify_ts = modify_ts  # type: long
        # The name of the vulnerability.
        self.name = name  # type: str
        # The namespace.
        self.namespace = namespace  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high. You must fix the vulnerability at the earliest opportunity.
        # *   **later**: medium. You can fix the vulnerability based on your business requirements.
        # *   **nntf**: low. You can ignore the vulnerability.
        self.necessity = necessity  # type: str
        # The pod.
        self.pod = pod  # type: str
        # The ID of the vulnerability.
        self.primary_id = primary_id  # type: long
        # The Common Vulnerabilities and Exposures (CVE) ID of the associated vulnerability.
        self.related = related  # type: str
        # The name of the image repository.
        self.repo_name = repo_name  # type: str
        # The namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace  # type: str
        self.scan_time = scan_time  # type: long
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **7**: fixed
        self.status = status  # type: int
        # The tag that is added to the vulnerability.
        self.tag = tag  # type: str
        self.target_id = target_id  # type: str
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str
        # The type of the vulnerability. The value is fixed as CVE, which indicates image vulnerabilities.
        self.type = type  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.extend_content_json:
            self.extend_content_json.validate()

    def to_map(self):
        _map = super(DescribeImageVulListResponseBodyVulRecords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.can_fix is not None:
            result['CanFix'] = self.can_fix
        if self.can_update is not None:
            result['CanUpdate'] = self.can_update
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.extend_content_json is not None:
            result['ExtendContentJson'] = self.extend_content_json.to_map()
        if self.first_ts is not None:
            result['FirstTs'] = self.first_ts
        if self.image is not None:
            result['Image'] = self.image
        if self.image_digest is not None:
            result['ImageDigest'] = self.image_digest
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.layers is not None:
            result['Layers'] = self.layers
        if self.malicious_source is not None:
            result['MaliciousSource'] = self.malicious_source
        if self.modify_ts is not None:
            result['ModifyTs'] = self.modify_ts
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        if self.related is not None:
            result['Related'] = self.related
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.scan_time is not None:
            result['ScanTime'] = self.scan_time
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CanFix') is not None:
            self.can_fix = m.get('CanFix')
        if m.get('CanUpdate') is not None:
            self.can_update = m.get('CanUpdate')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ExtendContentJson') is not None:
            temp_model = DescribeImageVulListResponseBodyVulRecordsExtendContentJson()
            self.extend_content_json = temp_model.from_map(m['ExtendContentJson'])
        if m.get('FirstTs') is not None:
            self.first_ts = m.get('FirstTs')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageDigest') is not None:
            self.image_digest = m.get('ImageDigest')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('Layers') is not None:
            self.layers = m.get('Layers')
        if m.get('MaliciousSource') is not None:
            self.malicious_source = m.get('MaliciousSource')
        if m.get('ModifyTs') is not None:
            self.modify_ts = m.get('ModifyTs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        if m.get('Related') is not None:
            self.related = m.get('Related')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('ScanTime') is not None:
            self.scan_time = m.get('ScanTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeImageVulListResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, request_id=None, total_count=None, vul_records=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int
        # An array that consists of the vulnerabilities.
        self.vul_records = vul_records  # type: list[DescribeImageVulListResponseBodyVulRecords]

    def validate(self):
        if self.vul_records:
            for k in self.vul_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageVulListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulRecords'] = []
        if self.vul_records is not None:
            for k in self.vul_records:
                result['VulRecords'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_records = []
        if m.get('VulRecords') is not None:
            for k in m.get('VulRecords'):
                temp_model = DescribeImageVulListResponseBodyVulRecords()
                self.vul_records.append(temp_model.from_map(k))
        return self


class DescribeImageVulListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageVulListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageVulListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCaptchaRequest(TeaModel):
    def __init__(self, deadline=None, lang=None, source_ip=None):
        # The validity period of the installation verification code. If this parameter is not specified, the validity period is 1 hour.
        # 
        # >  The installation verification code is valid only within the validity period. An expired installation verification code cannot be used to install the agent.
        self.deadline = deadline  # type: str
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstallCaptchaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deadline is not None:
            result['Deadline'] = self.deadline
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Deadline') is not None:
            self.deadline = m.get('Deadline')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeInstallCaptchaResponseBody(TeaModel):
    def __init__(self, captcha_code=None, deadline=None, request_id=None):
        # The installation verification code for you to manually install the Security Center agent.
        self.captcha_code = captcha_code  # type: str
        # The validity period of the installation verification code.
        # 
        # >  The installation verification code is valid only within the validity period. An expired installation verification code cannot be used to install the agent.
        self.deadline = deadline  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstallCaptchaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        if self.deadline is not None:
            result['Deadline'] = self.deadline
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        if m.get('Deadline') is not None:
            self.deadline = m.get('Deadline')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCaptchaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstallCaptchaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstallCaptchaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCaptchaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCodeResponseBody(TeaModel):
    def __init__(self, code=None, request_id=None):
        self.code = code  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstallCodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstallCodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstallCodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstallCodesResponseBodyInstallCodes(TeaModel):
    def __init__(self, captcha_code=None, expired_date=None, group_id=None, group_name=None, only_image=None,
                 os=None, vendor_name=None):
        self.captcha_code = captcha_code  # type: str
        self.expired_date = expired_date  # type: long
        self.group_id = group_id  # type: long
        self.group_name = group_name  # type: str
        self.only_image = only_image  # type: bool
        self.os = os  # type: str
        self.vendor_name = vendor_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstallCodesResponseBodyInstallCodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha_code is not None:
            result['CaptchaCode'] = self.captcha_code
        if self.expired_date is not None:
            result['ExpiredDate'] = self.expired_date
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.only_image is not None:
            result['OnlyImage'] = self.only_image
        if self.os is not None:
            result['Os'] = self.os
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CaptchaCode') is not None:
            self.captcha_code = m.get('CaptchaCode')
        if m.get('ExpiredDate') is not None:
            self.expired_date = m.get('ExpiredDate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('OnlyImage') is not None:
            self.only_image = m.get('OnlyImage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class DescribeInstallCodesResponseBody(TeaModel):
    def __init__(self, install_codes=None, request_id=None):
        self.install_codes = install_codes  # type: list[DescribeInstallCodesResponseBodyInstallCodes]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.install_codes:
            for k in self.install_codes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstallCodesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstallCodes'] = []
        if self.install_codes is not None:
            for k in self.install_codes:
                result['InstallCodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.install_codes = []
        if m.get('InstallCodes') is not None:
            for k in m.get('InstallCodes'):
                temp_model = DescribeInstallCodesResponseBodyInstallCodes()
                self.install_codes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstallCodesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstallCodesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstallCodesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstallCodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAntiBruteForceRulesRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, resource_owner_id=None, source_ip=None, uuid_list=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page. Default value: **10000**.
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # An array that consists of the UUIDs of the servers.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAntiBruteForceRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of servers to which the defense rule is applied on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of servers to which the defense rule is applied.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBodyRules(TeaModel):
    def __init__(self, id=None, name=None, uuid=None):
        # The ID of the defense rule.
        self.id = id  # type: long
        # The name of the defense rule.
        self.name = name  # type: str
        # The UUID of the server to which the defense rule is applied.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAntiBruteForceRulesResponseBodyRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceAntiBruteForceRulesResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, rules=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the servers to which the defense rule is applied.
        self.rules = rules  # type: list[DescribeInstanceAntiBruteForceRulesResponseBodyRules]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceAntiBruteForceRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeInstanceAntiBruteForceRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeInstanceAntiBruteForceRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceAntiBruteForceRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceAntiBruteForceRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAntiBruteForceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceRebootStatusRequest(TeaModel):
    def __init__(self, uuids=None):
        # The UUIDs of the servers that you restart. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceRebootStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeInstanceRebootStatusResponseBodyRebootStatuses(TeaModel):
    def __init__(self, code=None, msg=None, reboot_status=None, uuid=None):
        # The error code that is returned when the server failed to be restarted. Valid values:
        # 
        # *   **10001**: The restart command failed to be sent.
        # *   **10002**: The restart operation failed.
        # *   **10003**: A timeout error occurs.
        self.code = code  # type: str
        # The message that is returned when the server failed to be restarted.
        self.msg = msg  # type: str
        # The status of the server. Valid values:
        # 
        # *   **0**: The server is being restarted.
        # *   **1**: The server is restarted.
        # *   **2**: The server failed to be restarted.
        self.reboot_status = reboot_status  # type: int
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceRebootStatusResponseBodyRebootStatuses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.reboot_status is not None:
            result['RebootStatus'] = self.reboot_status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RebootStatus') is not None:
            self.reboot_status = m.get('RebootStatus')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceRebootStatusResponseBody(TeaModel):
    def __init__(self, reboot_statuses=None, request_id=None, total_count=None):
        # An array that consists of the status information about the servers that you restart.
        self.reboot_statuses = reboot_statuses  # type: list[DescribeInstanceRebootStatusResponseBodyRebootStatuses]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.reboot_statuses:
            for k in self.reboot_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceRebootStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RebootStatuses'] = []
        if self.reboot_statuses is not None:
            for k in self.reboot_statuses:
                result['RebootStatuses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.reboot_statuses = []
        if m.get('RebootStatuses') is not None:
            for k in m.get('RebootStatuses'):
                temp_model = DescribeInstanceRebootStatusResponseBodyRebootStatuses()
                self.reboot_statuses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceRebootStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceRebootStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceRebootStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceRebootStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceStatisticsRequest(TeaModel):
    def __init__(self, from_=None, lang=None, source_ip=None, uuid=None):
        # The source of the request. Set the value to **sas**, which indicates that the request is sent from Security Center.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUIDs of the assets to query. Separate multiple UUIDs with commas (,).
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeInstanceStatisticsResponseBodyData(TeaModel):
    def __init__(self, account=None, agentless_all=None, agentless_baseline=None, agentless_malicious=None,
                 agentless_vul_cve=None, agentless_vul_sca=None, app_num=None, cms_num=None, cve_num=None, emg_num=None, health=None,
                 sca_num=None, suspicious=None, sys_num=None, trojan=None, uuid=None, vul=None, weak_pwnum=None):
        # The number of unusual logons to the asset.
        self.account = account  # type: int
        # The number of alerts generated by the agentless detection feature.
        self.agentless_all = agentless_all  # type: int
        # The number of baseline risks detected by the agentless detection feature.
        self.agentless_baseline = agentless_baseline  # type: int
        # The number of malicious samples detected by the agentless detection feature.
        self.agentless_malicious = agentless_malicious  # type: int
        # The number of system vulnerabilities detected by the agentless detection feature.
        self.agentless_vul_cve = agentless_vul_cve  # type: int
        # The number of application vulnerabilities detected by the agentless detection feature.
        self.agentless_vul_sca = agentless_vul_sca  # type: int
        # The number of application vulnerabilities detected on the asset.
        self.app_num = app_num  # type: int
        # The number of Web-CMS vulnerabilities detected on the asset.
        self.cms_num = cms_num  # type: int
        # The number of common vulnerabilities detected on the asset.
        self.cve_num = cve_num  # type: int
        # The number of urgent vulnerabilities detected on the asset.
        self.emg_num = emg_num  # type: int
        # The number of baseline risks detected on the asset.
        self.health = health  # type: int
        # The number of middleware vulnerabilities detected on the asset.
        self.sca_num = sca_num  # type: int
        # The number of alerts generated on the asset.
        self.suspicious = suspicious  # type: int
        # The number of Windows system vulnerabilities detected on the asset.
        self.sys_num = sys_num  # type: int
        # The number of trojans detected on the asset.
        self.trojan = trojan  # type: int
        # The UUID of the asset.
        self.uuid = uuid  # type: str
        # The total number of vulnerabilities detected on the asset.
        self.vul = vul  # type: int
        # The number of weak passwords.
        self.weak_pwnum = weak_pwnum  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceStatisticsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.agentless_all is not None:
            result['AgentlessAll'] = self.agentless_all
        if self.agentless_baseline is not None:
            result['AgentlessBaseline'] = self.agentless_baseline
        if self.agentless_malicious is not None:
            result['AgentlessMalicious'] = self.agentless_malicious
        if self.agentless_vul_cve is not None:
            result['AgentlessVulCve'] = self.agentless_vul_cve
        if self.agentless_vul_sca is not None:
            result['AgentlessVulSca'] = self.agentless_vul_sca
        if self.app_num is not None:
            result['AppNum'] = self.app_num
        if self.cms_num is not None:
            result['CmsNum'] = self.cms_num
        if self.cve_num is not None:
            result['CveNum'] = self.cve_num
        if self.emg_num is not None:
            result['EmgNum'] = self.emg_num
        if self.health is not None:
            result['Health'] = self.health
        if self.sca_num is not None:
            result['ScaNum'] = self.sca_num
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        if self.sys_num is not None:
            result['SysNum'] = self.sys_num
        if self.trojan is not None:
            result['Trojan'] = self.trojan
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vul is not None:
            result['Vul'] = self.vul
        if self.weak_pwnum is not None:
            result['WeakPWNum'] = self.weak_pwnum
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('AgentlessAll') is not None:
            self.agentless_all = m.get('AgentlessAll')
        if m.get('AgentlessBaseline') is not None:
            self.agentless_baseline = m.get('AgentlessBaseline')
        if m.get('AgentlessMalicious') is not None:
            self.agentless_malicious = m.get('AgentlessMalicious')
        if m.get('AgentlessVulCve') is not None:
            self.agentless_vul_cve = m.get('AgentlessVulCve')
        if m.get('AgentlessVulSca') is not None:
            self.agentless_vul_sca = m.get('AgentlessVulSca')
        if m.get('AppNum') is not None:
            self.app_num = m.get('AppNum')
        if m.get('CmsNum') is not None:
            self.cms_num = m.get('CmsNum')
        if m.get('CveNum') is not None:
            self.cve_num = m.get('CveNum')
        if m.get('EmgNum') is not None:
            self.emg_num = m.get('EmgNum')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('ScaNum') is not None:
            self.sca_num = m.get('ScaNum')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        if m.get('SysNum') is not None:
            self.sys_num = m.get('SysNum')
        if m.get('Trojan') is not None:
            self.trojan = m.get('Trojan')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vul') is not None:
            self.vul = m.get('Vul')
        if m.get('WeakPWNum') is not None:
            self.weak_pwnum = m.get('WeakPWNum')
        return self


class DescribeInstanceStatisticsResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # An array that consists of the risk information about assets.
        self.data = data  # type: list[DescribeInstanceStatisticsResponseBodyData]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeInstanceStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIpTagsRequest(TeaModel):
    def __init__(self, ip=None, security_event_id=None):
        self.ip = ip  # type: str
        self.security_event_id = security_event_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeIpTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        return self


class DescribeIpTagsResponseBody(TeaModel):
    def __init__(self, request_id=None, tags=None):
        self.request_id = request_id  # type: str
        self.tags = tags  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeIpTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeIpTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeIpTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeIpTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIpTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLatestScanTaskResponseBody(TeaModel):
    def __init__(self, last_check_time=None, request_id=None, risk_num=None, target_info=None, uuids=None):
        self.last_check_time = last_check_time  # type: long
        self.request_id = request_id  # type: str
        self.risk_num = risk_num  # type: int
        self.target_info = target_info  # type: str
        self.uuids = uuids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLatestScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.last_check_time is not None:
            result['LastCheckTime'] = self.last_check_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_num is not None:
            result['RiskNum'] = self.risk_num
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LastCheckTime') is not None:
            self.last_check_time = m.get('LastCheckTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskNum') is not None:
            self.risk_num = m.get('RiskNum')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeLatestScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLatestScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLatestScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLatestScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogMetaRequest(TeaModel):
    def __init__(self, from_=None, lang=None, source_ip=None):
        # The ID of the request source. Default value: **aegis**. Valid values:
        # 
        # *   **aegis**: Server Guard
        # *   **sas**: Security Center
        # 
        # >  If you use Server Guard, set the value to **aegis**. If you use Security Center, set the value to **sas**.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMetaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeLogMetaResponseBodyLogMetaList(TeaModel):
    def __init__(self, category=None, hot_ttl=None, log_desc=None, log_store=None, project=None, status=None,
                 topic=None, ttl=None, user_log_store=None, user_project=None, user_region=None):
        # The category of logs. Valid values:
        # 
        # *   **host**: host logs
        # *   **network**: network logs
        # *   **security**: security logs
        self.category = category  # type: str
        # The time period after which logs in hot storage are moved to cold storage. Unit: days.
        # 
        # >  If the value is **-1**, logs that are stored in hot storage are not moved to cold storage.
        self.hot_ttl = hot_ttl  # type: int
        # The name of the log type.
        self.log_desc = log_desc  # type: str
        # The name of the dedicated Logstore in which logs are stored.
        self.log_store = log_store  # type: str
        # The name of the project.
        self.project = project  # type: str
        # The status of the log analysis feature. Valid values:
        # 
        # *   **disabled**\
        # *   **enabled**\
        self.status = status  # type: str
        # The topic of logs that are delivered.
        self.topic = topic  # type: str
        # The number of days during which logs can be retained.
        self.ttl = ttl  # type: int
        # The name of the dedicated Logstore in which user logs are stored.
        self.user_log_store = user_log_store  # type: str
        # The name of the dedicated project in which logs are stored.
        self.user_project = user_project  # type: str
        # The ID of the region.
        self.user_region = user_region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMetaResponseBodyLogMetaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.hot_ttl is not None:
            result['HotTtl'] = self.hot_ttl
        if self.log_desc is not None:
            result['LogDesc'] = self.log_desc
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.status is not None:
            result['Status'] = self.status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.user_log_store is not None:
            result['UserLogStore'] = self.user_log_store
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        if self.user_region is not None:
            result['UserRegion'] = self.user_region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('HotTtl') is not None:
            self.hot_ttl = m.get('HotTtl')
        if m.get('LogDesc') is not None:
            self.log_desc = m.get('LogDesc')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UserLogStore') is not None:
            self.user_log_store = m.get('UserLogStore')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        if m.get('UserRegion') is not None:
            self.user_region = m.get('UserRegion')
        return self


class DescribeLogMetaResponseBody(TeaModel):
    def __init__(self, log_meta_list=None, request_id=None, total_count=None):
        # An array that consists of the configurations of the log analysis feature.
        self.log_meta_list = log_meta_list  # type: list[DescribeLogMetaResponseBodyLogMetaList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.log_meta_list:
            for k in self.log_meta_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLogMetaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogMetaList'] = []
        if self.log_meta_list is not None:
            for k in self.log_meta_list:
                result['LogMetaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.log_meta_list = []
        if m.get('LogMetaList') is not None:
            for k in m.get('LogMetaList'):
                temp_model = DescribeLogMetaResponseBodyLogMetaList()
                self.log_meta_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLogMetaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLogMetaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLogMetaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogShipperStatusRequest(TeaModel):
    def __init__(self, from_=None):
        self.from_ = from_  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogShipperStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class DescribeLogShipperStatusResponseBodyLogShipperStatus(TeaModel):
    def __init__(self, auth_status=None, buy_status=None, open_status=None, post_paid_open_status=None,
                 post_paid_support_status=None, sls_project_status=None, sls_service_status=None):
        self.auth_status = auth_status  # type: str
        self.buy_status = buy_status  # type: str
        self.open_status = open_status  # type: str
        self.post_paid_open_status = post_paid_open_status  # type: str
        self.post_paid_support_status = post_paid_support_status  # type: str
        self.sls_project_status = sls_project_status  # type: str
        self.sls_service_status = sls_service_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogShipperStatusResponseBodyLogShipperStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_status is not None:
            result['AuthStatus'] = self.auth_status
        if self.buy_status is not None:
            result['BuyStatus'] = self.buy_status
        if self.open_status is not None:
            result['OpenStatus'] = self.open_status
        if self.post_paid_open_status is not None:
            result['PostPaidOpenStatus'] = self.post_paid_open_status
        if self.post_paid_support_status is not None:
            result['PostPaidSupportStatus'] = self.post_paid_support_status
        if self.sls_project_status is not None:
            result['SlsProjectStatus'] = self.sls_project_status
        if self.sls_service_status is not None:
            result['SlsServiceStatus'] = self.sls_service_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthStatus') is not None:
            self.auth_status = m.get('AuthStatus')
        if m.get('BuyStatus') is not None:
            self.buy_status = m.get('BuyStatus')
        if m.get('OpenStatus') is not None:
            self.open_status = m.get('OpenStatus')
        if m.get('PostPaidOpenStatus') is not None:
            self.post_paid_open_status = m.get('PostPaidOpenStatus')
        if m.get('PostPaidSupportStatus') is not None:
            self.post_paid_support_status = m.get('PostPaidSupportStatus')
        if m.get('SlsProjectStatus') is not None:
            self.sls_project_status = m.get('SlsProjectStatus')
        if m.get('SlsServiceStatus') is not None:
            self.sls_service_status = m.get('SlsServiceStatus')
        return self


class DescribeLogShipperStatusResponseBody(TeaModel):
    def __init__(self, log_shipper_status=None, request_id=None):
        self.log_shipper_status = log_shipper_status  # type: DescribeLogShipperStatusResponseBodyLogShipperStatus
        self.request_id = request_id  # type: str

    def validate(self):
        if self.log_shipper_status:
            self.log_shipper_status.validate()

    def to_map(self):
        _map = super(DescribeLogShipperStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_shipper_status is not None:
            result['LogShipperStatus'] = self.log_shipper_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogShipperStatus') is not None:
            temp_model = DescribeLogShipperStatusResponseBodyLogShipperStatus()
            self.log_shipper_status = temp_model.from_map(m['LogShipperStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLogShipperStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLogShipperStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLogShipperStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogShipperStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoginBaseConfigsRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, target=None, type=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page. Default value: **5**.
        self.page_size = page_size  # type: int
        # The server to which the configuration is applied. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **Target**: the UUID or group ID of the server to add or delete.
        # 
        # >  If targetType is set to uuid, the value of Target is the UUID of the server. If targetType is set to groupId, the value of Target is the group ID of the server. If targetType is set to global, the value of Target is a hyphen (-).
        # 
        # *   **targetType**: the type of the server to which the configuration is applied. Valid values:
        # 
        #     *   **uuid**: a server
        #     *   **groupId**: a server group
        #     *   **global**: all servers
        self.target = target  # type: str
        # The logon type of the configuration to query. Valid values:
        # 
        # *   **login\_common_location**: common logon location
        # *   **login\_common_ip**: common logon IP address
        # *   **login\_common_time**: common logon time range
        # *   **login\_common_account**: common logon account
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLoginBaseConfigsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList(TeaModel):
    def __init__(self, target=None, target_type=None):
        # The UUID or group ID of the server.
        self.target = target  # type: str
        # The type of the server to which the configuration is applied. Valid values:
        # 
        # *   **uuid**: a server
        # *   **groupId**: a server group
        # *   **global**: all servers
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeLoginBaseConfigsResponseBodyBaseConfigs(TeaModel):
    def __init__(self, account=None, end_time=None, ip=None, location=None, start_time=None, target_list=None,
                 total_count=None, uuid_count=None):
        # The common logon account.
        self.account = account  # type: str
        # The end time of the common logon time range.
        self.end_time = end_time  # type: str
        # The common logon IP address.
        self.ip = ip  # type: str
        # The common logon location.
        self.location = location  # type: str
        # The start time of the common logon time range.
        self.start_time = start_time  # type: str
        # The details of the servers to which the configuration is applied.
        self.target_list = target_list  # type: list[DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList]
        # The total number of servers.
        self.total_count = total_count  # type: int
        # The number of servers to which the configuration is applied.
        self.uuid_count = uuid_count  # type: int

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLoginBaseConfigsResponseBodyBaseConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.location is not None:
            result['Location'] = self.location
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.uuid_count is not None:
            result['UuidCount'] = self.uuid_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UuidCount') is not None:
            self.uuid_count = m.get('UuidCount')
        return self


class DescribeLoginBaseConfigsResponseBody(TeaModel):
    def __init__(self, base_configs=None, current_page=None, page_size=None, request_id=None, total_count=None):
        # An array that consists of the information about the configurations.
        self.base_configs = base_configs  # type: list[DescribeLoginBaseConfigsResponseBodyBaseConfigs]
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.base_configs:
            for k in self.base_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLoginBaseConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BaseConfigs'] = []
        if self.base_configs is not None:
            for k in self.base_configs:
                result['BaseConfigs'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.base_configs = []
        if m.get('BaseConfigs') is not None:
            for k in m.get('BaseConfigs'):
                temp_model = DescribeLoginBaseConfigsResponseBodyBaseConfigs()
                self.base_configs.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLoginBaseConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLoginBaseConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLoginBaseConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoginBaseConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoginSwitchConfigsResponseBodyConfigList(TeaModel):
    def __init__(self, item=None, status=None):
        self.item = item  # type: str
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLoginSwitchConfigsResponseBodyConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLoginSwitchConfigsResponseBody(TeaModel):
    def __init__(self, config_list=None, count=None, request_id=None):
        self.config_list = config_list  # type: list[DescribeLoginSwitchConfigsResponseBodyConfigList]
        self.count = count  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLoginSwitchConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeLoginSwitchConfigsResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLoginSwitchConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLoginSwitchConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLoginSwitchConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoginSwitchConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogstoreStorageRequest(TeaModel):
    def __init__(self, from_=None, lang=None):
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogstoreStorageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeLogstoreStorageResponseBody(TeaModel):
    def __init__(self, logstore=None, preserve=None, request_id=None, ttl=None, used=None, user_project=None):
        # The name of the dedicated Logstore that is used to store full logs of Security Center. The value is fixed as **sas-log**.
        self.logstore = logstore  # type: str
        # The purchased log storage capacity, in GB.
        self.preserve = preserve  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The number of days during which logs can be retained. The value is fixed as **180**, which indicates that logs can be retained for 180 days.
        # 
        # >  You are not allowed to change the value of this parameter.
        self.ttl = ttl  # type: int
        # The used log storage capacity, in GB.
        self.used = used  # type: long
        # The name of the dedicated Project that is used to store full logs of Security Center.
        self.user_project = user_project  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogstoreStorageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.preserve is not None:
            result['Preserve'] = self.preserve
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.used is not None:
            result['Used'] = self.used
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Preserve') is not None:
            self.preserve = m.get('Preserve')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        return self


class DescribeLogstoreStorageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLogstoreStorageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLogstoreStorageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogstoreStorageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMachineCanRebootRequest(TeaModel):
    def __init__(self, type=None, uuid=None):
        self.type = type  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMachineCanRebootRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeMachineCanRebootResponseBody(TeaModel):
    def __init__(self, can_reboot=None, request_id=None):
        self.can_reboot = can_reboot  # type: bool
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMachineCanRebootResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_reboot is not None:
            result['CanReboot'] = self.can_reboot
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanReboot') is not None:
            self.can_reboot = m.get('CanReboot')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMachineCanRebootResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMachineCanRebootResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMachineCanRebootResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMachineCanRebootResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeModuleConfigResponseBodyModuleConfigListItems(TeaModel):
    def __init__(self, group_id=None, instance_id=None, instance_name=None, ip=None, region=None, uuid=None):
        # The ID of the server group to which the server belongs.
        self.group_id = group_id  # type: int
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The IP address of the server.
        self.ip = ip  # type: str
        # The region in which the server resides.
        self.region = region  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeModuleConfigResponseBodyModuleConfigListItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.region is not None:
            result['Region'] = self.region
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeModuleConfigResponseBodyModuleConfigList(TeaModel):
    def __init__(self, config_name=None, items=None, module_name=None):
        # The name of the configuration.
        self.config_name = config_name  # type: str
        # The configuration items.
        self.items = items  # type: list[DescribeModuleConfigResponseBodyModuleConfigListItems]
        # The name of the module.
        self.module_name = module_name  # type: str

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeModuleConfigResponseBodyModuleConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = DescribeModuleConfigResponseBodyModuleConfigListItems()
                self.items.append(temp_model.from_map(k))
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class DescribeModuleConfigResponseBody(TeaModel):
    def __init__(self, count=None, http_status_code=None, module_config_list=None, request_id=None, success=None):
        # The number of configurations for the module.
        self.count = count  # type: int
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # An array that consists of the configurations.
        self.module_config_list = module_config_list  # type: list[DescribeModuleConfigResponseBodyModuleConfigList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        if self.module_config_list:
            for k in self.module_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeModuleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ModuleConfigList'] = []
        if self.module_config_list is not None:
            for k in self.module_config_list:
                result['ModuleConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.module_config_list = []
        if m.get('ModuleConfigList') is not None:
            for k in m.get('ModuleConfigList'):
                temp_model = DescribeModuleConfigResponseBodyModuleConfigList()
                self.module_config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeModuleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeModuleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeModuleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeModuleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNoticeConfigRequest(TeaModel):
    def __init__(self, source_ip=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNoticeConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeNoticeConfigResponseBodyNoticeConfigList(TeaModel):
    def __init__(self, ali_uid=None, current_page=None, project=None, route=None, time_limit=None):
        # The ID of the user.
        self.ali_uid = ali_uid  # type: long
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The identifier of the notification item. Valid values:
        # 
        # *   **yundun\_security_Weekreport**: notification for unhandled vulnerabilities.
        # *   **yundun\_sas\_antiransomware_task**: notification for results of restoration tasks.
        # *   **sas_healthcheck**: notification for baseline checks.
        # *   **sas_suspicious**: notification for alerts generated by Security Center.
        # *   **yundun\_aegis\_AV_true**: notification for precision defense.
        # *   **yundun\_sas\_ak_leakage**: notification for AccessKey pair leaks.
        # *   **yundun\_sas\_config_alert**: notification for configuration assessment.
        # *   **yundun\_sas\_vul_Emergency**: notification for urgent vulnerabilities.
        # *   **yundun\_webguard_event**: notification for web tamper proofing.
        # *   **yundun\_sas\_cloud\_native_firewall**: notification for alerts generated by the container firewall feature.
        # *   **yundun\_sas\_cloud\_native\_firewall_Defense**: notification for proactive defense implemented by the container firewall feature.
        # *   **yundun\_IP_Blocking**: notification for blocked brute-force attacks initiated from malicious IP addresses.
        # *   **yundun\_sas\_anti\_virus_config**: notification for virus scan.
        # *   **yundun\_sas_log**: notification for excess logs.
        # *   **yundun\_honeypot_alarm**: notification for alerts generated by the honeypot feature.
        # *   **aliyun\_rasp_alarm**: notification for alerts generated by the application security feature.
        # *   **virusScheduleTask**: notification for completion of scheduled virus scans.
        # *   **yundun\_anti_Virus**: notification that no security checks are performed.
        # *   **sas_vulnerability**: notification for vulnerabilities.
        # *   **weeklyreport**: notification for weekly reports.
        # *   **agent**: notification that the Security Center agent is offline.
        # *   **bruteforcesuccess**: notification for protection against brute-force attacks.
        # *   **webshell**: notification for webshells.
        # *   **suspicious**: notification for alerts generated by Server Guard.
        # *   **patch**: deprecated.
        # *   **remotelogin**: notification for remote logons.
        # *   **health**: notification for security checks.
        # *   **yundun\_sas\_cloudsiem_log**: notification of insufficient threat analysis log capacity.
        # >  If the value is **yundun\_security_Weekreport**, weekly reports are sent to notify you of unhandled vulnerabilities.
        self.project = project  # type: str
        # The notification method. Valid values:
        # 
        # *   **1**: text message
        # *   **2**: email
        # *   **4**: internal message
        # *   **3**: text message and email
        # *   **5**: text message and internal message
        # *   **6**: email and internal message
        # *   **7**: text message, email, and internal message
        self.route = route  # type: int
        # The time period during which Security Center sends notifications. Valid values:
        # 
        # *   **0**: any time
        # *   **1**: 08:00 to 22:00
        self.time_limit = time_limit  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNoticeConfigResponseBodyNoticeConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.project is not None:
            result['Project'] = self.project
        if self.route is not None:
            result['Route'] = self.route
        if self.time_limit is not None:
            result['TimeLimit'] = self.time_limit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Route') is not None:
            self.route = m.get('Route')
        if m.get('TimeLimit') is not None:
            self.time_limit = m.get('TimeLimit')
        return self


class DescribeNoticeConfigResponseBody(TeaModel):
    def __init__(self, notice_config_list=None, request_id=None):
        # An array that consists of the notification settings.
        self.notice_config_list = notice_config_list  # type: list[DescribeNoticeConfigResponseBodyNoticeConfigList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.notice_config_list:
            for k in self.notice_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNoticeConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NoticeConfigList'] = []
        if self.notice_config_list is not None:
            for k in self.notice_config_list:
                result['NoticeConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.notice_config_list = []
        if m.get('NoticeConfigList') is not None:
            for k in m.get('NoticeConfigList'):
                temp_model = DescribeNoticeConfigResponseBodyNoticeConfigList()
                self.notice_config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNoticeConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNoticeConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNoticeConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNoticeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNsasSuspEventTypeRequest(TeaModel):
    def __init__(self, container_field_name=None, container_field_value=None, from_=None, lang=None, name=None,
                 remark=None, source_ip=None, uuids=None):
        # The name of the container field. Valid values:
        # 
        # *   **clusterId**: the ID of the cluster
        self.container_field_name = container_field_name  # type: str
        # The value of the container field.
        self.container_field_value = container_field_value  # type: str
        # The ID of the request source. Set the value to **sas**, which indicates that the request is sent from Security Center.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the alert type.
        self.name = name  # type: str
        # The name of the server.
        self.remark = remark  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUIDs of servers. Separate multiple UUIDs with commas (,).
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~141932~~) operation to query the UUIDs of servers.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNsasSuspEventTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeNsasSuspEventTypeResponseBodyEventTypes(TeaModel):
    def __init__(self, name=None, susp_event_count=None, type=None):
        # The name of the alert type.
        self.name = name  # type: str
        # The number of assets for which an alert of the type is generated.
        self.susp_event_count = susp_event_count  # type: int
        # The alert type.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNsasSuspEventTypeResponseBodyEventTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.susp_event_count is not None:
            result['SuspEventCount'] = self.susp_event_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SuspEventCount') is not None:
            self.susp_event_count = m.get('SuspEventCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeNsasSuspEventTypeResponseBody(TeaModel):
    def __init__(self, event_types=None, request_id=None):
        # An array that consists of the information about the alert type.
        self.event_types = event_types  # type: list[DescribeNsasSuspEventTypeResponseBodyEventTypes]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.event_types:
            for k in self.event_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNsasSuspEventTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventTypes'] = []
        if self.event_types is not None:
            for k in self.event_types:
                result['EventTypes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_types = []
        if m.get('EventTypes') is not None:
            for k in m.get('EventTypes'):
                temp_model = DescribeNsasSuspEventTypeResponseBodyEventTypes()
                self.event_types.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNsasSuspEventTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNsasSuspEventTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNsasSuspEventTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNsasSuspEventTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOfflineMachinesRequest(TeaModel):
    def __init__(self, current_page=None, os=None, page_size=None, region_id_str=None, region_no=None, remark=None,
                 source_ip=None, vendor=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The operating system of the server.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **osType**, the value of the **Values** parameter indicates an operating system.
        self.os = os  # type: str
        # The number of entries to return on each page. Default value: **5**.
        self.page_size = page_size  # type: int
        # The region in which the server resides.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.
        self.region_id_str = region_id_str  # type: str
        # The region in which the server resides.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.
        self.region_no = region_no  # type: str
        # The information about the server that you want to query. The value can be the name or the public IP address of the server.
        self.remark = remark  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The source of the server. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOfflineMachinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.os is not None:
            result['Os'] = self.os
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_str is not None:
            result['RegionIdStr'] = self.region_id_str
        if self.region_no is not None:
            result['RegionNo'] = self.region_no
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdStr') is not None:
            self.region_id_str = m.get('RegionIdStr')
        if m.get('RegionNo') is not None:
            self.region_no = m.get('RegionNo')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class DescribeOfflineMachinesResponseBodyMachineList(TeaModel):
    def __init__(self, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 machine_region=None, os=None, region_id=None, uuid=None, vendor=None, vendor_name=None):
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The region in which the server resides.
        self.machine_region = machine_region  # type: str
        # The operating system of the server. Valid values:
        # 
        # *   **linux**\
        # *   **windows**\
        # *   **windows-2003**\
        self.os = os  # type: str
        # The ID of the region in which the server resides.
        self.region_id = region_id  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str
        # The source of the server. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int
        # The name of the service provider (SP) for the server.
        # 
        # Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        # *   **OUT**: a third-party service provider
        # *   **IDC**: a data center
        # *   **TENCENT**: Tencent Cloud
        # *   **HUAWEICLOUD**: Huawei Cloud
        # *   **Microsoft**: Microsoft
        # *   **AWS**: Amazon Web Services (AWS)
        # *   **TRIPARTITE**: a lightweight server
        self.vendor_name = vendor_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOfflineMachinesResponseBodyMachineList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class DescribeOfflineMachinesResponseBody(TeaModel):
    def __init__(self, current_page=None, machine_list=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of the information about servers.
        self.machine_list = machine_list  # type: list[DescribeOfflineMachinesResponseBodyMachineList]
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOfflineMachinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = DescribeOfflineMachinesResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOfflineMachinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOfflineMachinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOfflineMachinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOfflineMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOnceTaskRequest(TeaModel):
    def __init__(self, current_page=None, end_time_query=None, page_size=None, root_task_id=None,
                 start_time_query=None, task_id=None, task_type=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The timestamp when the root task ends. Unit: milliseconds.
        self.end_time_query = end_time_query  # type: long
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the root task.
        # 
        # >  You must specify at least one of the **TaskType** and **RootTaskId** parameters.
        self.root_task_id = root_task_id  # type: str
        # The timestamp when the root task starts. Unit: milliseconds.
        self.start_time_query = start_time_query  # type: long
        self.task_id = task_id  # type: str
        # The type of the task. Valid values:
        # 
        # *   **CLIENT\_PROBLEM_CHECK**: a task of the Security Center agent
        # *   **CLIENT\_DEV_OPS**: an O&M task of Cloud Assistant
        # *   **ASSET\_SECURITY_CHECK**: a task of asset information collection
        # 
        # >  You must specify at least one of the **TaskType** and **RootTaskId** parameters.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time_query is not None:
            result['EndTimeQuery'] = self.end_time_query
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.root_task_id is not None:
            result['RootTaskId'] = self.root_task_id
        if self.start_time_query is not None:
            result['StartTimeQuery'] = self.start_time_query
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTimeQuery') is not None:
            self.end_time_query = m.get('EndTimeQuery')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RootTaskId') is not None:
            self.root_task_id = m.get('RootTaskId')
        if m.get('StartTimeQuery') is not None:
            self.start_time_query = m.get('StartTimeQuery')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskResponseBodyTaskManageResponseList(TeaModel):
    def __init__(self, detail_data=None, fail_count=None, progress=None, result_info=None, success_count=None,
                 task_end_time=None, task_id=None, task_name=None, task_start_time=None, task_status=None, task_status_text=None,
                 task_type=None):
        # The execution details of the task. The value of this parameter is in the JSON format.
        # 
        # *   **causeCode**: the returned code for the cause
        # *   **causeMsg**: the returned information for the cause
        # *   **resCode**: the returned code of troubleshooting
        # *   **resMsg**: the returned information about troubleshooting
        # *   **problemType**: the type of the issue
        # *   **dispatchType**: the task delivery method
        # *   **uuid**: the UUID of the server
        # *   **instanceId**: the instance ID of the server
        # *   **internetIp**: the public IP address of the server
        # *   **intranetIp**: the private IP address of the server
        # *   **instanceName**: the instance name of the server
        # *   **url**: the download link of the troubleshooting log
        self.detail_data = detail_data  # type: str
        self.fail_count = fail_count  # type: int
        # The progress of the task. Unit: %.
        self.progress = progress  # type: str
        self.result_info = result_info  # type: str
        self.success_count = success_count  # type: int
        # The timestamp when the task ends. Unit: milliseconds.
        self.task_end_time = task_end_time  # type: long
        # The ID of the task.
        self.task_id = task_id  # type: str
        # The name of the task.
        self.task_name = task_name  # type: str
        # The timestamp when the task starts. Unit: milliseconds.
        self.task_start_time = task_start_time  # type: long
        # The status of the task. Valid values:
        # 
        # *   **1**: started
        # *   **2**: complete
        # *   **3**: failed
        # *   **4**: timed out
        self.task_status = task_status  # type: int
        # The text description of the status for the task. Valid values:
        # 
        # *   **INIT**: The task is to be started.
        # *   **START**: The task is started.
        # *   **DISPATCH**: The self-check command is issued.
        # *   **SUCCESS**: The self-check is complete.
        # *   **FAIL**: The task fails.
        # *   **TIMEOUT**: The task times out.
        self.task_status_text = task_status_text  # type: str
        # The type of the task. Valid values:
        # 
        # *   **CLIENT\_PROBLEM_CHECK**: a task of the Security Center agent
        # *   **CLIENT\_DEV_OPS**: an O&M task of Cloud Assistant
        # *   **ASSET\_SECURITY_CHECK**: a task of asset information collection
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskResponseBodyTaskManageResponseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail_data is not None:
            result['DetailData'] = self.detail_data
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_info is not None:
            result['ResultInfo'] = self.result_info
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.task_end_time is not None:
            result['TaskEndTime'] = self.task_end_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_start_time is not None:
            result['TaskStartTime'] = self.task_start_time
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_status_text is not None:
            result['TaskStatusText'] = self.task_status_text
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DetailData') is not None:
            self.detail_data = m.get('DetailData')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultInfo') is not None:
            self.result_info = m.get('ResultInfo')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('TaskEndTime') is not None:
            self.task_end_time = m.get('TaskEndTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStartTime') is not None:
            self.task_start_time = m.get('TaskStartTime')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskStatusText') is not None:
            self.task_status_text = m.get('TaskStatusText')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, task_manage_response_list=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeOnceTaskResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the tasks.
        self.task_manage_response_list = task_manage_response_list  # type: list[DescribeOnceTaskResponseBodyTaskManageResponseList]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.task_manage_response_list:
            for k in self.task_manage_response_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOnceTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TaskManageResponseList'] = []
        if self.task_manage_response_list is not None:
            for k in self.task_manage_response_list:
                result['TaskManageResponseList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeOnceTaskResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task_manage_response_list = []
        if m.get('TaskManageResponseList') is not None:
            for k in m.get('TaskManageResponseList'):
                temp_model = DescribeOnceTaskResponseBodyTaskManageResponseList()
                self.task_manage_response_list.append(temp_model.from_map(k))
        return self


class DescribeOnceTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOnceTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOnceTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOnceTaskLeafRecordPageRequest(TeaModel):
    def __init__(self, current_page=None, end_time=None, page_size=None, relate_info=None, source=None,
                 start_time=None, status_list=None, task_id=None, task_type=None):
        self.current_page = current_page  # type: int
        self.end_time = end_time  # type: long
        self.page_size = page_size  # type: int
        self.relate_info = relate_info  # type: bool
        self.source = source  # type: str
        self.start_time = start_time  # type: long
        self.status_list = status_list  # type: list[str]
        self.task_id = task_id  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.relate_info is not None:
            result['RelateInfo'] = self.relate_info
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RelateInfo') is not None:
            self.relate_info = m.get('RelateInfo')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo(TeaModel):
    def __init__(self, digest=None, image=None, pod=None, region_id=None, repo_id=None, repo_name=None,
                 repo_namespace=None, repo_region_id=None, tag=None):
        self.digest = digest  # type: str
        self.image = image  # type: str
        self.pod = pod  # type: str
        self.region_id = region_id  # type: str
        self.repo_id = repo_id  # type: str
        self.repo_name = repo_name  # type: str
        self.repo_namespace = repo_namespace  # type: str
        self.repo_region_id = repo_region_id  # type: str
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.image is not None:
            result['Image'] = self.image
        if self.pod is not None:
            result['Pod'] = self.pod
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_region_id is not None:
            result['RepoRegionId'] = self.repo_region_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Pod') is not None:
            self.pod = m.get('Pod')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoRegionId') is not None:
            self.repo_region_id = m.get('RepoRegionId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks(TeaModel):
    def __init__(self, end_time=None, finish=None, finish_count=None, progress=None, real_run_time=None,
                 result_info=None, start_time=None, status=None, status_text=None, target=None, target_type=None, task_id=None,
                 task_image_info=None, task_name=None, task_type=None, total_count=None):
        self.end_time = end_time  # type: long
        self.finish = finish  # type: int
        self.finish_count = finish_count  # type: str
        self.progress = progress  # type: long
        self.real_run_time = real_run_time  # type: long
        self.result_info = result_info  # type: str
        self.start_time = start_time  # type: long
        self.status = status  # type: str
        self.status_text = status_text  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str
        self.task_id = task_id  # type: str
        self.task_image_info = task_image_info  # type: DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str
        self.total_count = total_count  # type: str

    def validate(self):
        if self.task_image_info:
            self.task_image_info.validate()

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.finish is not None:
            result['Finish'] = self.finish
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.real_run_time is not None:
            result['RealRunTime'] = self.real_run_time
        if self.result_info is not None:
            result['ResultInfo'] = self.result_info
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.status_text is not None:
            result['StatusText'] = self.status_text
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_image_info is not None:
            result['TaskImageInfo'] = self.task_image_info.to_map()
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Finish') is not None:
            self.finish = m.get('Finish')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RealRunTime') is not None:
            self.real_run_time = m.get('RealRunTime')
        if m.get('ResultInfo') is not None:
            self.result_info = m.get('ResultInfo')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusText') is not None:
            self.status_text = m.get('StatusText')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskImageInfo') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo()
            self.task_image_info = temp_model.from_map(m['TaskImageInfo'])
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskLeafRecordPageResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeOnceTaskLeafRecordPageResponseBody(TeaModel):
    def __init__(self, once_tasks=None, page_info=None, request_id=None):
        self.once_tasks = once_tasks  # type: list[DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks]
        self.page_info = page_info  # type: DescribeOnceTaskLeafRecordPageResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.once_tasks:
            for k in self.once_tasks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OnceTasks'] = []
        if self.once_tasks is not None:
            for k in self.once_tasks:
                result['OnceTasks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.once_tasks = []
        if m.get('OnceTasks') is not None:
            for k in m.get('OnceTasks'):
                temp_model = DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks()
                self.once_tasks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOnceTaskLeafRecordPageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOnceTaskLeafRecordPageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOnceTaskLeafRecordPageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOnceTaskLeafRecordPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCountRequest(TeaModel):
    def __init__(self, type=None, uuid_list=None):
        self.type = type  # type: str
        self.uuid_list = uuid_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class DescribePropertyCountResponseBody(TeaModel):
    def __init__(self, autorun=None, cron=None, database=None, lkm=None, port=None, process=None, request_id=None,
                 sca=None, software=None, user=None, web=None, webserver=None):
        self.autorun = autorun  # type: int
        self.cron = cron  # type: int
        self.database = database  # type: int
        self.lkm = lkm  # type: int
        self.port = port  # type: int
        self.process = process  # type: int
        self.request_id = request_id  # type: str
        self.sca = sca  # type: int
        self.software = software  # type: int
        self.user = user  # type: int
        self.web = web  # type: int
        self.webserver = webserver  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.autorun is not None:
            result['Autorun'] = self.autorun
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.database is not None:
            result['Database'] = self.database
        if self.lkm is not None:
            result['Lkm'] = self.lkm
        if self.port is not None:
            result['Port'] = self.port
        if self.process is not None:
            result['Process'] = self.process
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sca is not None:
            result['Sca'] = self.sca
        if self.software is not None:
            result['Software'] = self.software
        if self.user is not None:
            result['User'] = self.user
        if self.web is not None:
            result['Web'] = self.web
        if self.webserver is not None:
            result['Webserver'] = self.webserver
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Autorun') is not None:
            self.autorun = m.get('Autorun')
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Lkm') is not None:
            self.lkm = m.get('Lkm')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Process') is not None:
            self.process = m.get('Process')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Sca') is not None:
            self.sca = m.get('Sca')
        if m.get('Software') is not None:
            self.software = m.get('Software')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Web') is not None:
            self.web = m.get('Web')
        if m.get('Webserver') is not None:
            self.webserver = m.get('Webserver')
        return self


class DescribePropertyCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCronDetailRequest(TeaModel):
    def __init__(self, current_page=None, extend=None, page_size=None, remark=None, source=None, user=None, uuid=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether fuzzy search by path to the scheduled task is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.extend = extend  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The name or IP address of the server.
        self.remark = remark  # type: str
        # The path to the scheduled task.
        self.source = source  # type: str
        # The username of the account that runs the scheduled task.
        self.user = user  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source is not None:
            result['Source'] = self.source
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyCronDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyCronDetailResponseBodyPropertys(TeaModel):
    def __init__(self, cmd=None, create_timestamp=None, instance_id=None, instance_name=None, internet_ip=None,
                 intranet_ip=None, ip=None, md_5=None, period=None, source=None, user=None, uuid=None):
        # The command that is used to run the scheduled task.
        self.cmd = cmd  # type: str
        # The timestamp of the last fingerprint collection. Unit: milliseconds.
        self.create_timestamp = create_timestamp  # type: long
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The IP addresses of the server.
        self.ip = ip  # type: str
        # The MD5 hash value of the path to the scheduled task.
        self.md_5 = md_5  # type: str
        # The interval at which the scheduled task is performed.
        self.period = period  # type: str
        # The path to the scheduled task.
        self.source = source  # type: str
        # The username of the account that runs the scheduled task.
        self.user = user  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmd is not None:
            result['Cmd'] = self.cmd
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.period is not None:
            result['Period'] = self.period
        if self.source is not None:
            result['Source'] = self.source
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cmd') is not None:
            self.cmd = m.get('Cmd')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyCronDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyCronDetailResponseBodyPageInfo
        # The details of the scheduled tasks.
        self.propertys = propertys  # type: list[DescribePropertyCronDetailResponseBodyPropertys]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyCronDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyCronDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyCronDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyCronDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyCronDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyCronDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCronDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyCronItemRequest(TeaModel):
    def __init__(self, current_page=None, force_flush=None, page_size=None, source=None):
        self.current_page = current_page  # type: int
        self.force_flush = force_flush  # type: bool
        self.page_size = page_size  # type: int
        self.source = source  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribePropertyCronItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyCronItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, source=None):
        self.count = count  # type: int
        self.source = source  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyCronItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribePropertyCronItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertyCronItemResponseBodyPageInfo
        self.property_items = property_items  # type: list[DescribePropertyCronItemResponseBodyPropertyItems]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyCronItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyCronItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyCronItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyCronItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyCronItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyCronItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyCronItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyPortDetailRequest(TeaModel):
    def __init__(self, bind_ip=None, current_page=None, extend=None, page_size=None, port=None, proc_name=None,
                 remark=None, uuid=None):
        self.bind_ip = bind_ip  # type: str
        self.current_page = current_page  # type: int
        self.extend = extend  # type: str
        self.page_size = page_size  # type: int
        self.port = port  # type: str
        self.proc_name = proc_name  # type: str
        self.remark = remark  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_ip is not None:
            result['BindIp'] = self.bind_ip
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.port is not None:
            result['Port'] = self.port
        if self.proc_name is not None:
            result['ProcName'] = self.proc_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindIp') is not None:
            self.bind_ip = m.get('BindIp')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcName') is not None:
            self.proc_name = m.get('ProcName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyPortDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyPortDetailResponseBodyPropertys(TeaModel):
    def __init__(self, bind_ip=None, create_timestamp=None, instance_id=None, instance_name=None, internet_ip=None,
                 intranet_ip=None, ip=None, pid=None, port=None, proc_name=None, proto=None, uuid=None):
        self.bind_ip = bind_ip  # type: str
        self.create_timestamp = create_timestamp  # type: long
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.ip = ip  # type: str
        self.pid = pid  # type: str
        self.port = port  # type: str
        self.proc_name = proc_name  # type: str
        self.proto = proto  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_ip is not None:
            result['BindIp'] = self.bind_ip
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.proc_name is not None:
            result['ProcName'] = self.proc_name
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindIp') is not None:
            self.bind_ip = m.get('BindIp')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcName') is not None:
            self.proc_name = m.get('ProcName')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyPortDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertyPortDetailResponseBodyPageInfo
        self.propertys = propertys  # type: list[DescribePropertyPortDetailResponseBodyPropertys]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyPortDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyPortDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyPortDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyPortDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyPortDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyPortDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyPortDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyPortItemRequest(TeaModel):
    def __init__(self, current_page=None, force_flush=None, page_size=None, port=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # Specifies whether to forcefully refresh the data that you want to query.
        self.force_flush = force_flush  # type: bool
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The port number.
        self.port = port  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class DescribePropertyPortItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyPortItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, port=None, proto=None):
        # The number of servers that use the port.
        self.count = count  # type: int
        # The number of the listening port.
        self.port = port  # type: str
        # The network protocol of the port.
        self.proto = proto  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyPortItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.port is not None:
            result['Port'] = self.port
        if self.proto is not None:
            result['Proto'] = self.proto
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        return self


class DescribePropertyPortItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyPortItemResponseBodyPageInfo
        # An array that consists of the ports returned.
        self.property_items = property_items  # type: list[DescribePropertyPortItemResponseBodyPropertyItems]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyPortItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyPortItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyPortItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyPortItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyPortItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyPortItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyPortItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyProcDetailRequest(TeaModel):
    def __init__(self, cmdline=None, current_page=None, extend=None, name=None, page_size=None, proc_time_end=None,
                 proc_time_start=None, remark=None, user=None, uuid=None):
        # The startup parameter of the process.
        self.cmdline = cmdline  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether fuzzy search by process name is supported. If you want to use fuzzy search, set the parameter to 1. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.extend = extend  # type: str
        # The name of the process.
        self.name = name  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The timestamp when the process ends. Unit: milliseconds.
        self.proc_time_end = proc_time_end  # type: long
        # The timestamp when the process starts. Unit: milliseconds.
        self.proc_time_start = proc_time_start  # type: long
        # The name or IP address of the server.
        self.remark = remark  # type: str
        # The user who runs the process.
        self.user = user  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.proc_time_end is not None:
            result['ProcTimeEnd'] = self.proc_time_end
        if self.proc_time_start is not None:
            result['ProcTimeStart'] = self.proc_time_start
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcTimeEnd') is not None:
            self.proc_time_end = m.get('ProcTimeEnd')
        if m.get('ProcTimeStart') is not None:
            self.proc_time_start = m.get('ProcTimeStart')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyProcDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyProcDetailResponseBodyPropertys(TeaModel):
    def __init__(self, cmdline=None, create_timestamp=None, euid_name=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, is_package=None, md_5=None, name=None, path=None, pid=None, pname=None,
                 start_time=None, start_time_dt=None, state=None, user=None, uuid=None):
        # The startup parameter of the process.
        self.cmdline = cmdline  # type: str
        # The timestamp of last data collection. Unit: milliseconds.
        self.create_timestamp = create_timestamp  # type: long
        # The permission that is required to run the process.
        self.euid_name = euid_name  # type: str
        # The ID of the server that is associated with the process.
        self.instance_id = instance_id  # type: str
        # The name of the server that is associated with the process.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # Indicates whether the process is a package installation process. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.is_package = is_package  # type: int
        # The MD5 hash value of the process file.
        self.md_5 = md_5  # type: str
        # The name of the process.
        self.name = name  # type: str
        # The path of the process.
        self.path = path  # type: str
        # The ID of the process.
        self.pid = pid  # type: str
        # The name of the parent process to which the process belongs.
        self.pname = pname  # type: str
        # The time when the process starts.
        self.start_time = start_time  # type: str
        # The timestamp when the process starts. Unit: milliseconds.
        self.start_time_dt = start_time_dt  # type: long
        # The status of the process.
        self.state = state  # type: str
        # The user who runs the process.
        self.user = user  # type: str
        # The UUID of the server that is associated with the process.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.euid_name is not None:
            result['EuidName'] = self.euid_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.is_package is not None:
            result['IsPackage'] = self.is_package
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.pname is not None:
            result['Pname'] = self.pname
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_time_dt is not None:
            result['StartTimeDt'] = self.start_time_dt
        if self.state is not None:
            result['State'] = self.state
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EuidName') is not None:
            self.euid_name = m.get('EuidName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('IsPackage') is not None:
            self.is_package = m.get('IsPackage')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Pname') is not None:
            self.pname = m.get('Pname')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimeDt') is not None:
            self.start_time_dt = m.get('StartTimeDt')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyProcDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyProcDetailResponseBodyPageInfo
        # An array that consists of the fingerprints of the processes.
        self.propertys = propertys  # type: list[DescribePropertyProcDetailResponseBodyPropertys]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyProcDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyProcDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyProcDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyProcDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyProcDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyProcDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyProcDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyProcItemRequest(TeaModel):
    def __init__(self, current_page=None, force_flush=None, name=None, page_size=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # Specifies whether to forcefully refresh the data that you want to query.
        self.force_flush = force_flush  # type: bool
        # The name of the process.
        self.name = name  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertyProcItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyProcItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, name=None):
        # The number of servers on which the process runs.
        self.count = count  # type: int
        # The name of the process.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyProcItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertyProcItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyProcItemResponseBodyPageInfo
        # An array that consists of the processes returned.
        self.property_items = property_items  # type: list[DescribePropertyProcItemResponseBodyPropertyItems]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyProcItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyProcItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyProcItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyProcItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyProcItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyProcItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyProcItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScaDetailRequest(TeaModel):
    def __init__(self, biz=None, biz_type=None, current_page=None, lang=None, name=None, page_size=None, pid=None,
                 port=None, process_started_end=None, process_started_start=None, remark=None, sca_name=None,
                 sca_name_pattern=None, sca_version=None, search_info=None, search_info_sub=None, search_item=None,
                 search_item_sub=None, user=None, uuid=None):
        # The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:
        # 
        # *   **sca**: middleware
        # *   **sca_database**: database
        # *   **sca_web**: web service
        # 
        # >  If you do not specify this parameter, the default value **sca** is used, which indicates that middleware fingerprints are queried.
        self.biz = biz  # type: str
        # The type of the middleware, database, or web service that you want to query. Valid values:
        # 
        # *   **system_service**: system service
        # *   **software_library**: software library
        # *   **docker_component**: container component
        # *   **database**: database
        # *   **web_container**: web container
        # *   **jar**: JAR package
        # *   **web_framework**: web framework
        self.biz_type = biz_type  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the middleware, database, or web service.
        # 
        # >  This parameter is deprecated. You can ignore it.
        self.name = name  # type: long
        # The number of entries to return on each page. Default value: **10**.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        # The PID.
        self.pid = pid  # type: str
        # The port that the process monitors.
        self.port = port  # type: str
        # The timestamp when the process ends. Unit: milliseconds.
        self.process_started_end = process_started_end  # type: long
        # The timestamp when the process starts. Unit: milliseconds.
        self.process_started_start = process_started_start  # type: long
        # The search condition, such as a server name or a server IP address.
        # 
        # >  Fuzzy match is supported.
        self.remark = remark  # type: str
        # The name of the asset fingerprint that you want to query.
        self.sca_name = sca_name  # type: str
        # The name of the process.
        self.sca_name_pattern = sca_name_pattern  # type: str
        # The version of the middleware, database, or web service.
        self.sca_version = sca_version  # type: str
        # The search keyword. You must specify this parameter based on the value of the **SearchItem** parameter.
        # 
        # *   If the **SearchItem** parameter is set to **name**, you must enter the name of an asset fingerprint.
        # 
        # *   If the **SearchItem** parameter is set to **type**, you must enter the type of an asset fingerprint. Valid values:
        # 
        #     *   **system_service**: system service
        #     *   **software_library**: software library
        #     *   **docker_component**: container component
        #     *   **database**: database
        #     *   **web_container**: web container
        #     *   **jar**: JAR package
        #     *   **web_framework**: web framework
        # 
        # >  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.search_info = search_info  # type: str
        # The keyword of the subquery. You must specify this parameter based on the value of the **SearchItemSub** parameter.
        # 
        # *   If the **SearchItemSub** parameter is set to **port**, you must enter a port number.
        # *   If the **SearchItemSub** parameter is set to **pid**, you must enter a process ID (PID).
        # *   If the **SearchItemSub** parameter is set to **version**, you must enter the version of a database, middleware, or web service.
        # *   If the **SearchItemSub** parameter is set to **user**, you must enter a username.
        # 
        # >  The subquery is used to search for data of a specified database, middleware, or web service.
        self.search_info_sub = search_info_sub  # type: str
        # The type of the search condition. Valid values:
        # 
        # *   **name**: the name of a database, middleware, or web service
        # *   **type**: the type of a database, middleware, or web service
        # 
        # >  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.
        self.search_item = search_item  # type: str
        # The type of the subquery. Valid values:
        # 
        # *   **port**\
        # *   **pid**\
        # *   **version**\
        # *   **user**\
        self.search_item_sub = search_item_sub  # type: str
        # The user who runs the process.
        self.user = user  # type: str
        # The UUID of the server on which the middleware, database, or web service is run.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.process_started_end is not None:
            result['ProcessStartedEnd'] = self.process_started_end
        if self.process_started_start is not None:
            result['ProcessStartedStart'] = self.process_started_start
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sca_name is not None:
            result['ScaName'] = self.sca_name
        if self.sca_name_pattern is not None:
            result['ScaNamePattern'] = self.sca_name_pattern
        if self.sca_version is not None:
            result['ScaVersion'] = self.sca_version
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_info_sub is not None:
            result['SearchInfoSub'] = self.search_info_sub
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        if self.search_item_sub is not None:
            result['SearchItemSub'] = self.search_item_sub
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcessStartedEnd') is not None:
            self.process_started_end = m.get('ProcessStartedEnd')
        if m.get('ProcessStartedStart') is not None:
            self.process_started_start = m.get('ProcessStartedStart')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScaName') is not None:
            self.sca_name = m.get('ScaName')
        if m.get('ScaNamePattern') is not None:
            self.sca_name_pattern = m.get('ScaNamePattern')
        if m.get('ScaVersion') is not None:
            self.sca_version = m.get('ScaVersion')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchInfoSub') is not None:
            self.search_info_sub = m.get('SearchInfoSub')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        if m.get('SearchItemSub') is not None:
            self.search_item_sub = m.get('SearchItemSub')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyScaDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyScaDetailResponseBodyPropertys(TeaModel):
    def __init__(self, biz_type=None, biz_type_dispaly=None, cmdline=None, config_path=None, container_name=None,
                 create_timestamp=None, image_name=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 ip=None, listen_ip=None, listen_protocol=None, listen_status=None, name=None, path=None, pid=None,
                 port=None, ppid=None, process_started=None, process_user=None, proof=None, runtime_env_version=None,
                 type=None, uuid=None, version=None, web_path=None):
        # The type of the middleware, database, or web service. Valid values:
        # 
        # *   **system_service**: system service
        # *   **software_library**: software library
        # *   **docker_component**: container component
        # *   **database**: database
        # *   **web_container**: web container
        # *   **jar**: JAR package
        # *   **web_framework**: web framework
        self.biz_type = biz_type  # type: str
        # The display name of the type of the middleware, database, or web service . Valid values:
        # 
        # *   System service
        # *   Software library
        # *   Container component
        # *   Database
        # *   Web container
        # *   JAR package
        # *   Web framework
        self.biz_type_dispaly = biz_type_dispaly  # type: str
        # The command line of the process.
        self.cmdline = cmdline  # type: str
        # The path to the configuration file.
        self.config_path = config_path  # type: str
        # The name of the container.
        self.container_name = container_name  # type: str
        # The latest collection timestamp, which indicates the last timestamp when Security Center collected the information about the middleware, database, or web service. Unit: milliseconds.
        self.create_timestamp = create_timestamp  # type: long
        # The name of the image.
        self.image_name = image_name  # type: str
        # The ID of the server on which the middleware, database, or web service is run.
        self.instance_id = instance_id  # type: str
        # The name of the server on which the middleware, database, or web service is run.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server on which the middleware, database, or web service is run.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server on which the middleware, database, or web service is run.
        self.intranet_ip = intranet_ip  # type: str
        # The public IP address of the server on which the middleware, database, or web service is run.
        self.ip = ip  # type: str
        # The IP address that the process monitors.
        self.listen_ip = listen_ip  # type: str
        # The protocol of the traffic on which the process listens. Valid values:
        # 
        # *   **UDP**\
        # *   **TCP**\
        self.listen_protocol = listen_protocol  # type: str
        # The listening status of the process. Valid values:
        # 
        # *   **NONE**: not listening
        # *   **LISTEN**: listening
        self.listen_status = listen_status  # type: str
        # The name of the middleware, database, or web service.
        self.name = name  # type: str
        # The path of the middleware, database, or web service.
        self.path = path  # type: str
        # The PID.
        self.pid = pid  # type: str
        # The port of the middleware, database, or web service.
        self.port = port  # type: str
        # The ID of the parent process.
        self.ppid = ppid  # type: str
        # The timestamp when the process starts. Unit: milliseconds.
        self.process_started = process_started  # type: long
        # The name of the user who runs the process.
        self.process_user = process_user  # type: str
        # The version verification information about the middleware, database, or web service.
        self.proof = proof  # type: str
        # The version of the runtime environment.
        # 
        # >  The value of this parameter can be the Java Development Kit (JDK) version of the runtime environment for a Java process.
        self.runtime_env_version = runtime_env_version  # type: str
        # The type of the middleware, database, or web service.
        self.type = type  # type: str
        # The UUID of the server on which the middleware, database, or web service is run.
        self.uuid = uuid  # type: str
        # The version of the middleware, database, or web service.
        self.version = version  # type: str
        # The web directory.
        self.web_path = web_path  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.biz_type_dispaly is not None:
            result['BizTypeDispaly'] = self.biz_type_dispaly
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.config_path is not None:
            result['ConfigPath'] = self.config_path
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.listen_ip is not None:
            result['ListenIp'] = self.listen_ip
        if self.listen_protocol is not None:
            result['ListenProtocol'] = self.listen_protocol
        if self.listen_status is not None:
            result['ListenStatus'] = self.listen_status
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.ppid is not None:
            result['Ppid'] = self.ppid
        if self.process_started is not None:
            result['ProcessStarted'] = self.process_started
        if self.process_user is not None:
            result['ProcessUser'] = self.process_user
        if self.proof is not None:
            result['Proof'] = self.proof
        if self.runtime_env_version is not None:
            result['RuntimeEnvVersion'] = self.runtime_env_version
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('BizTypeDispaly') is not None:
            self.biz_type_dispaly = m.get('BizTypeDispaly')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('ConfigPath') is not None:
            self.config_path = m.get('ConfigPath')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('ListenIp') is not None:
            self.listen_ip = m.get('ListenIp')
        if m.get('ListenProtocol') is not None:
            self.listen_protocol = m.get('ListenProtocol')
        if m.get('ListenStatus') is not None:
            self.listen_status = m.get('ListenStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Ppid') is not None:
            self.ppid = m.get('Ppid')
        if m.get('ProcessStarted') is not None:
            self.process_started = m.get('ProcessStarted')
        if m.get('ProcessUser') is not None:
            self.process_user = m.get('ProcessUser')
        if m.get('Proof') is not None:
            self.proof = m.get('Proof')
        if m.get('RuntimeEnvVersion') is not None:
            self.runtime_env_version = m.get('RuntimeEnvVersion')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class DescribePropertyScaDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyScaDetailResponseBodyPageInfo
        # The details about the asset fingerprints returned.
        self.propertys = propertys  # type: list[DescribePropertyScaDetailResponseBodyPropertys]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyScaDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyScaDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyScaDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScaDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyScaDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyScaDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScaDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScaItemRequest(TeaModel):
    def __init__(self, biz=None, current_page=None, force_flush=None, lang=None, page_size=None, search_info=None,
                 search_item=None):
        self.biz = biz  # type: str
        self.current_page = current_page  # type: int
        self.force_flush = force_flush  # type: bool
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.search_info = search_info  # type: str
        self.search_item = search_item  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        return self


class DescribePropertyScaItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyScaItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, biz_type=None, count=None, name=None, type_display=None):
        self.biz_type = biz_type  # type: str
        self.count = count  # type: int
        self.name = name  # type: str
        self.type_display = type_display  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScaItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        if self.type_display is not None:
            result['TypeDisplay'] = self.type_display
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TypeDisplay') is not None:
            self.type_display = m.get('TypeDisplay')
        return self


class DescribePropertyScaItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertyScaItemResponseBodyPageInfo
        self.property_items = property_items  # type: list[DescribePropertyScaItemResponseBodyPropertyItems]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyScaItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyScaItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyScaItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScaItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyScaItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyScaItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScaItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyScheduleConfigRequest(TeaModel):
    def __init__(self, type=None):
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScheduleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyScheduleConfigResponseBody(TeaModel):
    def __init__(self, config=None, request_id=None):
        self.config = config  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyScheduleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyScheduleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyScheduleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyScheduleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertySoftwareDetailRequest(TeaModel):
    def __init__(self, current_page=None, extend=None, install_time_end=None, install_time_start=None, name=None,
                 page_size=None, path=None, remark=None, software_version=None, uuid=None):
        self.current_page = current_page  # type: int
        self.extend = extend  # type: str
        self.install_time_end = install_time_end  # type: long
        self.install_time_start = install_time_start  # type: long
        self.name = name  # type: str
        self.page_size = page_size  # type: int
        self.path = path  # type: str
        self.remark = remark  # type: str
        self.software_version = software_version  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.install_time_end is not None:
            result['InstallTimeEnd'] = self.install_time_end
        if self.install_time_start is not None:
            result['InstallTimeStart'] = self.install_time_start
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.path is not None:
            result['Path'] = self.path
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.software_version is not None:
            result['SoftwareVersion'] = self.software_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('InstallTimeEnd') is not None:
            self.install_time_end = m.get('InstallTimeEnd')
        if m.get('InstallTimeStart') is not None:
            self.install_time_start = m.get('InstallTimeStart')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SoftwareVersion') is not None:
            self.software_version = m.get('SoftwareVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertySoftwareDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertySoftwareDetailResponseBodyPropertys(TeaModel):
    def __init__(self, create_timestamp=None, install_time=None, install_time_dt=None, instance_id=None,
                 instance_name=None, internet_ip=None, intranet_ip=None, ip=None, name=None, path=None, uuid=None, version=None):
        self.create_timestamp = create_timestamp  # type: long
        self.install_time = install_time  # type: str
        self.install_time_dt = install_time_dt  # type: long
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.ip = ip  # type: str
        self.name = name  # type: str
        self.path = path  # type: str
        self.uuid = uuid  # type: str
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.install_time is not None:
            result['InstallTime'] = self.install_time
        if self.install_time_dt is not None:
            result['InstallTimeDt'] = self.install_time_dt
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('InstallTime') is not None:
            self.install_time = m.get('InstallTime')
        if m.get('InstallTimeDt') is not None:
            self.install_time_dt = m.get('InstallTimeDt')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribePropertySoftwareDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertySoftwareDetailResponseBodyPageInfo
        self.propertys = propertys  # type: list[DescribePropertySoftwareDetailResponseBodyPropertys]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertySoftwareDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertySoftwareDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertySoftwareDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertySoftwareDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertySoftwareDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertySoftwareDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertySoftwareDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertySoftwareItemRequest(TeaModel):
    def __init__(self, current_page=None, force_flush=None, name=None, page_size=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # Specifies whether to forcefully refresh the data that you want to query.
        self.force_flush = force_flush  # type: bool
        # The name of the software that you want to query.
        self.name = name  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertySoftwareItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertySoftwareItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, name=None):
        # The number of servers on which the software is installed.
        self.count = count  # type: int
        # The name of the software.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertySoftwareItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertySoftwareItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertySoftwareItemResponseBodyPageInfo
        # An array that consists of the software assets returned.
        self.property_items = property_items  # type: list[DescribePropertySoftwareItemResponseBodyPropertyItems]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertySoftwareItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertySoftwareItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertySoftwareItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertySoftwareItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertySoftwareItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertySoftwareItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertySoftwareItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyTypeScaItemRequest(TeaModel):
    def __init__(self, current_page=None, lang=None, page_size=None):
        self.current_page = current_page  # type: int
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyTypeScaItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePropertyTypeScaItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyTypeScaItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyTypeScaItemResponseBodyPropertyTypeItems(TeaModel):
    def __init__(self, name=None, type=None):
        self.name = name  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyTypeScaItemResponseBodyPropertyTypeItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyTypeScaItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_type_items=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertyTypeScaItemResponseBodyPageInfo
        self.property_type_items = property_type_items  # type: list[DescribePropertyTypeScaItemResponseBodyPropertyTypeItems]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_type_items:
            for k in self.property_type_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyTypeScaItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyTypeItems'] = []
        if self.property_type_items is not None:
            for k in self.property_type_items:
                result['PropertyTypeItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyTypeScaItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_type_items = []
        if m.get('PropertyTypeItems') is not None:
            for k in m.get('PropertyTypeItems'):
                temp_model = DescribePropertyTypeScaItemResponseBodyPropertyTypeItems()
                self.property_type_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyTypeScaItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyTypeScaItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyTypeScaItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyTypeScaItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUsageNewestRequest(TeaModel):
    def __init__(self, type=None):
        # The type of the accounts.
        # 
        # Valid values:
        # 
        # *   user
        # *   system
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUsageNewestRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyUsageNewestResponseBodyNewestStatisticItems(TeaModel):
    def __init__(self, create=None, name=None):
        # The time when the account was created.
        self.create = create  # type: long
        # The username of the account.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUsageNewestResponseBodyNewestStatisticItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create is not None:
            result['Create'] = self.create
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Create') is not None:
            self.create = m.get('Create')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribePropertyUsageNewestResponseBody(TeaModel):
    def __init__(self, item_count=None, newest_statistic_items=None, request_id=None, type=None):
        # The number of accounts.
        self.item_count = item_count  # type: int
        # An array that consists of the accounts.
        self.newest_statistic_items = newest_statistic_items  # type: list[DescribePropertyUsageNewestResponseBodyNewestStatisticItems]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The type of the accounts that are created on the server. The value is fixed as user, which indicates user accounts.
        self.type = type  # type: str

    def validate(self):
        if self.newest_statistic_items:
            for k in self.newest_statistic_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyUsageNewestResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_count is not None:
            result['ItemCount'] = self.item_count
        result['NewestStatisticItems'] = []
        if self.newest_statistic_items is not None:
            for k in self.newest_statistic_items:
                result['NewestStatisticItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ItemCount') is not None:
            self.item_count = m.get('ItemCount')
        self.newest_statistic_items = []
        if m.get('NewestStatisticItems') is not None:
            for k in m.get('NewestStatisticItems'):
                temp_model = DescribePropertyUsageNewestResponseBodyNewestStatisticItems()
                self.newest_statistic_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePropertyUsageNewestResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyUsageNewestResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyUsageNewestResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUsageNewestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUserDetailRequest(TeaModel):
    def __init__(self, current_page=None, extend=None, is_root=None, last_login_time_end=None,
                 last_login_time_start=None, page_size=None, remark=None, user=None, uuid=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the fuzzy search by account name is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.
        self.extend = extend  # type: str
        # Specifies whether the account has root permissions. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_root = is_root  # type: str
        # The timestamp of the last logoff from the account. Unit: milliseconds.
        self.last_login_time_end = last_login_time_end  # type: long
        # The timestamp of the last logon to the account. Unit: milliseconds.
        self.last_login_time_start = last_login_time_start  # type: long
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The name or IP address of the server.
        self.remark = remark  # type: str
        # The name of the account to which the server belongs.
        self.user = user  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.is_root is not None:
            result['IsRoot'] = self.is_root
        if self.last_login_time_end is not None:
            result['LastLoginTimeEnd'] = self.last_login_time_end
        if self.last_login_time_start is not None:
            result['LastLoginTimeStart'] = self.last_login_time_start
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('IsRoot') is not None:
            self.is_root = m.get('IsRoot')
        if m.get('LastLoginTimeEnd') is not None:
            self.last_login_time_end = m.get('LastLoginTimeEnd')
        if m.get('LastLoginTimeStart') is not None:
            self.last_login_time_start = m.get('LastLoginTimeStart')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyUserDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyUserDetailResponseBodyPropertys(TeaModel):
    def __init__(self, accounts_expiration_date=None, create_timestamp=None, group_names=None, instance_id=None,
                 instance_name=None, internet_ip=None, intranet_ip=None, ip=None, is_could_login=None, is_passwd_expired=None,
                 is_passwd_locked=None, is_root=None, is_sudoer=None, is_user_expired=None, last_login_ip=None, last_login_time=None,
                 last_login_time_dt=None, last_login_timestamp=None, password_expiration_date=None, status=None, user=None, uuid=None):
        # The date on which the account expires.
        self.accounts_expiration_date = accounts_expiration_date  # type: str
        # The timestamp at which the last asset fingerprint collection is performed. Unit: milliseconds.
        self.create_timestamp = create_timestamp  # type: long
        # The details of the user groups to which the account belongs.
        self.group_names = group_names  # type: list[str]
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The IP addresses of the server.
        self.ip = ip  # type: str
        # Indicates whether the account is an interactive logon account. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_could_login = is_could_login  # type: int
        # Indicates whether the password expires. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.is_passwd_expired = is_passwd_expired  # type: int
        # Indicates whether the password is locked. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.is_passwd_locked = is_passwd_locked  # type: int
        # Indicates whether the account has root permissions. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_root = is_root  # type: str
        # Indicates whether the account is a sudo account. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_sudoer = is_sudoer  # type: int
        # Indicates whether the account expires. Valid values:
        # 
        # *   **0**: yes
        # *   **1**: no
        self.is_user_expired = is_user_expired  # type: int
        # The source IP address of the last logon to the account.
        self.last_login_ip = last_login_ip  # type: str
        # The last logon time of the account.
        self.last_login_time = last_login_time  # type: str
        # The timestamp of the last logon to the account. Unit: milliseconds.
        self.last_login_time_dt = last_login_time_dt  # type: long
        # The timestamp of the last logon to the account. Unit: milliseconds.
        self.last_login_timestamp = last_login_timestamp  # type: long
        # The date on which the password of the account expires.
        self.password_expiration_date = password_expiration_date  # type: str
        # This parameter is deprecated. You can ignore it.
        self.status = status  # type: str
        # The name of the account.
        self.user = user  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accounts_expiration_date is not None:
            result['AccountsExpirationDate'] = self.accounts_expiration_date
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.group_names is not None:
            result['GroupNames'] = self.group_names
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.is_could_login is not None:
            result['IsCouldLogin'] = self.is_could_login
        if self.is_passwd_expired is not None:
            result['IsPasswdExpired'] = self.is_passwd_expired
        if self.is_passwd_locked is not None:
            result['IsPasswdLocked'] = self.is_passwd_locked
        if self.is_root is not None:
            result['IsRoot'] = self.is_root
        if self.is_sudoer is not None:
            result['IsSudoer'] = self.is_sudoer
        if self.is_user_expired is not None:
            result['IsUserExpired'] = self.is_user_expired
        if self.last_login_ip is not None:
            result['LastLoginIp'] = self.last_login_ip
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.last_login_time_dt is not None:
            result['LastLoginTimeDt'] = self.last_login_time_dt
        if self.last_login_timestamp is not None:
            result['LastLoginTimestamp'] = self.last_login_timestamp
        if self.password_expiration_date is not None:
            result['PasswordExpirationDate'] = self.password_expiration_date
        if self.status is not None:
            result['Status'] = self.status
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountsExpirationDate') is not None:
            self.accounts_expiration_date = m.get('AccountsExpirationDate')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('GroupNames') is not None:
            self.group_names = m.get('GroupNames')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IsCouldLogin') is not None:
            self.is_could_login = m.get('IsCouldLogin')
        if m.get('IsPasswdExpired') is not None:
            self.is_passwd_expired = m.get('IsPasswdExpired')
        if m.get('IsPasswdLocked') is not None:
            self.is_passwd_locked = m.get('IsPasswdLocked')
        if m.get('IsRoot') is not None:
            self.is_root = m.get('IsRoot')
        if m.get('IsSudoer') is not None:
            self.is_sudoer = m.get('IsSudoer')
        if m.get('IsUserExpired') is not None:
            self.is_user_expired = m.get('IsUserExpired')
        if m.get('LastLoginIp') is not None:
            self.last_login_ip = m.get('LastLoginIp')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('LastLoginTimeDt') is not None:
            self.last_login_time_dt = m.get('LastLoginTimeDt')
        if m.get('LastLoginTimestamp') is not None:
            self.last_login_timestamp = m.get('LastLoginTimestamp')
        if m.get('PasswordExpirationDate') is not None:
            self.password_expiration_date = m.get('PasswordExpirationDate')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribePropertyUserDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribePropertyUserDetailResponseBodyPageInfo
        # The details of asset fingerprints for the account.
        self.propertys = propertys  # type: list[DescribePropertyUserDetailResponseBodyPropertys]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyUserDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyUserDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = DescribePropertyUserDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyUserDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyUserDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyUserDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUserDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePropertyUserItemRequest(TeaModel):
    def __init__(self, current_page=None, force_flush=None, page_size=None, user=None):
        self.current_page = current_page  # type: int
        self.force_flush = force_flush  # type: bool
        self.page_size = page_size  # type: int
        self.user = user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribePropertyUserItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePropertyUserItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, user=None):
        self.count = count  # type: int
        self.user = user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePropertyUserItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribePropertyUserItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        self.page_info = page_info  # type: DescribePropertyUserItemResponseBodyPageInfo
        self.property_items = property_items  # type: list[DescribePropertyUserItemResponseBodyPropertyItems]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePropertyUserItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribePropertyUserItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = DescribePropertyUserItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePropertyUserItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePropertyUserItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePropertyUserItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePropertyUserItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQuaraFileDownloadInfoRequest(TeaModel):
    def __init__(self, from_=None, quara_file_id=None):
        self.from_ = from_  # type: str
        self.quara_file_id = quara_file_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeQuaraFileDownloadInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        return self


class DescribeQuaraFileDownloadInfoResponseBody(TeaModel):
    def __init__(self, download_url=None, md_5=None, path=None, quara_file_id=None, request_id=None, tag=None,
                 uuid=None):
        self.download_url = download_url  # type: str
        self.md_5 = md_5  # type: str
        self.path = path  # type: str
        self.quara_file_id = quara_file_id  # type: int
        self.request_id = request_id  # type: str
        self.tag = tag  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeQuaraFileDownloadInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.path is not None:
            result['Path'] = self.path
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeQuaraFileDownloadInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeQuaraFileDownloadInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeQuaraFileDownloadInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQuaraFileDownloadInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRestoreJobsRequest(TeaModel):
    def __init__(self, current_page=None, machine_remark=None, page_size=None, status=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The unique identifier of the server on which the restoration task is run. For example, you can use the IP address or the name of the server.
        self.machine_remark = machine_remark  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The status of the restoration task. Valid values:
        # 
        # *   **RUNNING**: The task is running.
        # *   **COMPLETE**: The task is complete.
        # *   **FAILED**: The task fails.
        # *   **CANCELING**: The task is being canceled.
        # *   **CANCELED**: The task is canceled.
        # *   **PARTIAL_COMPLETE**: The task is partially successful.
        # *   **CREATED**: The task is created but is not run.
        # *   **EXPIRED**: The task is not updated.
        # *   **QUEUED**: The task is waiting to be run.
        # *   **CLIENT_DELETED**: The task fails because the anti-ransomware agent is uninstalled.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestoreJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRestoreJobsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of restoration tasks returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The total number of restoration tasks returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestoreJobsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRestoreJobsResponseBodyRestoreJobs(TeaModel):
    def __init__(self, actual_bytes=None, bytes_done=None, bytes_total=None, client_id=None, complete_time=None,
                 created_time=None, duration=None, error_count=None, error_file=None, error_file_url=None, error_type=None,
                 eta=None, excludes=None, exit_code=None, gmt_create=None, gmt_modified=None, includes=None,
                 instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None, items_done=None, items_total=None,
                 message=None, percentage=None, request_id=None, restore_id=None, restore_name=None, restore_type=None,
                 snapshot_hash=None, snapshot_id=None, snapshot_version=None, source=None, source_client_id=None, speed=None,
                 status=None, target=None, updated_time=None, uuid=None, vault_id=None):
        # The size of backup data. Unit: bytes.
        self.actual_bytes = actual_bytes  # type: long
        # The total size of data that is restored. Unit: bytes.
        self.bytes_done = bytes_done  # type: long
        # The total size of data that you want to restore. Unit: bytes.
        self.bytes_total = bytes_total  # type: long
        # The ID of the anti-ransomware agent that is used to restore data.
        self.client_id = client_id  # type: str
        # The timestamp when the restoration task is complete. Unit: milliseconds.
        self.complete_time = complete_time  # type: long
        # The timestamp when the restoration task is created. Unit: milliseconds.
        self.created_time = created_time  # type: long
        # The duration of the restoration task. Unit: seconds.
        self.duration = duration  # type: long
        # The number of the restoration tasks on which errors occur.
        self.error_count = error_count  # type: long
        # The name of the CSV file. The CSV file contains the files that fail to be restored.
        self.error_file = error_file  # type: str
        # The URL to download the CSV file. The CSV file contains the files that fail to be restored.
        self.error_file_url = error_file_url  # type: str
        # The error code that is returned for the restoration task.
        self.error_type = error_type  # type: str
        # The timestamp when the in-progress restoration task is expected to be complete. Unit: seconds.
        self.eta = eta  # type: long
        # The directory excluded from the anti-ransomware policy. The value is the directory that you specify to skip protection when you create the anti-ransomware policy.
        self.excludes = excludes  # type: str
        # The return value of the restoration task.
        self.exit_code = exit_code  # type: str
        # The time when the restoration task is created.
        self.gmt_create = gmt_create  # type: str
        # The time when the restoration task is updated.
        self.gmt_modified = gmt_modified  # type: str
        # The included directory based on which the files to restore are located. The value is the directory that you specify for protection when you create the anti-ransomware policy
        self.includes = includes  # type: str
        # The ID of the server whose data you want to restore.
        self.instance_id = instance_id  # type: str
        # The name of the server whose data you want to restore.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server whose data you want to restore.
        self.internet_ip = internet_ip  # type: str
        # The internal IP address of the server whose data you want to restore.
        self.intranet_ip = intranet_ip  # type: str
        # The number of files that are backed up.
        self.items_done = items_done  # type: long
        # The total number of files that you want to restore.
        self.items_total = items_total  # type: long
        # The error message returned.
        self.message = message  # type: str
        # The progress of the restoration task in percentage.
        self.percentage = percentage  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The ID of the restoration task.
        self.restore_id = restore_id  # type: str
        # The name of the restoration task.
        self.restore_name = restore_name  # type: str
        # The type of the file that is restored. Valid values:
        # 
        # *   **ECS_FILE**: files on Elastic Compute Service (ECS) instances
        # *   **FILE**: files on servers in data centers
        self.restore_type = restore_type  # type: str
        # The hash value of the snapshot that stores backup data when the data is backed up.
        self.snapshot_hash = snapshot_hash  # type: str
        # The hash value ID of the snapshot that stores backup data when the data is backed up.
        self.snapshot_id = snapshot_id  # type: str
        # The version of the backup data.
        self.snapshot_version = snapshot_version  # type: str
        # The path to the source file that you want to restore.
        self.source = source  # type: str
        # The ID of the anti-ransomware agent that is used to back up data.
        self.source_client_id = source_client_id  # type: str
        # The speed of data restoration. Unit: byte/s.
        self.speed = speed  # type: long
        # The status of the restoration task. Valid values:
        # 
        # *   **RUNNING**: The task is running.
        # *   **COMPLETE**: The task is complete.
        # *   **FAILED**: The task fails.
        # *   **CANCELING**: The task is being canceled.
        # *   **CANCELED**: The task is canceled.
        # *   **PARTIAL_COMPLETE**: The task is partially successful.
        # *   **CREATED**: The task is created but is not run.
        # *   **EXPIRED**: The task is not updated.
        # *   **QUEUED**: The task is waiting to be run.
        # *   **CLIENT_DELETED**: The task fails because the anti-ransomware agent is uninstalled.
        self.status = status  # type: str
        # The folder to which the backup data is restored. After you create the restoration task, the backup data is restored to the specified folder.
        self.target = target  # type: str
        # The timestamp when the restoration task was last updated. Unit: milliseconds.
        self.updated_time = updated_time  # type: long
        # The UUID of the server whose data you want to restore.
        self.uuid = uuid  # type: str
        # The ID of the backup vault in which the backup data is stored.
        self.vault_id = vault_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestoreJobsResponseBodyRestoreJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_bytes is not None:
            result['ActualBytes'] = self.actual_bytes
        if self.bytes_done is not None:
            result['BytesDone'] = self.bytes_done
        if self.bytes_total is not None:
            result['BytesTotal'] = self.bytes_total
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.error_count is not None:
            result['ErrorCount'] = self.error_count
        if self.error_file is not None:
            result['ErrorFile'] = self.error_file
        if self.error_file_url is not None:
            result['ErrorFileUrl'] = self.error_file_url
        if self.error_type is not None:
            result['ErrorType'] = self.error_type
        if self.eta is not None:
            result['Eta'] = self.eta
        if self.excludes is not None:
            result['Excludes'] = self.excludes
        if self.exit_code is not None:
            result['ExitCode'] = self.exit_code
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.includes is not None:
            result['Includes'] = self.includes
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.items_done is not None:
            result['ItemsDone'] = self.items_done
        if self.items_total is not None:
            result['ItemsTotal'] = self.items_total
        if self.message is not None:
            result['Message'] = self.message
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.restore_id is not None:
            result['RestoreId'] = self.restore_id
        if self.restore_name is not None:
            result['RestoreName'] = self.restore_name
        if self.restore_type is not None:
            result['RestoreType'] = self.restore_type
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_version is not None:
            result['SnapshotVersion'] = self.snapshot_version
        if self.source is not None:
            result['Source'] = self.source
        if self.source_client_id is not None:
            result['SourceClientId'] = self.source_client_id
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualBytes') is not None:
            self.actual_bytes = m.get('ActualBytes')
        if m.get('BytesDone') is not None:
            self.bytes_done = m.get('BytesDone')
        if m.get('BytesTotal') is not None:
            self.bytes_total = m.get('BytesTotal')
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ErrorCount') is not None:
            self.error_count = m.get('ErrorCount')
        if m.get('ErrorFile') is not None:
            self.error_file = m.get('ErrorFile')
        if m.get('ErrorFileUrl') is not None:
            self.error_file_url = m.get('ErrorFileUrl')
        if m.get('ErrorType') is not None:
            self.error_type = m.get('ErrorType')
        if m.get('Eta') is not None:
            self.eta = m.get('Eta')
        if m.get('Excludes') is not None:
            self.excludes = m.get('Excludes')
        if m.get('ExitCode') is not None:
            self.exit_code = m.get('ExitCode')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Includes') is not None:
            self.includes = m.get('Includes')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('ItemsDone') is not None:
            self.items_done = m.get('ItemsDone')
        if m.get('ItemsTotal') is not None:
            self.items_total = m.get('ItemsTotal')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RestoreId') is not None:
            self.restore_id = m.get('RestoreId')
        if m.get('RestoreName') is not None:
            self.restore_name = m.get('RestoreName')
        if m.get('RestoreType') is not None:
            self.restore_type = m.get('RestoreType')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotVersion') is not None:
            self.snapshot_version = m.get('SnapshotVersion')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceClientId') is not None:
            self.source_client_id = m.get('SourceClientId')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeRestoreJobsResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, restore_jobs=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeRestoreJobsResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the restoration tasks.
        self.restore_jobs = restore_jobs  # type: list[DescribeRestoreJobsResponseBodyRestoreJobs]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.restore_jobs:
            for k in self.restore_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRestoreJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RestoreJobs'] = []
        if self.restore_jobs is not None:
            for k in self.restore_jobs:
                result['RestoreJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeRestoreJobsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.restore_jobs = []
        if m.get('RestoreJobs') is not None:
            for k in m.get('RestoreJobs'):
                temp_model = DescribeRestoreJobsResponseBodyRestoreJobs()
                self.restore_jobs.append(temp_model.from_map(k))
        return self


class DescribeRestoreJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRestoreJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRestoreJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRestoreJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRestorePlansRequest(TeaModel):
    def __init__(self, current_page=None, instance_name=None, page_size=None, status=None):
        self.current_page = current_page  # type: int
        self.instance_name = instance_name  # type: str
        self.page_size = page_size  # type: int
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestorePlansRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRestorePlansResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestorePlansResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRestorePlansResponseBodyRestorePlans(TeaModel):
    def __init__(self, created_time=None, database_name=None, instance_name=None, policy_id=None, policy_name=None,
                 restore_point=None, status=None, target_database_name=None, target_instance_id=None, target_instance_name=None,
                 updated_time=None):
        self.created_time = created_time  # type: long
        self.database_name = database_name  # type: str
        self.instance_name = instance_name  # type: str
        self.policy_id = policy_id  # type: long
        self.policy_name = policy_name  # type: str
        self.restore_point = restore_point  # type: long
        self.status = status  # type: str
        self.target_database_name = target_database_name  # type: str
        self.target_instance_id = target_instance_id  # type: str
        self.target_instance_name = target_instance_name  # type: str
        self.updated_time = updated_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRestorePlansResponseBodyRestorePlans, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.restore_point is not None:
            result['RestorePoint'] = self.restore_point
        if self.status is not None:
            result['Status'] = self.status
        if self.target_database_name is not None:
            result['TargetDatabaseName'] = self.target_database_name
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_instance_name is not None:
            result['TargetInstanceName'] = self.target_instance_name
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RestorePoint') is not None:
            self.restore_point = m.get('RestorePoint')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetDatabaseName') is not None:
            self.target_database_name = m.get('TargetDatabaseName')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetInstanceName') is not None:
            self.target_instance_name = m.get('TargetInstanceName')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class DescribeRestorePlansResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, restore_plans=None):
        self.page_info = page_info  # type: DescribeRestorePlansResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.restore_plans = restore_plans  # type: list[DescribeRestorePlansResponseBodyRestorePlans]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.restore_plans:
            for k in self.restore_plans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRestorePlansResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RestorePlans'] = []
        if self.restore_plans is not None:
            for k in self.restore_plans:
                result['RestorePlans'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeRestorePlansResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.restore_plans = []
        if m.get('RestorePlans') is not None:
            for k in m.get('RestorePlans'):
                temp_model = DescribeRestorePlansResponseBodyRestorePlans()
                self.restore_plans.append(temp_model.from_map(k))
        return self


class DescribeRestorePlansResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRestorePlansResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRestorePlansResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRestorePlansResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckItemResultRequest(TeaModel):
    def __init__(self, current_page=None, item_id=None, lang=None, page_size=None, resource_owner_id=None,
                 source_ip=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The ID of the check item.
        # 
        # >  For more information about the IDs and details of the check items that can be used in configuration assessment, see [DescribeRiskCheckResult](~~DescribeRiskCheckResult~~).
        self.item_id = item_id  # type: long
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckItemResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskCheckItemResultResponseBodyPageContentResource(TeaModel):
    def __init__(self, content_resource=None, count=None, current_page=None, page_count=None, page_size=None,
                 total_count=None):
        # The data of the affected assets on each page in a dynamic table.
        self.content_resource = content_resource  # type: dict[str, any]
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The total number of pages returned.
        self.page_count = page_count  # type: int
        # The number of entries returned on each page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckItemResultResponseBodyPageContentResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_resource is not None:
            result['ContentResource'] = self.content_resource
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContentResource') is not None:
            self.content_resource = m.get('ContentResource')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRiskCheckItemResultResponseBody(TeaModel):
    def __init__(self, page_content_resource=None, request_id=None):
        # The pagination information.
        self.page_content_resource = page_content_resource  # type: DescribeRiskCheckItemResultResponseBodyPageContentResource
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_content_resource:
            self.page_content_resource.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckItemResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_content_resource is not None:
            result['PageContentResource'] = self.page_content_resource.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageContentResource') is not None:
            temp_model = DescribeRiskCheckItemResultResponseBodyPageContentResource()
            self.page_content_resource = temp_model.from_map(m['PageContentResource'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskCheckItemResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskCheckItemResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckItemResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckItemResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckResultRequest(TeaModel):
    def __init__(self, asset_type=None, current_page=None, group_id=None, item_ids=None, lang=None, name=None,
                 page_size=None, query_flag=None, resource_owner_id=None, risk_level=None, source_ip=None, status=None):
        # The type of the cloud service whose configuration assessment result you want to query. For more information about the description of the cloud service specified by this parameter, see the check item table in the "Response parameters" section of this topic.
        self.asset_type = asset_type  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The type of the check item that you want to query. Valid values:
        # 
        # *   **1**: identity authentication and permissions
        # *   **2**: network access control
        # *   **3**: log audit
        # *   **4**: data security
        # *   **5**: monitoring and alerting
        # *   **6**: basic security protection
        # 
        # >  If you do not specify this parameter, all types of check items are queried by default.
        self.group_id = group_id  # type: long
        self.item_ids = item_ids  # type: list[str]
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the check item. For more information about the description of the check item name, see the check item table in the "Response parameters" section of this topic.
        self.name = name  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # Specifies whether the check item is supported by the cloud service. Valid values:
        # 
        # *   **enabled**: The check item is supported by the cloud service.
        # *   **disabled**: The check item is not supported by the cloud service.
        self.query_flag = query_flag  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The risk level of the check item that you want to query. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The status of the check result. Valid values:
        # 
        # *   **pass**\
        # *   **failed**\
        # *   **running**\
        # *   **waiting**\
        # *   **ignored**\
        # *   **falsePositive**\
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_flag is not None:
            result['QueryFlag'] = self.query_flag
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ItemIds') is not None:
            self.item_ids = m.get('ItemIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryFlag') is not None:
            self.query_flag = m.get('QueryFlag')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRiskCheckResultResponseBodyListRiskItemResources(TeaModel):
    def __init__(self, content_resource=None, resource_name=None):
        # The details about the check result.
        self.content_resource = content_resource  # type: dict[str, any]
        # The title in the details. Valid values:
        # 
        # *   **bestPractice**: description
        # *   **influence**: risk
        # *   **suggestion**: solution
        # *   **helpResource**: reference
        self.resource_name = resource_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckResultResponseBodyListRiskItemResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_resource is not None:
            result['ContentResource'] = self.content_resource
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContentResource') is not None:
            self.content_resource = m.get('ContentResource')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        return self


class DescribeRiskCheckResultResponseBodyList(TeaModel):
    def __init__(self, affected_count=None, check_time=None, item_id=None, remaining_time=None, repair_status=None,
                 risk_assert_type=None, risk_item_resources=None, risk_level=None, sort=None, start_status=None, status=None,
                 task_id=None, title=None, type=None):
        # The number of affected assets.
        self.affected_count = affected_count  # type: int
        # The timestamp when the last check was performed. Unit: milliseconds.
        self.check_time = check_time  # type: long
        # The ID of the check item. For more information about the description of the check item ID, see the check item table in the "Response parameters" section of this topic.
        self.item_id = item_id  # type: long
        # The time when the next check will be performed.
        self.remaining_time = remaining_time  # type: int
        # Indicates whether the risks that are detected for the check item can be fixed. Valid values:
        # 
        # *   **enabled**: yes
        # *   **disabled**: no
        self.repair_status = repair_status  # type: str
        # The type of the affected assets.
        self.risk_assert_type = risk_assert_type  # type: str
        # An array that consists of the details about the check item.
        self.risk_item_resources = risk_item_resources  # type: list[DescribeRiskCheckResultResponseBodyListRiskItemResources]
        # The risk level of the check item. Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_level = risk_level  # type: str
        # The sequence number of the check result. The check items are sorted based on the sequence number.
        self.sort = sort  # type: int
        # Indicates whether the check item is supported by the cloud service. Valid values:
        # 
        # *   **enabled**: The check item is supported by the cloud service.
        # *   **disable**: The check item is not supported by the cloud service.
        self.start_status = start_status  # type: str
        # The status of the check result. Valid values:
        # 
        # *   **pass**\
        # *   **failed**\
        # *   **running**\
        # *   **waiting**\
        # *   **ignored**\
        # *   **falsePositive**\
        self.status = status  # type: str
        # The ID of the check task.
        self.task_id = task_id  # type: long
        # The name of the check item.
        self.title = title  # type: str
        # The type of the check item. Valid values:
        # 
        # *   Identity authentication and permissions
        # *   Network access control
        # *   Log audit
        # *   Data security
        # *   Monitoring and alerting
        # *   Basic security protection
        self.type = type  # type: str

    def validate(self):
        if self.risk_item_resources:
            for k in self.risk_item_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckResultResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_count is not None:
            result['AffectedCount'] = self.affected_count
        if self.check_time is not None:
            result['CheckTime'] = self.check_time
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.remaining_time is not None:
            result['RemainingTime'] = self.remaining_time
        if self.repair_status is not None:
            result['RepairStatus'] = self.repair_status
        if self.risk_assert_type is not None:
            result['RiskAssertType'] = self.risk_assert_type
        result['RiskItemResources'] = []
        if self.risk_item_resources is not None:
            for k in self.risk_item_resources:
                result['RiskItemResources'].append(k.to_map() if k else None)
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.start_status is not None:
            result['StartStatus'] = self.start_status
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedCount') is not None:
            self.affected_count = m.get('AffectedCount')
        if m.get('CheckTime') is not None:
            self.check_time = m.get('CheckTime')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('RemainingTime') is not None:
            self.remaining_time = m.get('RemainingTime')
        if m.get('RepairStatus') is not None:
            self.repair_status = m.get('RepairStatus')
        if m.get('RiskAssertType') is not None:
            self.risk_assert_type = m.get('RiskAssertType')
        self.risk_item_resources = []
        if m.get('RiskItemResources') is not None:
            for k in m.get('RiskItemResources'):
                temp_model = DescribeRiskCheckResultResponseBodyListRiskItemResources()
                self.risk_item_resources.append(temp_model.from_map(k))
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('StartStatus') is not None:
            self.start_status = m.get('StartStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeRiskCheckResultResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, list=None, page_count=None, page_size=None, request_id=None,
                 total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of the check items.
        self.list = list  # type: list[DescribeRiskCheckResultResponseBodyList]
        # The total number of pages returned.
        self.page_count = page_count  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskCheckResultResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRiskCheckResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskCheckResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskCheckSummaryRequest(TeaModel):
    def __init__(self, lang=None, resource_directory_account_id=None, resource_owner_id=None, source_ip=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The ID of the Alibaba Cloud account that is added as a member by using the multi-account control feature.
        self.resource_directory_account_id = resource_directory_account_id  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus(TeaModel):
    def __init__(self, count=None, status=None):
        # The number of detected risk items.
        self.count = count  # type: int
        # The status of the check item after the check is finished. Valid values:
        # 
        # *   **pass**: The check item passes the check, which indicates that the check item is normal.
        # *   **failed**: The check item fails the check, which indicates that risks are detected for the check item.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups(TeaModel):
    def __init__(self, count_by_status=None, id=None, remaining_time=None, sort=None, status=None, title=None):
        # An array that consists of the statistics about check results.
        self.count_by_status = count_by_status  # type: list[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus]
        # The ID of the check item type.
        self.id = id  # type: long
        # The remaining time before the check is complete.
        self.remaining_time = remaining_time  # type: int
        # The sequence number of the check item type in the **All Types** drop-down list in the Security Center console.
        self.sort = sort  # type: int
        # The status of the check. Valid values:
        # 
        # *   **finish**: The check is finished.
        # *   **running**: The check is in process.
        # *   **waiting**: The check is pending.
        # *   **notStart**: The check is not started.
        self.status = status  # type: str
        # The type of the check item.
        self.title = title  # type: str

    def validate(self):
        if self.count_by_status:
            for k in self.count_by_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CountByStatus'] = []
        if self.count_by_status is not None:
            for k in self.count_by_status:
                result['CountByStatus'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.remaining_time is not None:
            result['RemainingTime'] = self.remaining_time
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.count_by_status = []
        if m.get('CountByStatus') is not None:
            for k in m.get('CountByStatus'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus()
                self.count_by_status.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RemainingTime') is not None:
            self.remaining_time = m.get('RemainingTime')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount(TeaModel):
    def __init__(self, count=None, key=None):
        # The number of check items at the specified risk level.
        self.count = count  # type: int
        # The risk level of the check items. Valid values of risk levels:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.key = key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class DescribeRiskCheckSummaryResponseBodyRiskCheckSummary(TeaModel):
    def __init__(self, affected_asset_count=None, disabled_risk_count=None, enabled_risk_count=None, groups=None,
                 item_count=None, previous_count=None, previous_time=None, risk_count=None, risk_level_count=None,
                 risk_rate=None):
        # The number of affected assets.
        self.affected_asset_count = affected_asset_count  # type: int
        # The number of the check items that fail the check.
        self.disabled_risk_count = disabled_risk_count  # type: int
        # The number of the check items that pass the check.
        self.enabled_risk_count = enabled_risk_count  # type: int
        # An array that consists of the statistics about each type of check items.
        self.groups = groups  # type: list[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups]
        # The number of check items.
        self.item_count = item_count  # type: int
        # The number of risk items detected in the last check.
        self.previous_count = previous_count  # type: int
        # The timestamp of the last check. Unit: milliseconds.
        self.previous_time = previous_time  # type: long
        # The number of detected risk items.
        self.risk_count = risk_count  # type: int
        # An array that consists of the number of check items at each risk level.
        self.risk_level_count = risk_level_count  # type: list[DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount]
        # The proportion of risk items to all check items.
        self.risk_rate = risk_rate  # type: float

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        if self.risk_level_count:
            for k in self.risk_level_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponseBodyRiskCheckSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affected_asset_count is not None:
            result['AffectedAssetCount'] = self.affected_asset_count
        if self.disabled_risk_count is not None:
            result['DisabledRiskCount'] = self.disabled_risk_count
        if self.enabled_risk_count is not None:
            result['EnabledRiskCount'] = self.enabled_risk_count
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.item_count is not None:
            result['ItemCount'] = self.item_count
        if self.previous_count is not None:
            result['PreviousCount'] = self.previous_count
        if self.previous_time is not None:
            result['PreviousTime'] = self.previous_time
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        result['RiskLevelCount'] = []
        if self.risk_level_count is not None:
            for k in self.risk_level_count:
                result['RiskLevelCount'].append(k.to_map() if k else None)
        if self.risk_rate is not None:
            result['RiskRate'] = self.risk_rate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AffectedAssetCount') is not None:
            self.affected_asset_count = m.get('AffectedAssetCount')
        if m.get('DisabledRiskCount') is not None:
            self.disabled_risk_count = m.get('DisabledRiskCount')
        if m.get('EnabledRiskCount') is not None:
            self.enabled_risk_count = m.get('EnabledRiskCount')
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('ItemCount') is not None:
            self.item_count = m.get('ItemCount')
        if m.get('PreviousCount') is not None:
            self.previous_count = m.get('PreviousCount')
        if m.get('PreviousTime') is not None:
            self.previous_time = m.get('PreviousTime')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        self.risk_level_count = []
        if m.get('RiskLevelCount') is not None:
            for k in m.get('RiskLevelCount'):
                temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount()
                self.risk_level_count.append(temp_model.from_map(k))
        if m.get('RiskRate') is not None:
            self.risk_rate = m.get('RiskRate')
        return self


class DescribeRiskCheckSummaryResponseBody(TeaModel):
    def __init__(self, request_id=None, risk_check_summary=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The summary information about the check results of cloud service configurations.
        self.risk_check_summary = risk_check_summary  # type: DescribeRiskCheckSummaryResponseBodyRiskCheckSummary

    def validate(self):
        if self.risk_check_summary:
            self.risk_check_summary.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_check_summary is not None:
            result['RiskCheckSummary'] = self.risk_check_summary.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskCheckSummary') is not None:
            temp_model = DescribeRiskCheckSummaryResponseBodyRiskCheckSummary()
            self.risk_check_summary = temp_model.from_map(m['RiskCheckSummary'])
        return self


class DescribeRiskCheckSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskCheckSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskCheckSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskItemTypeRequest(TeaModel):
    def __init__(self, lang=None, resource_owner_id=None, source_ip=None):
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskItemTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskItemTypeResponseBodyList(TeaModel):
    def __init__(self, id=None, title=None):
        self.id = id  # type: long
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskItemTypeResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeRiskItemTypeResponseBody(TeaModel):
    def __init__(self, list=None, request_id=None):
        self.list = list  # type: list[DescribeRiskItemTypeResponseBodyList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskItemTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskItemTypeResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskItemTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskItemTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskItemTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskItemTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskListCheckResultRequest(TeaModel):
    def __init__(self, current_page=None, instance_ids=None, lang=None, page_size=None, resource_owner_id=None,
                 source_ip=None):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page  # type: int
        # The instance ID of the cloud service. Separate multiple IDs with commas (,).
        # 
        # >  If you do not specify this parameter, an empty list is returned.
        self.instance_ids = instance_ids  # type: list[str]
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskListCheckResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskListCheckResultResponseBodyList(TeaModel):
    def __init__(self, instance_id=None, risk_count=None):
        # The instance ID of the cloud service.
        self.instance_id = instance_id  # type: str
        # The total number of risk items detected in the current cloud service.
        self.risk_count = risk_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskListCheckResultResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.risk_count is not None:
            result['riskCount'] = self.risk_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('riskCount') is not None:
            self.risk_count = m.get('riskCount')
        return self


class DescribeRiskListCheckResultResponseBody(TeaModel):
    def __init__(self, list=None, request_id=None):
        # The number of risk items for each cloud service.
        self.list = list  # type: list[DescribeRiskListCheckResultResponseBodyList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskListCheckResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeRiskListCheckResultResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRiskListCheckResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskListCheckResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskListCheckResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskListCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskTypeRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList(TeaModel):
    def __init__(self, enum_value=None, max_value=None, min_value=None, param_default_value=None, param_desc=None,
                 param_name=None, param_type=None):
        # If the value of paramType is 1, this parameter is empty. If the value of paramType is 2, this parameter provides the options that can be selected for paramType.
        self.enum_value = enum_value  # type: str
        # The maximum value of the parameter.
        self.max_value = max_value  # type: int
        # The minimum value of the parameter.
        self.min_value = min_value  # type: int
        # The default value of the parameter.
        self.param_default_value = param_default_value  # type: str
        # The description of the parameter.
        self.param_desc = param_desc  # type: str
        # The name of the parameter.
        self.param_name = param_name  # type: str
        # The configuration type of the parameter. Valid values:
        # 
        # *   **1**: input
        # *   **2**: selection
        self.param_type = param_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules(TeaModel):
    def __init__(self, optional=None, param_list=None, rule_desc=None, rule_id=None):
        # Indicates whether the baseline can be edited. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.optional = optional  # type: int
        # An array that consists of the parameters in the rule for the baseline.
        self.param_list = param_list  # type: list[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList]
        # The description of the rule for the baseline.
        self.rule_desc = rule_desc  # type: str
        # The ID of the rule for the baseline.
        self.rule_id = rule_id  # type: str

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails(TeaModel):
    def __init__(self, check_desc=None, check_id=None, check_item=None, rules=None):
        # The description of the baseline.
        self.check_desc = check_desc  # type: str
        # The ID of the baseline.
        self.check_id = check_id  # type: long
        # The baseline.
        self.check_item = check_item  # type: str
        # An array that consists of the rule details about the baseline.
        self.rules = rules  # type: list[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules]

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeRiskTypeResponseBodyRiskTypesSubTypes(TeaModel):
    def __init__(self, alias=None, check_details=None, type_name=None):
        # The alias of the baseline subtype.
        self.alias = alias  # type: str
        # An array that consists of the check details about the baseline subtype.
        self.check_details = check_details  # type: list[DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails]
        # The name of the baseline subtype.
        self.type_name = type_name  # type: str

    def validate(self):
        if self.check_details:
            for k in self.check_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBodyRiskTypesSubTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['CheckDetails'] = []
        if self.check_details is not None:
            for k in self.check_details:
                result['CheckDetails'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.check_details = []
        if m.get('CheckDetails') is not None:
            for k in m.get('CheckDetails'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails()
                self.check_details.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeRiskTypeResponseBodyRiskTypes(TeaModel):
    def __init__(self, alias=None, sub_types=None, type_name=None):
        # The alias of the baseline type.
        self.alias = alias  # type: str
        # An array that consists of the information about baseline subtypes.
        self.sub_types = sub_types  # type: list[DescribeRiskTypeResponseBodyRiskTypesSubTypes]
        # The name of the baseline type.
        self.type_name = type_name  # type: str

    def validate(self):
        if self.sub_types:
            for k in self.sub_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBodyRiskTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['SubTypes'] = []
        if self.sub_types is not None:
            for k in self.sub_types:
                result['SubTypes'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.sub_types = []
        if m.get('SubTypes') is not None:
            for k in m.get('SubTypes'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypesSubTypes()
                self.sub_types.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeRiskTypeResponseBody(TeaModel):
    def __init__(self, request_id=None, risk_types=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the information about baseline types.
        self.risk_types = risk_types  # type: list[DescribeRiskTypeResponseBodyRiskTypes]

    def validate(self):
        if self.risk_types:
            for k in self.risk_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RiskTypes'] = []
        if self.risk_types is not None:
            for k in self.risk_types:
                result['RiskTypes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.risk_types = []
        if m.get('RiskTypes') is not None:
            for k in m.get('RiskTypes'):
                temp_model = DescribeRiskTypeResponseBodyRiskTypes()
                self.risk_types.append(temp_model.from_map(k))
        return self


class DescribeRiskTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRiskTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRiskTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRisksRequest(TeaModel):
    def __init__(self, lang=None, limit=None, risk_id=None, risk_name=None):
        self.lang = lang  # type: str
        self.limit = limit  # type: int
        self.risk_id = risk_id  # type: long
        self.risk_name = risk_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRisksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class DescribeRisksResponseBodyRisks(TeaModel):
    def __init__(self, risk_detail=None, risk_id=None, risk_name=None, risk_type=None, sub_risk_type=None,
                 sub_type_alias=None, type_alias=None):
        self.risk_detail = risk_detail  # type: str
        self.risk_id = risk_id  # type: long
        self.risk_name = risk_name  # type: str
        self.risk_type = risk_type  # type: str
        self.sub_risk_type = sub_risk_type  # type: str
        self.sub_type_alias = sub_type_alias  # type: str
        self.type_alias = type_alias  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRisksResponseBodyRisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_detail is not None:
            result['RiskDetail'] = self.risk_detail
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.sub_risk_type is not None:
            result['SubRiskType'] = self.sub_risk_type
        if self.sub_type_alias is not None:
            result['SubTypeAlias'] = self.sub_type_alias
        if self.type_alias is not None:
            result['TypeAlias'] = self.type_alias
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskDetail') is not None:
            self.risk_detail = m.get('RiskDetail')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('SubRiskType') is not None:
            self.sub_risk_type = m.get('SubRiskType')
        if m.get('SubTypeAlias') is not None:
            self.sub_type_alias = m.get('SubTypeAlias')
        if m.get('TypeAlias') is not None:
            self.type_alias = m.get('TypeAlias')
        return self


class DescribeRisksResponseBody(TeaModel):
    def __init__(self, request_id=None, risks=None, total_count=None):
        self.request_id = request_id  # type: str
        self.risks = risks  # type: list[DescribeRisksResponseBodyRisks]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.risks:
            for k in self.risks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRisksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Risks'] = []
        if self.risks is not None:
            for k in self.risks:
                result['Risks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.risks = []
        if m.get('Risks') is not None:
            for k in m.get('Risks'):
                temp_model = DescribeRisksResponseBodyRisks()
                self.risks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRisksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRisksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRisksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRisksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSasPmAgentListRequest(TeaModel):
    def __init__(self, lang=None, uuids=None):
        self.lang = lang  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSasPmAgentListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeSasPmAgentListResponseBodySasPmAgentList(TeaModel):
    def __init__(self, aliyun_assist_id=None, aliyun_monitor_id=None, assist_install_result=None,
                 assist_install_status=None, monitor_install_result=None, monitor_install_status=None, uuid=None):
        self.aliyun_assist_id = aliyun_assist_id  # type: str
        self.aliyun_monitor_id = aliyun_monitor_id  # type: str
        self.assist_install_result = assist_install_result  # type: int
        self.assist_install_status = assist_install_status  # type: int
        self.monitor_install_result = monitor_install_result  # type: int
        self.monitor_install_status = monitor_install_status  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSasPmAgentListResponseBodySasPmAgentList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_assist_id is not None:
            result['AliyunAssistId'] = self.aliyun_assist_id
        if self.aliyun_monitor_id is not None:
            result['AliyunMonitorId'] = self.aliyun_monitor_id
        if self.assist_install_result is not None:
            result['AssistInstallResult'] = self.assist_install_result
        if self.assist_install_status is not None:
            result['AssistInstallStatus'] = self.assist_install_status
        if self.monitor_install_result is not None:
            result['MonitorInstallResult'] = self.monitor_install_result
        if self.monitor_install_status is not None:
            result['MonitorInstallStatus'] = self.monitor_install_status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliyunAssistId') is not None:
            self.aliyun_assist_id = m.get('AliyunAssistId')
        if m.get('AliyunMonitorId') is not None:
            self.aliyun_monitor_id = m.get('AliyunMonitorId')
        if m.get('AssistInstallResult') is not None:
            self.assist_install_result = m.get('AssistInstallResult')
        if m.get('AssistInstallStatus') is not None:
            self.assist_install_status = m.get('AssistInstallStatus')
        if m.get('MonitorInstallResult') is not None:
            self.monitor_install_result = m.get('MonitorInstallResult')
        if m.get('MonitorInstallStatus') is not None:
            self.monitor_install_status = m.get('MonitorInstallStatus')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSasPmAgentListResponseBody(TeaModel):
    def __init__(self, request_id=None, sas_pm_agent_list=None):
        self.request_id = request_id  # type: str
        self.sas_pm_agent_list = sas_pm_agent_list  # type: list[DescribeSasPmAgentListResponseBodySasPmAgentList]

    def validate(self):
        if self.sas_pm_agent_list:
            for k in self.sas_pm_agent_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSasPmAgentListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SasPmAgentList'] = []
        if self.sas_pm_agent_list is not None:
            for k in self.sas_pm_agent_list:
                result['SasPmAgentList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sas_pm_agent_list = []
        if m.get('SasPmAgentList') is not None:
            for k in m.get('SasPmAgentList'):
                temp_model = DescribeSasPmAgentListResponseBodySasPmAgentList()
                self.sas_pm_agent_list.append(temp_model.from_map(k))
        return self


class DescribeSasPmAgentListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSasPmAgentListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSasPmAgentListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSasPmAgentListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScanTaskProgressRequest(TeaModel):
    def __init__(self, task_id=None):
        # The ID of the virus scan task.
        # 
        # >  You can call the [StartVirusScanTask](~~StartVirusScanTask~~) operation to query the IDs of virus scan tasks.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskProgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeScanTaskProgressResponseBody(TeaModel):
    def __init__(self, request_id=None, scan_task_progress=None, target_info=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The progress of the virus scan task. Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **Processing**: The task is running.
        # *   **Success**: The task is complete.
        # *   **Failed**: The task fails.
        self.scan_task_progress = scan_task_progress  # type: str
        # The information about the asset on which the virus scan task runs. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:
        # 
        # *   **type**: the type of the asset on which the virus scan task runs. Valid values:
        # 
        #     *   **groupId**: server group.
        #     *   **uuid**: server.
        # 
        # *   **name**: the name of the server group or server.
        # 
        # *   **target**: the asset on which the virus scan task runs. The value of this field varies based on the value of the type field.
        # 
        #     *   If the value of **type** is **groupId**, the value of this field is the ID of the server group.
        #     *   If the value of **type** is **uuid**, the value of this field is the UUID of the server.
        self.target_info = target_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskProgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scan_task_progress is not None:
            result['ScanTaskProgress'] = self.scan_task_progress
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScanTaskProgress') is not None:
            self.scan_task_progress = m.get('ScanTaskProgress')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class DescribeScanTaskProgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeScanTaskProgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeScanTaskProgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScanTaskProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScanTaskStatisticsRequest(TeaModel):
    def __init__(self, levels=None):
        self.levels = levels  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.levels is not None:
            result['Levels'] = self.levels
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        return self


class DescribeScanTaskStatisticsResponseBody(TeaModel):
    def __init__(self, dealed_risk_num=None, personal_task_num=None, request_id=None, total_task_num=None,
                 user_num=None):
        self.dealed_risk_num = dealed_risk_num  # type: int
        self.personal_task_num = personal_task_num  # type: long
        self.request_id = request_id  # type: str
        self.total_task_num = total_task_num  # type: long
        self.user_num = user_num  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed_risk_num is not None:
            result['DealedRiskNum'] = self.dealed_risk_num
        if self.personal_task_num is not None:
            result['PersonalTaskNum'] = self.personal_task_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_task_num is not None:
            result['TotalTaskNum'] = self.total_task_num
        if self.user_num is not None:
            result['UserNum'] = self.user_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DealedRiskNum') is not None:
            self.dealed_risk_num = m.get('DealedRiskNum')
        if m.get('PersonalTaskNum') is not None:
            self.personal_task_num = m.get('PersonalTaskNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalTaskNum') is not None:
            self.total_task_num = m.get('TotalTaskNum')
        if m.get('UserNum') is not None:
            self.user_num = m.get('UserNum')
        return self


class DescribeScanTaskStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeScanTaskStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeScanTaskStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScanTaskStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSearchConditionRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, type=None):
        # The language of the content within the request and the response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the asset. Valid values:
        # 
        # *   **ecs**: Elastic Compute Service (ECS) instance
        # *   **cloud_product**: cloud service except ECS
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSearchConditionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSearchConditionResponseBodyConditionList(TeaModel):
    def __init__(self, condition_type=None, filter_conditions=None, name=None, name_key=None):
        # The type of the filter condition. Valid values:
        # 
        # *   **system**: default filter condition
        # *   **user**: custom filter condition
        self.condition_type = condition_type  # type: str
        # The filter condition. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **filterParams**: the parameters of the filter condition. The value of this field is in the JSON format and contains the following fields:
        # 
        #     *   **labelKey**: the key for rendering.
        # 
        #     *   **label**: the display name.
        # 
        #     *   **value**: the value of the filter condition. The value of this field is in the JSON format and contains the following fields:
        # 
        #         *   **name**: the name of the filter item.
        #         *   **value**: the value of the filter item.
        # 
        # *   **LogicalExp**: the logical relationship among the filter conditions. Valid values:
        # 
        #     *   **AND**: The filter conditions are evaluated by using a logical **AND**.
        #     *   **OR**: The filter conditions are evaluated by using a logical **OR**.
        # 
        # >  If the value of **ConditionType** is **system**, **labelKey** is returned. The labelKey field is used only for internationalization rendering.
        self.filter_conditions = filter_conditions  # type: str
        # The name of the filter condition.
        self.name = name  # type: str
        # The key of the filter condition name.
        self.name_key = name_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSearchConditionResponseBodyConditionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_type is not None:
            result['ConditionType'] = self.condition_type
        if self.filter_conditions is not None:
            result['FilterConditions'] = self.filter_conditions
        if self.name is not None:
            result['Name'] = self.name
        if self.name_key is not None:
            result['NameKey'] = self.name_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConditionType') is not None:
            self.condition_type = m.get('ConditionType')
        if m.get('FilterConditions') is not None:
            self.filter_conditions = m.get('FilterConditions')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameKey') is not None:
            self.name_key = m.get('NameKey')
        return self


class DescribeSearchConditionResponseBody(TeaModel):
    def __init__(self, condition_list=None, request_id=None):
        # An array that consists of the filter conditions.
        self.condition_list = condition_list  # type: list[DescribeSearchConditionResponseBodyConditionList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.condition_list:
            for k in self.condition_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSearchConditionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConditionList'] = []
        if self.condition_list is not None:
            for k in self.condition_list:
                result['ConditionList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.condition_list = []
        if m.get('ConditionList') is not None:
            for k in m.get('ConditionList'):
                temp_model = DescribeSearchConditionResponseBodyConditionList()
                self.condition_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSearchConditionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSearchConditionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSearchConditionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSearchConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecureSuggestionRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None):
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecureSuggestionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecureSuggestionResponseBodySuggestionsDetail(TeaModel):
    def __init__(self, description=None, sub_type=None, title=None):
        self.description = description  # type: str
        self.sub_type = sub_type  # type: str
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecureSuggestionResponseBodySuggestionsDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.sub_type is not None:
            result['SubType'] = self.sub_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SubType') is not None:
            self.sub_type = m.get('SubType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeSecureSuggestionResponseBodySuggestions(TeaModel):
    def __init__(self, detail=None, points=None, suggest_type=None):
        self.detail = detail  # type: list[DescribeSecureSuggestionResponseBodySuggestionsDetail]
        self.points = points  # type: int
        self.suggest_type = suggest_type  # type: str

    def validate(self):
        if self.detail:
            for k in self.detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecureSuggestionResponseBodySuggestions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Detail'] = []
        if self.detail is not None:
            for k in self.detail:
                result['Detail'].append(k.to_map() if k else None)
        if self.points is not None:
            result['Points'] = self.points
        if self.suggest_type is not None:
            result['SuggestType'] = self.suggest_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.detail = []
        if m.get('Detail') is not None:
            for k in m.get('Detail'):
                temp_model = DescribeSecureSuggestionResponseBodySuggestionsDetail()
                self.detail.append(temp_model.from_map(k))
        if m.get('Points') is not None:
            self.points = m.get('Points')
        if m.get('SuggestType') is not None:
            self.suggest_type = m.get('SuggestType')
        return self


class DescribeSecureSuggestionResponseBody(TeaModel):
    def __init__(self, request_id=None, suggestions=None, total_count=None):
        self.request_id = request_id  # type: str
        self.suggestions = suggestions  # type: list[DescribeSecureSuggestionResponseBodySuggestions]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.suggestions:
            for k in self.suggestions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecureSuggestionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Suggestions'] = []
        if self.suggestions is not None:
            for k in self.suggestions:
                result['Suggestions'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.suggestions = []
        if m.get('Suggestions') is not None:
            for k in m.get('Suggestions'):
                temp_model = DescribeSecureSuggestionResponseBodySuggestions()
                self.suggestions.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecureSuggestionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecureSuggestionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecureSuggestionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecureSuggestionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityCheckScheduleConfigRequest(TeaModel):
    def __init__(self, lang=None, resource_owner_id=None, source_ip=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityCheckScheduleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig(TeaModel):
    def __init__(self, days_of_week=None, end_time=None, start_time=None):
        # The day of the week when the check tasks are performed. Multiple days can be specified. Multiple days are separated by commas (,).
        # 
        # *   **1**: Monday
        # *   **2**: Tuesday
        # *   **3**: Wednesday
        # *   **4**: Thursday
        # *   **5**: Friday
        # *   **6**: Saturday
        # *   **7**: Sunday
        self.days_of_week = days_of_week  # type: str
        # The time range during which check tasks end. Valid values:
        # 
        # *   **6**: 00:00 to 06:00
        # *   **12**: 06:00 to 12:00
        # *   **18**: 12:00 to 18:00
        # *   **24**: 18:00 to 24:00
        self.end_time = end_time  # type: int
        # The time range during which check tasks start. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.start_time = start_time  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSecurityCheckScheduleConfigResponseBody(TeaModel):
    def __init__(self, request_id=None, risk_check_job_config=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The configurations of custom check tasks.
        self.risk_check_job_config = risk_check_job_config  # type: DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig

    def validate(self):
        if self.risk_check_job_config:
            self.risk_check_job_config.validate()

    def to_map(self):
        _map = super(DescribeSecurityCheckScheduleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_check_job_config is not None:
            result['RiskCheckJobConfig'] = self.risk_check_job_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskCheckJobConfig') is not None:
            temp_model = DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig()
            self.risk_check_job_config = temp_model.from_map(m['RiskCheckJobConfig'])
        return self


class DescribeSecurityCheckScheduleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityCheckScheduleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityCheckScheduleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityCheckScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationStatusRequest(TeaModel):
    def __init__(self, resource_owner_id=None, security_event_ids=None, source_ip=None, task_id=None):
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of the alert events.
        # 
        # >  You must specify at least one of the TaskId and SecurityEventIds parameters.
        self.security_event_ids = security_event_ids  # type: list[str]
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the task that handles the alert events.
        # 
        # >  You must specify at least one of the TaskId and SecurityEventIds parameters.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses(TeaModel):
    def __init__(self, error_code=None, security_event_id=None, status=None):
        # The code that indicates the handling result of the alert event.
        self.error_code = error_code  # type: str
        # The ID of the alert event.
        self.security_event_id = security_event_id  # type: str
        # The handling status of the alert event. Valid values:
        # 
        # *   **Processing**: The alert event is being handled.
        # *   **Success**: The alert event is handled.
        # *   **Failed**: The alert event failed to be handled.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse(TeaModel):
    def __init__(self, security_event_operation_statuses=None, task_status=None):
        # An array consisting of the status of the alert events handled by the task.
        self.security_event_operation_statuses = security_event_operation_statuses  # type: list[DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses]
        # The status of the task that handles the alert events. Valid values:
        # 
        # *   **Processing**: The task is running.
        # *   **Success**: The task is successful.
        # *   **Failure**: The task failed.
        # *   **Pending**: The task is pending.
        self.task_status = task_status  # type: str

    def validate(self):
        if self.security_event_operation_statuses:
            for k in self.security_event_operation_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SecurityEventOperationStatuses'] = []
        if self.security_event_operation_statuses is not None:
            for k in self.security_event_operation_statuses:
                result['SecurityEventOperationStatuses'].append(k.to_map() if k else None)
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.security_event_operation_statuses = []
        if m.get('SecurityEventOperationStatuses') is not None:
            for k in m.get('SecurityEventOperationStatuses'):
                temp_model = DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses()
                self.security_event_operation_statuses.append(temp_model.from_map(k))
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeSecurityEventOperationStatusResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_operation_status_response=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The information about the task that handles the alert events.
        self.security_event_operation_status_response = security_event_operation_status_response  # type: DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse

    def validate(self):
        if self.security_event_operation_status_response:
            self.security_event_operation_status_response.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event_operation_status_response is not None:
            result['SecurityEventOperationStatusResponse'] = self.security_event_operation_status_response.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEventOperationStatusResponse') is not None:
            temp_model = DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse()
            self.security_event_operation_status_response = temp_model.from_map(m['SecurityEventOperationStatusResponse'])
        return self


class DescribeSecurityEventOperationStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityEventOperationStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationsRequest(TeaModel):
    def __init__(self, lang=None, resource_owner_id=None, security_event_id=None, source_ip=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the alert event that you want to handle.
        self.security_event_id = security_event_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(TeaModel):
    def __init__(self, filed_alias_name=None, filed_name=None, mark_mis_type=None, mark_mis_value=None,
                 supported_mis_type=None, uuid=None):
        # The alias of the field that is used in the whitelist rule.
        self.filed_alias_name = filed_alias_name  # type: str
        # The field that is used in the whitelist rule.
        self.filed_name = filed_name  # type: str
        # The operation that is used in the whitelist rule. Valid values:
        # 
        # *   **contains**: contains
        # *   **notContains**: does not contain
        # *   **regex**: regular expression
        # *   **strEqual**: equals
        # *   **strNotEqual**: does not equal
        self.mark_mis_type = mark_mis_type  # type: str
        # The value of the field that is used in the whitelist rule.
        self.mark_mis_value = mark_mis_value  # type: str
        # An array consisting of the operations that are supported by the method to add the alert event to the whitelist.
        self.supported_mis_type = supported_mis_type  # type: list[str]
        # The UUID of the server on which the alert event is detected.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_type is not None:
            result['MarkMisType'] = self.mark_mis_type
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisType') is not None:
            self.mark_mis_type = m.get('MarkMisType')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(TeaModel):
    def __init__(self, filed_alias_name=None, filed_name=None, mark_mis_value=None, supported_mis_type=None):
        # The alias of the field that can be used in the whitelist rule.
        self.filed_alias_name = filed_alias_name  # type: str
        # The field that can be used in the whitelist rule.
        self.filed_name = filed_name  # type: str
        # The value of the field that can be used in the whitelist rule.
        self.mark_mis_value = mark_mis_value  # type: str
        # An array consisting of the operations that are supported by the method to add the alert event to the whitelist.
        self.supported_mis_type = supported_mis_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.filed_name is not None:
            result['FiledName'] = self.filed_name
        if self.mark_mis_value is not None:
            result['MarkMisValue'] = self.mark_mis_value
        if self.supported_mis_type is not None:
            result['SupportedMisType'] = self.supported_mis_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('FiledName') is not None:
            self.filed_name = m.get('FiledName')
        if m.get('MarkMisValue') is not None:
            self.mark_mis_value = m.get('MarkMisValue')
        if m.get('SupportedMisType') is not None:
            self.supported_mis_type = m.get('SupportedMisType')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse(TeaModel):
    def __init__(self, mark_field=None, mark_fields_source=None, operation_code=None, operation_params=None,
                 user_can_operate=None):
        # An array consisting of the configuration information that is used when the value of the OperationCode parameter is **advance\_mark\_mis_info**.
        self.mark_field = mark_field  # type: list[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField]
        # An array consisting of the configuration items that can be used when the value of the OperationCode parameter is advance_mark_mis_info.
        self.mark_fields_source = mark_fields_source  # type: list[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource]
        # The operation that you can perform to handle the alert. Valid values:
        # 
        # *   **block_ip**: blocks the source IP address.
        # *   **advance\_mark\_mis_info**: adds the alert to the whitelist.
        # *   **ignore**: ignores the alert.
        # *   **manual_handled**: marks the alert as manually handled.
        # *   **kill_process**: terminates the malicious process.
        # *   **cleanup**: performs in-depth virus detection and removal.
        # *   **kill\_and_quara**: terminates the malicious process and quarantines the source file.
        # *   **disable\_malicious_defense**: stops the container on which the alerting files or processes exist.
        # *   **client\_problem_check**: performs troubleshooting.
        # *   **quara**: quarantines the source file of the malicious process.
        self.operation_code = operation_code  # type: str
        # The configuration of the operation that you can perform to handle the alert event.
        # 
        # >  If the value of the OperationCode parameter is `kill_and_quara` or `block_ip`, the OperationParams parameter is required. If the value of the OperationCode parameter is a different value, the OperationParams parameter can be left empty.
        self.operation_params = operation_params  # type: str
        # Indicates whether you can handle the alert event in the current edition of Security Center. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.user_can_operate = user_can_operate  # type: bool

    def validate(self):
        if self.mark_field:
            for k in self.mark_field:
                if k:
                    k.validate()
        if self.mark_fields_source:
            for k in self.mark_fields_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MarkField'] = []
        if self.mark_field is not None:
            for k in self.mark_field:
                result['MarkField'].append(k.to_map() if k else None)
        result['MarkFieldsSource'] = []
        if self.mark_fields_source is not None:
            for k in self.mark_fields_source:
                result['MarkFieldsSource'].append(k.to_map() if k else None)
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.user_can_operate is not None:
            result['UserCanOperate'] = self.user_can_operate
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.mark_field = []
        if m.get('MarkField') is not None:
            for k in m.get('MarkField'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField()
                self.mark_field.append(temp_model.from_map(k))
        self.mark_fields_source = []
        if m.get('MarkFieldsSource') is not None:
            for k in m.get('MarkFieldsSource'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource()
                self.mark_fields_source.append(temp_model.from_map(k))
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('UserCanOperate') is not None:
            self.user_can_operate = m.get('UserCanOperate')
        return self


class DescribeSecurityEventOperationsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_operations_response=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the operations that you can perform to handle the alert event.
        self.security_event_operations_response = security_event_operations_response  # type: list[DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse]

    def validate(self):
        if self.security_event_operations_response:
            for k in self.security_event_operations_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperationsResponse'] = []
        if self.security_event_operations_response is not None:
            for k in self.security_event_operations_response:
                result['SecurityEventOperationsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operations_response = []
        if m.get('SecurityEventOperationsResponse') is not None:
            for k in m.get('SecurityEventOperationsResponse'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse()
                self.security_event_operations_response.append(temp_model.from_map(k))
        return self


class DescribeSecurityEventOperationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityEventOperationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityStatInfoRequest(TeaModel):
    def __init__(self, lang=None, resource_directory_account_id=None, source_ip=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The ID of the account that is added to the resource directory as a member for multi-account control. You can use this parameter to query the security status of the account.
        self.resource_directory_account_id = resource_directory_account_id  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityStatInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSecurityStatInfoResponseBodyAttackEvent(TeaModel):
    def __init__(self, date_array=None, total_count=None, value_array=None):
        # The points in time when the number of attacks is collected in the trend chart.
        self.date_array = date_array  # type: list[str]
        # The total number of attacks on the current day.
        self.total_count = total_count  # type: int
        # The numbers of attacks at all points in time.
        self.value_array = value_array  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponseBodyAttackEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodyHealthCheck(TeaModel):
    def __init__(self, date_array=None, high_count=None, high_list=None, levels_on=None, low_count=None,
                 low_list=None, medium_count=None, medium_list=None, time_array=None, total_count=None, value_array=None):
        # The points in time when data of baseline risk items is collected in the trend chart.
        self.date_array = date_array  # type: list[str]
        # The number of baseline risk items that have the high-risk level on the current day.
        self.high_count = high_count  # type: int
        # The numbers of baseline risk items that have the high-risk level at all points in time.
        self.high_list = high_list  # type: list[str]
        # The risk levels of baseline risk items.
        self.levels_on = levels_on  # type: list[str]
        # The number of baseline risk items that have the low-risk level on the current day.
        self.low_count = low_count  # type: int
        # The numbers of baseline risk items that have the low-risk level at all points in time.
        self.low_list = low_list  # type: list[str]
        # The number of baseline risk items that have the medium-risk level on the current day.
        self.medium_count = medium_count  # type: int
        # The numbers of baseline risk items that have the medium-risk level at all points in time.
        self.medium_list = medium_list  # type: list[str]
        # The time periods during which data of baseline risk items is collected.
        self.time_array = time_array  # type: list[str]
        # The total number of baseline risk items on the current day.
        self.total_count = total_count  # type: int
        # The total number of baseline risk items at all points in time.
        self.value_array = value_array  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponseBodyHealthCheck, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.high_count is not None:
            result['HighCount'] = self.high_count
        if self.high_list is not None:
            result['HighList'] = self.high_list
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.low_count is not None:
            result['LowCount'] = self.low_count
        if self.low_list is not None:
            result['LowList'] = self.low_list
        if self.medium_count is not None:
            result['MediumCount'] = self.medium_count
        if self.medium_list is not None:
            result['MediumList'] = self.medium_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('HighCount') is not None:
            self.high_count = m.get('HighCount')
        if m.get('HighList') is not None:
            self.high_list = m.get('HighList')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('LowCount') is not None:
            self.low_count = m.get('LowCount')
        if m.get('LowList') is not None:
            self.low_list = m.get('LowList')
        if m.get('MediumCount') is not None:
            self.medium_count = m.get('MediumCount')
        if m.get('MediumList') is not None:
            self.medium_list = m.get('MediumList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodySecurityEvent(TeaModel):
    def __init__(self, date_array=None, levels_on=None, remind_count=None, remind_list=None, serious_count=None,
                 serious_list=None, suspicious_count=None, suspicious_list=None, time_array=None, total_count=None,
                 value_array=None):
        # The points in time when data of unhandled alerts is collected in the trend chart.
        self.date_array = date_array  # type: list[str]
        # The risk levels of unhandled alerts.
        self.levels_on = levels_on  # type: list[str]
        # The number of **remind** alerts on the current day.
        self.remind_count = remind_count  # type: int
        # The numbers of remind alerts at all points in time.
        self.remind_list = remind_list  # type: list[str]
        # The number of **serious** alerts on the current day.
        self.serious_count = serious_count  # type: int
        # The numbers of serious alerts at all points in time.
        self.serious_list = serious_list  # type: list[str]
        # The number of **suspicious** alerts on the current day.
        self.suspicious_count = suspicious_count  # type: int
        # The numbers of suspicious alerts at all points in time.
        self.suspicious_list = suspicious_list  # type: list[str]
        # The time periods during which data of the same alert is collected.
        self.time_array = time_array  # type: list[str]
        # The total number of unhandled alerts on the current day.
        self.total_count = total_count  # type: int
        # The numbers of unhandled alerts at all points in time.
        self.value_array = value_array  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponseBodySecurityEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.remind_count is not None:
            result['RemindCount'] = self.remind_count
        if self.remind_list is not None:
            result['RemindList'] = self.remind_list
        if self.serious_count is not None:
            result['SeriousCount'] = self.serious_count
        if self.serious_list is not None:
            result['SeriousList'] = self.serious_list
        if self.suspicious_count is not None:
            result['SuspiciousCount'] = self.suspicious_count
        if self.suspicious_list is not None:
            result['SuspiciousList'] = self.suspicious_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('RemindCount') is not None:
            self.remind_count = m.get('RemindCount')
        if m.get('RemindList') is not None:
            self.remind_list = m.get('RemindList')
        if m.get('SeriousCount') is not None:
            self.serious_count = m.get('SeriousCount')
        if m.get('SeriousList') is not None:
            self.serious_list = m.get('SeriousList')
        if m.get('SuspiciousCount') is not None:
            self.suspicious_count = m.get('SuspiciousCount')
        if m.get('SuspiciousList') is not None:
            self.suspicious_list = m.get('SuspiciousList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBodyVulnerability(TeaModel):
    def __init__(self, asap_count=None, asap_list=None, date_array=None, later_count=None, later_list=None,
                 levels_on=None, nntf_count=None, nntf_list=None, time_array=None, total_count=None, value_array=None):
        # The number of **high-risk** unfixed vulnerabilities on the current day.
        self.asap_count = asap_count  # type: int
        # The numbers of high-risk unfixed vulnerabilities at all points in time.
        self.asap_list = asap_list  # type: list[str]
        # The points in time when data of unfixed vulnerabilities is collected in the trend chart.
        self.date_array = date_array  # type: list[str]
        # The number of **medium-risk** unfixed vulnerabilities on the current day.
        self.later_count = later_count  # type: int
        # The numbers of medium-risk unfixed vulnerabilities at all points in time.
        self.later_list = later_list  # type: list[str]
        # The risk levels of unfixed vulnerabilities.
        self.levels_on = levels_on  # type: list[str]
        # The number of **low-risk** unfixed vulnerabilities on the current day.
        self.nntf_count = nntf_count  # type: int
        # The numbers of low-risk unfixed vulnerabilities at all points in time.
        self.nntf_list = nntf_list  # type: list[str]
        # The time periods during which data of unfixed vulnerabilities is collected.
        self.time_array = time_array  # type: list[str]
        # The total number of unfixed vulnerabilities on the current day.
        self.total_count = total_count  # type: int
        # The numbers of unfixed vulnerabilities at all points in time.
        self.value_array = value_array  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponseBodyVulnerability, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.asap_list is not None:
            result['AsapList'] = self.asap_list
        if self.date_array is not None:
            result['DateArray'] = self.date_array
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.later_list is not None:
            result['LaterList'] = self.later_list
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.nntf_list is not None:
            result['NntfList'] = self.nntf_list
        if self.time_array is not None:
            result['TimeArray'] = self.time_array
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.value_array is not None:
            result['ValueArray'] = self.value_array
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('AsapList') is not None:
            self.asap_list = m.get('AsapList')
        if m.get('DateArray') is not None:
            self.date_array = m.get('DateArray')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('LaterList') is not None:
            self.later_list = m.get('LaterList')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('NntfList') is not None:
            self.nntf_list = m.get('NntfList')
        if m.get('TimeArray') is not None:
            self.time_array = m.get('TimeArray')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('ValueArray') is not None:
            self.value_array = m.get('ValueArray')
        return self


class DescribeSecurityStatInfoResponseBody(TeaModel):
    def __init__(self, attack_event=None, health_check=None, request_id=None, security_event=None, success=None,
                 vulnerability=None):
        # The detailed statistics of attacks.
        self.attack_event = attack_event  # type: DescribeSecurityStatInfoResponseBodyAttackEvent
        # The detailed statistics of baseline risk items.
        self.health_check = health_check  # type: DescribeSecurityStatInfoResponseBodyHealthCheck
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The detailed statistics of unhandled alerts.
        self.security_event = security_event  # type: DescribeSecurityStatInfoResponseBodySecurityEvent
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool
        # The detailed statistics of unfixed vulnerabilities.
        self.vulnerability = vulnerability  # type: DescribeSecurityStatInfoResponseBodyVulnerability

    def validate(self):
        if self.attack_event:
            self.attack_event.validate()
        if self.health_check:
            self.health_check.validate()
        if self.security_event:
            self.security_event.validate()
        if self.vulnerability:
            self.vulnerability.validate()

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attack_event is not None:
            result['AttackEvent'] = self.attack_event.to_map()
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_event is not None:
            result['SecurityEvent'] = self.security_event.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.vulnerability is not None:
            result['Vulnerability'] = self.vulnerability.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttackEvent') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyAttackEvent()
            self.attack_event = temp_model.from_map(m['AttackEvent'])
        if m.get('HealthCheck') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyHealthCheck()
            self.health_check = temp_model.from_map(m['HealthCheck'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityEvent') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodySecurityEvent()
            self.security_event = temp_model.from_map(m['SecurityEvent'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Vulnerability') is not None:
            temp_model = DescribeSecurityStatInfoResponseBodyVulnerability()
            self.vulnerability = temp_model.from_map(m['Vulnerability'])
        return self


class DescribeSecurityStatInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityStatInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityStatInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityStatInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServiceLinkedRoleStatusRequest(TeaModel):
    def __init__(self, service_linked_role=None):
        # The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:
        # 
        # *   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
        # *   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.
        self.service_linked_role = service_linked_role  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeServiceLinkedRoleStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_linked_role is not None:
            result['ServiceLinkedRole'] = self.service_linked_role
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ServiceLinkedRole') is not None:
            self.service_linked_role = m.get('ServiceLinkedRole')
        return self


class DescribeServiceLinkedRoleStatusResponseBodyRoleStatus(TeaModel):
    def __init__(self, status=None):
        # Indicates whether the service-linked role is created. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.status = status  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeServiceLinkedRoleStatusResponseBodyRoleStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeServiceLinkedRoleStatusResponseBody(TeaModel):
    def __init__(self, request_id=None, role_status=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The status information about the service-linked role.
        self.role_status = role_status  # type: DescribeServiceLinkedRoleStatusResponseBodyRoleStatus

    def validate(self):
        if self.role_status:
            self.role_status.validate()

    def to_map(self):
        _map = super(DescribeServiceLinkedRoleStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.role_status is not None:
            result['RoleStatus'] = self.role_status.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RoleStatus') is not None:
            temp_model = DescribeServiceLinkedRoleStatusResponseBodyRoleStatus()
            self.role_status = temp_model.from_map(m['RoleStatus'])
        return self


class DescribeServiceLinkedRoleStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeServiceLinkedRoleStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeServiceLinkedRoleStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServiceLinkedRoleStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimilarEventScenariosRequest(TeaModel):
    def __init__(self, resource_owner_id=None, security_event_id=None, source_ip=None):
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the alert to query.
        self.security_event_id = security_event_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSimilarEventScenariosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSimilarEventScenariosResponseBodyScenarios(TeaModel):
    def __init__(self, code=None):
        # The code of the scenario. Valid values: Valid values:
        # - **default**: the same alert type
        # - **same_file_content**: the same file content rule
        # - **same_ip**: the same IP address rule
        # - **same_url**: the same URL rule
        self.code = code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSimilarEventScenariosResponseBodyScenarios, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        return self


class DescribeSimilarEventScenariosResponseBody(TeaModel):
    def __init__(self, request_id=None, scenarios=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The scenarios in which you can handle the alerts triggered by the same rule or rules of the same type.
        self.scenarios = scenarios  # type: list[DescribeSimilarEventScenariosResponseBodyScenarios]

    def validate(self):
        if self.scenarios:
            for k in self.scenarios:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSimilarEventScenariosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Scenarios'] = []
        if self.scenarios is not None:
            for k in self.scenarios:
                result['Scenarios'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scenarios = []
        if m.get('Scenarios') is not None:
            for k in m.get('Scenarios'):
                temp_model = DescribeSimilarEventScenariosResponseBodyScenarios()
                self.scenarios.append(temp_model.from_map(k))
        return self


class DescribeSimilarEventScenariosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSimilarEventScenariosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSimilarEventScenariosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimilarEventScenariosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimilarSecurityEventsRequest(TeaModel):
    def __init__(self, current_page=None, lang=None, page_size=None, resource_owner_id=None, source_ip=None,
                 task_id=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the task. You can call the [CreateSimilarSecurityEventsQueryTask](~~CreateSimilarSecurityEventsQueryTask~~) operation to query the IDs of tasks.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSimilarSecurityEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSimilarSecurityEventsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSimilarSecurityEventsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse(TeaModel):
    def __init__(self, event_name=None, event_type=None, last_time=None, occurrence_time=None,
                 security_event_id=None, uuid=None):
        # The name of the alert event.
        self.event_name = event_name  # type: str
        # The alert type of the alert event. Valid values:
        # 
        # *   Suspicious process
        # *   Webshell
        # *   Unusual logon
        # *   Exception
        # *   Sensitive file tampering
        # *   Malicious process (cloud threat detection)
        # *   Suspicious network connection
        # *   Other
        # *   Abnormal account
        # *   Application intrusion event
        # *   Cloud threat detection
        # *   Precise defense
        # *   Application whitelist
        # *   Persistent webshell
        # *   Web application threat detection
        # *   Malicious script
        # *   Threat intelligence
        # *   Malicious network activity
        # *   Cluster exception
        # *   Webshell (on-premises threat detection)
        # *   Vulnerability exploitation
        # *   Malicious process (on-premises threat detection)
        # *   Trusted exception
        # 
        # For more information about alert types, see [Alerts](~~191144~~).
        self.event_type = event_type  # type: str
        # The timestamp when the alert event was last detected. Unit: milliseconds.
        self.last_time = last_time  # type: long
        # The timestamp when the alert event was first detected. Unit: milliseconds.
        self.occurrence_time = occurrence_time  # type: long
        # The ID of the alert event.
        self.security_event_id = security_event_id  # type: long
        # The UUID of the server that is affected by the alert event.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSimilarSecurityEventsResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, security_events_response=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeSimilarSecurityEventsResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the alert events that are triggered by the same rule or of the same alert type.
        self.security_events_response = security_events_response  # type: list[DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.security_events_response:
            for k in self.security_events_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSimilarSecurityEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventsResponse'] = []
        if self.security_events_response is not None:
            for k in self.security_events_response:
                result['SecurityEventsResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeSimilarSecurityEventsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_events_response = []
        if m.get('SecurityEventsResponse') is not None:
            for k in m.get('SecurityEventsResponse'):
                temp_model = DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse()
                self.security_events_response.append(temp_model.from_map(k))
        return self


class DescribeSimilarSecurityEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSimilarSecurityEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSimilarSecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimilarSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsRequest(TeaModel):
    def __init__(self, api_version=None, current_page=None, is_ali_yun_ecs=None, machine_region=None,
                 machine_remark=None, next_token=None, page_size=None, status_list=None, uuid=None):
        self.api_version = api_version  # type: str
        self.current_page = current_page  # type: int
        self.is_ali_yun_ecs = is_ali_yun_ecs  # type: str
        self.machine_region = machine_region  # type: str
        self.machine_remark = machine_remark  # type: str
        self.next_token = next_token  # type: str
        self.page_size = page_size  # type: int
        self.status_list = status_list  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_version is not None:
            result['ApiVersion'] = self.api_version
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_ali_yun_ecs is not None:
            result['IsAliYunEcs'] = self.is_ali_yun_ecs
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.machine_remark is not None:
            result['MachineRemark'] = self.machine_remark
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApiVersion') is not None:
            self.api_version = m.get('ApiVersion')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsAliYunEcs') is not None:
            self.is_ali_yun_ecs = m.get('IsAliYunEcs')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('MachineRemark') is not None:
            self.machine_remark = m.get('MachineRemark')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSnapshotsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, next_token=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.next_token = next_token  # type: str
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotsResponseBodySnapshots(TeaModel):
    def __init__(self, actual_bytes=None, actual_items=None, bytes_done=None, bytes_total=None, client_id=None,
                 client_version=None, created_time=None, error_file=None, instance_id=None, items_done=None, items_total=None,
                 job_id=None, parent_snapshot_hash=None, path=None, paths=None, plan_id=None, region_id=None,
                 retention=None, snapshot_hash=None, snapshot_id=None, source_type=None, status=None, uuid=None, vault_id=None):
        self.actual_bytes = actual_bytes  # type: long
        self.actual_items = actual_items  # type: long
        self.bytes_done = bytes_done  # type: long
        self.bytes_total = bytes_total  # type: long
        self.client_id = client_id  # type: str
        self.client_version = client_version  # type: str
        self.created_time = created_time  # type: long
        self.error_file = error_file  # type: str
        self.instance_id = instance_id  # type: str
        self.items_done = items_done  # type: long
        self.items_total = items_total  # type: long
        self.job_id = job_id  # type: str
        self.parent_snapshot_hash = parent_snapshot_hash  # type: str
        self.path = path  # type: str
        self.paths = paths  # type: list[str]
        self.plan_id = plan_id  # type: str
        self.region_id = region_id  # type: str
        self.retention = retention  # type: long
        self.snapshot_hash = snapshot_hash  # type: str
        self.snapshot_id = snapshot_id  # type: str
        self.source_type = source_type  # type: str
        self.status = status  # type: str
        self.uuid = uuid  # type: str
        self.vault_id = vault_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshots, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_bytes is not None:
            result['ActualBytes'] = self.actual_bytes
        if self.actual_items is not None:
            result['ActualItems'] = self.actual_items
        if self.bytes_done is not None:
            result['BytesDone'] = self.bytes_done
        if self.bytes_total is not None:
            result['BytesTotal'] = self.bytes_total
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.error_file is not None:
            result['ErrorFile'] = self.error_file
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.items_done is not None:
            result['ItemsDone'] = self.items_done
        if self.items_total is not None:
            result['ItemsTotal'] = self.items_total
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.parent_snapshot_hash is not None:
            result['ParentSnapshotHash'] = self.parent_snapshot_hash
        if self.path is not None:
            result['Path'] = self.path
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.plan_id is not None:
            result['PlanId'] = self.plan_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.snapshot_hash is not None:
            result['SnapshotHash'] = self.snapshot_hash
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vault_id is not None:
            result['VaultId'] = self.vault_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActualBytes') is not None:
            self.actual_bytes = m.get('ActualBytes')
        if m.get('ActualItems') is not None:
            self.actual_items = m.get('ActualItems')
        if m.get('BytesDone') is not None:
            self.bytes_done = m.get('BytesDone')
        if m.get('BytesTotal') is not None:
            self.bytes_total = m.get('BytesTotal')
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('ErrorFile') is not None:
            self.error_file = m.get('ErrorFile')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemsDone') is not None:
            self.items_done = m.get('ItemsDone')
        if m.get('ItemsTotal') is not None:
            self.items_total = m.get('ItemsTotal')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ParentSnapshotHash') is not None:
            self.parent_snapshot_hash = m.get('ParentSnapshotHash')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('PlanId') is not None:
            self.plan_id = m.get('PlanId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SnapshotHash') is not None:
            self.snapshot_hash = m.get('SnapshotHash')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VaultId') is not None:
            self.vault_id = m.get('VaultId')
        return self


class DescribeSnapshotsResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, snapshots=None):
        self.page_info = page_info  # type: DescribeSnapshotsResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.snapshots = snapshots  # type: list[DescribeSnapshotsResponseBodySnapshots]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.snapshots:
            for k in self.snapshots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Snapshots'] = []
        if self.snapshots is not None:
            for k in self.snapshots:
                result['Snapshots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeSnapshotsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.snapshots = []
        if m.get('Snapshots') is not None:
            for k in m.get('Snapshots'):
                temp_model = DescribeSnapshotsResponseBodySnapshots()
                self.snapshots.append(temp_model.from_map(k))
        return self


class DescribeSnapshotsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyRequest(TeaModel):
    def __init__(self, custom_type=None, lang=None, source_ip=None, strategy_ids=None):
        self.custom_type = custom_type  # type: str
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str
        self.strategy_ids = strategy_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_ids is not None:
            result['StrategyIds'] = self.strategy_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyIds') is not None:
            self.strategy_ids = m.get('StrategyIds')
        return self


class DescribeStrategyResponseBodyStrategiesConfigTargets(TeaModel):
    def __init__(self, flag=None, target=None, target_type=None):
        self.flag = flag  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyResponseBodyStrategiesConfigTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeStrategyResponseBodyStrategies(TeaModel):
    def __init__(self, config_targets=None, custom_type=None, cycle_days=None, cycle_start_time=None,
                 ecs_count=None, end_time=None, exec_status=None, id=None, name=None, pass_rate=None, process_rate=None,
                 risk_count=None, start_time=None, type=None):
        self.config_targets = config_targets  # type: list[DescribeStrategyResponseBodyStrategiesConfigTargets]
        self.custom_type = custom_type  # type: str
        self.cycle_days = cycle_days  # type: int
        self.cycle_start_time = cycle_start_time  # type: int
        self.ecs_count = ecs_count  # type: int
        self.end_time = end_time  # type: str
        self.exec_status = exec_status  # type: int
        self.id = id  # type: int
        self.name = name  # type: str
        self.pass_rate = pass_rate  # type: int
        self.process_rate = process_rate  # type: int
        self.risk_count = risk_count  # type: int
        self.start_time = start_time  # type: str
        self.type = type  # type: int

    def validate(self):
        if self.config_targets:
            for k in self.config_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyResponseBodyStrategies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigTargets'] = []
        if self.config_targets is not None:
            for k in self.config_targets:
                result['ConfigTargets'].append(k.to_map() if k else None)
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.ecs_count is not None:
            result['EcsCount'] = self.ecs_count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_status is not None:
            result['ExecStatus'] = self.exec_status
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.pass_rate is not None:
            result['PassRate'] = self.pass_rate
        if self.process_rate is not None:
            result['ProcessRate'] = self.process_rate
        if self.risk_count is not None:
            result['RiskCount'] = self.risk_count
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.config_targets = []
        if m.get('ConfigTargets') is not None:
            for k in m.get('ConfigTargets'):
                temp_model = DescribeStrategyResponseBodyStrategiesConfigTargets()
                self.config_targets.append(temp_model.from_map(k))
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EcsCount') is not None:
            self.ecs_count = m.get('EcsCount')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecStatus') is not None:
            self.exec_status = m.get('ExecStatus')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PassRate') is not None:
            self.pass_rate = m.get('PassRate')
        if m.get('ProcessRate') is not None:
            self.process_rate = m.get('ProcessRate')
        if m.get('RiskCount') is not None:
            self.risk_count = m.get('RiskCount')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None, strategies=None):
        self.request_id = request_id  # type: str
        self.strategies = strategies  # type: list[DescribeStrategyResponseBodyStrategies]

    def validate(self):
        if self.strategies:
            for k in self.strategies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Strategies'] = []
        if self.strategies is not None:
            for k in self.strategies:
                result['Strategies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.strategies = []
        if m.get('Strategies') is not None:
            for k in m.get('Strategies'):
                temp_model = DescribeStrategyResponseBodyStrategies()
                self.strategies.append(temp_model.from_map(k))
        return self


class DescribeStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyDetailRequest(TeaModel):
    def __init__(self, id=None, lang=None, source_ip=None):
        # The ID of the baseline check policy.
        self.id = id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList(TeaModel):
    def __init__(self, enum_value=None, max_value=None, min_value=None, param_default_value=None, param_desc=None,
                 param_name=None, param_type=None, value=None):
        # If the value of paramType is 2, this parameter provides the options that can be selected for the rule parameter.
        self.enum_value = enum_value  # type: str
        # The maximum value of the rule parameter.
        self.max_value = max_value  # type: int
        # The minimum value of the rule parameter.
        self.min_value = min_value  # type: int
        # The default value of the rule parameter.
        self.param_default_value = param_default_value  # type: str
        # The description of the rule parameter.
        self.param_desc = param_desc  # type: str
        # The name of the rule parameter.
        self.param_name = param_name  # type: str
        # The type of the rule parameter. Valid values:
        # 
        # *   **1**: input
        # *   **2**: selection
        self.param_type = param_type  # type: int
        # The specified value of the rule parameter.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enum_value is not None:
            result['EnumValue'] = self.enum_value
        if self.max_value is not None:
            result['MaxValue'] = self.max_value
        if self.min_value is not None:
            result['MinValue'] = self.min_value
        if self.param_default_value is not None:
            result['ParamDefaultValue'] = self.param_default_value
        if self.param_desc is not None:
            result['ParamDesc'] = self.param_desc
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnumValue') is not None:
            self.enum_value = m.get('EnumValue')
        if m.get('MaxValue') is not None:
            self.max_value = m.get('MaxValue')
        if m.get('MinValue') is not None:
            self.min_value = m.get('MinValue')
        if m.get('ParamDefaultValue') is not None:
            self.param_default_value = m.get('ParamDefaultValue')
        if m.get('ParamDesc') is not None:
            self.param_desc = m.get('ParamDesc')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules(TeaModel):
    def __init__(self, default_value=None, optional=None, param_list=None, rule_desc=None, rule_id=None):
        # The default value of the rule.
        self.default_value = default_value  # type: int
        # Indicates whether the rule is included in the policy. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.optional = optional  # type: int
        # An array that consists of the rule parameters.
        self.param_list = param_list  # type: list[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList]
        # The description of the rule.
        self.rule_desc = rule_desc  # type: str
        # The ID of the rule.
        self.rule_id = rule_id  # type: str

    def validate(self):
        if self.param_list:
            for k in self.param_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.optional is not None:
            result['Optional'] = self.optional
        result['ParamList'] = []
        if self.param_list is not None:
            for k in self.param_list:
                result['ParamList'].append(k.to_map() if k else None)
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        self.param_list = []
        if m.get('ParamList') is not None:
            for k in m.get('ParamList'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList()
                self.param_list.append(temp_model.from_map(k))
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails(TeaModel):
    def __init__(self, check_desc=None, check_id=None, check_item=None, rules=None):
        # The description of the check item.
        self.check_desc = check_desc  # type: str
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The check item.
        self.check_item = check_item  # type: str
        # An array that consists of the details of rules.
        self.rules = rules  # type: list[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules]

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_desc is not None:
            result['CheckDesc'] = self.check_desc
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckDesc') is not None:
            self.check_desc = m.get('CheckDesc')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes(TeaModel):
    def __init__(self, alias=None, check_details=None, on=None, type_name=None):
        # The alias of the sub-check item.
        self.alias = alias  # type: str
        # An array that consists of the details of custom check items.
        self.check_details = check_details  # type: list[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails]
        # Indicates whether the sub-risk item is selected. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.on = on  # type: bool
        # The type of the sub-check item.
        self.type_name = type_name  # type: str

    def validate(self):
        if self.check_details:
            for k in self.check_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['CheckDetails'] = []
        if self.check_details is not None:
            for k in self.check_details:
                result['CheckDetails'].append(k.to_map() if k else None)
        if self.on is not None:
            result['On'] = self.on
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.check_details = []
        if m.get('CheckDetails') is not None:
            for k in m.get('CheckDetails'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails()
                self.check_details.append(temp_model.from_map(k))
        if m.get('On') is not None:
            self.on = m.get('On')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList(TeaModel):
    def __init__(self, alias=None, on=None, sub_types=None, type_name=None):
        # The alias of the check item.
        self.alias = alias  # type: str
        # Indicates whether the risk item is selected. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.on = on  # type: bool
        # An array that consists of sub-risk items.
        self.sub_types = sub_types  # type: list[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes]
        # The check item.
        self.type_name = type_name  # type: str

    def validate(self):
        if self.sub_types:
            for k in self.sub_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.on is not None:
            result['On'] = self.on
        result['SubTypes'] = []
        if self.sub_types is not None:
            for k in self.sub_types:
                result['SubTypes'].append(k.to_map() if k else None)
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('On') is not None:
            self.on = m.get('On')
        self.sub_types = []
        if m.get('SubTypes') is not None:
            for k in m.get('SubTypes'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes()
                self.sub_types.append(temp_model.from_map(k))
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class DescribeStrategyDetailResponseBodyStrategy(TeaModel):
    def __init__(self, custom_type=None, cycle_days=None, cycle_start_time=None, end_time=None, id=None, name=None,
                 risk_sub_type_name=None, risk_type_white_list_query_result_list=None, start_time=None, target_type=None, type=None):
        # The type of the baseline check policy. Valid values:
        # 
        # *   **common**: standard baseline check policy
        # *   **custom**: custom baseline check policy
        self.custom_type = custom_type  # type: str
        # The check interval of the policy.
        self.cycle_days = cycle_days  # type: int
        # The time period during which the check starts. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.cycle_start_time = cycle_start_time  # type: int
        # The time when the baseline check based on the baseline check policy ends.
        self.end_time = end_time  # type: str
        # The ID of the baseline check policy.
        self.id = id  # type: int
        # The name of the baseline check policy.
        self.name = name  # type: str
        # The subtype of the baselines.
        self.risk_sub_type_name = risk_sub_type_name  # type: str
        # An array that consists of the whitelist of risk items.
        self.risk_type_white_list_query_result_list = risk_type_white_list_query_result_list  # type: list[DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList]
        # The time when the baseline check based on the baseline check policy starts.
        self.start_time = start_time  # type: str
        # The condition by which the baseline check policy is applied to the asset. Valid values:
        # 
        # *   **groupId**: the ID of the asset group
        # *   **uuid**: the UUID of the asset
        self.target_type = target_type  # type: str
        # The type of the baseline check policy. Valid values:
        # 
        # *   **1**: standard baseline check policy
        # *   **2**: custom baseline check policy
        self.type = type  # type: int

    def validate(self):
        if self.risk_type_white_list_query_result_list:
            for k in self.risk_type_white_list_query_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBodyStrategy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.risk_sub_type_name is not None:
            result['RiskSubTypeName'] = self.risk_sub_type_name
        result['RiskTypeWhiteListQueryResultList'] = []
        if self.risk_type_white_list_query_result_list is not None:
            for k in self.risk_type_white_list_query_result_list:
                result['RiskTypeWhiteListQueryResultList'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RiskSubTypeName') is not None:
            self.risk_sub_type_name = m.get('RiskSubTypeName')
        self.risk_type_white_list_query_result_list = []
        if m.get('RiskTypeWhiteListQueryResultList') is not None:
            for k in m.get('RiskTypeWhiteListQueryResultList'):
                temp_model = DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList()
                self.risk_type_white_list_query_result_list.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyDetailResponseBody(TeaModel):
    def __init__(self, request_id=None, strategy=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The information about the baseline check policy.
        self.strategy = strategy  # type: DescribeStrategyDetailResponseBodyStrategy

    def validate(self):
        if self.strategy:
            self.strategy.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategy') is not None:
            temp_model = DescribeStrategyDetailResponseBodyStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        return self


class DescribeStrategyDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStrategyDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStrategyDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyExecDetailRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, source_ip=None, strategy_id=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyExecDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeStrategyExecDetailResponseBodyFailedEcsList(TeaModel):
    def __init__(self, ip=None, instance_name=None, internet_ip=None, intranet_ip=None, reason=None):
        # The IP address of the server on which the baseline check was performed.
        self.ip = ip  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The public IP address.
        self.internet_ip = internet_ip  # type: str
        # The private IP address.
        self.intranet_ip = intranet_ip  # type: str
        # The failure cause for the check item.
        self.reason = reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyExecDetailResponseBodyFailedEcsList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['IP'] = self.ip
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class DescribeStrategyExecDetailResponseBody(TeaModel):
    def __init__(self, end_time=None, fail_count=None, failed_ecs_list=None, in_process_count=None, percent=None,
                 request_id=None, source=None, start_time=None, success_count=None):
        # The time when the baseline check ends.
        self.end_time = end_time  # type: str
        # The number of check items that failed to pass the baseline check. This type of check item is considered risk items.
        self.fail_count = fail_count  # type: int
        # An array consisting of the servers on which risk items were detected.
        self.failed_ecs_list = failed_ecs_list  # type: list[DescribeStrategyExecDetailResponseBodyFailedEcsList]
        # The number of tasks that are **running** based on the baseline check policy.
        self.in_process_count = in_process_count  # type: int
        # The execution progress of the baseline check policy.
        self.percent = percent  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The type of the baseline check. Valid values:
        # 
        # *   **Schedule**: automatic check that periodically runs
        # *   **Manual**: intermediate check that is manually performed
        self.source = source  # type: str
        # The time when the baseline check starts.
        self.start_time = start_time  # type: str
        # The number of check items that **passed** the baseline check.
        self.success_count = success_count  # type: int

    def validate(self):
        if self.failed_ecs_list:
            for k in self.failed_ecs_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyExecDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        result['FailedEcsList'] = []
        if self.failed_ecs_list is not None:
            for k in self.failed_ecs_list:
                result['FailedEcsList'].append(k.to_map() if k else None)
        if self.in_process_count is not None:
            result['InProcessCount'] = self.in_process_count
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        self.failed_ecs_list = []
        if m.get('FailedEcsList') is not None:
            for k in m.get('FailedEcsList'):
                temp_model = DescribeStrategyExecDetailResponseBodyFailedEcsList()
                self.failed_ecs_list.append(temp_model.from_map(k))
        if m.get('InProcessCount') is not None:
            self.in_process_count = m.get('InProcessCount')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DescribeStrategyExecDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStrategyExecDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStrategyExecDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyExecDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStrategyTargetRequest(TeaModel):
    def __init__(self, config=None, source_ip=None, type=None):
        # The ID of the baseline check policy.
        self.config = config  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the policy. Set the value to hc_strategy, which indicates baseline check policies.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStrategyTargetResponseBodyStrategyTargets(TeaModel):
    def __init__(self, bind_uuid_count=None, flag=None, target=None, target_type=None):
        # The number of the assets that belong to the asset group.
        self.bind_uuid_count = bind_uuid_count  # type: int
        # Indicates whether the baseline check policy is applied to the asset group. Valid values:
        # 
        # *   **add**: yes
        # *   **del**: no
        self.flag = flag  # type: str
        # The ID of the asset group to which the assets belong or the UUID of the asset.
        self.target = target  # type: str
        # The method that is used to add the assets to the baseline check policy. Valid values:
        # 
        # *   **groupId**: the ID of the asset group
        # *   **uuid**: the UUID of the asset
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStrategyTargetResponseBodyStrategyTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_uuid_count is not None:
            result['BindUuidCount'] = self.bind_uuid_count
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindUuidCount') is not None:
            self.bind_uuid_count = m.get('BindUuidCount')
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeStrategyTargetResponseBody(TeaModel):
    def __init__(self, request_id=None, strategy_targets=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array consisting of the assets to which the baseline check policy is applied.
        self.strategy_targets = strategy_targets  # type: list[DescribeStrategyTargetResponseBodyStrategyTargets]

    def validate(self):
        if self.strategy_targets:
            for k in self.strategy_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStrategyTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StrategyTargets'] = []
        if self.strategy_targets is not None:
            for k in self.strategy_targets:
                result['StrategyTargets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.strategy_targets = []
        if m.get('StrategyTargets') is not None:
            for k in m.get('StrategyTargets'):
                temp_model = DescribeStrategyTargetResponseBodyStrategyTargets()
                self.strategy_targets.append(temp_model.from_map(k))
        return self


class DescribeStrategyTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStrategyTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStrategyTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStrategyTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSummaryInfoRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSummaryInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSummaryInfoResponseBody(TeaModel):
    def __init__(self, aegis_client_offline_count=None, aegis_client_online_count=None, request_id=None,
                 security_score=None, success=None):
        # The number of unprotected assets.
        self.aegis_client_offline_count = aegis_client_offline_count  # type: int
        # The number of protected assets.
        self.aegis_client_online_count = aegis_client_online_count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The security score of the assets. Valid values:
        # 
        # *   95 to 100: The assets are secure.
        # *   85 to 94: The assets are exposed to a few security risks. We recommend that you reinforce your security system in a timely manner.
        # *   70 to 84: The assets are exposed to multiple security risks. We recommend that you reinforce your security system in a timely manner.
        # *   69 or lower: The current security system is unable to protect the assets against intrusions. We recommend that you reinforce your security system at the earliest opportunity.
        self.security_score = security_score  # type: int
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSummaryInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aegis_client_offline_count is not None:
            result['AegisClientOfflineCount'] = self.aegis_client_offline_count
        if self.aegis_client_online_count is not None:
            result['AegisClientOnlineCount'] = self.aegis_client_online_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_score is not None:
            result['SecurityScore'] = self.security_score
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AegisClientOfflineCount') is not None:
            self.aegis_client_offline_count = m.get('AegisClientOfflineCount')
        if m.get('AegisClientOnlineCount') is not None:
            self.aegis_client_online_count = m.get('AegisClientOnlineCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityScore') is not None:
            self.security_score = m.get('SecurityScore')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSummaryInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSummaryInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSummaryInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSummaryInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSupportRegionResponseBody(TeaModel):
    def __init__(self, request_id=None, support_region=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The regions in which the anti-ransomware feature is supported.
        self.support_region = support_region  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSupportRegionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_region is not None:
            result['SupportRegion'] = self.support_region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportRegion') is not None:
            self.support_region = m.get('SupportRegion')
        return self


class DescribeSupportRegionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSupportRegionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSupportRegionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSupportRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventDetailRequest(TeaModel):
    def __init__(self, from_=None, lang=None, source_ip=None, suspicious_event_id=None):
        # The data source of the exception. Set the value to sas.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the exception.
        self.suspicious_event_id = suspicious_event_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.suspicious_event_id is not None:
            result['SuspiciousEventId'] = self.suspicious_event_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SuspiciousEventId') is not None:
            self.suspicious_event_id = m.get('SuspiciousEventId')
        return self


class DescribeSuspEventDetailResponseBodyDetails(TeaModel):
    def __init__(self, name_display=None, type=None, value=None):
        # The display name of the alert event.
        self.name_display = name_display  # type: str
        # The format in which the details about the exception are displayed.
        # 
        # Valid values:
        # 
        # *   **text**\
        # *   **html**\
        self.type = type  # type: str
        # The attribute information about the exception. For example, if the exception is associated with an alert that is triggered by an unusual logon, the information can include the time when the logon is initiated and the location from which the logon is initiated. If the exception is associated with an alert that is triggered by a webshell file, the information can include the path of the trojan file and the type of the trojan.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventDetailResponseBodyDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_display is not None:
            result['NameDisplay'] = self.name_display
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NameDisplay') is not None:
            self.name_display = m.get('NameDisplay')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSuspEventDetailResponseBody(TeaModel):
    def __init__(self, can_be_deal_on_line=None, data_source=None, details=None, event_desc=None, event_name=None,
                 event_status=None, event_type_desc=None, id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 last_time=None, level=None, operate_error_code=None, operate_msg=None, request_id=None, sale_version=None,
                 uuid=None):
        # Indicates whether the online processing of exceptions is supported, such as blocking an exception, adding an exception to the whitelist, and ignoring an exception. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.can_be_deal_on_line = can_be_deal_on_line  # type: bool
        # The data source of the exception.
        self.data_source = data_source  # type: str
        # The details about the exception.
        self.details = details  # type: list[DescribeSuspEventDetailResponseBodyDetails]
        # The description of the exception.
        self.event_desc = event_desc  # type: str
        # The name of the exception.
        self.event_name = event_name  # type: str
        # The status of the exception. Valid values:
        # 
        # *   **1**: pending handling
        # *   **2**: ignored
        # *   **4**: confirmed
        # *   **8**: marked as a false positive
        # *   **16**: handling
        # *   **32**: handled
        # *   **64**: expired
        self.event_status = event_status  # type: str
        # The type of the exception.
        self.event_type_desc = event_type_desc  # type: str
        # The ID of the exception.
        self.id = id  # type: int
        # The name of the server on which the exception was detected.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server on which the exception was detected.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server on which the exception was detected.
        self.intranet_ip = intranet_ip  # type: str
        # The time when the exception was last detected.
        self.last_time = last_time  # type: str
        # The severity of the exception. Valid values:
        # 
        # *   **serious**\
        # *   **suspicious**\
        # *   **remind**\
        self.level = level  # type: str
        # The code that indicates the handling result of the exception.
        self.operate_error_code = operate_error_code  # type: str
        # The message that indicates the handling result of the exception.
        self.operate_msg = operate_msg  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The edition of Security Center in which the exception can be detected. Valid values:
        # 
        # *   **0**: Basic edition
        # *   **1**: Advanced edition
        # *   **2**: Enterprise edition
        self.sale_version = sale_version  # type: str
        # The UUID of the server on which the exception was detected.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.event_desc is not None:
            result['EventDesc'] = self.event_desc
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_type_desc is not None:
            result['EventTypeDesc'] = self.event_type_desc
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.level is not None:
            result['Level'] = self.level
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_msg is not None:
            result['OperateMsg'] = self.operate_msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DescribeSuspEventDetailResponseBodyDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('EventDesc') is not None:
            self.event_desc = m.get('EventDesc')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventTypeDesc') is not None:
            self.event_type_desc = m.get('EventTypeDesc')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateMsg') is not None:
            self.operate_msg = m.get('OperateMsg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSuspEventDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventExportInfoRequest(TeaModel):
    def __init__(self, export_id=None):
        self.export_id = export_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeSuspEventExportInfoResponseBody(TeaModel):
    def __init__(self, export_status=None, file_name=None, gmt_create=None, gmt_modified=None, id=None, link=None,
                 progress=None, properties=None, request_id=None, total_count=None, type=None):
        self.export_status = export_status  # type: str
        self.file_name = file_name  # type: str
        self.gmt_create = gmt_create  # type: long
        self.gmt_modified = gmt_modified  # type: long
        self.id = id  # type: int
        self.link = link  # type: str
        self.progress = progress  # type: int
        self.properties = properties  # type: str
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.properties is not None:
            result['Properties'] = self.properties
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Properties') is not None:
            self.properties = m.get('Properties')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspEventExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventQuaraFilesRequest(TeaModel):
    def __init__(self, current_page=None, from_=None, group_id=None, grouping_id=None, page_size=None,
                 quara_tag=None, source_ip=None, status=None):
        # The number of the page to return.
        self.current_page = current_page  # type: str
        # The ID of the request source. Set the value to **sas**.
        self.from_ = from_  # type: str
        # The ID of the asset group.
        self.group_id = group_id  # type: str
        # The ID of the server group to which the server belongs. The quarantined file is located on the server.
        self.grouping_id = grouping_id  # type: long
        # The number of entries to return on each page.
        self.page_size = page_size  # type: str
        # The unique ID of the quarantined file.
        self.quara_tag = quara_tag  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The status of the quarantined file that you want to query. Valid values:
        # 
        # *   **quaraFailed**: The file fails to be quarantined.
        # *   **quaraDone**: The file is quarantined.
        # *   **quaraing**: The file is being quarantined.
        # *   **rollbackFailed**: The system fails to cancel quarantining the file.
        # *   **rollbackDone**: The system cancelled quarantining the file.
        # *   **rollbacking**: The system is cancelling quarantining the file.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.grouping_id is not None:
            result['GroupingId'] = self.grouping_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.quara_tag is not None:
            result['QuaraTag'] = self.quara_tag
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupingId') is not None:
            self.grouping_id = m.get('GroupingId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QuaraTag') is not None:
            self.quara_tag = m.get('QuaraTag')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles(TeaModel):
    def __init__(self, event_name=None, event_type=None, id=None, instance_id=None, instance_name=None,
                 internet_ip=None, ip=None, link=None, md_5=None, modify_time=None, path=None, status=None, tag=None, uuid=None):
        # The name of the event.
        self.event_name = event_name  # type: str
        # The type of the event.
        self.event_type = event_type  # type: str
        # The ID of the quarantined file.
        self.id = id  # type: int
        # The instance ID of the asset.
        self.instance_id = instance_id  # type: str
        # The name of the server on which the quarantined file is located.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server on which the quarantined file is located.
        self.internet_ip = internet_ip  # type: str
        # The public IP address of the server on which the quarantined file is located.
        self.ip = ip  # type: str
        # The download link of the quarantined file.
        self.link = link  # type: str
        # The MD5 hash value of the quarantined file.
        self.md_5 = md_5  # type: str
        # The time when the quarantined file was last modified.
        self.modify_time = modify_time  # type: str
        # The path to the quarantined file on the server.
        self.path = path  # type: str
        # The status of the quarantined file. Valid values:
        # 
        # *   **quaraFailed**: The file fails to be quarantined.
        # *   **quaraDone**: The file is quarantined.
        # *   **quaraing**: The file is being quarantined.
        # *   **rollbackFailed**: The system fails to cancel quarantining the file.
        # *   **rollbackDone**: The system cancelled quarantining the file.
        # *   **rollbacking**: The system is cancelling quarantining the file.
        self.status = status  # type: str
        # The unique ID of the event.
        self.tag = tag  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponseBodyQuaraFiles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.link is not None:
            result['Link'] = self.link
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.path is not None:
            result['Path'] = self.path
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeSuspEventQuaraFilesResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, quara_files=None, request_id=None,
                 total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # An array that consists of the quarantined files.
        self.quara_files = quara_files  # type: list[DescribeSuspEventQuaraFilesResponseBodyQuaraFiles]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.quara_files:
            for k in self.quara_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['QuaraFiles'] = []
        if self.quara_files is not None:
            for k in self.quara_files:
                result['QuaraFiles'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.quara_files = []
        if m.get('QuaraFiles') is not None:
            for k in m.get('QuaraFiles'):
                temp_model = DescribeSuspEventQuaraFilesResponseBodyQuaraFiles()
                self.quara_files.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventQuaraFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventQuaraFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventQuaraFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventUserSettingRequest(TeaModel):
    def __init__(self, from_=None, id=None, source_ip=None):
        self.from_ = from_  # type: str
        self.id = id  # type: int
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventUserSettingRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.id is not None:
            result['Id'] = self.id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeSuspEventUserSettingResponseBody(TeaModel):
    def __init__(self, levels_on=None, request_id=None):
        self.levels_on = levels_on  # type: list[str]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventUserSettingResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSuspEventUserSettingResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventUserSettingResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventUserSettingResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventsRequest(TeaModel):
    def __init__(self, alarm_unique_info=None, assets_type_list=None, cluster_id=None, container_field_name=None,
                 container_field_value=None, current_page=None, dealed=None, event_names=None, from_=None, group_id=None, id=None,
                 lang=None, levels=None, name=None, operate_error_code_list=None, operate_time_end=None,
                 operate_time_start=None, page_size=None, parent_event_types=None, remark=None, sort_column=None, sort_type=None,
                 source=None, source_ip=None, status=None, tactic_id=None, target_type=None, time_end=None, time_start=None,
                 unique_info=None, uuids=None):
        self.alarm_unique_info = alarm_unique_info  # type: str
        self.assets_type_list = assets_type_list  # type: list[str]
        self.cluster_id = cluster_id  # type: str
        self.container_field_name = container_field_name  # type: str
        self.container_field_value = container_field_value  # type: str
        self.current_page = current_page  # type: str
        self.dealed = dealed  # type: str
        self.event_names = event_names  # type: str
        self.from_ = from_  # type: str
        self.group_id = group_id  # type: long
        self.id = id  # type: long
        self.lang = lang  # type: str
        self.levels = levels  # type: str
        self.name = name  # type: str
        self.operate_error_code_list = operate_error_code_list  # type: list[str]
        self.operate_time_end = operate_time_end  # type: str
        self.operate_time_start = operate_time_start  # type: str
        self.page_size = page_size  # type: str
        self.parent_event_types = parent_event_types  # type: str
        self.remark = remark  # type: str
        self.sort_column = sort_column  # type: str
        self.sort_type = sort_type  # type: str
        self.source = source  # type: str
        self.source_ip = source_ip  # type: str
        self.status = status  # type: str
        self.tactic_id = tactic_id  # type: str
        self.target_type = target_type  # type: str
        self.time_end = time_end  # type: str
        self.time_start = time_start  # type: str
        self.unique_info = unique_info  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.assets_type_list is not None:
            result['AssetsTypeList'] = self.assets_type_list
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.event_names is not None:
            result['EventNames'] = self.event_names
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.name is not None:
            result['Name'] = self.name
        if self.operate_error_code_list is not None:
            result['OperateErrorCodeList'] = self.operate_error_code_list
        if self.operate_time_end is not None:
            result['OperateTimeEnd'] = self.operate_time_end
        if self.operate_time_start is not None:
            result['OperateTimeStart'] = self.operate_time_start
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_event_types is not None:
            result['ParentEventTypes'] = self.parent_event_types
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sort_column is not None:
            result['SortColumn'] = self.sort_column
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.source is not None:
            result['Source'] = self.source
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.time_end is not None:
            result['TimeEnd'] = self.time_end
        if self.time_start is not None:
            result['TimeStart'] = self.time_start
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AssetsTypeList') is not None:
            self.assets_type_list = m.get('AssetsTypeList')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('EventNames') is not None:
            self.event_names = m.get('EventNames')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OperateErrorCodeList') is not None:
            self.operate_error_code_list = m.get('OperateErrorCodeList')
        if m.get('OperateTimeEnd') is not None:
            self.operate_time_end = m.get('OperateTimeEnd')
        if m.get('OperateTimeStart') is not None:
            self.operate_time_start = m.get('OperateTimeStart')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentEventTypes') is not None:
            self.parent_event_types = m.get('ParentEventTypes')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SortColumn') is not None:
            self.sort_column = m.get('SortColumn')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TimeEnd') is not None:
            self.time_end = m.get('TimeEnd')
        if m.get('TimeStart') is not None:
            self.time_start = m.get('TimeStart')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeSuspEventsResponseBodySuspEventsDetails(TeaModel):
    def __init__(self, name_display=None, type=None, value=None, value_display=None):
        self.name_display = name_display  # type: str
        self.type = type  # type: str
        self.value = value  # type: str
        self.value_display = value_display  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEventsDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_display is not None:
            result['NameDisplay'] = self.name_display
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.value_display is not None:
            result['ValueDisplay'] = self.value_display
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NameDisplay') is not None:
            self.name_display = m.get('NameDisplay')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueDisplay') is not None:
            self.value_display = m.get('ValueDisplay')
        return self


class DescribeSuspEventsResponseBodySuspEventsEventNotes(TeaModel):
    def __init__(self, note=None, note_id=None, note_time=None):
        self.note = note  # type: str
        self.note_id = note_id  # type: long
        self.note_time = note_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEventsEventNotes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.note is not None:
            result['Note'] = self.note
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        if self.note_time is not None:
            result['NoteTime'] = self.note_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Note') is not None:
            self.note = m.get('Note')
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        if m.get('NoteTime') is not None:
            self.note_time = m.get('NoteTime')
        return self


class DescribeSuspEventsResponseBodySuspEventsTacticItems(TeaModel):
    def __init__(self, tactic_display_name=None, tactic_id=None):
        self.tactic_display_name = tactic_display_name  # type: str
        self.tactic_id = tactic_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEventsTacticItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tactic_display_name is not None:
            result['TacticDisplayName'] = self.tactic_display_name
        if self.tactic_id is not None:
            result['TacticId'] = self.tactic_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TacticDisplayName') is not None:
            self.tactic_display_name = m.get('TacticDisplayName')
        if m.get('TacticId') is not None:
            self.tactic_id = m.get('TacticId')
        return self


class DescribeSuspEventsResponseBodySuspEvents(TeaModel):
    def __init__(self, advanced=None, alarm_event_name=None, alarm_event_name_display=None, alarm_event_type=None,
                 alarm_event_type_display=None, alarm_unique_info=None, app_name=None, auto_breaking=None, can_be_deal_on_line=None,
                 can_cancel_fault=None, contain_hw_mode=None, container_id=None, container_image_id=None, container_image_name=None,
                 data_source=None, desc=None, details=None, display_sandbox_result=None, event_notes=None, event_status=None,
                 event_sub_type=None, has_trace_info=None, id=None, instance_id=None, instance_name=None, internet_ip=None,
                 intranet_ip=None, k_8s_cluster_id=None, k_8s_cluster_name=None, k_8s_namespace=None, k_8s_node_id=None,
                 k_8s_node_name=None, k_8s_pod_name=None, last_time=None, last_time_stamp=None, level=None,
                 malicious_rule_status=None, mark_mis_rules=None, name=None, occurrence_time=None, occurrence_time_stamp=None,
                 operate_error_code=None, operate_msg=None, operate_time=None, sale_version=None, security_event_ids=None, stages=None,
                 tactic_items=None, unique_info=None, uuid=None, cluster_id=None):
        self.advanced = advanced  # type: bool
        self.alarm_event_name = alarm_event_name  # type: str
        self.alarm_event_name_display = alarm_event_name_display  # type: str
        self.alarm_event_type = alarm_event_type  # type: str
        self.alarm_event_type_display = alarm_event_type_display  # type: str
        self.alarm_unique_info = alarm_unique_info  # type: str
        self.app_name = app_name  # type: str
        self.auto_breaking = auto_breaking  # type: bool
        self.can_be_deal_on_line = can_be_deal_on_line  # type: bool
        self.can_cancel_fault = can_cancel_fault  # type: bool
        self.contain_hw_mode = contain_hw_mode  # type: bool
        self.container_id = container_id  # type: str
        self.container_image_id = container_image_id  # type: str
        self.container_image_name = container_image_name  # type: str
        self.data_source = data_source  # type: str
        self.desc = desc  # type: str
        self.details = details  # type: list[DescribeSuspEventsResponseBodySuspEventsDetails]
        self.display_sandbox_result = display_sandbox_result  # type: bool
        self.event_notes = event_notes  # type: list[DescribeSuspEventsResponseBodySuspEventsEventNotes]
        self.event_status = event_status  # type: int
        self.event_sub_type = event_sub_type  # type: str
        self.has_trace_info = has_trace_info  # type: bool
        self.id = id  # type: long
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.k_8s_cluster_id = k_8s_cluster_id  # type: str
        self.k_8s_cluster_name = k_8s_cluster_name  # type: str
        self.k_8s_namespace = k_8s_namespace  # type: str
        self.k_8s_node_id = k_8s_node_id  # type: str
        self.k_8s_node_name = k_8s_node_name  # type: str
        self.k_8s_pod_name = k_8s_pod_name  # type: str
        self.last_time = last_time  # type: str
        self.last_time_stamp = last_time_stamp  # type: long
        self.level = level  # type: str
        self.malicious_rule_status = malicious_rule_status  # type: str
        self.mark_mis_rules = mark_mis_rules  # type: str
        self.name = name  # type: str
        self.occurrence_time = occurrence_time  # type: str
        self.occurrence_time_stamp = occurrence_time_stamp  # type: long
        self.operate_error_code = operate_error_code  # type: str
        self.operate_msg = operate_msg  # type: str
        self.operate_time = operate_time  # type: long
        self.sale_version = sale_version  # type: str
        self.security_event_ids = security_event_ids  # type: str
        self.stages = stages  # type: str
        self.tactic_items = tactic_items  # type: list[DescribeSuspEventsResponseBodySuspEventsTacticItems]
        self.unique_info = unique_info  # type: str
        self.uuid = uuid  # type: str
        self.cluster_id = cluster_id  # type: str

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.event_notes:
            for k in self.event_notes:
                if k:
                    k.validate()
        if self.tactic_items:
            for k in self.tactic_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced is not None:
            result['Advanced'] = self.advanced
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_name_display is not None:
            result['AlarmEventNameDisplay'] = self.alarm_event_name_display
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_event_type_display is not None:
            result['AlarmEventTypeDisplay'] = self.alarm_event_type_display
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_breaking is not None:
            result['AutoBreaking'] = self.auto_breaking
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        if self.contain_hw_mode is not None:
            result['ContainHwMode'] = self.contain_hw_mode
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_image_id is not None:
            result['ContainerImageId'] = self.container_image_id
        if self.container_image_name is not None:
            result['ContainerImageName'] = self.container_image_name
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.desc is not None:
            result['Desc'] = self.desc
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.display_sandbox_result is not None:
            result['DisplaySandboxResult'] = self.display_sandbox_result
        result['EventNotes'] = []
        if self.event_notes is not None:
            for k in self.event_notes:
                result['EventNotes'].append(k.to_map() if k else None)
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_sub_type is not None:
            result['EventSubType'] = self.event_sub_type
        if self.has_trace_info is not None:
            result['HasTraceInfo'] = self.has_trace_info
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.k_8s_cluster_id is not None:
            result['K8sClusterId'] = self.k_8s_cluster_id
        if self.k_8s_cluster_name is not None:
            result['K8sClusterName'] = self.k_8s_cluster_name
        if self.k_8s_namespace is not None:
            result['K8sNamespace'] = self.k_8s_namespace
        if self.k_8s_node_id is not None:
            result['K8sNodeId'] = self.k_8s_node_id
        if self.k_8s_node_name is not None:
            result['K8sNodeName'] = self.k_8s_node_name
        if self.k_8s_pod_name is not None:
            result['K8sPodName'] = self.k_8s_pod_name
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.last_time_stamp is not None:
            result['LastTimeStamp'] = self.last_time_stamp
        if self.level is not None:
            result['Level'] = self.level
        if self.malicious_rule_status is not None:
            result['MaliciousRuleStatus'] = self.malicious_rule_status
        if self.mark_mis_rules is not None:
            result['MarkMisRules'] = self.mark_mis_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.occurrence_time_stamp is not None:
            result['OccurrenceTimeStamp'] = self.occurrence_time_stamp
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_msg is not None:
            result['OperateMsg'] = self.operate_msg
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.stages is not None:
            result['Stages'] = self.stages
        result['TacticItems'] = []
        if self.tactic_items is not None:
            for k in self.tactic_items:
                result['TacticItems'].append(k.to_map() if k else None)
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advanced') is not None:
            self.advanced = m.get('Advanced')
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventNameDisplay') is not None:
            self.alarm_event_name_display = m.get('AlarmEventNameDisplay')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmEventTypeDisplay') is not None:
            self.alarm_event_type_display = m.get('AlarmEventTypeDisplay')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoBreaking') is not None:
            self.auto_breaking = m.get('AutoBreaking')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        if m.get('ContainHwMode') is not None:
            self.contain_hw_mode = m.get('ContainHwMode')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerImageId') is not None:
            self.container_image_id = m.get('ContainerImageId')
        if m.get('ContainerImageName') is not None:
            self.container_image_name = m.get('ContainerImageName')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('DisplaySandboxResult') is not None:
            self.display_sandbox_result = m.get('DisplaySandboxResult')
        self.event_notes = []
        if m.get('EventNotes') is not None:
            for k in m.get('EventNotes'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsEventNotes()
                self.event_notes.append(temp_model.from_map(k))
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventSubType') is not None:
            self.event_sub_type = m.get('EventSubType')
        if m.get('HasTraceInfo') is not None:
            self.has_trace_info = m.get('HasTraceInfo')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('K8sClusterId') is not None:
            self.k_8s_cluster_id = m.get('K8sClusterId')
        if m.get('K8sClusterName') is not None:
            self.k_8s_cluster_name = m.get('K8sClusterName')
        if m.get('K8sNamespace') is not None:
            self.k_8s_namespace = m.get('K8sNamespace')
        if m.get('K8sNodeId') is not None:
            self.k_8s_node_id = m.get('K8sNodeId')
        if m.get('K8sNodeName') is not None:
            self.k_8s_node_name = m.get('K8sNodeName')
        if m.get('K8sPodName') is not None:
            self.k_8s_pod_name = m.get('K8sPodName')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('LastTimeStamp') is not None:
            self.last_time_stamp = m.get('LastTimeStamp')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaliciousRuleStatus') is not None:
            self.malicious_rule_status = m.get('MaliciousRuleStatus')
        if m.get('MarkMisRules') is not None:
            self.mark_mis_rules = m.get('MarkMisRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('OccurrenceTimeStamp') is not None:
            self.occurrence_time_stamp = m.get('OccurrenceTimeStamp')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateMsg') is not None:
            self.operate_msg = m.get('OperateMsg')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('Stages') is not None:
            self.stages = m.get('Stages')
        self.tactic_items = []
        if m.get('TacticItems') is not None:
            for k in m.get('TacticItems'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsTacticItems()
                self.tactic_items.append(temp_model.from_map(k))
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        return self


class DescribeSuspEventsResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, request_id=None, susp_events=None,
                 total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.susp_events = susp_events  # type: list[DescribeSuspEventsResponseBodySuspEvents]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.susp_events:
            for k in self.susp_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspEvents'] = []
        if self.susp_events is not None:
            for k in self.susp_events:
                result['SuspEvents'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_events = []
        if m.get('SuspEvents') is not None:
            for k in m.get('SuspEvents'):
                temp_model = DescribeSuspEventsResponseBodySuspEvents()
                self.susp_events.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspiciousOverallConfigRequest(TeaModel):
    def __init__(self, source_ip=None, type=None):
        self.source_ip = source_ip  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspiciousOverallConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousOverallConfigResponseBodyOverallConfig(TeaModel):
    def __init__(self, config=None, type=None):
        self.config = config  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspiciousOverallConfigResponseBodyOverallConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousOverallConfigResponseBody(TeaModel):
    def __init__(self, overall_config=None, request_id=None):
        self.overall_config = overall_config  # type: DescribeSuspiciousOverallConfigResponseBodyOverallConfig
        self.request_id = request_id  # type: str

    def validate(self):
        if self.overall_config:
            self.overall_config.validate()

    def to_map(self):
        _map = super(DescribeSuspiciousOverallConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverallConfig') is not None:
            temp_model = DescribeSuspiciousOverallConfigResponseBodyOverallConfig()
            self.overall_config = temp_model.from_map(m['OverallConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSuspiciousOverallConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspiciousOverallConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspiciousOverallConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspiciousOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspiciousUUIDConfigRequest(TeaModel):
    def __init__(self, type=None):
        # The type of proactive defense. Valid values:
        # 
        # *   **auto_breaking**: virus defense
        # *   **ransomware_breaking**: ransomware capture
        # *   **webshell\_cloud_breaking**: webshell defense
        # *   **alinet**: malicious behavior defense
        # *   **alisecguard**: client protection
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspiciousUUIDConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSuspiciousUUIDConfigResponseBody(TeaModel):
    def __init__(self, count=None, request_id=None, uuidlist=None):
        # The total number of servers on which proactive defense of the specified type takes effect.
        self.count = count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The UUIDs of servers on which proactive defense of the specified type takes effect.
        self.uuidlist = uuidlist  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspiciousUUIDConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uuidlist is not None:
            result['UUIDList'] = self.uuidlist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UUIDList') is not None:
            self.uuidlist = m.get('UUIDList')
        return self


class DescribeSuspiciousUUIDConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspiciousUUIDConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspiciousUUIDConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspiciousUUIDConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTargetRequest(TeaModel):
    def __init__(self, config=None, type=None):
        self.config = config  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTargetResponseBodyTargets(TeaModel):
    def __init__(self, flag=None, target=None, target_type=None):
        self.flag = flag  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTargetResponseBodyTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeTargetResponseBody(TeaModel):
    def __init__(self, request_id=None, targets=None, total_count=None):
        self.request_id = request_id  # type: str
        self.targets = targets  # type: list[DescribeTargetResponseBodyTargets]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = DescribeTargetResponseBodyTargets()
                self.targets.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTaskErrorLogRequest(TeaModel):
    def __init__(self, build_task_id=None):
        # The ID of the task that you create to fix an image vulnerability.
        self.build_task_id = build_task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTaskErrorLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_task_id is not None:
            result['BuildTaskId'] = self.build_task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuildTaskId') is not None:
            self.build_task_id = m.get('BuildTaskId')
        return self


class DescribeTaskErrorLogResponseBodyLogs(TeaModel):
    def __init__(self, text=None):
        # The error log.
        self.text = text  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTaskErrorLogResponseBodyLogs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class DescribeTaskErrorLogResponseBody(TeaModel):
    def __init__(self, logs=None, request_id=None):
        # The error logs that are returned.
        self.logs = logs  # type: list[DescribeTaskErrorLogResponseBodyLogs]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTaskErrorLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribeTaskErrorLogResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTaskErrorLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTaskErrorLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTaskErrorLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTaskErrorLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTotalStatisticsRequest(TeaModel):
    def __init__(self, from_=None, group_id=None, remark=None):
        self.from_ = from_  # type: str
        self.group_id = group_id  # type: long
        self.remark = remark  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTotalStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class DescribeTotalStatisticsResponseBody(TeaModel):
    def __init__(self, account=None, health=None, health_total=None, healthdealed_total=None, healthhigh_total=None,
                 healthlow_total=None, healthmedium_total=None, healthserious_total=None, newsuspicious=None, online=None,
                 patch=None, request_id=None, suspicious=None, suspicious_total=None, suspiciousdealed_total=None,
                 suspicioushigh_total=None, suspiciouslow_total=None, suspiciousmedium_total=None, suspiciousserious_total=None,
                 trojan=None, vul=None, vul_asap_sum=None, vul_dealed_total=None, vul_later_sum=None, vul_nntf_sum=None,
                 vul_total=None):
        self.account = account  # type: int
        self.health = health  # type: int
        self.health_total = health_total  # type: int
        self.healthdealed_total = healthdealed_total  # type: int
        self.healthhigh_total = healthhigh_total  # type: int
        self.healthlow_total = healthlow_total  # type: int
        self.healthmedium_total = healthmedium_total  # type: int
        self.healthserious_total = healthserious_total  # type: int
        self.newsuspicious = newsuspicious  # type: int
        self.online = online  # type: bool
        self.patch = patch  # type: int
        self.request_id = request_id  # type: str
        self.suspicious = suspicious  # type: int
        self.suspicious_total = suspicious_total  # type: int
        self.suspiciousdealed_total = suspiciousdealed_total  # type: int
        self.suspicioushigh_total = suspicioushigh_total  # type: int
        self.suspiciouslow_total = suspiciouslow_total  # type: int
        self.suspiciousmedium_total = suspiciousmedium_total  # type: int
        self.suspiciousserious_total = suspiciousserious_total  # type: int
        self.trojan = trojan  # type: int
        self.vul = vul  # type: int
        self.vul_asap_sum = vul_asap_sum  # type: int
        self.vul_dealed_total = vul_dealed_total  # type: int
        self.vul_later_sum = vul_later_sum  # type: int
        self.vul_nntf_sum = vul_nntf_sum  # type: int
        self.vul_total = vul_total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTotalStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['Account'] = self.account
        if self.health is not None:
            result['Health'] = self.health
        if self.health_total is not None:
            result['HealthTotal'] = self.health_total
        if self.healthdealed_total is not None:
            result['HealthdealedTotal'] = self.healthdealed_total
        if self.healthhigh_total is not None:
            result['HealthhighTotal'] = self.healthhigh_total
        if self.healthlow_total is not None:
            result['HealthlowTotal'] = self.healthlow_total
        if self.healthmedium_total is not None:
            result['HealthmediumTotal'] = self.healthmedium_total
        if self.healthserious_total is not None:
            result['HealthseriousTotal'] = self.healthserious_total
        if self.newsuspicious is not None:
            result['Newsuspicious'] = self.newsuspicious
        if self.online is not None:
            result['Online'] = self.online
        if self.patch is not None:
            result['Patch'] = self.patch
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        if self.suspicious_total is not None:
            result['SuspiciousTotal'] = self.suspicious_total
        if self.suspiciousdealed_total is not None:
            result['SuspiciousdealedTotal'] = self.suspiciousdealed_total
        if self.suspicioushigh_total is not None:
            result['SuspicioushighTotal'] = self.suspicioushigh_total
        if self.suspiciouslow_total is not None:
            result['SuspiciouslowTotal'] = self.suspiciouslow_total
        if self.suspiciousmedium_total is not None:
            result['SuspiciousmediumTotal'] = self.suspiciousmedium_total
        if self.suspiciousserious_total is not None:
            result['SuspiciousseriousTotal'] = self.suspiciousserious_total
        if self.trojan is not None:
            result['Trojan'] = self.trojan
        if self.vul is not None:
            result['Vul'] = self.vul
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_dealed_total is not None:
            result['VulDealedTotal'] = self.vul_dealed_total
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        if self.vul_total is not None:
            result['VulTotal'] = self.vul_total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Account') is not None:
            self.account = m.get('Account')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('HealthTotal') is not None:
            self.health_total = m.get('HealthTotal')
        if m.get('HealthdealedTotal') is not None:
            self.healthdealed_total = m.get('HealthdealedTotal')
        if m.get('HealthhighTotal') is not None:
            self.healthhigh_total = m.get('HealthhighTotal')
        if m.get('HealthlowTotal') is not None:
            self.healthlow_total = m.get('HealthlowTotal')
        if m.get('HealthmediumTotal') is not None:
            self.healthmedium_total = m.get('HealthmediumTotal')
        if m.get('HealthseriousTotal') is not None:
            self.healthserious_total = m.get('HealthseriousTotal')
        if m.get('Newsuspicious') is not None:
            self.newsuspicious = m.get('Newsuspicious')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('Patch') is not None:
            self.patch = m.get('Patch')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        if m.get('SuspiciousTotal') is not None:
            self.suspicious_total = m.get('SuspiciousTotal')
        if m.get('SuspiciousdealedTotal') is not None:
            self.suspiciousdealed_total = m.get('SuspiciousdealedTotal')
        if m.get('SuspicioushighTotal') is not None:
            self.suspicioushigh_total = m.get('SuspicioushighTotal')
        if m.get('SuspiciouslowTotal') is not None:
            self.suspiciouslow_total = m.get('SuspiciouslowTotal')
        if m.get('SuspiciousmediumTotal') is not None:
            self.suspiciousmedium_total = m.get('SuspiciousmediumTotal')
        if m.get('SuspiciousseriousTotal') is not None:
            self.suspiciousserious_total = m.get('SuspiciousseriousTotal')
        if m.get('Trojan') is not None:
            self.trojan = m.get('Trojan')
        if m.get('Vul') is not None:
            self.vul = m.get('Vul')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulDealedTotal') is not None:
            self.vul_dealed_total = m.get('VulDealedTotal')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        if m.get('VulTotal') is not None:
            self.vul_total = m.get('VulTotal')
        return self


class DescribeTotalStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTotalStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTotalStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTotalStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTraceInfoDetailRequest(TeaModel):
    def __init__(self, from_=None, incident_time=None, lang=None, source_ip=None, type=None, uuid=None,
                 vertex_id=None):
        self.from_ = from_  # type: str
        self.incident_time = incident_time  # type: long
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str
        self.type = type  # type: str
        self.uuid = uuid  # type: str
        self.vertex_id = vertex_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.incident_time is not None:
            result['IncidentTime'] = self.incident_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vertex_id is not None:
            result['VertexId'] = self.vertex_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('IncidentTime') is not None:
            self.incident_time = m.get('IncidentTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VertexId') is not None:
            self.vertex_id = m.get('VertexId')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList(TeaModel):
    def __init__(self, count=None, end_id=None, start_id=None, time=None, type=None):
        self.count = count  # type: int
        self.end_id = end_id  # type: str
        self.start_id = start_id  # type: str
        self.time = time  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.end_id is not None:
            result['EndId'] = self.end_id
        if self.start_id is not None:
            result['StartId'] = self.start_id
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('EndId') is not None:
            self.end_id = m.get('EndId')
        if m.get('StartId') is not None:
            self.start_id = m.get('StartId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList(TeaModel):
    def __init__(self, db_id=None, display_color=None, display_icon=None, display_template=None, gmt_create=None,
                 gmt_modified=None, id=None, limit=None, name=None, namespace=None, offset=None):
        self.db_id = db_id  # type: int
        self.display_color = display_color  # type: str
        self.display_icon = display_icon  # type: str
        self.display_template = display_template  # type: str
        self.gmt_create = gmt_create  # type: long
        self.gmt_modified = gmt_modified  # type: long
        self.id = id  # type: str
        self.limit = limit  # type: int
        self.name = name  # type: str
        self.namespace = namespace  # type: str
        self.offset = offset  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.display_color is not None:
            result['DisplayColor'] = self.display_color
        if self.display_icon is not None:
            result['DisplayIcon'] = self.display_icon
        if self.display_template is not None:
            result['DisplayTemplate'] = self.display_template
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.offset is not None:
            result['Offset'] = self.offset
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DisplayColor') is not None:
            self.display_color = m.get('DisplayColor')
        if m.get('DisplayIcon') is not None:
            self.display_icon = m.get('DisplayIcon')
        if m.get('DisplayTemplate') is not None:
            self.display_template = m.get('DisplayTemplate')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList(TeaModel):
    def __init__(self, directed=None, display_color=None, name=None, relation_type_id=None, show_type=None):
        self.directed = directed  # type: int
        self.display_color = display_color  # type: str
        self.name = name  # type: str
        self.relation_type_id = relation_type_id  # type: str
        self.show_type = show_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed is not None:
            result['Directed'] = self.directed
        if self.display_color is not None:
            result['DisplayColor'] = self.display_color
        if self.name is not None:
            result['Name'] = self.name
        if self.relation_type_id is not None:
            result['RelationTypeId'] = self.relation_type_id
        if self.show_type is not None:
            result['ShowType'] = self.show_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Directed') is not None:
            self.directed = m.get('Directed')
        if m.get('DisplayColor') is not None:
            self.display_color = m.get('DisplayColor')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RelationTypeId') is not None:
            self.relation_type_id = m.get('RelationTypeId')
        if m.get('ShowType') is not None:
            self.show_type = m.get('ShowType')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList(TeaModel):
    def __init__(self, count=None, has_more=None, type=None):
        self.count = count  # type: int
        self.has_more = has_more  # type: bool
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList(TeaModel):
    def __init__(self, count=None, id=None, name=None, neighbor_list=None, time=None, type=None):
        self.count = count  # type: int
        self.id = id  # type: str
        self.name = name  # type: str
        self.neighbor_list = neighbor_list  # type: list[DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList]
        self.time = time  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.neighbor_list:
            for k in self.neighbor_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['NeighborList'] = []
        if self.neighbor_list is not None:
            for k in self.neighbor_list:
                result['NeighborList'].append(k.to_map() if k else None)
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.neighbor_list = []
        if m.get('NeighborList') is not None:
            for k in m.get('NeighborList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList()
                self.neighbor_list.append(temp_model.from_map(k))
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoDetailResponseBodyTraceInfoDetail(TeaModel):
    def __init__(self, edge_list=None, entity_type_list=None, relation_type_list=None, vertex_list=None):
        self.edge_list = edge_list  # type: list[DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList]
        self.entity_type_list = entity_type_list  # type: list[DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList]
        self.relation_type_list = relation_type_list  # type: list[DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList]
        self.vertex_list = vertex_list  # type: list[DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList]

    def validate(self):
        if self.edge_list:
            for k in self.edge_list:
                if k:
                    k.validate()
        if self.entity_type_list:
            for k in self.entity_type_list:
                if k:
                    k.validate()
        if self.relation_type_list:
            for k in self.relation_type_list:
                if k:
                    k.validate()
        if self.vertex_list:
            for k in self.vertex_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBodyTraceInfoDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EdgeList'] = []
        if self.edge_list is not None:
            for k in self.edge_list:
                result['EdgeList'].append(k.to_map() if k else None)
        result['EntityTypeList'] = []
        if self.entity_type_list is not None:
            for k in self.entity_type_list:
                result['EntityTypeList'].append(k.to_map() if k else None)
        result['RelationTypeList'] = []
        if self.relation_type_list is not None:
            for k in self.relation_type_list:
                result['RelationTypeList'].append(k.to_map() if k else None)
        result['VertexList'] = []
        if self.vertex_list is not None:
            for k in self.vertex_list:
                result['VertexList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.edge_list = []
        if m.get('EdgeList') is not None:
            for k in m.get('EdgeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList()
                self.edge_list.append(temp_model.from_map(k))
        self.entity_type_list = []
        if m.get('EntityTypeList') is not None:
            for k in m.get('EntityTypeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList()
                self.entity_type_list.append(temp_model.from_map(k))
        self.relation_type_list = []
        if m.get('RelationTypeList') is not None:
            for k in m.get('RelationTypeList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList()
                self.relation_type_list.append(temp_model.from_map(k))
        self.vertex_list = []
        if m.get('VertexList') is not None:
            for k in m.get('VertexList'):
                temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList()
                self.vertex_list.append(temp_model.from_map(k))
        return self


class DescribeTraceInfoDetailResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None, trace_info_detail=None):
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.trace_info_detail = trace_info_detail  # type: DescribeTraceInfoDetailResponseBodyTraceInfoDetail

    def validate(self):
        if self.trace_info_detail:
            self.trace_info_detail.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_info_detail is not None:
            result['TraceInfoDetail'] = self.trace_info_detail.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceInfoDetail') is not None:
            temp_model = DescribeTraceInfoDetailResponseBodyTraceInfoDetail()
            self.trace_info_detail = temp_model.from_map(m['TraceInfoDetail'])
        return self


class DescribeTraceInfoDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTraceInfoDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTraceInfoDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTraceInfoNodeRequest(TeaModel):
    def __init__(self, event_name=None, from_=None, incident_time=None, lang=None, source_ip=None, type=None,
                 uuid=None, vertex_id=None):
        self.event_name = event_name  # type: str
        self.from_ = from_  # type: str
        self.incident_time = incident_time  # type: long
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str
        self.type = type  # type: str
        self.uuid = uuid  # type: str
        self.vertex_id = vertex_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.incident_time is not None:
            result['IncidentTime'] = self.incident_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vertex_id is not None:
            result['VertexId'] = self.vertex_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('IncidentTime') is not None:
            self.incident_time = m.get('IncidentTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VertexId') is not None:
            self.vertex_id = m.get('VertexId')
        return self


class DescribeTraceInfoNodeResponseBodyNodePropertyList(TeaModel):
    def __init__(self, name=None, value=None):
        self.name = name  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTraceInfoNodeResponseBodyNodePropertyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeTraceInfoNodeResponseBodyNode(TeaModel):
    def __init__(self, name=None, property_list=None, type=None):
        self.name = name  # type: str
        self.property_list = property_list  # type: list[DescribeTraceInfoNodeResponseBodyNodePropertyList]
        self.type = type  # type: str

    def validate(self):
        if self.property_list:
            for k in self.property_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoNodeResponseBodyNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['PropertyList'] = []
        if self.property_list is not None:
            for k in self.property_list:
                result['PropertyList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.property_list = []
        if m.get('PropertyList') is not None:
            for k in m.get('PropertyList'):
                temp_model = DescribeTraceInfoNodeResponseBodyNodePropertyList()
                self.property_list.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeTraceInfoNodeResponseBody(TeaModel):
    def __init__(self, node=None, request_id=None):
        self.node = node  # type: DescribeTraceInfoNodeResponseBodyNode
        self.request_id = request_id  # type: str

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Node') is not None:
            temp_model = DescribeTraceInfoNodeResponseBodyNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTraceInfoNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTraceInfoNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTraceInfoNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTraceInfoNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupDatabaseRequest(TeaModel):
    def __init__(self, current_page=None, database_type=None, instance_name=None, page_size=None, query_type=None,
                 uni_region_id=None):
        self.current_page = current_page  # type: int
        self.database_type = database_type  # type: str
        self.instance_name = instance_name  # type: str
        self.page_size = page_size  # type: int
        self.query_type = query_type  # type: str
        self.uni_region_id = uni_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class DescribeUniBackupDatabaseResponseBodyDatabaseList(TeaModel):
    def __init__(self, agent_status=None, created_by_product=None, database_name=None, database_type=None,
                 database_version=None, instance_id=None, instance_name=None, instance_uuid=None, policy_id=None, status=None):
        self.agent_status = agent_status  # type: str
        self.created_by_product = created_by_product  # type: str
        self.database_name = database_name  # type: str
        self.database_type = database_type  # type: str
        self.database_version = database_version  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.instance_uuid = instance_uuid  # type: str
        self.policy_id = policy_id  # type: long
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupDatabaseResponseBodyDatabaseList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.created_by_product is not None:
            result['CreatedByProduct'] = self.created_by_product
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.database_version is not None:
            result['DatabaseVersion'] = self.database_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('CreatedByProduct') is not None:
            self.created_by_product = m.get('CreatedByProduct')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('DatabaseVersion') is not None:
            self.database_version = m.get('DatabaseVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeUniBackupDatabaseResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupDatabaseResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniBackupDatabaseResponseBody(TeaModel):
    def __init__(self, database_list=None, page_info=None, request_id=None):
        self.database_list = database_list  # type: list[DescribeUniBackupDatabaseResponseBodyDatabaseList]
        self.page_info = page_info  # type: DescribeUniBackupDatabaseResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(DescribeUniBackupDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = DescribeUniBackupDatabaseResponseBodyDatabaseList()
                self.database_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = DescribeUniBackupDatabaseResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUniBackupDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUniBackupDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUniBackupDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupPoliciesRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, policy_name=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.policy_name = policy_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPoliciesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        return self


class DescribeUniBackupPoliciesResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPoliciesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniBackupPoliciesResponseBodyUniBackupPolicies(TeaModel):
    def __init__(self, agent_error_message=None, agent_status=None, database_name=None, database_type=None,
                 error_code=None, error_message=None, instance_id=None, instance_name=None, instance_status=None,
                 instance_uuid=None, latest_back_result=None, latest_backup_time=None, plan_status=None, policy_id=None,
                 policy_name=None, policy_status=None, uni_region_id=None):
        self.agent_error_message = agent_error_message  # type: str
        self.agent_status = agent_status  # type: str
        self.database_name = database_name  # type: str
        self.database_type = database_type  # type: str
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.instance_status = instance_status  # type: str
        self.instance_uuid = instance_uuid  # type: str
        self.latest_back_result = latest_back_result  # type: str
        self.latest_backup_time = latest_backup_time  # type: str
        self.plan_status = plan_status  # type: str
        self.policy_id = policy_id  # type: long
        self.policy_name = policy_name  # type: str
        self.policy_status = policy_status  # type: str
        self.uni_region_id = uni_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPoliciesResponseBodyUniBackupPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_error_message is not None:
            result['AgentErrorMessage'] = self.agent_error_message
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.latest_back_result is not None:
            result['LatestBackResult'] = self.latest_back_result
        if self.latest_backup_time is not None:
            result['LatestBackupTime'] = self.latest_backup_time
        if self.plan_status is not None:
            result['PlanStatus'] = self.plan_status
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AgentErrorMessage') is not None:
            self.agent_error_message = m.get('AgentErrorMessage')
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('LatestBackResult') is not None:
            self.latest_back_result = m.get('LatestBackResult')
        if m.get('LatestBackupTime') is not None:
            self.latest_backup_time = m.get('LatestBackupTime')
        if m.get('PlanStatus') is not None:
            self.plan_status = m.get('PlanStatus')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class DescribeUniBackupPoliciesResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, uni_backup_policies=None):
        self.page_info = page_info  # type: DescribeUniBackupPoliciesResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.uni_backup_policies = uni_backup_policies  # type: list[DescribeUniBackupPoliciesResponseBodyUniBackupPolicies]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.uni_backup_policies:
            for k in self.uni_backup_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUniBackupPoliciesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UniBackupPolicies'] = []
        if self.uni_backup_policies is not None:
            for k in self.uni_backup_policies:
                result['UniBackupPolicies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeUniBackupPoliciesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.uni_backup_policies = []
        if m.get('UniBackupPolicies') is not None:
            for k in m.get('UniBackupPolicies'):
                temp_model = DescribeUniBackupPoliciesResponseBodyUniBackupPolicies()
                self.uni_backup_policies.append(temp_model.from_map(k))
        return self


class DescribeUniBackupPoliciesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUniBackupPoliciesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUniBackupPoliciesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniBackupPolicyDetailRequest(TeaModel):
    def __init__(self, policy_id=None):
        self.policy_id = policy_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan(TeaModel):
    def __init__(self, days=None, interval=None, plan_type=None, start_time=None):
        self.days = days  # type: list[str]
        self.interval = interval  # type: int
        self.plan_type = plan_type  # type: str
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan(TeaModel):
    def __init__(self, days=None, interval=None, plan_type=None, start_time=None):
        self.days = days  # type: list[str]
        self.interval = interval  # type: int
        self.plan_type = plan_type  # type: str
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.plan_type is not None:
            result['PlanType'] = self.plan_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PlanType') is not None:
            self.plan_type = m.get('PlanType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO(TeaModel):
    def __init__(self, account_name=None, agent_status=None, database_type=None, full_plan=None, inc_plan=None,
                 instance_id=None, instance_name=None, policy_id=None, policy_name=None, policy_status=None, retention=None,
                 speed_limiter=None):
        self.account_name = account_name  # type: str
        self.agent_status = agent_status  # type: str
        self.database_type = database_type  # type: str
        self.full_plan = full_plan  # type: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan
        self.inc_plan = inc_plan  # type: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.policy_id = policy_id  # type: long
        self.policy_name = policy_name  # type: str
        self.policy_status = policy_status  # type: str
        self.retention = retention  # type: int
        self.speed_limiter = speed_limiter  # type: long

    def validate(self):
        if self.full_plan:
            self.full_plan.validate()
        if self.inc_plan:
            self.inc_plan.validate()

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan.to_map()
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('FullPlan') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan()
            self.full_plan = temp_model.from_map(m['FullPlan'])
        if m.get('IncPlan') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan()
            self.inc_plan = temp_model.from_map(m['IncPlan'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class DescribeUniBackupPolicyDetailResponseBody(TeaModel):
    def __init__(self, request_id=None, uni_backup_policy_dto=None):
        self.request_id = request_id  # type: str
        self.uni_backup_policy_dto = uni_backup_policy_dto  # type: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO

    def validate(self):
        if self.uni_backup_policy_dto:
            self.uni_backup_policy_dto.validate()

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uni_backup_policy_dto is not None:
            result['UniBackupPolicyDTO'] = self.uni_backup_policy_dto.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UniBackupPolicyDTO') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO()
            self.uni_backup_policy_dto = temp_model.from_map(m['UniBackupPolicyDTO'])
        return self


class DescribeUniBackupPolicyDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUniBackupPolicyDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUniBackupPolicyDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniBackupPolicyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniRecoverableListRequest(TeaModel):
    def __init__(self, current_page=None, database=None, page_size=None, policy_id=None):
        self.current_page = current_page  # type: int
        self.database = database  # type: str
        self.page_size = page_size  # type: int
        self.policy_id = policy_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniRecoverableListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database is not None:
            result['Database'] = self.database
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class DescribeUniRecoverableListResponseBodyRecoverableInfoList(TeaModel):
    def __init__(self, first_time=None, last_time=None, reset_scn=None, reset_time=None, restore_info=None):
        self.first_time = first_time  # type: long
        self.last_time = last_time  # type: long
        self.reset_scn = reset_scn  # type: str
        self.reset_time = reset_time  # type: long
        self.restore_info = restore_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniRecoverableListResponseBodyRecoverableInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.reset_scn is not None:
            result['ResetScn'] = self.reset_scn
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.restore_info is not None:
            result['RestoreInfo'] = self.restore_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('ResetScn') is not None:
            self.reset_scn = m.get('ResetScn')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('RestoreInfo') is not None:
            self.restore_info = m.get('RestoreInfo')
        return self


class DescribeUniRecoverableListResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, database=None, page_size=None, recoverable_info_list=None,
                 request_id=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.database = database  # type: str
        self.page_size = page_size  # type: int
        self.recoverable_info_list = recoverable_info_list  # type: list[DescribeUniRecoverableListResponseBodyRecoverableInfoList]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.recoverable_info_list:
            for k in self.recoverable_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUniRecoverableListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.database is not None:
            result['Database'] = self.database
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RecoverableInfoList'] = []
        if self.recoverable_info_list is not None:
            for k in self.recoverable_info_list:
                result['RecoverableInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.recoverable_info_list = []
        if m.get('RecoverableInfoList') is not None:
            for k in m.get('RecoverableInfoList'):
                temp_model = DescribeUniRecoverableListResponseBodyRecoverableInfoList()
                self.recoverable_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeUniRecoverableListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUniRecoverableListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUniRecoverableListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniRecoverableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUniSupportRegionResponseBody(TeaModel):
    def __init__(self, request_id=None, uni_support_region=None):
        self.request_id = request_id  # type: str
        self.uni_support_region = uni_support_region  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUniSupportRegionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.uni_support_region is not None:
            result['UniSupportRegion'] = self.uni_support_region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UniSupportRegion') is not None:
            self.uni_support_region = m.get('UniSupportRegion')
        return self


class DescribeUniSupportRegionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUniSupportRegionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUniSupportRegionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUniSupportRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBackupMachinesResponseBodyMachines(TeaModel):
    def __init__(self, id=None, policy_name=None, uuid=None):
        # The ID of the anti-ransomware policy that is applied to the server.
        self.id = id  # type: long
        # The name of the anti-ransomware policy that is applied to the server.
        self.policy_name = policy_name  # type: str
        # The UUID of the server to which the anti-ransomware policy is applied.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserBackupMachinesResponseBodyMachines, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeUserBackupMachinesResponseBody(TeaModel):
    def __init__(self, machines=None, request_id=None):
        # An array consisting of the servers to which the anti-ransomware policy is applied.
        self.machines = machines  # type: list[DescribeUserBackupMachinesResponseBodyMachines]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.machines:
            for k in self.machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUserBackupMachinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Machines'] = []
        if self.machines is not None:
            for k in self.machines:
                result['Machines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.machines = []
        if m.get('Machines') is not None:
            for k in m.get('Machines'):
                temp_model = DescribeUserBackupMachinesResponseBodyMachines()
                self.machines.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserBackupMachinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserBackupMachinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserBackupMachinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBackupMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBaselineAuthorizationRequest(TeaModel):
    def __init__(self, lang=None, resource_owner_id=None, source_ip=None):
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The ID of the asset owner.
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserBaselineAuthorizationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization(TeaModel):
    def __init__(self, status=None):
        # Indicates whether Security Center is authorized to run configuration checks on cloud services.
        # 
        # *   **0**: no. Security Center is not authorized to run configuration checks on cloud services.
        # *   **1**: yes. Security Center is authorized to run configuration checks on cloud services.
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeUserBaselineAuthorizationResponseBody(TeaModel):
    def __init__(self, request_id=None, user_baseline_authorization=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about whether Security Center is authorized to run configuration checks on cloud services.
        self.user_baseline_authorization = user_baseline_authorization  # type: DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization

    def validate(self):
        if self.user_baseline_authorization:
            self.user_baseline_authorization.validate()

    def to_map(self):
        _map = super(DescribeUserBaselineAuthorizationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_baseline_authorization is not None:
            result['UserBaselineAuthorization'] = self.user_baseline_authorization.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserBaselineAuthorization') is not None:
            temp_model = DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization()
            self.user_baseline_authorization = temp_model.from_map(m['UserBaselineAuthorization'])
        return self


class DescribeUserBaselineAuthorizationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserBaselineAuthorizationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserBaselineAuthorizationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBaselineAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserLayoutAuthorizationRequest(TeaModel):
    def __init__(self, lang=None, resource_owner_id=None, source_ip=None):
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserLayoutAuthorizationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeUserLayoutAuthorizationResponseBody(TeaModel):
    def __init__(self, authorized=None, request_id=None):
        self.authorized = authorized  # type: bool
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserLayoutAuthorizationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserLayoutAuthorizationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserLayoutAuthorizationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserLayoutAuthorizationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserLayoutAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUuidsByVulNamesRequest(TeaModel):
    def __init__(self, dealed=None, field_name=None, field_value=None, group_id=None, lang=None, level=None,
                 necessity=None, remark=None, search_tags=None, status_list=None, tag=None, target_type=None, type=None,
                 vpc_instance_ids=None, vul_names=None):
        # Specifies whether the vulnerability is handled. Valid values:
        # 
        # **y**: yes. **n**: no.
        self.dealed = dealed  # type: str
        # The name of the search field that is used to query containers.
        self.field_name = field_name  # type: str
        # The value of the search field that is used to query containers.
        self.field_value = field_value  # type: str
        # The ID of the asset group.
        self.group_id = group_id  # type: long
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The severity of the vulnerability. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.level = level  # type: str
        # The priority based on which the vulnerability is fixed. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity  # type: str
        # The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset. Fuzzy match is supported.
        self.remark = remark  # type: str
        # The tags that are used to search for the vulnerability.
        self.search_tags = search_tags  # type: str
        # The status of the vulnerability. Separate multiple states with commas (,). Valid values:
        # 
        # *   **1**: unfixed
        # *   **4**: being fixed
        # *   **7**: fixed
        self.status_list = status_list  # type: str
        # The tag that is added to the vulnerability.
        self.tag = tag  # type: str
        # The type of the query condition. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the ID of the asset
        self.target_type = target_type  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerabilities
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerabilities
        # *   **sca**: vulnerabilities that are detected based on software component analysis
        self.type = type  # type: str
        # The ID of the virtual private cloud (VPC) in which the vulnerability is detected. Separate multiple IDs with commas (,).
        self.vpc_instance_ids = vpc_instance_ids  # type: str
        # An array that consists of the names of vulnerabilities.
        # 
        # >  You can call the [DescribeGroupedVul](~~DescribeGroupedVul~~) operation to obtain the names of vulnerabilities.
        self.vul_names = vul_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUuidsByVulNamesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        if self.vul_names is not None:
            result['VulNames'] = self.vul_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        if m.get('VulNames') is not None:
            self.vul_names = m.get('VulNames')
        return self


class DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics(TeaModel):
    def __init__(self, machine_instance_id=None, machine_ip=None, machine_name=None, os=None, region_id=None,
                 uuid=None):
        # The ID of the server.
        self.machine_instance_id = machine_instance_id  # type: str
        # The IP address of the server.
        self.machine_ip = machine_ip  # type: str
        # The name of the server.
        self.machine_name = machine_name  # type: str
        # The name of the operating system that the server runs.
        self.os = os  # type: str
        # The ID of the region in which the server resides.
        self.region_id = region_id  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_instance_id is not None:
            result['MachineInstanceId'] = self.machine_instance_id
        if self.machine_ip is not None:
            result['MachineIp'] = self.machine_ip
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineInstanceId') is not None:
            self.machine_instance_id = m.get('MachineInstanceId')
        if m.get('MachineIp') is not None:
            self.machine_ip = m.get('MachineIp')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeUuidsByVulNamesResponseBody(TeaModel):
    def __init__(self, machine_info_statistics=None, request_id=None):
        # An array that consists of the statistics about the assets.
        self.machine_info_statistics = machine_info_statistics  # type: list[DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.machine_info_statistics:
            for k in self.machine_info_statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUuidsByVulNamesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MachineInfoStatistics'] = []
        if self.machine_info_statistics is not None:
            for k in self.machine_info_statistics:
                result['MachineInfoStatistics'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.machine_info_statistics = []
        if m.get('MachineInfoStatistics') is not None:
            for k in m.get('MachineInfoStatistics'):
                temp_model = DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics()
                self.machine_info_statistics.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUuidsByVulNamesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUuidsByVulNamesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUuidsByVulNamesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUuidsByVulNamesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVendorListResponseBody(TeaModel):
    def __init__(self, request_id=None, vendor_name_list=None):
        self.request_id = request_id  # type: str
        self.vendor_name_list = vendor_name_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVendorListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vendor_name_list is not None:
            result['VendorNameList'] = self.vendor_name_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VendorNameList') is not None:
            self.vendor_name_list = m.get('VendorNameList')
        return self


class DescribeVendorListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVendorListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVendorListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVendorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVersionConfigRequest(TeaModel):
    def __init__(self, resource_directory_account_id=None, source_ip=None):
        self.resource_directory_account_id = resource_directory_account_id  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVersionConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeVersionConfigResponseBody(TeaModel):
    def __init__(self, allow_partial_buy=None, app_white_list=None, app_white_list_auth_count=None,
                 asset_level=None, highest_version=None, honeypot_capacity=None, image_scan_capacity=None, instance_id=None,
                 is_new_container_version=None, is_over_balance=None, is_trial_version=None, last_trail_end_time=None, mvauth_count=None,
                 mvunused_auth_count=None, open_time=None, release_time=None, request_id=None, sas_log=None, sas_screen=None,
                 sls_capacity=None, threat_analysis_capacity=None, user_defined_alarms=None, version=None, vm_cores=None,
                 web_lock=None, web_lock_auth_count=None):
        self.allow_partial_buy = allow_partial_buy  # type: int
        self.app_white_list = app_white_list  # type: int
        self.app_white_list_auth_count = app_white_list_auth_count  # type: long
        self.asset_level = asset_level  # type: int
        self.highest_version = highest_version  # type: int
        self.honeypot_capacity = honeypot_capacity  # type: long
        self.image_scan_capacity = image_scan_capacity  # type: long
        self.instance_id = instance_id  # type: str
        self.is_new_container_version = is_new_container_version  # type: bool
        self.is_over_balance = is_over_balance  # type: bool
        self.is_trial_version = is_trial_version  # type: int
        self.last_trail_end_time = last_trail_end_time  # type: long
        self.mvauth_count = mvauth_count  # type: int
        self.mvunused_auth_count = mvunused_auth_count  # type: int
        self.open_time = open_time  # type: long
        self.release_time = release_time  # type: long
        self.request_id = request_id  # type: str
        self.sas_log = sas_log  # type: int
        self.sas_screen = sas_screen  # type: int
        self.sls_capacity = sls_capacity  # type: long
        self.threat_analysis_capacity = threat_analysis_capacity  # type: long
        self.user_defined_alarms = user_defined_alarms  # type: int
        self.version = version  # type: int
        self.vm_cores = vm_cores  # type: int
        self.web_lock = web_lock  # type: int
        self.web_lock_auth_count = web_lock_auth_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVersionConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_partial_buy is not None:
            result['AllowPartialBuy'] = self.allow_partial_buy
        if self.app_white_list is not None:
            result['AppWhiteList'] = self.app_white_list
        if self.app_white_list_auth_count is not None:
            result['AppWhiteListAuthCount'] = self.app_white_list_auth_count
        if self.asset_level is not None:
            result['AssetLevel'] = self.asset_level
        if self.highest_version is not None:
            result['HighestVersion'] = self.highest_version
        if self.honeypot_capacity is not None:
            result['HoneypotCapacity'] = self.honeypot_capacity
        if self.image_scan_capacity is not None:
            result['ImageScanCapacity'] = self.image_scan_capacity
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_new_container_version is not None:
            result['IsNewContainerVersion'] = self.is_new_container_version
        if self.is_over_balance is not None:
            result['IsOverBalance'] = self.is_over_balance
        if self.is_trial_version is not None:
            result['IsTrialVersion'] = self.is_trial_version
        if self.last_trail_end_time is not None:
            result['LastTrailEndTime'] = self.last_trail_end_time
        if self.mvauth_count is not None:
            result['MVAuthCount'] = self.mvauth_count
        if self.mvunused_auth_count is not None:
            result['MVUnusedAuthCount'] = self.mvunused_auth_count
        if self.open_time is not None:
            result['OpenTime'] = self.open_time
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sas_log is not None:
            result['SasLog'] = self.sas_log
        if self.sas_screen is not None:
            result['SasScreen'] = self.sas_screen
        if self.sls_capacity is not None:
            result['SlsCapacity'] = self.sls_capacity
        if self.threat_analysis_capacity is not None:
            result['ThreatAnalysisCapacity'] = self.threat_analysis_capacity
        if self.user_defined_alarms is not None:
            result['UserDefinedAlarms'] = self.user_defined_alarms
        if self.version is not None:
            result['Version'] = self.version
        if self.vm_cores is not None:
            result['VmCores'] = self.vm_cores
        if self.web_lock is not None:
            result['WebLock'] = self.web_lock
        if self.web_lock_auth_count is not None:
            result['WebLockAuthCount'] = self.web_lock_auth_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowPartialBuy') is not None:
            self.allow_partial_buy = m.get('AllowPartialBuy')
        if m.get('AppWhiteList') is not None:
            self.app_white_list = m.get('AppWhiteList')
        if m.get('AppWhiteListAuthCount') is not None:
            self.app_white_list_auth_count = m.get('AppWhiteListAuthCount')
        if m.get('AssetLevel') is not None:
            self.asset_level = m.get('AssetLevel')
        if m.get('HighestVersion') is not None:
            self.highest_version = m.get('HighestVersion')
        if m.get('HoneypotCapacity') is not None:
            self.honeypot_capacity = m.get('HoneypotCapacity')
        if m.get('ImageScanCapacity') is not None:
            self.image_scan_capacity = m.get('ImageScanCapacity')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsNewContainerVersion') is not None:
            self.is_new_container_version = m.get('IsNewContainerVersion')
        if m.get('IsOverBalance') is not None:
            self.is_over_balance = m.get('IsOverBalance')
        if m.get('IsTrialVersion') is not None:
            self.is_trial_version = m.get('IsTrialVersion')
        if m.get('LastTrailEndTime') is not None:
            self.last_trail_end_time = m.get('LastTrailEndTime')
        if m.get('MVAuthCount') is not None:
            self.mvauth_count = m.get('MVAuthCount')
        if m.get('MVUnusedAuthCount') is not None:
            self.mvunused_auth_count = m.get('MVUnusedAuthCount')
        if m.get('OpenTime') is not None:
            self.open_time = m.get('OpenTime')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SasLog') is not None:
            self.sas_log = m.get('SasLog')
        if m.get('SasScreen') is not None:
            self.sas_screen = m.get('SasScreen')
        if m.get('SlsCapacity') is not None:
            self.sls_capacity = m.get('SlsCapacity')
        if m.get('ThreatAnalysisCapacity') is not None:
            self.threat_analysis_capacity = m.get('ThreatAnalysisCapacity')
        if m.get('UserDefinedAlarms') is not None:
            self.user_defined_alarms = m.get('UserDefinedAlarms')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VmCores') is not None:
            self.vm_cores = m.get('VmCores')
        if m.get('WebLock') is not None:
            self.web_lock = m.get('WebLock')
        if m.get('WebLockAuthCount') is not None:
            self.web_lock_auth_count = m.get('WebLockAuthCount')
        return self


class DescribeVersionConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVersionConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVersionConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVersionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList(TeaModel):
    def __init__(self, name=None, type=None, values=None):
        # The name of the search condition.
        self.name = name  # type: str
        # The type of the search condition. Valid values:
        # 
        # *   **input**: You must manually enter the search condition.
        # *   **select**: You must select a search condition from the **Values** drop-down list.
        self.type = type  # type: str
        # The values of the search condition. This parameter is returned only if the value of **Type** is **select**.
        # 
        # >  If the value of **Type** is **input**, the value of this parameter is an empty string.
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeVpcHoneyPotCriteriaResponseBody(TeaModel):
    def __init__(self, criteria_list=None, request_id=None):
        # An array consisting of the search conditions that can be used to query honeypots.
        self.criteria_list = criteria_list  # type: list[DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.criteria_list:
            for k in self.criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVpcHoneyPotCriteriaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CriteriaList'] = []
        if self.criteria_list is not None:
            for k in self.criteria_list:
                result['CriteriaList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.criteria_list = []
        if m.get('CriteriaList') is not None:
            for k in m.get('CriteriaList'):
                temp_model = DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList()
                self.criteria_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVpcHoneyPotCriteriaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVpcHoneyPotCriteriaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVpcHoneyPotCriteriaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcHoneyPotCriteriaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcHoneyPotListRequest(TeaModel):
    def __init__(self, current_page=None, honey_pot_existence=None, page_size=None, vpc_id=None, vpc_name=None,
                 vpc_region_id=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # Specifies whether the cloud honeypot feature is enabled for the VPC. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.honey_pot_existence = honey_pot_existence  # type: bool
        # The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.
        # 
        # >  We recommend that you do not leave this parameter empty.
        self.page_size = page_size  # type: int
        # The ID of the VPC on which the honeypot is deployed.
        # 
        # >  You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the IDs of VPCs.
        self.vpc_id = vpc_id  # type: str
        # The name of the VPC.
        # 
        # >  You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the names of VPCs.
        self.vpc_name = vpc_name  # type: str
        # The region ID of the VPC.
        # 
        # >  You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the region IDs of VPCs.
        self.vpc_region_id = vpc_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honey_pot_existence is not None:
            result['HoneyPotExistence'] = self.honey_pot_existence
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        if self.vpc_region_id is not None:
            result['VpcRegionId'] = self.vpc_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneyPotExistence') is not None:
            self.honey_pot_existence = m.get('HoneyPotExistence')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        if m.get('VpcRegionId') is not None:
            self.vpc_region_id = m.get('VpcRegionId')
        return self


class DescribeVpcHoneyPotListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList(TeaModel):
    def __init__(self, vpc_switch_id=None, vpc_switch_name=None, zone_id=None):
        # The ID of the vSwitch.
        self.vpc_switch_id = vpc_switch_id  # type: str
        # The name of the vSwitch.
        self.vpc_switch_name = vpc_switch_name  # type: str
        # The zone ID of the vSwitch.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_switch_id is not None:
            result['VpcSwitchId'] = self.vpc_switch_id
        if self.vpc_switch_name is not None:
            result['VpcSwitchName'] = self.vpc_switch_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VpcSwitchId') is not None:
            self.vpc_switch_id = m.get('VpcSwitchId')
        if m.get('VpcSwitchName') is not None:
            self.vpc_switch_name = m.get('VpcSwitchName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList(TeaModel):
    def __init__(self, cidr_block=None, create_time=None, honey_pot_ecs_instance_status=None,
                 honey_pot_eni_instance_id=None, honey_pot_existence=None, honey_pot_instance_status=None, honey_pot_vpc_switch_id=None,
                 vpc_id=None, vpc_name=None, vpc_region_id=None, vpc_status=None, vpc_switch_id_list=None):
        # The CIDR block of the VPC.
        self.cidr_block = cidr_block  # type: str
        # The time when the VPC was created. Unit: milliseconds.
        self.create_time = create_time  # type: long
        # The status of the server on which the honeypot is deployed. Valid values:
        # 
        # *   **Pending**: The server is being created.
        # *   **Running**: The server is running.
        # *   **Starting**: The server is being started.
        # *   **Stopping**: The server is being stopped.
        # *   **Stopped**: The server is stopped.
        self.honey_pot_ecs_instance_status = honey_pot_ecs_instance_status  # type: str
        # The ID of the elastic network interface (ENI) used by the honeypot in the VPC.
        self.honey_pot_eni_instance_id = honey_pot_eni_instance_id  # type: str
        # Indicates whether the cloud honeypot feature is enabled for the VPC. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.honey_pot_existence = honey_pot_existence  # type: bool
        # The status of the honeypot. Valid values:
        # 
        # *   **pending**: The honeypot is being created.
        # *   **deleting**: The honeypot is being deleted.
        # *   **off**: The honeypot is disabled.
        # *   **suspending**: The honeypot is suspended.
        # *   **on**: The honeypot is enabled.
        self.honey_pot_instance_status = honey_pot_instance_status  # type: str
        # The ID of the vSwitch to which the ENI used by the honeypot is connected.
        self.honey_pot_vpc_switch_id = honey_pot_vpc_switch_id  # type: str
        # The ID of the VPC.
        self.vpc_id = vpc_id  # type: str
        # The name of the VPC.
        self.vpc_name = vpc_name  # type: str
        # The region ID of the VPC.
        # 
        # >  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).
        self.vpc_region_id = vpc_region_id  # type: str
        # The status of the VPC. Valid values:
        # 
        # *   **Available**: The VPC is normal and available.
        # *   **Pending**: The VPC is being configured.
        self.vpc_status = vpc_status  # type: str
        # An array that consists of the vSwitches in the VPC.
        self.vpc_switch_id_list = vpc_switch_id_list  # type: list[DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList]

    def validate(self):
        if self.vpc_switch_id_list:
            for k in self.vpc_switch_id_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.honey_pot_ecs_instance_status is not None:
            result['HoneyPotEcsInstanceStatus'] = self.honey_pot_ecs_instance_status
        if self.honey_pot_eni_instance_id is not None:
            result['HoneyPotEniInstanceId'] = self.honey_pot_eni_instance_id
        if self.honey_pot_existence is not None:
            result['HoneyPotExistence'] = self.honey_pot_existence
        if self.honey_pot_instance_status is not None:
            result['HoneyPotInstanceStatus'] = self.honey_pot_instance_status
        if self.honey_pot_vpc_switch_id is not None:
            result['HoneyPotVpcSwitchId'] = self.honey_pot_vpc_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        if self.vpc_region_id is not None:
            result['VpcRegionId'] = self.vpc_region_id
        if self.vpc_status is not None:
            result['VpcStatus'] = self.vpc_status
        result['VpcSwitchIdList'] = []
        if self.vpc_switch_id_list is not None:
            for k in self.vpc_switch_id_list:
                result['VpcSwitchIdList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HoneyPotEcsInstanceStatus') is not None:
            self.honey_pot_ecs_instance_status = m.get('HoneyPotEcsInstanceStatus')
        if m.get('HoneyPotEniInstanceId') is not None:
            self.honey_pot_eni_instance_id = m.get('HoneyPotEniInstanceId')
        if m.get('HoneyPotExistence') is not None:
            self.honey_pot_existence = m.get('HoneyPotExistence')
        if m.get('HoneyPotInstanceStatus') is not None:
            self.honey_pot_instance_status = m.get('HoneyPotInstanceStatus')
        if m.get('HoneyPotVpcSwitchId') is not None:
            self.honey_pot_vpc_switch_id = m.get('HoneyPotVpcSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        if m.get('VpcRegionId') is not None:
            self.vpc_region_id = m.get('VpcRegionId')
        if m.get('VpcStatus') is not None:
            self.vpc_status = m.get('VpcStatus')
        self.vpc_switch_id_list = []
        if m.get('VpcSwitchIdList') is not None:
            for k in m.get('VpcSwitchIdList'):
                temp_model = DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList()
                self.vpc_switch_id_list.append(temp_model.from_map(k))
        return self


class DescribeVpcHoneyPotListResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, vpc_honey_pot_dtolist=None):
        # The pagination information.
        self.page_info = page_info  # type: DescribeVpcHoneyPotListResponseBodyPageInfo
        # The ID of the request.
        self.request_id = request_id  # type: str
        # An array that consists of the honeypots.
        self.vpc_honey_pot_dtolist = vpc_honey_pot_dtolist  # type: list[DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.vpc_honey_pot_dtolist:
            for k in self.vpc_honey_pot_dtolist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VpcHoneyPotDTOList'] = []
        if self.vpc_honey_pot_dtolist is not None:
            for k in self.vpc_honey_pot_dtolist:
                result['VpcHoneyPotDTOList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = DescribeVpcHoneyPotListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vpc_honey_pot_dtolist = []
        if m.get('VpcHoneyPotDTOList') is not None:
            for k in m.get('VpcHoneyPotDTOList'):
                temp_model = DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList()
                self.vpc_honey_pot_dtolist.append(temp_model.from_map(k))
        return self


class DescribeVpcHoneyPotListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVpcHoneyPotListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVpcHoneyPotListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcHoneyPotListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcListResponseBodyVpcList(TeaModel):
    def __init__(self, ecs_count=None, instance_desc=None, instance_id=None, instance_name=None, region_id=None):
        # The number of ECS instances.
        self.ecs_count = ecs_count  # type: int
        # The information about the VPC.
        self.instance_desc = instance_desc  # type: str
        # The ID of the ECS instance.
        self.instance_id = instance_id  # type: str
        # The name of the VPC.
        self.instance_name = instance_name  # type: str
        # The region in which the ECS instance resides.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcListResponseBodyVpcList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_count is not None:
            result['EcsCount'] = self.ecs_count
        if self.instance_desc is not None:
            result['InstanceDesc'] = self.instance_desc
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EcsCount') is not None:
            self.ecs_count = m.get('EcsCount')
        if m.get('InstanceDesc') is not None:
            self.instance_desc = m.get('InstanceDesc')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeVpcListResponseBody(TeaModel):
    def __init__(self, count=None, request_id=None, vpc_list=None):
        # The total number of entries returned.
        self.count = count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of VPCs.
        self.vpc_list = vpc_list  # type: list[DescribeVpcListResponseBodyVpcList]

    def validate(self):
        if self.vpc_list:
            for k in self.vpc_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVpcListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VpcList'] = []
        if self.vpc_list is not None:
            for k in self.vpc_list:
                result['VpcList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vpc_list = []
        if m.get('VpcList') is not None:
            for k in m.get('VpcList'):
                temp_model = DescribeVpcListResponseBodyVpcList()
                self.vpc_list.append(temp_model.from_map(k))
        return self


class DescribeVpcListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVpcListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVpcListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulCheckTaskStatusDetailRequest(TeaModel):
    def __init__(self, task_ids=None, types=None, uuid=None):
        self.task_ids = task_ids  # type: list[str]
        self.types = types  # type: list[str]
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulCheckTaskStatusDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.types is not None:
            result['Types'] = self.types
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList(TeaModel):
    def __init__(self, code=None, status=None, type=None):
        self.code = code  # type: str
        self.status = status  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses(TeaModel):
    def __init__(self, task_id=None, task_status_list=None):
        self.task_id = task_id  # type: str
        self.task_status_list = task_status_list  # type: list[DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList]

    def validate(self):
        if self.task_status_list:
            for k in self.task_status_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        result['TaskStatusList'] = []
        if self.task_status_list is not None:
            for k in self.task_status_list:
                result['TaskStatusList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        self.task_status_list = []
        if m.get('TaskStatusList') is not None:
            for k in m.get('TaskStatusList'):
                temp_model = DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList()
                self.task_status_list.append(temp_model.from_map(k))
        return self


class DescribeVulCheckTaskStatusDetailResponseBody(TeaModel):
    def __init__(self, request_id=None, task_statuses=None, total_count=None):
        self.request_id = request_id  # type: str
        self.task_statuses = task_statuses  # type: list[DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.task_statuses:
            for k in self.task_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulCheckTaskStatusDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TaskStatuses'] = []
        if self.task_statuses is not None:
            for k in self.task_statuses:
                result['TaskStatuses'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task_statuses = []
        if m.get('TaskStatuses') is not None:
            for k in m.get('TaskStatuses'):
                temp_model = DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses()
                self.task_statuses.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulCheckTaskStatusDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulCheckTaskStatusDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulCheckTaskStatusDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulCheckTaskStatusDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulConfigRequest(TeaModel):
    def __init__(self, source_ip=None, type=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of configuration. By default, all types of configurations are queried. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability that is detected by using web scanner
        # *   **emg**: urgent vulnerability
        # *   **scanMode**: displays easily exploitable vulnerability
        # *   **imageVulClean**: vulnerability retention duration
        # *   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulConfigResponseBodyTargetConfigs(TeaModel):
    def __init__(self, config=None, over_all_config=None, type=None):
        # The configuartion of vulnerability scan.
        # 
        # > 
        # 
        # Valid values of this parameter if **cve**, **sys**, **cms**, **app**, **emg**, or **yum** is returned for the Type parameter:
        # 
        # *   **on**: enabled
        # *   **off**: disabled
        # 
        # > 
        # 
        # Valid values of this parameter if **scanMode** is returned for the Type parameter:
        # 
        # *   **real**: displays easily exploitable vulnerability
        # *   **all**: displays all vulnerabilities
        # 
        # > 
        # 
        # If **imageVulClean** is returned for the Type parameter, the value of this parameter indicates the vulnerability retention duration.
        self.config = config  # type: str
        # The status of vulnerability management. Valid values:
        # 
        # *   **off**: disabled
        # *   **on**: enabled
        self.over_all_config = over_all_config  # type: str
        # The type of configuration. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability that is detected by using web scanner
        # *   **emg**: urgent vulnerability
        # *   **scanMode**: displays easily exploitable vulnerability
        # *   **imageVulClean**: vulnerability retention duration
        # *   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulConfigResponseBodyTargetConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.over_all_config is not None:
            result['OverAllConfig'] = self.over_all_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('OverAllConfig') is not None:
            self.over_all_config = m.get('OverAllConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulConfigResponseBody(TeaModel):
    def __init__(self, request_id=None, target_configs=None, total_count=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # An array that consists of the configurations of vulnerability management.
        self.target_configs = target_configs  # type: list[DescribeVulConfigResponseBodyTargetConfigs]
        # The total number of configurations.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.target_configs:
            for k in self.target_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetConfigs'] = []
        if self.target_configs is not None:
            for k in self.target_configs:
                result['TargetConfigs'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_configs = []
        if m.get('TargetConfigs') is not None:
            for k in m.get('TargetConfigs'):
                temp_model = DescribeVulConfigResponseBodyTargetConfigs()
                self.target_configs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulDetailsRequest(TeaModel):
    def __init__(self, alias_name=None, lang=None, name=None, type=None):
        # The name in the **vulnerability introduction**.
        self.alias_name = alias_name  # type: str
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        # *   **sca**: vulnerability that is detected based on software component analysis
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulDetailsResponseBodyCvesClassifys(TeaModel):
    def __init__(self, classify=None, demo_video_url=None, description=None):
        # The type of the vulnerability.
        self.classify = classify  # type: str
        # The URL of the demo video for the vulnerability.
        self.demo_video_url = demo_video_url  # type: str
        # The description of the vulnerability type.
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulDetailsResponseBodyCvesClassifys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.demo_video_url is not None:
            result['DemoVideoUrl'] = self.demo_video_url
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('DemoVideoUrl') is not None:
            self.demo_video_url = m.get('DemoVideoUrl')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class DescribeVulDetailsResponseBodyCves(TeaModel):
    def __init__(self, classify=None, classifys=None, cnvd_id=None, complexity=None, content=None, cve_id=None,
                 cvss_score=None, cvss_vector=None, instance_name=None, internet_ip=None, intranet_ip=None, poc=None,
                 poc_create_time=None, poc_disclosure_time=None, product=None, reference=None, release_time=None, solution=None,
                 summary=None, target_id=None, target_name=None, title=None, vendor=None, vul_level=None):
        # The type of the vulnerability.
        self.classify = classify  # type: str
        # An array that consists of vulnerability types.
        self.classifys = classifys  # type: list[DescribeVulDetailsResponseBodyCvesClassifys]
        # The China National Vulnerability Database (CNVD) ID.
        self.cnvd_id = cnvd_id  # type: str
        # The difficulty level of exploiting the vulnerability. Valid values:
        # 
        # *   **LOW**\
        # *   **MEDIUM**\
        # *   **HIGH**\
        self.complexity = complexity  # type: str
        # The CVE content.
        self.content = content  # type: str
        # The Common Vulnerabilities and Exposures (CVE) ID.
        self.cve_id = cve_id  # type: str
        # The Common Vulnerability Scoring System (CVSS) score of the vulnerability in the Alibaba Cloud vulnerability library.
        self.cvss_score = cvss_score  # type: str
        # The vector that is used to calculate the CVSS score.
        self.cvss_vector = cvss_vector  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        # The POC content.
        self.poc = poc  # type: str
        # The timestamp when the proof of concept (POC) was created. Unit: milliseconds.
        self.poc_create_time = poc_create_time  # type: long
        # The timestamp when the POC was disclosed. Unit: milliseconds.
        self.poc_disclosure_time = poc_disclosure_time  # type: long
        # The service that is affected by the vulnerability.
        self.product = product  # type: str
        # The reference of the vulnerability in the Alibaba Cloud vulnerability library. The value is a URL.
        self.reference = reference  # type: str
        # The disclosure time that is displayed for the vulnerability in the Alibaba Cloud vulnerability library. The value is a UNIX timestamp. Unit: milliseconds.
        self.release_time = release_time  # type: long
        # The fixing suggestions of the vulnerability.
        self.solution = solution  # type: str
        # The introduction to the vulnerability.
        self.summary = summary  # type: str
        self.target_id = target_id  # type: str
        self.target_name = target_name  # type: str
        # The title of the vulnerability announcement.
        self.title = title  # type: str
        # The vendor that disclosed the vulnerability.
        self.vendor = vendor  # type: str
        # The severity of the vulnerability. Valid values:
        # 
        # *   **serious**\
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.vul_level = vul_level  # type: str

    def validate(self):
        if self.classifys:
            for k in self.classifys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulDetailsResponseBodyCves, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['Classifys'] = []
        if self.classifys is not None:
            for k in self.classifys:
                result['Classifys'].append(k.to_map() if k else None)
        if self.cnvd_id is not None:
            result['CnvdId'] = self.cnvd_id
        if self.complexity is not None:
            result['Complexity'] = self.complexity
        if self.content is not None:
            result['Content'] = self.content
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.cvss_score is not None:
            result['CvssScore'] = self.cvss_score
        if self.cvss_vector is not None:
            result['CvssVector'] = self.cvss_vector
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.poc is not None:
            result['Poc'] = self.poc
        if self.poc_create_time is not None:
            result['PocCreateTime'] = self.poc_create_time
        if self.poc_disclosure_time is not None:
            result['PocDisclosureTime'] = self.poc_disclosure_time
        if self.product is not None:
            result['Product'] = self.product
        if self.reference is not None:
            result['Reference'] = self.reference
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.title is not None:
            result['Title'] = self.title
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vul_level is not None:
            result['VulLevel'] = self.vul_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.classifys = []
        if m.get('Classifys') is not None:
            for k in m.get('Classifys'):
                temp_model = DescribeVulDetailsResponseBodyCvesClassifys()
                self.classifys.append(temp_model.from_map(k))
        if m.get('CnvdId') is not None:
            self.cnvd_id = m.get('CnvdId')
        if m.get('Complexity') is not None:
            self.complexity = m.get('Complexity')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('CvssScore') is not None:
            self.cvss_score = m.get('CvssScore')
        if m.get('CvssVector') is not None:
            self.cvss_vector = m.get('CvssVector')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Poc') is not None:
            self.poc = m.get('Poc')
        if m.get('PocCreateTime') is not None:
            self.poc_create_time = m.get('PocCreateTime')
        if m.get('PocDisclosureTime') is not None:
            self.poc_disclosure_time = m.get('PocDisclosureTime')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('Reference') is not None:
            self.reference = m.get('Reference')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VulLevel') is not None:
            self.vul_level = m.get('VulLevel')
        return self


class DescribeVulDetailsResponseBody(TeaModel):
    def __init__(self, cves=None, request_id=None):
        # An array that consists of the details about the vulnerability.
        self.cves = cves  # type: list[DescribeVulDetailsResponseBodyCves]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cves:
            for k in self.cves:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cves'] = []
        if self.cves is not None:
            for k in self.cves:
                result['Cves'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cves = []
        if m.get('Cves') is not None:
            for k in m.get('Cves'):
                temp_model = DescribeVulDetailsResponseBodyCves()
                self.cves.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulExportInfoRequest(TeaModel):
    def __init__(self, export_id=None):
        # The ID of the vulnerability export task.
        self.export_id = export_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeVulExportInfoResponseBody(TeaModel):
    def __init__(self, current_count=None, export_status=None, file_name=None, id=None, link=None, message=None,
                 progress=None, request_id=None, total_count=None):
        # The number of exported entries.
        self.current_count = current_count  # type: int
        # The status of the export task. Valid values:
        # 
        # - **init**: The task is being initialized.
        # - **exporting**: The task is in progress.
        # - **success**: The task is complete.
        self.export_status = export_status  # type: str
        # The name of the exported Excel file.
        self.file_name = file_name  # type: str
        # The ID of the vulnerability export task.
        self.id = id  # type: long
        # The URL at which you can download the exported Excel file.
        self.link = link  # type: str
        # The message that shows the task result. The value is fixed as **success*, which indicates that the export task is completed.
        self.message = message  # type: str
        # The progress percentage of the asset export task.
        self.progress = progress  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries in the Excel file.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulFixStatisticsResponseBodyFixStat(TeaModel):
    def __init__(self, fixed_today_num=None, fixed_total_num=None, fixing_num=None, need_fix_num=None, type=None):
        # The number of vulnerabilities that are fixed on the current day.
        self.fixed_today_num = fixed_today_num  # type: int
        # The total number of fixed vulnerabilities.
        self.fixed_total_num = fixed_total_num  # type: int
        # The number of vulnerabilities that are being fixed.
        self.fixing_num = fixing_num  # type: int
        # The number of unfixed vulnerabilities.
        self.need_fix_num = need_fix_num  # type: int
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulFixStatisticsResponseBodyFixStat, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_today_num is not None:
            result['FixedTodayNum'] = self.fixed_today_num
        if self.fixed_total_num is not None:
            result['FixedTotalNum'] = self.fixed_total_num
        if self.fixing_num is not None:
            result['FixingNum'] = self.fixing_num
        if self.need_fix_num is not None:
            result['NeedFixNum'] = self.need_fix_num
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FixedTodayNum') is not None:
            self.fixed_today_num = m.get('FixedTodayNum')
        if m.get('FixedTotalNum') is not None:
            self.fixed_total_num = m.get('FixedTotalNum')
        if m.get('FixingNum') is not None:
            self.fixing_num = m.get('FixingNum')
        if m.get('NeedFixNum') is not None:
            self.need_fix_num = m.get('NeedFixNum')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulFixStatisticsResponseBodyFixTotal(TeaModel):
    def __init__(self, fixed_today_num=None, fixed_total_num=None, fixing_num=None, need_fix_num=None):
        # The number of vulnerabilities that are fixed on the current day.
        self.fixed_today_num = fixed_today_num  # type: int
        # The total number of fixed vulnerabilities.
        self.fixed_total_num = fixed_total_num  # type: int
        # The number of vulnerabilities that are being fixed.
        self.fixing_num = fixing_num  # type: int
        # The number of unfixed vulnerabilities.
        self.need_fix_num = need_fix_num  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulFixStatisticsResponseBodyFixTotal, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_today_num is not None:
            result['FixedTodayNum'] = self.fixed_today_num
        if self.fixed_total_num is not None:
            result['FixedTotalNum'] = self.fixed_total_num
        if self.fixing_num is not None:
            result['FixingNum'] = self.fixing_num
        if self.need_fix_num is not None:
            result['NeedFixNum'] = self.need_fix_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FixedTodayNum') is not None:
            self.fixed_today_num = m.get('FixedTodayNum')
        if m.get('FixedTotalNum') is not None:
            self.fixed_total_num = m.get('FixedTotalNum')
        if m.get('FixingNum') is not None:
            self.fixing_num = m.get('FixingNum')
        if m.get('NeedFixNum') is not None:
            self.need_fix_num = m.get('NeedFixNum')
        return self


class DescribeVulFixStatisticsResponseBody(TeaModel):
    def __init__(self, fix_stat=None, fix_total=None, request_id=None):
        # An array that consists of the statistics of vulnerability fixes by vulnerability type.
        self.fix_stat = fix_stat  # type: list[DescribeVulFixStatisticsResponseBodyFixStat]
        # The total statistics of vulnerability fixes.
        self.fix_total = fix_total  # type: DescribeVulFixStatisticsResponseBodyFixTotal
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.fix_stat:
            for k in self.fix_stat:
                if k:
                    k.validate()
        if self.fix_total:
            self.fix_total.validate()

    def to_map(self):
        _map = super(DescribeVulFixStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FixStat'] = []
        if self.fix_stat is not None:
            for k in self.fix_stat:
                result['FixStat'].append(k.to_map() if k else None)
        if self.fix_total is not None:
            result['FixTotal'] = self.fix_total.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fix_stat = []
        if m.get('FixStat') is not None:
            for k in m.get('FixStat'):
                temp_model = DescribeVulFixStatisticsResponseBodyFixStat()
                self.fix_stat.append(temp_model.from_map(k))
        if m.get('FixTotal') is not None:
            temp_model = DescribeVulFixStatisticsResponseBodyFixTotal()
            self.fix_total = temp_model.from_map(m['FixTotal'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulFixStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulFixStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulFixStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulFixStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulListRequest(TeaModel):
    def __init__(self, alias_name=None, attach_types=None, current_page=None, dealed=None, group_id=None, lang=None,
                 name=None, necessity=None, page_size=None, remark=None, type=None, uuids=None, vpc_instance_ids=None):
        # The name of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The additional type of the vulnerability. You can specify this parameter when you query application vulnerabilities. Set the value to **sca**. If you set **Type** to **app**, you must specify this parameter.
        # 
        # >  If you set this parameter to **sca**, application vulnerabilities and the vulnerabilities that are detected based on software component analysis are queried. If you do not specify this parameter, only application vulnerabilities are queried.
        self.attach_types = attach_types  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the vulnerability is fixed. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.dealed = dealed  # type: str
        # The ID of the asset group.
        # 
        # >  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.
        self.group_id = group_id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The alias of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset.
        self.remark = remark  # type: str
        # The type of the vulnerabilities. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability that is detected by using web scanner
        # *   **emg**: urgent vulnerability
        # *   **sca**: application vulnerability that is detected by using software component analysis
        self.type = type  # type: str
        # The UUIDs of the servers on which you want to query the vulnerabilities. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str
        # The IDs of the virtual private clouds (VPCs) in which the vulnerability is detected. Separate multiple IDs with commas (,).
        self.vpc_instance_ids = vpc_instance_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity(TeaModel):
    def __init__(self, assets_factor=None, cvss_factor=None, enviroment_factor=None, is_calc=None, status=None,
                 time_factor=None, total_score=None):
        # The asset importance score. Valid values:
        # 
        # *   **2**: an important asset
        # *   **1**: a common asset
        # *   **0**: a test asset
        self.assets_factor = assets_factor  # type: str
        # The Common Vulnerability Scoring System (CVSS) score.
        self.cvss_factor = cvss_factor  # type: str
        # The environment score.
        self.enviroment_factor = enviroment_factor  # type: str
        # Indicates whether the score of urgency to fix a vulnerability is calculated. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_calc = is_calc  # type: str
        # The status of the score of urgency to fix a vulnerability. Valid values:
        # 
        # *   **none**: No score is generated.
        # *   **pending**: The score is pending calculation.
        # *   **normal**: The calculation is normal.
        self.status = status  # type: str
        # The time score.
        self.time_factor = time_factor  # type: str
        # The score of urgency to fix a vulnerability.
        # 
        # The following list describes scores and related fixing suggestions:
        # 
        # *   If the score is from **13.5 to 15**, the vulnerability is a high-risk vulnerability. You must fix the vulnerability at the earliest opportunity.
        # *   If the score is **greater than or equal to 7 but less than 13.5**, the vulnerability is a medium-risk vulnerability. You can fix the vulnerability at your convenience.
        # *   If the score is **less than 7**, the vulnerability is a low-risk vulnerability. You can ignore the vulnerability.
        self.total_score = total_score  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_factor is not None:
            result['Assets_factor'] = self.assets_factor
        if self.cvss_factor is not None:
            result['Cvss_factor'] = self.cvss_factor
        if self.enviroment_factor is not None:
            result['Enviroment_factor'] = self.enviroment_factor
        if self.is_calc is not None:
            result['Is_calc'] = self.is_calc
        if self.status is not None:
            result['Status'] = self.status
        if self.time_factor is not None:
            result['Time_factor'] = self.time_factor
        if self.total_score is not None:
            result['Total_score'] = self.total_score
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Assets_factor') is not None:
            self.assets_factor = m.get('Assets_factor')
        if m.get('Cvss_factor') is not None:
            self.cvss_factor = m.get('Cvss_factor')
        if m.get('Enviroment_factor') is not None:
            self.enviroment_factor = m.get('Enviroment_factor')
        if m.get('Is_calc') is not None:
            self.is_calc = m.get('Is_calc')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Time_factor') is not None:
            self.time_factor = m.get('Time_factor')
        if m.get('Total_score') is not None:
            self.total_score = m.get('Total_score')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(TeaModel):
    def __init__(self, container_name=None, full_version=None, image_name=None, match_detail=None, match_list=None,
                 name=None, path=None, pid=None, update_cmd=None, version=None):
        # The name of the container.
        self.container_name = container_name  # type: str
        # The complete version number.
        self.full_version = full_version  # type: str
        # The name of the image.
        self.image_name = image_name  # type: str
        # The reason why the vulnerability is detected.
        self.match_detail = match_detail  # type: str
        # The rule that is used to detect the vulnerability.
        self.match_list = match_list  # type: list[str]
        # The name of the RPM package.
        self.name = name  # type: str
        # The path of the software that has the vulnerability.
        self.path = path  # type: str
        # The process ID.
        self.pid = pid  # type: str
        # The command that is used to fix the vulnerability.
        self.update_cmd = update_cmd  # type: str
        # The package version number of the software that has the vulnerability.
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.full_version is not None:
            result['FullVersion'] = self.full_version
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.match_detail is not None:
            result['MatchDetail'] = self.match_detail
        if self.match_list is not None:
            result['MatchList'] = self.match_list
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.update_cmd is not None:
            result['UpdateCmd'] = self.update_cmd
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('FullVersion') is not None:
            self.full_version = m.get('FullVersion')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('MatchDetail') is not None:
            self.match_detail = m.get('MatchDetail')
        if m.get('MatchList') is not None:
            self.match_list = m.get('MatchList')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('UpdateCmd') is not None:
            self.update_cmd = m.get('UpdateCmd')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJson(TeaModel):
    def __init__(self, absolute_path=None, alias_name=None, description=None, ip=None, last_ts=None, necessity=None,
                 os=None, os_release=None, primary_id=None, rpm_entity_list=None, status=None, tag=None, cve_list=None):
        # The package path of the software that has the vulnerability.
        self.absolute_path = absolute_path  # type: str
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The description of the vulnerability.
        self.description = description  # type: str
        # The public IP address of the asset that is associated with the vulnerability.
        self.ip = ip  # type: str
        # The timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.last_ts = last_ts  # type: long
        # Indicates whether the vulnerability needs to be fixed.
        self.necessity = necessity  # type: DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity
        # The name of the operating system for your asset.
        self.os = os  # type: str
        # The release of the operating system.
        self.os_release = os_release  # type: str
        # The ID of the vulnerability.
        self.primary_id = primary_id  # type: long
        # An array that consists of the information about RPM Package Manager (RPM) packages.
        self.rpm_entity_list = rpm_entity_list  # type: list[DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList]
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **2**: fix failed
        # *   3: rollback failed
        # *   **4**: being fixed
        # *   **5**: being rolled back
        # *   **6**: being verified
        # *   **7**: fixed
        # *   **8**: fixed and to be restarted
        # *   **9**: rolled back
        # *   **10**: ignored
        # *   **11**: rolled back and to be restarted
        # *   **12**: not found
        # *   **20**: expired
        self.status = status  # type: str
        # The tag that is added to the vulnerability.
        self.tag = tag  # type: str
        # The CVE list.
        self.cve_list = cve_list  # type: list[str]

    def validate(self):
        if self.necessity:
            self.necessity.validate()
        if self.rpm_entity_list:
            for k in self.rpm_entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecordsExtendContentJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.absolute_path is not None:
            result['AbsolutePath'] = self.absolute_path
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.description is not None:
            result['Description'] = self.description
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.necessity is not None:
            result['Necessity'] = self.necessity.to_map()
        if self.os is not None:
            result['Os'] = self.os
        if self.os_release is not None:
            result['OsRelease'] = self.os_release
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        result['RpmEntityList'] = []
        if self.rpm_entity_list is not None:
            for k in self.rpm_entity_list:
                result['RpmEntityList'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.cve_list is not None:
            result['cveList'] = self.cve_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbsolutePath') is not None:
            self.absolute_path = m.get('AbsolutePath')
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('Necessity') is not None:
            temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity()
            self.necessity = temp_model.from_map(m['Necessity'])
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsRelease') is not None:
            self.os_release = m.get('OsRelease')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        self.rpm_entity_list = []
        if m.get('RpmEntityList') is not None:
            for k in m.get('RpmEntityList'):
                temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList()
                self.rpm_entity_list.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('cveList') is not None:
            self.cve_list = m.get('cveList')
        return self


class DescribeVulListResponseBodyVulRecords(TeaModel):
    def __init__(self, alias_name=None, auth_version=None, bind=None, extend_content_json=None, first_ts=None,
                 group_id=None, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None, last_ts=None,
                 modify_ts=None, name=None, necessity=None, online=None, os_name=None, os_version=None, primary_id=None,
                 region_id=None, related=None, repair_ts=None, result_code=None, result_message=None, status=None, tag=None,
                 type=None, uuid=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The edition of Security Center that is authorized to scan the asset. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version  # type: str
        # Indicates whether Security Center is authorized to scan the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind  # type: bool
        # The extended information about the vulnerability.
        self.extend_content_json = extend_content_json  # type: DescribeVulListResponseBodyVulRecordsExtendContentJson
        # The timestamp when the vulnerability was first detected. Unit: milliseconds.
        self.first_ts = first_ts  # type: long
        # The ID of the asset group.
        self.group_id = group_id  # type: int
        # The instance ID of the asset.
        self.instance_id = instance_id  # type: str
        # The name of the asset.
        self.instance_name = instance_name  # type: str
        # The public IP address of the asset.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip  # type: str
        # The timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.last_ts = last_ts  # type: long
        # The timestamp when the vulnerability status was modified. Unit: milliseconds.
        self.modify_ts = modify_ts  # type: long
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability. Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        # 
        # >  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.
        self.necessity = necessity  # type: str
        # Indicates whether the Security Center agent on the asset is online. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.online = online  # type: bool
        # The name of the operating system for your asset.
        self.os_name = os_name  # type: str
        # The name of the operating system for your asset.
        self.os_version = os_version  # type: str
        # The ID of the vulnerability.
        self.primary_id = primary_id  # type: long
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The Common Vulnerabilities and Exposures (CVE) IDs related to the vulnerability. Multiple CVE IDs are separated by commas (,).
        self.related = related  # type: str
        # The timestamp when the vulnerability was fixed. Unit: milliseconds.
        self.repair_ts = repair_ts  # type: long
        # The code that indicates the vulnerability fixing result.
        self.result_code = result_code  # type: str
        # The message that indicates the vulnerability fixing result.
        self.result_message = result_message  # type: str
        # The status of the vulnerability. Valid values:
        # 
        # *   **1**: unfixed
        # *   **2**: fix failed
        # *   **3**: rollback failed
        # *   **4**: being fixed
        # *   **5**: being rolled back
        # *   **6**: being verified
        # *   **7**: fixed
        # *   **8**: fixed and to be restarted
        # *   **9**: rolled back
        # *   **10**: ignored
        # *   **11**: rolled back and to be restarted
        # *   **12**: not found
        # *   **20**: expired
        self.status = status  # type: int
        # The tag that is added to the vulnerability.
        self.tag = tag  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **emg**: urgent vulnerability
        # *   **app**: application vulnerability
        self.type = type  # type: str
        # The instance UUID of the asset.
        self.uuid = uuid  # type: str

    def validate(self):
        if self.extend_content_json:
            self.extend_content_json.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.extend_content_json is not None:
            result['ExtendContentJson'] = self.extend_content_json.to_map()
        if self.first_ts is not None:
            result['FirstTs'] = self.first_ts
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.modify_ts is not None:
            result['ModifyTs'] = self.modify_ts
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.online is not None:
            result['Online'] = self.online
        if self.os_name is not None:
            result['OsName'] = self.os_name
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.primary_id is not None:
            result['PrimaryId'] = self.primary_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.related is not None:
            result['Related'] = self.related
        if self.repair_ts is not None:
            result['RepairTs'] = self.repair_ts
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.result_message is not None:
            result['ResultMessage'] = self.result_message
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('ExtendContentJson') is not None:
            temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJson()
            self.extend_content_json = temp_model.from_map(m['ExtendContentJson'])
        if m.get('FirstTs') is not None:
            self.first_ts = m.get('FirstTs')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('ModifyTs') is not None:
            self.modify_ts = m.get('ModifyTs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('OsName') is not None:
            self.os_name = m.get('OsName')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('PrimaryId') is not None:
            self.primary_id = m.get('PrimaryId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Related') is not None:
            self.related = m.get('Related')
        if m.get('RepairTs') is not None:
            self.repair_ts = m.get('RepairTs')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('ResultMessage') is not None:
            self.result_message = m.get('ResultMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulListResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, request_id=None, total_count=None, vul_records=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of vulnerabilities returned.
        self.total_count = total_count  # type: int
        # An array that consists of the vulnerabilities.
        self.vul_records = vul_records  # type: list[DescribeVulListResponseBodyVulRecords]

    def validate(self):
        if self.vul_records:
            for k in self.vul_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulRecords'] = []
        if self.vul_records is not None:
            for k in self.vul_records:
                result['VulRecords'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_records = []
        if m.get('VulRecords') is not None:
            for k in m.get('VulRecords'):
                temp_model = DescribeVulListResponseBodyVulRecords()
                self.vul_records.append(temp_model.from_map(k))
        return self


class DescribeVulListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulListPageRequest(TeaModel):
    def __init__(self, current_page=None, cve_id=None, page_size=None, vul_name_like=None):
        self.current_page = current_page  # type: int
        self.cve_id = cve_id  # type: str
        self.page_size = page_size  # type: int
        self.vul_name_like = vul_name_like  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListPageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vul_name_like is not None:
            result['VulNameLike'] = self.vul_name_like
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VulNameLike') is not None:
            self.vul_name_like = m.get('VulNameLike')
        return self


class DescribeVulListPageResponseBodyData(TeaModel):
    def __init__(self, cve_id=None, ext_aegis=None, id=None, is_aegis=None, is_sas=None, other_id=None,
                 release_time=None, title=None):
        self.cve_id = cve_id  # type: str
        self.ext_aegis = ext_aegis  # type: str
        self.id = id  # type: long
        self.is_aegis = is_aegis  # type: int
        self.is_sas = is_sas  # type: int
        self.other_id = other_id  # type: str
        self.release_time = release_time  # type: long
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListPageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.ext_aegis is not None:
            result['ExtAegis'] = self.ext_aegis
        if self.id is not None:
            result['Id'] = self.id
        if self.is_aegis is not None:
            result['IsAegis'] = self.is_aegis
        if self.is_sas is not None:
            result['IsSas'] = self.is_sas
        if self.other_id is not None:
            result['OtherId'] = self.other_id
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('ExtAegis') is not None:
            self.ext_aegis = m.get('ExtAegis')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsAegis') is not None:
            self.is_aegis = m.get('IsAegis')
        if m.get('IsSas') is not None:
            self.is_sas = m.get('IsSas')
        if m.get('OtherId') is not None:
            self.other_id = m.get('OtherId')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeVulListPageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None, total_count=None):
        self.data = data  # type: list[DescribeVulListPageResponseBodyData]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulListPageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeVulListPageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulListPageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulListPageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulListPageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulListPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulNumStatisticsRequest(TeaModel):
    def __init__(self, from_=None):
        self.from_ = from_  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulNumStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class DescribeVulNumStatisticsResponseBody(TeaModel):
    def __init__(self, app_cnt=None, app_num=None, cms_dealed_total_num=None, cms_num=None, cve_num=None,
                 emg_num=None, request_id=None, sca_num=None, sys_num=None, vul_asap_sum=None, vul_dealed_total_num=None,
                 vul_later_sum=None, vul_nntf_sum=None):
        self.app_cnt = app_cnt  # type: int
        self.app_num = app_num  # type: int
        self.cms_dealed_total_num = cms_dealed_total_num  # type: int
        self.cms_num = cms_num  # type: int
        self.cve_num = cve_num  # type: int
        self.emg_num = emg_num  # type: int
        self.request_id = request_id  # type: str
        self.sca_num = sca_num  # type: int
        self.sys_num = sys_num  # type: int
        self.vul_asap_sum = vul_asap_sum  # type: int
        self.vul_dealed_total_num = vul_dealed_total_num  # type: int
        self.vul_later_sum = vul_later_sum  # type: int
        self.vul_nntf_sum = vul_nntf_sum  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulNumStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_cnt is not None:
            result['AppCnt'] = self.app_cnt
        if self.app_num is not None:
            result['AppNum'] = self.app_num
        if self.cms_dealed_total_num is not None:
            result['CmsDealedTotalNum'] = self.cms_dealed_total_num
        if self.cms_num is not None:
            result['CmsNum'] = self.cms_num
        if self.cve_num is not None:
            result['CveNum'] = self.cve_num
        if self.emg_num is not None:
            result['EmgNum'] = self.emg_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sca_num is not None:
            result['ScaNum'] = self.sca_num
        if self.sys_num is not None:
            result['SysNum'] = self.sys_num
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_dealed_total_num is not None:
            result['VulDealedTotalNum'] = self.vul_dealed_total_num
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppCnt') is not None:
            self.app_cnt = m.get('AppCnt')
        if m.get('AppNum') is not None:
            self.app_num = m.get('AppNum')
        if m.get('CmsDealedTotalNum') is not None:
            self.cms_dealed_total_num = m.get('CmsDealedTotalNum')
        if m.get('CmsNum') is not None:
            self.cms_num = m.get('CmsNum')
        if m.get('CveNum') is not None:
            self.cve_num = m.get('CveNum')
        if m.get('EmgNum') is not None:
            self.emg_num = m.get('EmgNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScaNum') is not None:
            self.sca_num = m.get('ScaNum')
        if m.get('SysNum') is not None:
            self.sys_num = m.get('SysNum')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulDealedTotalNum') is not None:
            self.vul_dealed_total_num = m.get('VulDealedTotalNum')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        return self


class DescribeVulNumStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulNumStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulNumStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulNumStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulTargetConfigRequest(TeaModel):
    def __init__(self, type=None, uuid=None):
        self.type = type  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulTargetConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeVulTargetConfigResponseBodyTargetConfigs(TeaModel):
    def __init__(self, config=None, over_all_config=None, type=None):
        self.config = config  # type: str
        self.over_all_config = over_all_config  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulTargetConfigResponseBodyTargetConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.over_all_config is not None:
            result['OverAllConfig'] = self.over_all_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('OverAllConfig') is not None:
            self.over_all_config = m.get('OverAllConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulTargetConfigResponseBody(TeaModel):
    def __init__(self, request_id=None, target_configs=None, total_count=None):
        self.request_id = request_id  # type: str
        self.target_configs = target_configs  # type: list[DescribeVulTargetConfigResponseBodyTargetConfigs]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.target_configs:
            for k in self.target_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulTargetConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetConfigs'] = []
        if self.target_configs is not None:
            for k in self.target_configs:
                result['TargetConfigs'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_configs = []
        if m.get('TargetConfigs') is not None:
            for k in m.get('TargetConfigs'):
                temp_model = DescribeVulTargetConfigResponseBodyTargetConfigs()
                self.target_configs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulTargetConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulTargetConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulTargetConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulTargetStatisticsRequest(TeaModel):
    def __init__(self, type=None):
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulTargetStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulTargetStatisticsResponseBodyTargetStatsTargets(TeaModel):
    def __init__(self, flag=None, target=None, target_type=None):
        self.flag = flag  # type: str
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulTargetStatisticsResponseBodyTargetStatsTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flag is not None:
            result['Flag'] = self.flag
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Flag') is not None:
            self.flag = m.get('Flag')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeVulTargetStatisticsResponseBodyTargetStats(TeaModel):
    def __init__(self, targets=None, total_count=None, uuid_count=None, vul_type=None):
        self.targets = targets  # type: list[DescribeVulTargetStatisticsResponseBodyTargetStatsTargets]
        self.total_count = total_count  # type: int
        self.uuid_count = uuid_count  # type: int
        self.vul_type = vul_type  # type: str

    def validate(self):
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulTargetStatisticsResponseBodyTargetStats, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.uuid_count is not None:
            result['UuidCount'] = self.uuid_count
        if self.vul_type is not None:
            result['VulType'] = self.vul_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = DescribeVulTargetStatisticsResponseBodyTargetStatsTargets()
                self.targets.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UuidCount') is not None:
            self.uuid_count = m.get('UuidCount')
        if m.get('VulType') is not None:
            self.vul_type = m.get('VulType')
        return self


class DescribeVulTargetStatisticsResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, request_id=None, target_stats=None, total_count=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.target_stats = target_stats  # type: list[DescribeVulTargetStatisticsResponseBodyTargetStats]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.target_stats:
            for k in self.target_stats:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulTargetStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TargetStats'] = []
        if self.target_stats is not None:
            for k in self.target_stats:
                result['TargetStats'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.target_stats = []
        if m.get('TargetStats') is not None:
            for k in m.get('TargetStats'):
                temp_model = DescribeVulTargetStatisticsResponseBodyTargetStats()
                self.target_stats.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeVulTargetStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulTargetStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulTargetStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulTargetStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulWhitelistRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulWhitelistRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeVulWhitelistResponseBodyVulWhitelists(TeaModel):
    def __init__(self, alias_name=None, id=None, name=None, reason=None, target_info=None, type=None, whitelist=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The ID of the rule.
        self.id = id  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The reason why the vulnerability is added to the whitelist.
        self.reason = reason  # type: str
        # The application scope of the rule. The value is a JSON string that contains the following fields:
        # 
        # *   **type**: the type of the asset to which the rule is applied. Valid values:
        # 
        #        -  **Uuid**: server
        #        -  **GroupId**: server group
        # 
        # *   **groupIds**: the IDs of server groups.
        # 
        # *   **uuids**: the UUIDs of servers.
        # 
        # >  If this field is empty, the rule is applied to all assets.
        self.target_info = target_info  # type: str
        # The type of the vulnerability.
        self.type = type  # type: str
        self.whitelist = whitelist  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulWhitelistResponseBodyVulWhitelists, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class DescribeVulWhitelistResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, request_id=None, total_count=None,
                 vul_whitelists=None):
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int
        # An array that consists of the whitelist of vulnerabilities.
        self.vul_whitelists = vul_whitelists  # type: list[DescribeVulWhitelistResponseBodyVulWhitelists]

    def validate(self):
        if self.vul_whitelists:
            for k in self.vul_whitelists:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulWhitelistResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulWhitelists'] = []
        if self.vul_whitelists is not None:
            for k in self.vul_whitelists:
                result['VulWhitelists'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_whitelists = []
        if m.get('VulWhitelists') is not None:
            for k in m.get('VulWhitelists'):
                temp_model = DescribeVulWhitelistResponseBodyVulWhitelists()
                self.vul_whitelists.append(temp_model.from_map(k))
        return self


class DescribeVulWhitelistResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulWhitelistResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulWhitelistResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWarningExportInfoRequest(TeaModel):
    def __init__(self, export_id=None):
        # The ID of the export task.
        # 
        # >  You can can call the [ExportWarning](~~ExportWarning~~) operation to query the IDs of export tasks.
        self.export_id = export_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWarningExportInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_id is not None:
            result['ExportId'] = self.export_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportId') is not None:
            self.export_id = m.get('ExportId')
        return self


class DescribeWarningExportInfoResponseBody(TeaModel):
    def __init__(self, current_count=None, export_status=None, file_name=None, id=None, link=None, message=None,
                 progress=None, request_id=None, total_count=None):
        # The number of baseline entries that are exported.
        self.current_count = current_count  # type: int
        # The status of the export task.
        # 
        # Valid values:
        # 
        # *   **init**: The task is being initialized.
        # *   **exporting**: The task is in progress.
        # *   **success**: The task is successful.
        self.export_status = export_status  # type: str
        # The name of the exported Excel file.
        self.file_name = file_name  # type: str
        # The ID of the export task for the baseline check result.
        self.id = id  # type: long
        # The URL at which you can download the exported Excel file.
        self.link = link  # type: str
        # The message that shows the export task result. The value is fixed as **successful**, which indicates that the export task is successful.
        self.message = message  # type: str
        # The progress percentage of the export task.
        self.progress = progress  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of baseline entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWarningExportInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_count is not None:
            result['CurrentCount'] = self.current_count
        if self.export_status is not None:
            result['ExportStatus'] = self.export_status
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.link is not None:
            result['Link'] = self.link
        if self.message is not None:
            result['Message'] = self.message
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentCount') is not None:
            self.current_count = m.get('CurrentCount')
        if m.get('ExportStatus') is not None:
            self.export_status = m.get('ExportStatus')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWarningExportInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWarningExportInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWarningExportInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWarningExportInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWarningMachinesRequest(TeaModel):
    def __init__(self, cluster_id=None, container_field_name=None, container_field_value=None, current_page=None,
                 group_id=None, have_risk=None, lang=None, machine_name=None, page_size=None, risk_id=None, source_ip=None,
                 strategy_id=None, target_type=None, uuids=None):
        # The ID of the container cluster.
        # 
        # >  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.
        self.cluster_id = cluster_id  # type: str
        # The name of the field that is used to search for the container. Valid values:
        # 
        # *   **CONTAINER_ID**: the ID of the container
        # *   **IMAGE**: the name of the image
        # *   **NAMESPACE**: the namespace
        # *   **NODE_NAME**: the name of the node
        # *   **POD_IP**: the IP address of the pod
        # *   **HOST_IP**: the IP address of the host
        # *   **INSTANCE_ID**: the ID of the instance
        self.container_field_name = container_field_name  # type: str
        # The value of the field that is used to search for the container.
        self.container_field_value = container_field_value  # type: str
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        self.group_id = group_id  # type: long
        # Specifies whether risks were detected. Valid values:
        # 
        # *   **1**: yes
        # *   **0**: no
        self.have_risk = have_risk  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the server on which the baseline check is performed.
        self.machine_name = machine_name  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The ID of the risk item.
        # 
        # >  You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.
        self.risk_id = risk_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id  # type: long
        # The type of the query condition. Valid values:
        # 
        # *   **containerId**: the ID of the container
        # *   **uuid**: the UUID of the asset
        self.target_type = target_type  # type: str
        # The UUID of the server on which the baseline check is performed. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWarningMachinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.have_risk is not None:
            result['HaveRisk'] = self.have_risk
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('HaveRisk') is not None:
            self.have_risk = m.get('HaveRisk')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class DescribeWarningMachinesResponseBodyWarningMachines(TeaModel):
    def __init__(self, auth_version=None, bind=None, high_warning_count=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, low_warning_count=None, medium_warning_count=None, pass_count=None,
                 port_open=None, region_id=None, status=None, uuid=None):
        # The edition of Security Center that is authorized to protect the asset. Valid values:
        # 
        # *   **1**: Basic edition
        # *   **6**: Anti-virus edition
        # *   **5**: Advanced edition
        # *   **3**: Enterprise edition
        # *   **7**: Ultimate edition
        # *   **10**: Value-added Plan edition
        self.auth_version = auth_version  # type: int
        # Indicates whether Security Center is authorized to protect the asset. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.bind = bind  # type: bool
        # The number of **high-risk** items on the server.
        self.high_warning_count = high_warning_count  # type: int
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The number of **low-risk** items on the server.
        self.low_warning_count = low_warning_count  # type: int
        # The number of **medium-risk** items on the server.
        self.medium_warning_count = medium_warning_count  # type: int
        # The number of the check items that passed the baseline check on the server.
        self.pass_count = pass_count  # type: int
        # Indicates whether a port on the server is accessible over the Internet. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.port_open = port_open  # type: bool
        # The ID of the region in which the server is deployed.
        self.region_id = region_id  # type: str
        # The verification status of the risk item after the risk item is fixed. Valid values:
        # 
        # *   **1**: complete
        # *   **2**: verifying
        self.status = status  # type: int
        # The UUID of the server on which the baseline check is performed.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWarningMachinesResponseBodyWarningMachines, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.port_open is not None:
            result['PortOpen'] = self.port_open
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('PortOpen') is not None:
            self.port_open = m.get('PortOpen')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWarningMachinesResponseBody(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, request_id=None, total_count=None,
                 warning_machines=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int
        # An array that consists of the servers.
        self.warning_machines = warning_machines  # type: list[DescribeWarningMachinesResponseBodyWarningMachines]

    def validate(self):
        if self.warning_machines:
            for k in self.warning_machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWarningMachinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WarningMachines'] = []
        if self.warning_machines is not None:
            for k in self.warning_machines:
                result['WarningMachines'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.warning_machines = []
        if m.get('WarningMachines') is not None:
            for k in m.get('WarningMachines'):
                temp_model = DescribeWarningMachinesResponseBodyWarningMachines()
                self.warning_machines.append(temp_model.from_map(k))
        return self


class DescribeWarningMachinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWarningMachinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWarningMachinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWarningMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockBindListRequest(TeaModel):
    def __init__(self, current_page=None, lang=None, page_size=None, remark=None, source_ip=None, status=None):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page  # type: int
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size  # type: int
        # The string that allows you to search for servers in fuzzy match mode. You can enter a server name or IP address.
        self.remark = remark  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The protection status of the server that you want to query. Valid values:
        # 
        # *   **on**: protected
        # *   **off**: unprotected
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockBindListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeWebLockBindListResponseBodyBindList(TeaModel):
    def __init__(self, audit_count=None, block_count=None, dir_count=None, instance_name=None, internet_ip=None,
                 intranet_ip=None, os=None, percent=None, service_code=None, service_detail=None, service_status=None,
                 status=None, uuid=None):
        # The number of alerts.
        self.audit_count = audit_count  # type: str
        # The number of blocked tampering events.
        self.block_count = block_count  # type: str
        # The number of protected directories.
        self.dir_count = dir_count  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The operating system that the server runs.
        self.os = os  # type: str
        # The starting progress percentage of web tamper proofing. Valid values: 0 to 100.
        self.percent = percent  # type: int
        # The error code for web tamper proofing. Valid values:
        # 
        # *   **2001**: The Security Center agent is offline.
        # *   **9999**: The connection timed out.
        self.service_code = service_code  # type: str
        # The error message for web tamper proofing. Valid values:
        # 
        # *   **client offline**: The Security Center agent is offline.
        # *   **timeout**: The connection timed out.
        self.service_detail = service_detail  # type: str
        # The status of web tamper proofing on the server. Valid values:
        # 
        # *   **stop**: Web tamper proofing is disabled.
        # *   **initializing**: Web tamper proofing is being enabled.
        # *   **exception**: Web tamper proofing is not running as expected.
        # *   **running**: Web tamper proofing is running.
        # *   **closing**: Web tamper proofing is being disabled.
        self.service_status = service_status  # type: str
        # The protection status of the server. Valid values:
        # 
        # *   **on**: protected
        # *   **off**: unprotected
        self.status = status  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockBindListResponseBodyBindList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_count is not None:
            result['AuditCount'] = self.audit_count
        if self.block_count is not None:
            result['BlockCount'] = self.block_count
        if self.dir_count is not None:
            result['DirCount'] = self.dir_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.os is not None:
            result['Os'] = self.os
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.service_code is not None:
            result['ServiceCode'] = self.service_code
        if self.service_detail is not None:
            result['ServiceDetail'] = self.service_detail
        if self.service_status is not None:
            result['ServiceStatus'] = self.service_status
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuditCount') is not None:
            self.audit_count = m.get('AuditCount')
        if m.get('BlockCount') is not None:
            self.block_count = m.get('BlockCount')
        if m.get('DirCount') is not None:
            self.dir_count = m.get('DirCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('ServiceCode') is not None:
            self.service_code = m.get('ServiceCode')
        if m.get('ServiceDetail') is not None:
            self.service_detail = m.get('ServiceDetail')
        if m.get('ServiceStatus') is not None:
            self.service_status = m.get('ServiceStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockBindListResponseBody(TeaModel):
    def __init__(self, bind_list=None, current_page=None, page_size=None, request_id=None, total_count=None):
        # The information about the servers that have web tamper proofing enabled.
        self.bind_list = bind_list  # type: list[DescribeWebLockBindListResponseBodyBindList]
        # The page number of the returned page. Pages start from page 1. Default value: 1.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: 20.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of servers that have web tamper proofing enabled.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.bind_list:
            for k in self.bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockBindListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BindList'] = []
        if self.bind_list is not None:
            for k in self.bind_list:
                result['BindList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bind_list = []
        if m.get('BindList') is not None:
            for k in m.get('BindList'):
                temp_model = DescribeWebLockBindListResponseBodyBindList()
                self.bind_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockBindListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockBindListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockBindListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockBindListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockConfigListRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, uuid=None):
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the server for which you want to query the configurations.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockConfigListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockConfigListResponseBodyConfigList(TeaModel):
    def __init__(self, defence_mode=None, dir=None, exclusive_dir=None, exclusive_file=None,
                 exclusive_file_type=None, id=None, inclusive_file=None, inclusive_file_type=None, local_backup_dir=None, mode=None,
                 uuid=None):
        # The prevention mode. Valid values:
        # 
        # *   **block**: Interception Mode
        # *   **audit**: Alert Mode
        self.defence_mode = defence_mode  # type: str
        # The directory that has web tamper proofing enabled.
        self.dir = dir  # type: str
        # The directory that has web tamper proofing disabled.
        # 
        # >  If the value of **Mode** is **blacklist**, this parameter is returned.
        self.exclusive_dir = exclusive_dir  # type: str
        # The file that has web tamper proofing disabled.
        # 
        # >  If the value of **Mode** is **blacklist**, this parameter is returned.
        self.exclusive_file = exclusive_file  # type: str
        # The type of the file that has web tamper proofing disabled.
        # 
        # >  If the value of **Mode** is **blacklist**, this parameter is returned.
        self.exclusive_file_type = exclusive_file_type  # type: str
        # The ID of the directory that has web tamper proofing enabled.
        self.id = id  # type: str
        # The file that has web tamper proofing enabled.
        # 
        # >  If the value of **Mode** is **whitelist**, this parameter is returned.
        self.inclusive_file = inclusive_file  # type: str
        # The type of the file that has web tamper proofing enabled.
        # 
        # >  If the value of **Mode** is **whitelist**, this parameter is returned.
        self.inclusive_file_type = inclusive_file_type  # type: str
        # The local path to the backup files of the protected directory.
        self.local_backup_dir = local_backup_dir  # type: str
        # The protection mode of web tamper proofing. Valid values:
        # 
        # *   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
        # *   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified sub-directories, file types, and files in the protected directories.
        self.mode = mode  # type: str
        # The UUID of the server that has web tamper proofing enabled.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockConfigListResponseBodyConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockConfigListResponseBody(TeaModel):
    def __init__(self, config_list=None, request_id=None, total_count=None):
        # An array that consists of the configurations of web tamper proofing.
        self.config_list = config_list  # type: list[DescribeWebLockConfigListResponseBodyConfigList]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of directories that have web tamper proofing enabled on the specified server.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockConfigListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeWebLockConfigListResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockConfigListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockConfigListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockConfigListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockConfigListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockExclusiveFileTypeResponseBody(TeaModel):
    def __init__(self, exclusive_file_type=None, request_id=None, total_count=None):
        self.exclusive_file_type = exclusive_file_type  # type: list[str]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockExclusiveFileTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockExclusiveFileTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockExclusiveFileTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockExclusiveFileTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockExclusiveFileTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileChangeStatisticsRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockFileChangeStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeWebLockFileChangeStatisticsResponseBodyList(TeaModel):
    def __init__(self, count=None, file=None):
        self.count = count  # type: int
        self.file = file  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockFileChangeStatisticsResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            self.file = m.get('File')
        return self


class DescribeWebLockFileChangeStatisticsResponseBody(TeaModel):
    def __init__(self, current_page=None, list=None, page_size=None, request_id=None, total_count=None):
        self.current_page = current_page  # type: int
        self.list = list  # type: list[DescribeWebLockFileChangeStatisticsResponseBodyList]
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileChangeStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileChangeStatisticsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileChangeStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockFileChangeStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileChangeStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileChangeStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileEventsRequest(TeaModel):
    def __init__(self, current_page=None, dealed=None, page_size=None, process_name=None, remark=None, ts_begin=None,
                 ts_end=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # Specifies whether the event on web tamper proofing is handled. Valid values:
        # 
        # *   **n**: no
        # *   **y**: yes
        self.dealed = dealed  # type: str
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size  # type: int
        # The name of the process.
        self.process_name = process_name  # type: str
        # The name of the asset.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the names of assets.
        self.remark = remark  # type: str
        # The beginning of the time range to query. The value is a UNIX timestamp.
        self.ts_begin = ts_begin  # type: long
        # The end of the time range to query. The value is a UNIX timestamp.
        self.ts_end = ts_end  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockFileEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.ts_begin is not None:
            result['TsBegin'] = self.ts_begin
        if self.ts_end is not None:
            result['TsEnd'] = self.ts_end
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TsBegin') is not None:
            self.ts_begin = m.get('TsBegin')
        if m.get('TsEnd') is not None:
            self.ts_end = m.get('TsEnd')
        return self


class DescribeWebLockFileEventsResponseBodyList(TeaModel):
    def __init__(self, count=None, ds=None, event_name=None, event_status=None, event_type=None, gmt_event=None,
                 id=None, instance_name=None, internet_ip=None, intranet_ip=None, ip=None, level=None, path=None,
                 process_name=None, process_path=None, status=None, uuid=None):
        # The number of attempts.
        self.count = count  # type: long
        # The timestamp at which the event on web tamper proofing was first detected.
        self.ds = ds  # type: long
        # The name of the event on web tamper proofing.
        self.event_name = event_name  # type: str
        # The status of the event on web tamper proofing. Valid values:
        # 
        # *   **1**: unhandled
        # *   **2**: ignored
        # *   **4**: deprecated
        # *   **8**: marked as false positive
        # *   **10**: added to the whitelist
        # *   **16**: being handled
        # *   **32**: defended
        # *   **64**: invalid
        # *   **128**: deleted
        # *   **512**: automatically handled
        self.event_status = event_status  # type: str
        # The prevention mode. Valid values:
        # 
        # *   **audit**: Interception Mode
        # *   **web_lock**: Alert Mode
        self.event_type = event_type  # type: str
        # The timestamp at which the event on web tamper proofing was last detected.
        self.gmt_event = gmt_event  # type: long
        # The ID of the event on web tamper proofing.
        self.id = id  # type: long
        # The name of the asset.
        self.instance_name = instance_name  # type: str
        # The public IP address of the affected asset.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the asset.
        self.intranet_ip = intranet_ip  # type: str
        # The IP address of the asset.
        self.ip = ip  # type: str
        # The severity of the event on web tamper proofing. Valid values: **medium**.
        self.level = level  # type: str
        # The file path.
        self.path = path  # type: str
        # The name of the process.
        self.process_name = process_name  # type: str
        # The path of the process.
        self.process_path = process_path  # type: str
        # The status of the event on web tamper proofing. Valid values:
        # 
        # *   **1**: unhandled
        # *   **2**: ignored
        # *   **4**: deprecated
        # *   **8**: marked as false positive
        # *   **10**: added to the whitelist
        # *   **16**: being handled
        # *   **32**: defended
        # *   **64**: invalid
        # *   **128**: deleted
        # *   **512**: automatically handled
        self.status = status  # type: str
        # The UUID of the asset.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockFileEventsResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.ds is not None:
            result['Ds'] = self.ds
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.gmt_event is not None:
            result['GmtEvent'] = self.gmt_event
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.level is not None:
            result['Level'] = self.level
        if self.path is not None:
            result['Path'] = self.path
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Ds') is not None:
            self.ds = m.get('Ds')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GmtEvent') is not None:
            self.gmt_event = m.get('GmtEvent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockFileEventsResponseBody(TeaModel):
    def __init__(self, current_page=None, list=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of events on web tamper proofing returned.
        self.list = list  # type: list[DescribeWebLockFileEventsResponseBodyList]
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of events on web tamper proofing returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileEventsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockFileEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockFileTypeSummaryResponseBodyList(TeaModel):
    def __init__(self, count=None, type=None):
        self.count = count  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockFileTypeSummaryResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeWebLockFileTypeSummaryResponseBody(TeaModel):
    def __init__(self, list=None, request_id=None, total_count=None):
        self.list = list  # type: list[DescribeWebLockFileTypeSummaryResponseBodyList]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileTypeSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockFileTypeSummaryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockFileTypeSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockFileTypeSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockFileTypeSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockFileTypeSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockInclusiveFileTypeResponseBody(TeaModel):
    def __init__(self, inclusive_file_type=None, request_id=None, total_count=None):
        self.inclusive_file_type = inclusive_file_type  # type: list[str]
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockInclusiveFileTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockInclusiveFileTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockInclusiveFileTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockInclusiveFileTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockInclusiveFileTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockProcessBlockStatisticsRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockProcessBlockStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeWebLockProcessBlockStatisticsResponseBodyList(TeaModel):
    def __init__(self, count=None, process=None):
        self.count = count  # type: int
        self.process = process  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockProcessBlockStatisticsResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.process is not None:
            result['Process'] = self.process
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Process') is not None:
            self.process = m.get('Process')
        return self


class DescribeWebLockProcessBlockStatisticsResponseBody(TeaModel):
    def __init__(self, current_page=None, list=None, page_size=None, request_id=None, total_count=None):
        self.current_page = current_page  # type: int
        self.list = list  # type: list[DescribeWebLockProcessBlockStatisticsResponseBodyList]
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockProcessBlockStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockProcessBlockStatisticsResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockProcessBlockStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockProcessBlockStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockProcessBlockStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockProcessBlockStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockProcessListRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, process_name=None, status=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.process_name = process_name  # type: str
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockProcessListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeWebLockProcessListResponseBodyList(TeaModel):
    def __init__(self, count=None, instance_name=None, internet_ip=None, intranet_ip=None, process_name=None,
                 process_path=None, status=None, uuid=None):
        self.count = count  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.process_name = process_name  # type: str
        self.process_path = process_path  # type: str
        self.status = status  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockProcessListResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeWebLockProcessListResponseBody(TeaModel):
    def __init__(self, current_page=None, list=None, page_size=None, request_id=None, total_count=None):
        self.current_page = current_page  # type: int
        self.list = list  # type: list[DescribeWebLockProcessListResponseBodyList]
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebLockProcessListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeWebLockProcessListResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockProcessListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockProcessListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockProcessListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockProcessListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockStatusRequest(TeaModel):
    def __init__(self, from_=None, lang=None, source_ip=None):
        self.from_ = from_  # type: str
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class DescribeWebLockStatusResponseBody(TeaModel):
    def __init__(self, auth_count=None, bind_count=None, block_count=None, dir_count=None, expire_time=None,
                 request_id=None, white_count=None):
        self.auth_count = auth_count  # type: int
        self.bind_count = bind_count  # type: int
        self.block_count = block_count  # type: int
        self.dir_count = dir_count  # type: int
        self.expire_time = expire_time  # type: long
        self.request_id = request_id  # type: str
        self.white_count = white_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_count is not None:
            result['AuthCount'] = self.auth_count
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.block_count is not None:
            result['BlockCount'] = self.block_count
        if self.dir_count is not None:
            result['DirCount'] = self.dir_count
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.white_count is not None:
            result['WhiteCount'] = self.white_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthCount') is not None:
            self.auth_count = m.get('AuthCount')
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('BlockCount') is not None:
            self.block_count = m.get('BlockCount')
        if m.get('DirCount') is not None:
            self.dir_count = m.get('DirCount')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WhiteCount') is not None:
            self.white_count = m.get('WhiteCount')
        return self


class DescribeWebLockStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebLockTotalFileChangeCountResponseBody(TeaModel):
    def __init__(self, request_id=None, total_count=None):
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebLockTotalFileChangeCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebLockTotalFileChangeCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebLockTotalFileChangeCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebLockTotalFileChangeCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebLockTotalFileChangeCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebPathRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, type=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebPathRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeWebPathResponseBodyConfigListTargetList(TeaModel):
    def __init__(self, target=None, target_type=None):
        self.target = target  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeWebPathResponseBodyConfigListTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target is not None:
            result['Target'] = self.target
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class DescribeWebPathResponseBodyConfigList(TeaModel):
    def __init__(self, target_list=None, web_path=None, web_path_type=None):
        self.target_list = target_list  # type: list[DescribeWebPathResponseBodyConfigListTargetList]
        self.web_path = web_path  # type: str
        self.web_path_type = web_path_type  # type: str

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebPathResponseBodyConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        if self.web_path_type is not None:
            result['WebPathType'] = self.web_path_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = DescribeWebPathResponseBodyConfigListTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        if m.get('WebPathType') is not None:
            self.web_path_type = m.get('WebPathType')
        return self


class DescribeWebPathResponseBody(TeaModel):
    def __init__(self, config_list=None, count=None, current_page=None, page_size=None, request_id=None,
                 total_count=None):
        self.config_list = config_list  # type: list[DescribeWebPathResponseBodyConfigList]
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeWebPathResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = DescribeWebPathResponseBodyConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeWebPathResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeWebPathResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeWebPathResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableBruteForceRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, id=None, port=None, resource_owner_id=None, uuid=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.id = id  # type: long
        self.port = port  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableBruteForceRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DisableBruteForceRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableBruteForceRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableBruteForceRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableBruteForceRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableBruteForceRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableBruteForceRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableCustomBlockRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, resource_owner_id=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableCustomBlockRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DisableCustomBlockRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableCustomBlockRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableCustomBlockRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableCustomBlockRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableCustomBlockRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableBruteForceRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, id=None, port=None, resource_owner_id=None, uuid=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.id = id  # type: long
        self.port = port  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableBruteForceRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.id is not None:
            result['Id'] = self.id
        if self.port is not None:
            result['Port'] = self.port
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class EnableBruteForceRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableBruteForceRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableBruteForceRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableBruteForceRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableBruteForceRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableBruteForceRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableCustomBlockRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, resource_owner_id=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableCustomBlockRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class EnableCustomBlockRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableCustomBlockRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableCustomBlockRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableCustomBlockRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableCustomBlockRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecStrategyRequest(TeaModel):
    def __init__(self, lang=None, strategy_id=None):
        self.lang = lang  # type: str
        self.strategy_id = strategy_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class ExecStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExecStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExecStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExecStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExecStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportRecordRequest(TeaModel):
    def __init__(self, export_type=None, lang=None, params=None):
        # The type of the check result list to export. Valid values:
        # 
        # *   **assetInstance**: the list of servers displayed on the Host page
        # *   **user**: the list of fingerprints for accounts
        # *   **port**: the list of fingerprints for ports
        # *   **process**: the list of fingerprints for processes
        # *   **sca**: the list of fingerprints for middleware assets
        # *   **database**: the list of fingerprints for databases
        # *   **web**: the list of fingerprints for web services
        # *   **software**: the list of fingerprints for software assets
        # *   **cron**: the list of fingerprints for scheduled tasks
        # *   **autorun**: the list of fingerprints for startup items
        # *   **lkm**: the list of fingerprints for kernel modules
        # *   **webserver**: the list of fingerprints for websites
        # *   **imageVulExport**: the list of image system vulnerabilities
        # *   **imageBaseLineExport**: the list of baseline check results for images
        # *   **imageAffectedMaliciousExport**: the list of check results for malicious image samples
        # *   **baseline**: the list of check results for configuration assessment
        # *   **attack**: the list of alerts for attack analysis
        # *   **accessKey**: the list of alerts that are generated for AccessKey pair leaks
        self.export_type = export_type  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The conditions that are used to filter check results.
        # 
        # >  This operation is a common export operation for multiple features of Security Center. The available configuration fields of this parameter vary based on the features. We recommend that you do not specify this parameter when you call the operation. You can export an information list without specifying this parameter, and then filter data in the exported Excel file.
        self.params = params  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.params is not None:
            result['Params'] = self.params
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        return self


class ExportRecordResponseBody(TeaModel):
    def __init__(self, file_name=None, id=None, request_id=None):
        # The name of the exported file.
        self.file_name = file_name  # type: str
        # The ID of the exported file.
        self.id = id  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportSuspEventsRequest(TeaModel):
    def __init__(self, assets_type_list=None, cluster_id=None, container_field_name=None,
                 container_field_value=None, current_page=None, dealed=None, from_=None, lang=None, levels=None, name=None, page_size=None,
                 parent_event_types=None, remark=None, source_ip=None, status=None, target_type=None, time_end=None, time_start=None):
        self.assets_type_list = assets_type_list  # type: list[str]
        self.cluster_id = cluster_id  # type: str
        self.container_field_name = container_field_name  # type: str
        self.container_field_value = container_field_value  # type: str
        self.current_page = current_page  # type: str
        self.dealed = dealed  # type: str
        self.from_ = from_  # type: str
        self.lang = lang  # type: str
        self.levels = levels  # type: str
        self.name = name  # type: str
        self.page_size = page_size  # type: str
        self.parent_event_types = parent_event_types  # type: str
        self.remark = remark  # type: str
        self.source_ip = source_ip  # type: str
        self.status = status  # type: str
        self.target_type = target_type  # type: str
        self.time_end = time_end  # type: str
        self.time_start = time_start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportSuspEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assets_type_list is not None:
            result['AssetsTypeList'] = self.assets_type_list
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_event_types is not None:
            result['ParentEventTypes'] = self.parent_event_types
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.time_end is not None:
            result['TimeEnd'] = self.time_end
        if self.time_start is not None:
            result['TimeStart'] = self.time_start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetsTypeList') is not None:
            self.assets_type_list = m.get('AssetsTypeList')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentEventTypes') is not None:
            self.parent_event_types = m.get('ParentEventTypes')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TimeEnd') is not None:
            self.time_end = m.get('TimeEnd')
        if m.get('TimeStart') is not None:
            self.time_start = m.get('TimeStart')
        return self


class ExportSuspEventsResponseBody(TeaModel):
    def __init__(self, file_name=None, id=None, request_id=None):
        self.file_name = file_name  # type: str
        self.id = id  # type: int
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportSuspEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportSuspEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportSuspEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportSuspEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportVulRequest(TeaModel):
    def __init__(self, alias_name=None, attach_types=None, dealed=None, group_id=None, lang=None, necessity=None,
                 search_tags=None, type=None, uuids=None, vpc_instance_ids=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The additional type of the vulnerabilities. You can specify this parameter when you query application vulnerabilities. If you set Type to app, you must specify this parameter. If you set Type to a different value, this parameter is invalid. Set the value to **sca**.
        # 
        # >  If this parameter is set to **sca**, application vulnerabilities and the vulnerabilities that are detected based on software component analysis are queried. If you do not specify this parameter, only application vulnerabilities are queried.
        self.attach_types = attach_types  # type: str
        # Specifies whether the vulnerabilities are fixed. Valid values:
        # 
        # *   **y**: yes
        # *   **n**: no
        self.dealed = dealed  # type: str
        # The server group ID of the server on which the vulnerabilities are detected.
        # 
        # >  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.
        self.group_id = group_id  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The priority to fix the vulnerabilities. Separate multiple priorities with commas (,). Valid values:
        # 
        # *   **asap**: high
        # *   **later**: medium
        # *   **nntf**: low
        self.necessity = necessity  # type: str
        # The tag that is used to search for the vulnerabilities. Valid values:
        # 
        # *   Restart required
        # *   Remote exploitation
        # *   Exploit exists
        # *   Exploitable
        # *   Privilege escalation
        # *   Code execution
        self.search_tags = search_tags  # type: str
        # The type of the vulnerabilities that you want to export. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **app**: application vulnerability
        # *   **emg**: urgent vulnerability
        self.type = type  # type: str
        # The UUID of the server on which the vulnerabilities are detected. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str
        # The ID of the virtual private cloud (VPC) in which the vulnerabilities are detected. Separate multiple IDs with commas (,).
        # 
        # >  You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the IDs of VPCs.
        self.vpc_instance_ids = vpc_instance_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.attach_types is not None:
            result['AttachTypes'] = self.attach_types
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.search_tags is not None:
            result['SearchTags'] = self.search_tags
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vpc_instance_ids is not None:
            result['VpcInstanceIds'] = self.vpc_instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AttachTypes') is not None:
            self.attach_types = m.get('AttachTypes')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('SearchTags') is not None:
            self.search_tags = m.get('SearchTags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VpcInstanceIds') is not None:
            self.vpc_instance_ids = m.get('VpcInstanceIds')
        return self


class ExportVulResponseBody(TeaModel):
    def __init__(self, file_name=None, id=None, request_id=None):
        # The name of the exported file.
        self.file_name = file_name  # type: str
        # The ID of the exported file.
        self.id = id  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportWarningRequest(TeaModel):
    def __init__(self, dealed=None, export_type=None, is_cleartext_pwd=None, is_summary_export=None, lang=None,
                 risk_ids=None, risk_levels=None, risk_name=None, source_ip=None, status_list=None, strategy_id=None,
                 sub_type_names=None, type_name=None, type_names=None, uuids=None):
        # Specifies whether the baseline risks are handled. Valid values:
        # 
        # *   **Y**: yes
        # *   **N**: no
        self.dealed = dealed  # type: str
        # The type of the export task. Set the value to **hc_check_warning**, which indicates tasks to export baseline check results.
        self.export_type = export_type  # type: str
        # The export method of the results for the weak password baseline check. Valid values:
        # 
        # *   **0**: exports the check results after it is masked.
        # *   **1**: exports the check results in plaintext.
        self.is_cleartext_pwd = is_cleartext_pwd  # type: int
        # Specifies whether the baseline check results are aggregated and exported. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        self.is_summary_export = is_summary_export  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The ID of the risk item in the baseline check results. Separate multiple IDs with commas (,).
        self.risk_ids = risk_ids  # type: str
        # The severity of the baseline check item. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **high**\
        # *   **medium**\
        # *   **low**\
        self.risk_levels = risk_levels  # type: str
        # The name of the baseline.
        self.risk_name = risk_name  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The status of the check item in the baseline check results. Separate multiple statuses with commas (,). Valid values:
        # 
        # *   **3**: passed
        # *   **1**: failed
        self.status_list = status_list  # type: str
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id  # type: long
        # The subtypes of the baselines based on which baseline checks are performed. Separate multiple subtypes with commas (,).
        # 
        # >  You must set the value of this parameter to the value of the **TypeName** parameter that is contained in the **SubTypes** parameter. You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to obtain the value of the TypeName parameter.
        self.sub_type_names = sub_type_names  # type: str
        # The type of the baseline based on which baseline checks are performed.
        # 
        # >  You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.
        self.type_name = type_name  # type: str
        # The types of the baselines based on which baseline checks are performed. Separate multiple types with commas (,).
        # 
        # >  You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.
        self.type_names = type_names  # type: str
        # The UUID of the server whose baseline check results you want to export. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportWarningRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.is_cleartext_pwd is not None:
            result['IsCleartextPwd'] = self.is_cleartext_pwd
        if self.is_summary_export is not None:
            result['IsSummaryExport'] = self.is_summary_export
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_ids is not None:
            result['RiskIds'] = self.risk_ids
        if self.risk_levels is not None:
            result['RiskLevels'] = self.risk_levels
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.sub_type_names is not None:
            result['SubTypeNames'] = self.sub_type_names
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        if self.type_names is not None:
            result['TypeNames'] = self.type_names
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('IsCleartextPwd') is not None:
            self.is_cleartext_pwd = m.get('IsCleartextPwd')
        if m.get('IsSummaryExport') is not None:
            self.is_summary_export = m.get('IsSummaryExport')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskIds') is not None:
            self.risk_ids = m.get('RiskIds')
        if m.get('RiskLevels') is not None:
            self.risk_levels = m.get('RiskLevels')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('SubTypeNames') is not None:
            self.sub_type_names = m.get('SubTypeNames')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        if m.get('TypeNames') is not None:
            self.type_names = m.get('TypeNames')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ExportWarningResponseBody(TeaModel):
    def __init__(self, file_name=None, id=None, request_id=None):
        # The name of the file that contains exported baseline check results.
        self.file_name = file_name  # type: str
        # The ID of the task to export baseline check results.
        self.id = id  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportWarningResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportWarningResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportWarningResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportWarningResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportWarningResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FindContainerNetworkConnectRequestDstNode(TeaModel):
    def __init__(self, app_name=None, cluster_id=None, namespace=None, node_ids=None, node_type=None, pod_name=None):
        self.app_name = app_name  # type: str
        self.cluster_id = cluster_id  # type: str
        self.namespace = namespace  # type: str
        self.node_ids = node_ids  # type: list[str]
        self.node_type = node_type  # type: str
        self.pod_name = pod_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectRequestDstNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class FindContainerNetworkConnectRequestSrcNode(TeaModel):
    def __init__(self, app_name=None, cluster_id=None, namespace=None, node_ids=None, node_type=None, pod_name=None):
        self.app_name = app_name  # type: str
        self.cluster_id = cluster_id  # type: str
        self.namespace = namespace  # type: str
        self.node_ids = node_ids  # type: list[str]
        self.node_type = node_type  # type: str
        self.pod_name = pod_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectRequestSrcNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class FindContainerNetworkConnectRequest(TeaModel):
    def __init__(self, criteria_type=None, current_page=None, dst_node=None, end_time=None, page_size=None,
                 src_node=None, start_time=None):
        self.criteria_type = criteria_type  # type: str
        self.current_page = current_page  # type: long
        self.dst_node = dst_node  # type: FindContainerNetworkConnectRequestDstNode
        self.end_time = end_time  # type: long
        self.page_size = page_size  # type: long
        self.src_node = src_node  # type: FindContainerNetworkConnectRequestSrcNode
        self.start_time = start_time  # type: long

    def validate(self):
        if self.dst_node:
            self.dst_node.validate()
        if self.src_node:
            self.src_node.validate()

    def to_map(self):
        _map = super(FindContainerNetworkConnectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dst_node is not None:
            result['DstNode'] = self.dst_node.to_map()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.src_node is not None:
            result['SrcNode'] = self.src_node.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DstNode') is not None:
            temp_model = FindContainerNetworkConnectRequestDstNode()
            self.dst_node = temp_model.from_map(m['DstNode'])
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SrcNode') is not None:
            temp_model = FindContainerNetworkConnectRequestSrcNode()
            self.src_node = temp_model.from_map(m['SrcNode'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class FindContainerNetworkConnectShrinkRequest(TeaModel):
    def __init__(self, criteria_type=None, current_page=None, dst_node_shrink=None, end_time=None, page_size=None,
                 src_node_shrink=None, start_time=None):
        self.criteria_type = criteria_type  # type: str
        self.current_page = current_page  # type: long
        self.dst_node_shrink = dst_node_shrink  # type: str
        self.end_time = end_time  # type: long
        self.page_size = page_size  # type: long
        self.src_node_shrink = src_node_shrink  # type: str
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dst_node_shrink is not None:
            result['DstNode'] = self.dst_node_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.src_node_shrink is not None:
            result['SrcNode'] = self.src_node_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DstNode') is not None:
            self.dst_node_shrink = m.get('DstNode')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SrcNode') is not None:
            self.src_node_shrink = m.get('SrcNode')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class FindContainerNetworkConnectResponseBodyConnectsDstContainer(TeaModel):
    def __init__(self, container_id=None):
        self.container_id = container_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponseBodyConnectsDstContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        return self


class FindContainerNetworkConnectResponseBodyConnectsSrcContainer(TeaModel):
    def __init__(self, container_id=None):
        self.container_id = container_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponseBodyConnectsSrcContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        return self


class FindContainerNetworkConnectResponseBodyConnects(TeaModel):
    def __init__(self, dst_container=None, dst_ip=None, dst_port=None, first_time=None, id=None, last_time=None,
                 src_container=None, src_ip=None, src_port=None):
        self.dst_container = dst_container  # type: FindContainerNetworkConnectResponseBodyConnectsDstContainer
        self.dst_ip = dst_ip  # type: str
        self.dst_port = dst_port  # type: str
        self.first_time = first_time  # type: long
        self.id = id  # type: long
        self.last_time = last_time  # type: long
        self.src_container = src_container  # type: FindContainerNetworkConnectResponseBodyConnectsSrcContainer
        self.src_ip = src_ip  # type: str
        self.src_port = src_port  # type: str

    def validate(self):
        if self.dst_container:
            self.dst_container.validate()
        if self.src_container:
            self.src_container.validate()

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponseBodyConnects, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_container is not None:
            result['DstContainer'] = self.dst_container.to_map()
        if self.dst_ip is not None:
            result['DstIp'] = self.dst_ip
        if self.dst_port is not None:
            result['DstPort'] = self.dst_port
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.id is not None:
            result['Id'] = self.id
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.src_container is not None:
            result['SrcContainer'] = self.src_container.to_map()
        if self.src_ip is not None:
            result['SrcIp'] = self.src_ip
        if self.src_port is not None:
            result['SrcPort'] = self.src_port
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DstContainer') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyConnectsDstContainer()
            self.dst_container = temp_model.from_map(m['DstContainer'])
        if m.get('DstIp') is not None:
            self.dst_ip = m.get('DstIp')
        if m.get('DstPort') is not None:
            self.dst_port = m.get('DstPort')
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('SrcContainer') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyConnectsSrcContainer()
            self.src_container = temp_model.from_map(m['SrcContainer'])
        if m.get('SrcIp') is not None:
            self.src_ip = m.get('SrcIp')
        if m.get('SrcPort') is not None:
            self.src_port = m.get('SrcPort')
        return self


class FindContainerNetworkConnectResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: long
        self.current_page = current_page  # type: long
        self.page_size = page_size  # type: long
        self.total_count = total_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class FindContainerNetworkConnectResponseBody(TeaModel):
    def __init__(self, connects=None, page_info=None, request_id=None):
        self.connects = connects  # type: list[FindContainerNetworkConnectResponseBodyConnects]
        self.page_info = page_info  # type: FindContainerNetworkConnectResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.connects:
            for k in self.connects:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Connects'] = []
        if self.connects is not None:
            for k in self.connects:
                result['Connects'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.connects = []
        if m.get('Connects') is not None:
            for k in m.get('Connects'):
                temp_model = FindContainerNetworkConnectResponseBodyConnects()
                self.connects.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = FindContainerNetworkConnectResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class FindContainerNetworkConnectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: FindContainerNetworkConnectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(FindContainerNetworkConnectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FindContainerNetworkConnectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FixCheckWarningsRequest(TeaModel):
    def __init__(self, check_params=None, lang=None, risk_id=None, source_ip=None, uuids=None):
        # The parameters for the baseline risk item that you want to fix.
        # 
        # *   **checkId**: the ID of the check item that corresponds to the baseline risk item.
        # 
        # *   **rules**: an array that consists of the rules applied to fixes.
        # 
        #     *   **value**: specifies whether a fix method is selected. Valid values: **0** and **1**. The value 0 indicates that no fix method is selected and the value 1 indicates that a fix method is selected.
        #     *   **ruleId**: the ID of the fix method.
        #     *   **paramList**: an array that consists of the details about the fix method.\
        #         • **paramName**: the name of the fix method.\
        #         • **value**: the value of the fix method.
        self.check_params = check_params  # type: str
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The ID of the baseline risk item.
        # 
        # >  To query specified baseline risk items and the check items of a specified server, you must provide the IDs of the baseline risk items. You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs.
        self.risk_id = risk_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the asset for which you want to fix the baseline risk item. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the UUIDs of assets.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FixCheckWarningsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_params is not None:
            result['CheckParams'] = self.check_params
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckParams') is not None:
            self.check_params = m.get('CheckParams')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class FixCheckWarningsResponseBody(TeaModel):
    def __init__(self, batch_id=None, request_id=None):
        # The ID of the baseline risk item that has been fixed by using the Batch Repair feature.
        self.batch_id = batch_id  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FixCheckWarningsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_id is not None:
            result['BatchId'] = self.batch_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BatchId') is not None:
            self.batch_id = m.get('BatchId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class FixCheckWarningsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: FixCheckWarningsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(FixCheckWarningsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FixCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateOnceTaskRequest(TeaModel):
    def __init__(self, param=None, source=None, task_name=None, task_type=None):
        self.param = param  # type: str
        self.source = source  # type: str
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GenerateOnceTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.param is not None:
            result['Param'] = self.param
        if self.source is not None:
            result['Source'] = self.source
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GenerateOnceTaskResponseBody(TeaModel):
    def __init__(self, can_create=None, collect_time=None, finish_count=None, last_task=None, request_id=None,
                 task_id=None, total_count=None):
        self.can_create = can_create  # type: bool
        self.collect_time = collect_time  # type: long
        self.finish_count = finish_count  # type: int
        self.last_task = last_task  # type: str
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GenerateOnceTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.last_task is not None:
            result['LastTask'] = self.last_task
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('LastTask') is not None:
            self.last_task = m.get('LastTask')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GenerateOnceTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GenerateOnceTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GenerateOnceTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateOnceTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlarmMachineCountRequest(TeaModel):
    def __init__(self, from_=None):
        self.from_ = from_  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAlarmMachineCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class GetAlarmMachineCountResponseBodyData(TeaModel):
    def __init__(self, machine_count=None):
        self.machine_count = machine_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAlarmMachineCountResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_count is not None:
            result['MachineCount'] = self.machine_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineCount') is not None:
            self.machine_count = m.get('MachineCount')
        return self


class GetAlarmMachineCountResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: GetAlarmMachineCountResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetAlarmMachineCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetAlarmMachineCountResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAlarmMachineCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAlarmMachineCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAlarmMachineCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlarmMachineCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssetsPropertyDetailRequestSearchCriteriaList(TeaModel):
    def __init__(self, name=None, value=None):
        self.name = name  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyDetailRequestSearchCriteriaList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAssetsPropertyDetailRequest(TeaModel):
    def __init__(self, biz=None, current_page=None, item_name=None, lang=None, page_size=None, remark=None,
                 search_criteria_list=None, uuid=None):
        self.biz = biz  # type: str
        self.current_page = current_page  # type: int
        self.item_name = item_name  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.remark = remark  # type: str
        self.search_criteria_list = search_criteria_list  # type: list[GetAssetsPropertyDetailRequestSearchCriteriaList]
        self.uuid = uuid  # type: str

    def validate(self):
        if self.search_criteria_list:
            for k in self.search_criteria_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetAssetsPropertyDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        result['SearchCriteriaList'] = []
        if self.search_criteria_list is not None:
            for k in self.search_criteria_list:
                result['SearchCriteriaList'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        self.search_criteria_list = []
        if m.get('SearchCriteriaList') is not None:
            for k in m.get('SearchCriteriaList'):
                temp_model = GetAssetsPropertyDetailRequestSearchCriteriaList()
                self.search_criteria_list.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetAssetsPropertyDetailResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyDetailResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetAssetsPropertyDetailResponseBodyPropertys(TeaModel):
    def __init__(self, container_name=None, create_timestamp=None, domain=None, filepath=None, image_name=None,
                 instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None, ip=None, listen_protocol=None,
                 module_name=None, path=None, path_mode=None, pid=None, port=None, process_started=None, region_id=None,
                 server_type=None, size=None, used_by_count=None, user=None, uuid=None, web_path=None):
        self.container_name = container_name  # type: str
        self.create_timestamp = create_timestamp  # type: long
        self.domain = domain  # type: str
        self.filepath = filepath  # type: str
        self.image_name = image_name  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.ip = ip  # type: str
        self.listen_protocol = listen_protocol  # type: str
        self.module_name = module_name  # type: str
        self.path = path  # type: str
        self.path_mode = path_mode  # type: str
        self.pid = pid  # type: str
        self.port = port  # type: str
        self.process_started = process_started  # type: long
        self.region_id = region_id  # type: str
        self.server_type = server_type  # type: str
        self.size = size  # type: int
        self.used_by_count = used_by_count  # type: int
        self.user = user  # type: str
        self.uuid = uuid  # type: str
        self.web_path = web_path  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyDetailResponseBodyPropertys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.filepath is not None:
            result['Filepath'] = self.filepath
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.listen_protocol is not None:
            result['ListenProtocol'] = self.listen_protocol
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.path is not None:
            result['Path'] = self.path
        if self.path_mode is not None:
            result['PathMode'] = self.path_mode
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.port is not None:
            result['Port'] = self.port
        if self.process_started is not None:
            result['ProcessStarted'] = self.process_started
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.server_type is not None:
            result['ServerType'] = self.server_type
        if self.size is not None:
            result['Size'] = self.size
        if self.used_by_count is not None:
            result['UsedByCount'] = self.used_by_count
        if self.user is not None:
            result['User'] = self.user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Filepath') is not None:
            self.filepath = m.get('Filepath')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('ListenProtocol') is not None:
            self.listen_protocol = m.get('ListenProtocol')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('PathMode') is not None:
            self.path_mode = m.get('PathMode')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ProcessStarted') is not None:
            self.process_started = m.get('ProcessStarted')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServerType') is not None:
            self.server_type = m.get('ServerType')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('UsedByCount') is not None:
            self.used_by_count = m.get('UsedByCount')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class GetAssetsPropertyDetailResponseBody(TeaModel):
    def __init__(self, page_info=None, propertys=None, request_id=None):
        self.page_info = page_info  # type: GetAssetsPropertyDetailResponseBodyPageInfo
        self.propertys = propertys  # type: list[GetAssetsPropertyDetailResponseBodyPropertys]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetAssetsPropertyDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['Propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['Propertys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = GetAssetsPropertyDetailResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.propertys = []
        if m.get('Propertys') is not None:
            for k in m.get('Propertys'):
                temp_model = GetAssetsPropertyDetailResponseBodyPropertys()
                self.propertys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAssetsPropertyDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAssetsPropertyDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAssetsPropertyDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssetsPropertyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAssetsPropertyItemRequest(TeaModel):
    def __init__(self, biz=None, current_page=None, force_flush=None, lang=None, page_size=None, search_info=None,
                 search_item=None):
        self.biz = biz  # type: str
        self.current_page = current_page  # type: int
        self.force_flush = force_flush  # type: bool
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.search_info = search_info  # type: str
        self.search_item = search_item  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyItemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.force_flush is not None:
            result['ForceFlush'] = self.force_flush
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_info is not None:
            result['SearchInfo'] = self.search_info
        if self.search_item is not None:
            result['SearchItem'] = self.search_item
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ForceFlush') is not None:
            self.force_flush = m.get('ForceFlush')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchInfo') is not None:
            self.search_info = m.get('SearchInfo')
        if m.get('SearchItem') is not None:
            self.search_item = m.get('SearchItem')
        return self


class GetAssetsPropertyItemResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyItemResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetAssetsPropertyItemResponseBodyPropertyItems(TeaModel):
    def __init__(self, count=None, domain=None, module_name=None, path=None):
        self.count = count  # type: int
        self.domain = domain  # type: str
        self.module_name = module_name  # type: str
        self.path = path  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAssetsPropertyItemResponseBodyPropertyItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class GetAssetsPropertyItemResponseBody(TeaModel):
    def __init__(self, page_info=None, property_items=None, request_id=None):
        self.page_info = page_info  # type: GetAssetsPropertyItemResponseBodyPageInfo
        self.property_items = property_items  # type: list[GetAssetsPropertyItemResponseBodyPropertyItems]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.property_items:
            for k in self.property_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetAssetsPropertyItemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        result['PropertyItems'] = []
        if self.property_items is not None:
            for k in self.property_items:
                result['PropertyItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = GetAssetsPropertyItemResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        self.property_items = []
        if m.get('PropertyItems') is not None:
            for k in m.get('PropertyItems'):
                temp_model = GetAssetsPropertyItemResponseBodyPropertyItems()
                self.property_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAssetsPropertyItemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAssetsPropertyItemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAssetsPropertyItemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAssetsPropertyItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBackupStorageCountResponseBodyBackupStorageCount(TeaModel):
    def __init__(self, buy_storage_byte=None, ecs_usage_storage_byte=None, overflow=None,
                 uni_usage_storage_byte=None, usage_storage_byte=None):
        self.buy_storage_byte = buy_storage_byte  # type: long
        self.ecs_usage_storage_byte = ecs_usage_storage_byte  # type: long
        self.overflow = overflow  # type: int
        self.uni_usage_storage_byte = uni_usage_storage_byte  # type: long
        self.usage_storage_byte = usage_storage_byte  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetBackupStorageCountResponseBodyBackupStorageCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buy_storage_byte is not None:
            result['BuyStorageByte'] = self.buy_storage_byte
        if self.ecs_usage_storage_byte is not None:
            result['EcsUsageStorageByte'] = self.ecs_usage_storage_byte
        if self.overflow is not None:
            result['Overflow'] = self.overflow
        if self.uni_usage_storage_byte is not None:
            result['UniUsageStorageByte'] = self.uni_usage_storage_byte
        if self.usage_storage_byte is not None:
            result['UsageStorageByte'] = self.usage_storage_byte
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuyStorageByte') is not None:
            self.buy_storage_byte = m.get('BuyStorageByte')
        if m.get('EcsUsageStorageByte') is not None:
            self.ecs_usage_storage_byte = m.get('EcsUsageStorageByte')
        if m.get('Overflow') is not None:
            self.overflow = m.get('Overflow')
        if m.get('UniUsageStorageByte') is not None:
            self.uni_usage_storage_byte = m.get('UniUsageStorageByte')
        if m.get('UsageStorageByte') is not None:
            self.usage_storage_byte = m.get('UsageStorageByte')
        return self


class GetBackupStorageCountResponseBody(TeaModel):
    def __init__(self, backup_storage_count=None, request_id=None):
        self.backup_storage_count = backup_storage_count  # type: GetBackupStorageCountResponseBodyBackupStorageCount
        self.request_id = request_id  # type: str

    def validate(self):
        if self.backup_storage_count:
            self.backup_storage_count.validate()

    def to_map(self):
        _map = super(GetBackupStorageCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backup_storage_count is not None:
            result['BackupStorageCount'] = self.backup_storage_count.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BackupStorageCount') is not None:
            temp_model = GetBackupStorageCountResponseBodyBackupStorageCount()
            self.backup_storage_count = temp_model.from_map(m['BackupStorageCount'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetBackupStorageCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetBackupStorageCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetBackupStorageCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBackupStorageCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckConfigRequest(TeaModel):
    def __init__(self, lang=None):
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class GetCheckConfigResponseBodyStandards(TeaModel):
    def __init__(self, id=None, show_name=None, status=None, type=None):
        self.id = id  # type: long
        self.show_name = show_name  # type: str
        self.status = status  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckConfigResponseBodyStandards, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCheckConfigResponseBody(TeaModel):
    def __init__(self, cycle_days=None, end_time=None, request_id=None, standards=None, start_time=None):
        self.cycle_days = cycle_days  # type: list[int]
        self.end_time = end_time  # type: int
        self.request_id = request_id  # type: str
        self.standards = standards  # type: list[GetCheckConfigResponseBodyStandards]
        self.start_time = start_time  # type: int

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCheckConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = GetCheckConfigResponseBodyStandards()
                self.standards.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetCheckConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCheckConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCheckConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckDetailRequest(TeaModel):
    def __init__(self, check_id=None, lang=None):
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class GetCheckDetailResponseBodyAssistInfo(TeaModel):
    def __init__(self, link=None, type=None, value=None):
        # The link to the help information about the risk item when the Type parameter is set to link.
        self.link = link  # type: str
        # The type of the help information about the risk item. Valid values:
        # 
        # *   **text**\
        # *   **link**\
        self.type = type  # type: str
        # The content in the help information about the risk item when the Type parameter is set to text.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckDetailResponseBodyAssistInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBodyDescription(TeaModel):
    def __init__(self, link=None, type=None, value=None):
        # The link to the description of the check item.
        self.link = link  # type: str
        # The type of the description of the check item. The value is fixed as text.
        self.type = type  # type: str
        # The content in the description of the check item.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckDetailResponseBodyDescription, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBodySolution(TeaModel):
    def __init__(self, link=None, type=None, value=None):
        # The link to the solution to handle the risk item when the Type parameter is set to link.
        self.link = link  # type: str
        # The type of the solution to handle to the risk item. Valid values:
        # 
        # *   **text**\
        # *   **link**\
        self.type = type  # type: str
        # The content of the solution to handle the risk item when the Type parameter is set to text.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckDetailResponseBodySolution, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.link is not None:
            result['Link'] = self.link
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Link') is not None:
            self.link = m.get('Link')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetCheckDetailResponseBody(TeaModel):
    def __init__(self, assist_info=None, description=None, request_id=None, solution=None):
        # The help information about the check item.
        self.assist_info = assist_info  # type: GetCheckDetailResponseBodyAssistInfo
        # The description of the check item.
        self.description = description  # type: GetCheckDetailResponseBodyDescription
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The solution to handle the risk item.
        self.solution = solution  # type: GetCheckDetailResponseBodySolution

    def validate(self):
        if self.assist_info:
            self.assist_info.validate()
        if self.description:
            self.description.validate()
        if self.solution:
            self.solution.validate()

    def to_map(self):
        _map = super(GetCheckDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assist_info is not None:
            result['AssistInfo'] = self.assist_info.to_map()
        if self.description is not None:
            result['Description'] = self.description.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.solution is not None:
            result['Solution'] = self.solution.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssistInfo') is not None:
            temp_model = GetCheckDetailResponseBodyAssistInfo()
            self.assist_info = temp_model.from_map(m['AssistInfo'])
        if m.get('Description') is not None:
            temp_model = GetCheckDetailResponseBodyDescription()
            self.description = temp_model.from_map(m['Description'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Solution') is not None:
            temp_model = GetCheckDetailResponseBodySolution()
            self.solution = temp_model.from_map(m['Solution'])
        return self


class GetCheckDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCheckDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCheckDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckProcessRequest(TeaModel):
    def __init__(self, task_id=None):
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetCheckProcessResponseBody(TeaModel):
    def __init__(self, finish_count=None, request_id=None, total_count=None):
        self.finish_count = finish_count  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetCheckProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCheckProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCheckProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckRiskStatisticsRequest(TeaModel):
    def __init__(self, current_page=None, lang=None, page_size=None):
        self.current_page = current_page  # type: int
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckRiskStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class GetCheckRiskStatisticsResponseBodyDataSubStatistics(TeaModel):
    def __init__(self, alias=None, high_warning_count=None, low_warning_count=None, medium_warning_count=None,
                 pass_count=None, total_count=None, type_name=None):
        self.alias = alias  # type: str
        self.high_warning_count = high_warning_count  # type: int
        self.low_warning_count = low_warning_count  # type: int
        self.medium_warning_count = medium_warning_count  # type: int
        self.pass_count = pass_count  # type: int
        self.total_count = total_count  # type: int
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckRiskStatisticsResponseBodyDataSubStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetCheckRiskStatisticsResponseBodyData(TeaModel):
    def __init__(self, high_warning_count=None, low_warning_count=None, medium_warning_count=None, pass_count=None,
                 scene_name=None, sub_statistics=None, total_count=None):
        self.high_warning_count = high_warning_count  # type: int
        self.low_warning_count = low_warning_count  # type: int
        self.medium_warning_count = medium_warning_count  # type: int
        self.pass_count = pass_count  # type: int
        self.scene_name = scene_name  # type: str
        self.sub_statistics = sub_statistics  # type: list[GetCheckRiskStatisticsResponseBodyDataSubStatistics]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.sub_statistics:
            for k in self.sub_statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCheckRiskStatisticsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.scene_name is not None:
            result['SceneName'] = self.scene_name
        result['SubStatistics'] = []
        if self.sub_statistics is not None:
            for k in self.sub_statistics:
                result['SubStatistics'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('SceneName') is not None:
            self.scene_name = m.get('SceneName')
        self.sub_statistics = []
        if m.get('SubStatistics') is not None:
            for k in m.get('SubStatistics'):
                temp_model = GetCheckRiskStatisticsResponseBodyDataSubStatistics()
                self.sub_statistics.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetCheckRiskStatisticsResponseBody(TeaModel):
    def __init__(self, count=None, data=None, request_id=None):
        self.count = count  # type: int
        self.data = data  # type: list[GetCheckRiskStatisticsResponseBodyData]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCheckRiskStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetCheckRiskStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCheckRiskStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCheckRiskStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCheckRiskStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckRiskStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckSummaryRequest(TeaModel):
    def __init__(self, lang=None, resource_directory_account_id=None):
        self.lang = lang  # type: str
        self.resource_directory_account_id = resource_directory_account_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_directory_account_id is not None:
            result['ResourceDirectoryAccountId'] = self.resource_directory_account_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceDirectoryAccountId') is not None:
            self.resource_directory_account_id = m.get('ResourceDirectoryAccountId')
        return self


class GetCheckSummaryResponseBodySummarysStandards(TeaModel):
    def __init__(self, fail_count=None, id=None, pass_count=None, risk_level_high_count=None,
                 risk_level_low_count=None, risk_level_medium_count=None, show_name=None):
        self.fail_count = fail_count  # type: int
        self.id = id  # type: long
        self.pass_count = pass_count  # type: int
        self.risk_level_high_count = risk_level_high_count  # type: int
        self.risk_level_low_count = risk_level_low_count  # type: int
        self.risk_level_medium_count = risk_level_medium_count  # type: int
        self.show_name = show_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCheckSummaryResponseBodySummarysStandards, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.id is not None:
            result['Id'] = self.id
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        if self.risk_level_high_count is not None:
            result['RiskLevelHighCount'] = self.risk_level_high_count
        if self.risk_level_low_count is not None:
            result['RiskLevelLowCount'] = self.risk_level_low_count
        if self.risk_level_medium_count is not None:
            result['RiskLevelMediumCount'] = self.risk_level_medium_count
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        if m.get('RiskLevelHighCount') is not None:
            self.risk_level_high_count = m.get('RiskLevelHighCount')
        if m.get('RiskLevelLowCount') is not None:
            self.risk_level_low_count = m.get('RiskLevelLowCount')
        if m.get('RiskLevelMediumCount') is not None:
            self.risk_level_medium_count = m.get('RiskLevelMediumCount')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        return self


class GetCheckSummaryResponseBodySummarys(TeaModel):
    def __init__(self, fail_count=None, pass_count=None, standards=None, type=None):
        self.fail_count = fail_count  # type: int
        self.pass_count = pass_count  # type: long
        self.standards = standards  # type: list[GetCheckSummaryResponseBodySummarysStandards]
        self.type = type  # type: str

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCheckSummaryResponseBodySummarys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.pass_count is not None:
            result['PassCount'] = self.pass_count
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('PassCount') is not None:
            self.pass_count = m.get('PassCount')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = GetCheckSummaryResponseBodySummarysStandards()
                self.standards.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCheckSummaryResponseBody(TeaModel):
    def __init__(self, request_id=None, summarys=None):
        self.request_id = request_id  # type: str
        self.summarys = summarys  # type: list[GetCheckSummaryResponseBodySummarys]

    def validate(self):
        if self.summarys:
            for k in self.summarys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCheckSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Summarys'] = []
        if self.summarys is not None:
            for k in self.summarys:
                result['Summarys'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.summarys = []
        if m.get('Summarys') is not None:
            for k in m.get('Summarys'):
                temp_model = GetCheckSummaryResponseBodySummarys()
                self.summarys.append(temp_model.from_map(k))
        return self


class GetCheckSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCheckSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCheckSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClientUserDefineRuleRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClientUserDefineRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetClientUserDefineRuleResponseBodyUserDefineRuleDetail(TeaModel):
    def __init__(self, action_type=None, cmdline=None, file_path=None, gmt_create=None, gmt_modified=None, ip=None,
                 id=None, md_5list=None, name=None, new_file_path=None, parent_cmdline=None, parent_proc_path=None,
                 platform=None, port=None, port_str=None, proc_path=None, registry_content=None, registry_key=None, type=None):
        self.action_type = action_type  # type: str
        self.cmdline = cmdline  # type: str
        self.file_path = file_path  # type: str
        self.gmt_create = gmt_create  # type: long
        self.gmt_modified = gmt_modified  # type: long
        self.ip = ip  # type: str
        self.id = id  # type: long
        self.md_5list = md_5list  # type: str
        self.name = name  # type: str
        self.new_file_path = new_file_path  # type: str
        self.parent_cmdline = parent_cmdline  # type: str
        self.parent_proc_path = parent_proc_path  # type: str
        self.platform = platform  # type: str
        self.port = port  # type: int
        self.port_str = port_str  # type: str
        self.proc_path = proc_path  # type: str
        self.registry_content = registry_content  # type: str
        self.registry_key = registry_key  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClientUserDefineRuleResponseBodyUserDefineRuleDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.ip is not None:
            result['IP'] = self.ip
        if self.id is not None:
            result['Id'] = self.id
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetClientUserDefineRuleResponseBody(TeaModel):
    def __init__(self, request_id=None, user_define_rule_detail=None):
        self.request_id = request_id  # type: str
        self.user_define_rule_detail = user_define_rule_detail  # type: GetClientUserDefineRuleResponseBodyUserDefineRuleDetail

    def validate(self):
        if self.user_define_rule_detail:
            self.user_define_rule_detail.validate()

    def to_map(self):
        _map = super(GetClientUserDefineRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_detail is not None:
            result['UserDefineRuleDetail'] = self.user_define_rule_detail.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleDetail') is not None:
            temp_model = GetClientUserDefineRuleResponseBodyUserDefineRuleDetail()
            self.user_define_rule_detail = temp_model.from_map(m['UserDefineRuleDetail'])
        return self


class GetClientUserDefineRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetClientUserDefineRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetClientUserDefineRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudAssetDetailRequestCloudAssetInstances(TeaModel):
    def __init__(self, instance_id=None, region_id=None):
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCloudAssetDetailRequestCloudAssetInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCloudAssetDetailRequest(TeaModel):
    def __init__(self, asset_sub_type=None, asset_type=None, cloud_asset_instances=None, vendor=None):
        self.asset_sub_type = asset_sub_type  # type: int
        self.asset_type = asset_type  # type: int
        self.cloud_asset_instances = cloud_asset_instances  # type: list[GetCloudAssetDetailRequestCloudAssetInstances]
        self.vendor = vendor  # type: int

    def validate(self):
        if self.cloud_asset_instances:
            for k in self.cloud_asset_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCloudAssetDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        result['CloudAssetInstances'] = []
        if self.cloud_asset_instances is not None:
            for k in self.cloud_asset_instances:
                result['CloudAssetInstances'].append(k.to_map() if k else None)
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        self.cloud_asset_instances = []
        if m.get('CloudAssetInstances') is not None:
            for k in m.get('CloudAssetInstances'):
                temp_model = GetCloudAssetDetailRequestCloudAssetInstances()
                self.cloud_asset_instances.append(temp_model.from_map(k))
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class GetCloudAssetDetailResponseBodyInstances(TeaModel):
    def __init__(self, alarm_status=None, asset_sub_type=None, asset_sub_type_name=None, asset_type=None,
                 asset_type_name=None, created_time=None, detail_link=None, instance_id=None, instance_name=None, internet_ip=None,
                 region_id=None, risk_status=None, security_info=None, vendor=None):
        self.alarm_status = alarm_status  # type: str
        self.asset_sub_type = asset_sub_type  # type: int
        self.asset_sub_type_name = asset_sub_type_name  # type: str
        self.asset_type = asset_type  # type: int
        self.asset_type_name = asset_type_name  # type: str
        self.created_time = created_time  # type: long
        self.detail_link = detail_link  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.region_id = region_id  # type: str
        self.risk_status = risk_status  # type: str
        self.security_info = security_info  # type: str
        self.vendor = vendor  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCloudAssetDetailResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_status is not None:
            result['AlarmStatus'] = self.alarm_status
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_sub_type_name is not None:
            result['AssetSubTypeName'] = self.asset_sub_type_name
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.asset_type_name is not None:
            result['AssetTypeName'] = self.asset_type_name
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.detail_link is not None:
            result['DetailLink'] = self.detail_link
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.risk_status is not None:
            result['RiskStatus'] = self.risk_status
        if self.security_info is not None:
            result['SecurityInfo'] = self.security_info
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmStatus') is not None:
            self.alarm_status = m.get('AlarmStatus')
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetSubTypeName') is not None:
            self.asset_sub_type_name = m.get('AssetSubTypeName')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('AssetTypeName') is not None:
            self.asset_type_name = m.get('AssetTypeName')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DetailLink') is not None:
            self.detail_link = m.get('DetailLink')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RiskStatus') is not None:
            self.risk_status = m.get('RiskStatus')
        if m.get('SecurityInfo') is not None:
            self.security_info = m.get('SecurityInfo')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class GetCloudAssetDetailResponseBody(TeaModel):
    def __init__(self, count=None, instances=None, request_id=None):
        self.count = count  # type: int
        self.instances = instances  # type: list[GetCloudAssetDetailResponseBodyInstances]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCloudAssetDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = GetCloudAssetDetailResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudAssetDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCloudAssetDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCloudAssetDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudAssetDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas(TeaModel):
    def __init__(self, asset_sub_type=None, asset_type=None, instance_count=None, instance_risk_count=None):
        self.asset_sub_type = asset_sub_type  # type: int
        self.asset_type = asset_type  # type: int
        self.instance_count = instance_count  # type: int
        self.instance_risk_count = instance_risk_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_sub_type is not None:
            result['AssetSubType'] = self.asset_sub_type
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_risk_count is not None:
            result['InstanceRiskCount'] = self.instance_risk_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetSubType') is not None:
            self.asset_sub_type = m.get('AssetSubType')
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceRiskCount') is not None:
            self.instance_risk_count = m.get('InstanceRiskCount')
        return self


class GetCloudAssetSummaryResponseBodyGroupedFields(TeaModel):
    def __init__(self, cloud_asset_summary_metas=None, instance_count_total=None, instance_risk_count_total=None):
        self.cloud_asset_summary_metas = cloud_asset_summary_metas  # type: list[GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas]
        self.instance_count_total = instance_count_total  # type: int
        self.instance_risk_count_total = instance_risk_count_total  # type: int

    def validate(self):
        if self.cloud_asset_summary_metas:
            for k in self.cloud_asset_summary_metas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCloudAssetSummaryResponseBodyGroupedFields, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudAssetSummaryMetas'] = []
        if self.cloud_asset_summary_metas is not None:
            for k in self.cloud_asset_summary_metas:
                result['CloudAssetSummaryMetas'].append(k.to_map() if k else None)
        if self.instance_count_total is not None:
            result['InstanceCountTotal'] = self.instance_count_total
        if self.instance_risk_count_total is not None:
            result['InstanceRiskCountTotal'] = self.instance_risk_count_total
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cloud_asset_summary_metas = []
        if m.get('CloudAssetSummaryMetas') is not None:
            for k in m.get('CloudAssetSummaryMetas'):
                temp_model = GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas()
                self.cloud_asset_summary_metas.append(temp_model.from_map(k))
        if m.get('InstanceCountTotal') is not None:
            self.instance_count_total = m.get('InstanceCountTotal')
        if m.get('InstanceRiskCountTotal') is not None:
            self.instance_risk_count_total = m.get('InstanceRiskCountTotal')
        return self


class GetCloudAssetSummaryResponseBody(TeaModel):
    def __init__(self, grouped_fields=None, request_id=None):
        self.grouped_fields = grouped_fields  # type: GetCloudAssetSummaryResponseBodyGroupedFields
        self.request_id = request_id  # type: str

    def validate(self):
        if self.grouped_fields:
            self.grouped_fields.validate()

    def to_map(self):
        _map = super(GetCloudAssetSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouped_fields is not None:
            result['GroupedFields'] = self.grouped_fields.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupedFields') is not None:
            temp_model = GetCloudAssetSummaryResponseBodyGroupedFields()
            self.grouped_fields = temp_model.from_map(m['GroupedFields'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudAssetSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCloudAssetSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCloudAssetSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudAssetSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterCheckItemWarningStatisticsRequest(TeaModel):
    def __init__(self, cluster_id=None):
        self.cluster_id = cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClusterCheckItemWarningStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class GetClusterCheckItemWarningStatisticsResponseBodyData(TeaModel):
    def __init__(self, high_warning_count=None, low_warning_count=None, medium_warning_count=None):
        self.high_warning_count = high_warning_count  # type: int
        self.low_warning_count = low_warning_count  # type: int
        self.medium_warning_count = medium_warning_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClusterCheckItemWarningStatisticsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.high_warning_count is not None:
            result['HighWarningCount'] = self.high_warning_count
        if self.low_warning_count is not None:
            result['LowWarningCount'] = self.low_warning_count
        if self.medium_warning_count is not None:
            result['MediumWarningCount'] = self.medium_warning_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HighWarningCount') is not None:
            self.high_warning_count = m.get('HighWarningCount')
        if m.get('LowWarningCount') is not None:
            self.low_warning_count = m.get('LowWarningCount')
        if m.get('MediumWarningCount') is not None:
            self.medium_warning_count = m.get('MediumWarningCount')
        return self


class GetClusterCheckItemWarningStatisticsResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: GetClusterCheckItemWarningStatisticsResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetClusterCheckItemWarningStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetClusterCheckItemWarningStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterCheckItemWarningStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetClusterCheckItemWarningStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetClusterCheckItemWarningStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterCheckItemWarningStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterSuspEventStatisticsRequest(TeaModel):
    def __init__(self, cluster_id=None, from_=None):
        self.cluster_id = cluster_id  # type: str
        self.from_ = from_  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClusterSuspEventStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class GetClusterSuspEventStatisticsResponseBodySuspStatistics(TeaModel):
    def __init__(self, remind=None, serious=None, suspicious=None):
        self.remind = remind  # type: int
        self.serious = serious  # type: int
        self.suspicious = suspicious  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClusterSuspEventStatisticsResponseBodySuspStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind is not None:
            result['Remind'] = self.remind
        if self.serious is not None:
            result['Serious'] = self.serious
        if self.suspicious is not None:
            result['Suspicious'] = self.suspicious
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Remind') is not None:
            self.remind = m.get('Remind')
        if m.get('Serious') is not None:
            self.serious = m.get('Serious')
        if m.get('Suspicious') is not None:
            self.suspicious = m.get('Suspicious')
        return self


class GetClusterSuspEventStatisticsResponseBody(TeaModel):
    def __init__(self, request_id=None, susp_statistics=None):
        self.request_id = request_id  # type: str
        self.susp_statistics = susp_statistics  # type: GetClusterSuspEventStatisticsResponseBodySuspStatistics

    def validate(self):
        if self.susp_statistics:
            self.susp_statistics.validate()

    def to_map(self):
        _map = super(GetClusterSuspEventStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.susp_statistics is not None:
            result['SuspStatistics'] = self.susp_statistics.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuspStatistics') is not None:
            temp_model = GetClusterSuspEventStatisticsResponseBodySuspStatistics()
            self.susp_statistics = temp_model.from_map(m['SuspStatistics'])
        return self


class GetClusterSuspEventStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetClusterSuspEventStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetClusterSuspEventStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterSuspEventStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileDetectApiInvokeInfoResponseBodyData(TeaModel):
    def __init__(self, auth_count=None, expire=None, flow_rate=None, remain_auth_count=None, sale_version=None,
                 time_unit=None):
        self.auth_count = auth_count  # type: long
        self.expire = expire  # type: long
        self.flow_rate = flow_rate  # type: int
        self.remain_auth_count = remain_auth_count  # type: long
        self.sale_version = sale_version  # type: int
        self.time_unit = time_unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetFileDetectApiInvokeInfoResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_count is not None:
            result['AuthCount'] = self.auth_count
        if self.expire is not None:
            result['Expire'] = self.expire
        if self.flow_rate is not None:
            result['FlowRate'] = self.flow_rate
        if self.remain_auth_count is not None:
            result['RemainAuthCount'] = self.remain_auth_count
        if self.sale_version is not None:
            result['SaleVersion'] = self.sale_version
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthCount') is not None:
            self.auth_count = m.get('AuthCount')
        if m.get('Expire') is not None:
            self.expire = m.get('Expire')
        if m.get('FlowRate') is not None:
            self.flow_rate = m.get('FlowRate')
        if m.get('RemainAuthCount') is not None:
            self.remain_auth_count = m.get('RemainAuthCount')
        if m.get('SaleVersion') is not None:
            self.sale_version = m.get('SaleVersion')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        return self


class GetFileDetectApiInvokeInfoResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: GetFileDetectApiInvokeInfoResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetFileDetectApiInvokeInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetFileDetectApiInvokeInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetFileDetectApiInvokeInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetFileDetectApiInvokeInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetFileDetectApiInvokeInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileDetectApiInvokeInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileDetectResultRequest(TeaModel):
    def __init__(self, hash_key_list=None, source_ip=None, type=None):
        self.hash_key_list = hash_key_list  # type: list[str]
        self.source_ip = source_ip  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetFileDetectResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key_list is not None:
            result['HashKeyList'] = self.hash_key_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HashKeyList') is not None:
            self.hash_key_list = m.get('HashKeyList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetFileDetectResultResponseBodyResultList(TeaModel):
    def __init__(self, code=None, ext=None, hash_key=None, message=None, result=None, score=None, virus_type=None):
        self.code = code  # type: str
        self.ext = ext  # type: str
        self.hash_key = hash_key  # type: str
        self.message = message  # type: str
        self.result = result  # type: int
        self.score = score  # type: int
        self.virus_type = virus_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetFileDetectResultResponseBodyResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result
        if self.score is not None:
            result['Score'] = self.score
        if self.virus_type is not None:
            result['VirusType'] = self.virus_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('VirusType') is not None:
            self.virus_type = m.get('VirusType')
        return self


class GetFileDetectResultResponseBody(TeaModel):
    def __init__(self, request_id=None, result_list=None):
        self.request_id = request_id  # type: str
        self.result_list = result_list  # type: list[GetFileDetectResultResponseBodyResultList]

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetFileDetectResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = GetFileDetectResultResponseBodyResultList()
                self.result_list.append(temp_model.from_map(k))
        return self


class GetFileDetectResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetFileDetectResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetFileDetectResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileDetectResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotNodeRequest(TeaModel):
    def __init__(self, node_id=None):
        self.node_id = node_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class GetHoneypotNodeResponseBodyHoneypotNode(TeaModel):
    def __init__(self, allow_honeypot_access_internet=None, create_time=None, ecs_instance_id=None,
                 honeypot_total_count=None, honeypot_used_count=None, node_id=None, node_ip=None, node_name=None, probe_total_count=None,
                 probe_used_count=None, security_group_probe_ip_list=None, total_status=None, upgrade_available=None):
        self.allow_honeypot_access_internet = allow_honeypot_access_internet  # type: bool
        self.create_time = create_time  # type: str
        self.ecs_instance_id = ecs_instance_id  # type: str
        self.honeypot_total_count = honeypot_total_count  # type: int
        self.honeypot_used_count = honeypot_used_count  # type: int
        self.node_id = node_id  # type: str
        self.node_ip = node_ip  # type: str
        self.node_name = node_name  # type: str
        self.probe_total_count = probe_total_count  # type: int
        self.probe_used_count = probe_used_count  # type: int
        self.security_group_probe_ip_list = security_group_probe_ip_list  # type: list[str]
        self.total_status = total_status  # type: int
        self.upgrade_available = upgrade_available  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotNodeResponseBodyHoneypotNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.honeypot_total_count is not None:
            result['HoneypotTotalCount'] = self.honeypot_total_count
        if self.honeypot_used_count is not None:
            result['HoneypotUsedCount'] = self.honeypot_used_count
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.probe_total_count is not None:
            result['ProbeTotalCount'] = self.probe_total_count
        if self.probe_used_count is not None:
            result['ProbeUsedCount'] = self.probe_used_count
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        if self.total_status is not None:
            result['TotalStatus'] = self.total_status
        if self.upgrade_available is not None:
            result['UpgradeAvailable'] = self.upgrade_available
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('HoneypotTotalCount') is not None:
            self.honeypot_total_count = m.get('HoneypotTotalCount')
        if m.get('HoneypotUsedCount') is not None:
            self.honeypot_used_count = m.get('HoneypotUsedCount')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('ProbeTotalCount') is not None:
            self.probe_total_count = m.get('ProbeTotalCount')
        if m.get('ProbeUsedCount') is not None:
            self.probe_used_count = m.get('ProbeUsedCount')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        if m.get('TotalStatus') is not None:
            self.total_status = m.get('TotalStatus')
        if m.get('UpgradeAvailable') is not None:
            self.upgrade_available = m.get('UpgradeAvailable')
        return self


class GetHoneypotNodeResponseBody(TeaModel):
    def __init__(self, code=None, honeypot_node=None, http_status_code=None, message=None, request_id=None,
                 success=None):
        self.code = code  # type: str
        self.honeypot_node = honeypot_node  # type: GetHoneypotNodeResponseBodyHoneypotNode
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.honeypot_node:
            self.honeypot_node.validate()

    def to_map(self):
        _map = super(GetHoneypotNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.honeypot_node is not None:
            result['HoneypotNode'] = self.honeypot_node.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HoneypotNode') is not None:
            temp_model = GetHoneypotNodeResponseBodyHoneypotNode()
            self.honeypot_node = temp_model.from_map(m['HoneypotNode'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetHoneypotNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetHoneypotNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotPresetRequest(TeaModel):
    def __init__(self, honeypot_preset_id=None, lang=None):
        self.honeypot_preset_id = honeypot_preset_id  # type: str
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotPresetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class GetHoneypotPresetResponseBodyDataFileInfoList(TeaModel):
    def __init__(self, file_id=None, file_name=None, oss_url=None):
        self.file_id = file_id  # type: str
        self.file_name = file_name  # type: str
        self.oss_url = oss_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotPresetResponseBodyDataFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.oss_url is not None:
            result['OssUrl'] = self.oss_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('OssUrl') is not None:
            self.oss_url = m.get('OssUrl')
        return self


class GetHoneypotPresetResponseBodyData(TeaModel):
    def __init__(self, control_node_name=None, file_info_list=None, honeypot_image_display_name=None,
                 honeypot_image_name=None, honeypot_preset_id=None, meta=None, node_id=None, preset_name=None, preset_type=None):
        self.control_node_name = control_node_name  # type: str
        self.file_info_list = file_info_list  # type: list[GetHoneypotPresetResponseBodyDataFileInfoList]
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.honeypot_preset_id = honeypot_preset_id  # type: str
        self.meta = meta  # type: str
        self.node_id = node_id  # type: str
        self.preset_name = preset_name  # type: str
        self.preset_type = preset_type  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetHoneypotPresetResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        if self.preset_type is not None:
            result['PresetType'] = self.preset_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetHoneypotPresetResponseBodyDataFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        if m.get('PresetType') is not None:
            self.preset_type = m.get('PresetType')
        return self


class GetHoneypotPresetResponseBody(TeaModel):
    def __init__(self, code=None, data=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: GetHoneypotPresetResponseBodyData
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetHoneypotPresetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHoneypotPresetResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotPresetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetHoneypotPresetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetHoneypotPresetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHoneypotProbeRequest(TeaModel):
    def __init__(self, probe_id=None):
        self.probe_id = probe_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotProbeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        return self


class GetHoneypotProbeResponseBodyDataControlNode(TeaModel):
    def __init__(self, ecs_instance_id=None, node_id=None, node_name=None):
        self.ecs_instance_id = ecs_instance_id  # type: str
        self.node_id = node_id  # type: str
        self.node_name = node_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBodyDataControlNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        return self


class GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort(TeaModel):
    def __init__(self, id=None, ports=None, probe_id=None, service_ip_list=None, status=None):
        self.id = id  # type: long
        self.ports = ports  # type: str
        self.probe_id = probe_id  # type: str
        self.service_ip_list = service_ip_list  # type: list[str]
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.ports is not None:
            result['Ports'] = self.ports
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ports') is not None:
            self.ports = m.get('Ports')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList(TeaModel):
    def __init__(self, bind_port=None, end_port=None, err=None, fixed=None, id=None, msg=None, proto=None,
                 start_port=None, status=None, target_port=None):
        self.bind_port = bind_port  # type: bool
        self.end_port = end_port  # type: int
        self.err = err  # type: str
        self.fixed = fixed  # type: bool
        self.id = id  # type: long
        self.msg = msg  # type: str
        self.proto = proto  # type: str
        self.start_port = start_port  # type: int
        self.status = status  # type: int
        self.target_port = target_port  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_port is not None:
            result['BindPort'] = self.bind_port
        if self.end_port is not None:
            result['EndPort'] = self.end_port
        if self.err is not None:
            result['Err'] = self.err
        if self.fixed is not None:
            result['Fixed'] = self.fixed
        if self.id is not None:
            result['Id'] = self.id
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.start_port is not None:
            result['StartPort'] = self.start_port
        if self.status is not None:
            result['Status'] = self.status
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindPort') is not None:
            self.bind_port = m.get('BindPort')
        if m.get('EndPort') is not None:
            self.end_port = m.get('EndPort')
        if m.get('Err') is not None:
            self.err = m.get('Err')
        if m.get('Fixed') is not None:
            self.fixed = m.get('Fixed')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('StartPort') is not None:
            self.start_port = m.get('StartPort')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class GetHoneypotProbeResponseBodyDataHoneypotProbeBindList(TeaModel):
    def __init__(self, bind_id=None, bind_port_list=None, honeypot_id=None, service_ip_list=None, status=None):
        self.bind_id = bind_id  # type: str
        self.bind_port_list = bind_port_list  # type: list[GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList]
        self.honeypot_id = honeypot_id  # type: str
        self.service_ip_list = service_ip_list  # type: list[str]
        self.status = status  # type: int

    def validate(self):
        if self.bind_port_list:
            for k in self.bind_port_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBodyDataHoneypotProbeBindList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_id is not None:
            result['BindId'] = self.bind_id
        result['BindPortList'] = []
        if self.bind_port_list is not None:
            for k in self.bind_port_list:
                result['BindPortList'].append(k.to_map() if k else None)
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindId') is not None:
            self.bind_id = m.get('BindId')
        self.bind_port_list = []
        if m.get('BindPortList') is not None:
            for k in m.get('BindPortList'):
                temp_model = GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList()
                self.bind_port_list.append(temp_model.from_map(k))
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetHoneypotProbeResponseBodyData(TeaModel):
    def __init__(self, arp=None, can_listen_ip_list=None, cidr_list=None, control_node=None, cpu_load=None,
                 deploy_time=None, display_name=None, honey_pot_probe_scan_port=None, honeypot_probe_bind_list=None,
                 host_ip=None, listen_ip_list=None, memory_load=None, os_type=None, ping=None, probe_id=None,
                 probe_type=None, probe_version=None, proxy_ip=None, status=None, uuid=None, vpc_id=None):
        self.arp = arp  # type: bool
        self.can_listen_ip_list = can_listen_ip_list  # type: list[str]
        self.cidr_list = cidr_list  # type: list[str]
        self.control_node = control_node  # type: GetHoneypotProbeResponseBodyDataControlNode
        self.cpu_load = cpu_load  # type: float
        self.deploy_time = deploy_time  # type: long
        self.display_name = display_name  # type: str
        self.honey_pot_probe_scan_port = honey_pot_probe_scan_port  # type: GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort
        self.honeypot_probe_bind_list = honeypot_probe_bind_list  # type: list[GetHoneypotProbeResponseBodyDataHoneypotProbeBindList]
        self.host_ip = host_ip  # type: str
        self.listen_ip_list = listen_ip_list  # type: list[str]
        self.memory_load = memory_load  # type: float
        self.os_type = os_type  # type: str
        self.ping = ping  # type: bool
        self.probe_id = probe_id  # type: str
        self.probe_type = probe_type  # type: str
        self.probe_version = probe_version  # type: str
        self.proxy_ip = proxy_ip  # type: str
        self.status = status  # type: int
        self.uuid = uuid  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.control_node:
            self.control_node.validate()
        if self.honey_pot_probe_scan_port:
            self.honey_pot_probe_scan_port.validate()
        if self.honeypot_probe_bind_list:
            for k in self.honeypot_probe_bind_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.can_listen_ip_list is not None:
            result['CanListenIpList'] = self.can_listen_ip_list
        if self.cidr_list is not None:
            result['CidrList'] = self.cidr_list
        if self.control_node is not None:
            result['ControlNode'] = self.control_node.to_map()
        if self.cpu_load is not None:
            result['CpuLoad'] = self.cpu_load
        if self.deploy_time is not None:
            result['DeployTime'] = self.deploy_time
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.honey_pot_probe_scan_port is not None:
            result['HoneyPotProbeScanPort'] = self.honey_pot_probe_scan_port.to_map()
        result['HoneypotProbeBindList'] = []
        if self.honeypot_probe_bind_list is not None:
            for k in self.honeypot_probe_bind_list:
                result['HoneypotProbeBindList'].append(k.to_map() if k else None)
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.listen_ip_list is not None:
            result['ListenIpList'] = self.listen_ip_list
        if self.memory_load is not None:
            result['MemoryLoad'] = self.memory_load
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.proxy_ip is not None:
            result['ProxyIp'] = self.proxy_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('CanListenIpList') is not None:
            self.can_listen_ip_list = m.get('CanListenIpList')
        if m.get('CidrList') is not None:
            self.cidr_list = m.get('CidrList')
        if m.get('ControlNode') is not None:
            temp_model = GetHoneypotProbeResponseBodyDataControlNode()
            self.control_node = temp_model.from_map(m['ControlNode'])
        if m.get('CpuLoad') is not None:
            self.cpu_load = m.get('CpuLoad')
        if m.get('DeployTime') is not None:
            self.deploy_time = m.get('DeployTime')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('HoneyPotProbeScanPort') is not None:
            temp_model = GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort()
            self.honey_pot_probe_scan_port = temp_model.from_map(m['HoneyPotProbeScanPort'])
        self.honeypot_probe_bind_list = []
        if m.get('HoneypotProbeBindList') is not None:
            for k in m.get('HoneypotProbeBindList'):
                temp_model = GetHoneypotProbeResponseBodyDataHoneypotProbeBindList()
                self.honeypot_probe_bind_list.append(temp_model.from_map(k))
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('ListenIpList') is not None:
            self.listen_ip_list = m.get('ListenIpList')
        if m.get('MemoryLoad') is not None:
            self.memory_load = m.get('MemoryLoad')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('ProxyIp') is not None:
            self.proxy_ip = m.get('ProxyIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetHoneypotProbeResponseBody(TeaModel):
    def __init__(self, code=None, data=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: GetHoneypotProbeResponseBodyData
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(GetHoneypotProbeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHoneypotProbeResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHoneypotProbeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetHoneypotProbeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetHoneypotProbeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetImageScanNumInPeriodRequest(TeaModel):
    def __init__(self, past_day=None):
        self.past_day = past_day  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetImageScanNumInPeriodRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.past_day is not None:
            result['PastDay'] = self.past_day
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PastDay') is not None:
            self.past_day = m.get('PastDay')
        return self


class GetImageScanNumInPeriodResponseBodyImageScanData(TeaModel):
    def __init__(self, image_scan_count=None):
        self.image_scan_count = image_scan_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetImageScanNumInPeriodResponseBodyImageScanData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_count is not None:
            result['ImageScanCount'] = self.image_scan_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageScanCount') is not None:
            self.image_scan_count = m.get('ImageScanCount')
        return self


class GetImageScanNumInPeriodResponseBody(TeaModel):
    def __init__(self, image_scan_data=None, request_id=None):
        self.image_scan_data = image_scan_data  # type: GetImageScanNumInPeriodResponseBodyImageScanData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_scan_data:
            self.image_scan_data.validate()

    def to_map(self):
        _map = super(GetImageScanNumInPeriodResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_scan_data is not None:
            result['ImageScanData'] = self.image_scan_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageScanData') is not None:
            temp_model = GetImageScanNumInPeriodResponseBodyImageScanData()
            self.image_scan_data = temp_model.from_map(m['ImageScanData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetImageScanNumInPeriodResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetImageScanNumInPeriodResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetImageScanNumInPeriodResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetImageScanNumInPeriodResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterceptionSummaryResponseBodyInterceptionSummary(TeaModel):
    def __init__(self, close_cluster_count=None, close_rule_count=None, cluster_count=None,
                 open_cluster_count=None, open_rule_count=None, risk_count_180day=None, risk_count_30day=None, risk_count_today=None,
                 rule_count=None):
        self.close_cluster_count = close_cluster_count  # type: int
        self.close_rule_count = close_rule_count  # type: int
        self.cluster_count = cluster_count  # type: int
        self.open_cluster_count = open_cluster_count  # type: int
        self.open_rule_count = open_rule_count  # type: int
        self.risk_count_180day = risk_count_180day  # type: long
        self.risk_count_30day = risk_count_30day  # type: long
        self.risk_count_today = risk_count_today  # type: long
        self.rule_count = rule_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInterceptionSummaryResponseBodyInterceptionSummary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_cluster_count is not None:
            result['CloseClusterCount'] = self.close_cluster_count
        if self.close_rule_count is not None:
            result['CloseRuleCount'] = self.close_rule_count
        if self.cluster_count is not None:
            result['ClusterCount'] = self.cluster_count
        if self.open_cluster_count is not None:
            result['OpenClusterCount'] = self.open_cluster_count
        if self.open_rule_count is not None:
            result['OpenRuleCount'] = self.open_rule_count
        if self.risk_count_180day is not None:
            result['RiskCount180Day'] = self.risk_count_180day
        if self.risk_count_30day is not None:
            result['RiskCount30Day'] = self.risk_count_30day
        if self.risk_count_today is not None:
            result['RiskCountToday'] = self.risk_count_today
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CloseClusterCount') is not None:
            self.close_cluster_count = m.get('CloseClusterCount')
        if m.get('CloseRuleCount') is not None:
            self.close_rule_count = m.get('CloseRuleCount')
        if m.get('ClusterCount') is not None:
            self.cluster_count = m.get('ClusterCount')
        if m.get('OpenClusterCount') is not None:
            self.open_cluster_count = m.get('OpenClusterCount')
        if m.get('OpenRuleCount') is not None:
            self.open_rule_count = m.get('OpenRuleCount')
        if m.get('RiskCount180Day') is not None:
            self.risk_count_180day = m.get('RiskCount180Day')
        if m.get('RiskCount30Day') is not None:
            self.risk_count_30day = m.get('RiskCount30Day')
        if m.get('RiskCountToday') is not None:
            self.risk_count_today = m.get('RiskCountToday')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        return self


class GetInterceptionSummaryResponseBody(TeaModel):
    def __init__(self, interception_summary=None, request_id=None):
        self.interception_summary = interception_summary  # type: GetInterceptionSummaryResponseBodyInterceptionSummary
        self.request_id = request_id  # type: str

    def validate(self):
        if self.interception_summary:
            self.interception_summary.validate()

    def to_map(self):
        _map = super(GetInterceptionSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interception_summary is not None:
            result['InterceptionSummary'] = self.interception_summary.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InterceptionSummary') is not None:
            temp_model = GetInterceptionSummaryResponseBodyInterceptionSummary()
            self.interception_summary = temp_model.from_map(m['InterceptionSummary'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInterceptionSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetInterceptionSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetInterceptionSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterceptionSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterceptionTargetDetailRequest(TeaModel):
    def __init__(self, target_id=None):
        self.target_id = target_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInterceptionTargetDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class GetInterceptionTargetDetailResponseBodyRuleTarget(TeaModel):
    def __init__(self, app_name=None, cluster_id=None, cluster_name=None, image_list=None, namespace=None,
                 tag_list=None, target_id=None, target_name=None, target_type=None):
        self.app_name = app_name  # type: str
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.image_list = image_list  # type: list[str]
        self.namespace = namespace  # type: str
        self.tag_list = tag_list  # type: list[str]
        self.target_id = target_id  # type: long
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInterceptionTargetDetailResponseBodyRuleTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class GetInterceptionTargetDetailResponseBody(TeaModel):
    def __init__(self, request_id=None, rule_target=None):
        self.request_id = request_id  # type: str
        self.rule_target = rule_target  # type: GetInterceptionTargetDetailResponseBodyRuleTarget

    def validate(self):
        if self.rule_target:
            self.rule_target.validate()

    def to_map(self):
        _map = super(GetInterceptionTargetDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_target is not None:
            result['RuleTarget'] = self.rule_target.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleTarget') is not None:
            temp_model = GetInterceptionTargetDetailResponseBodyRuleTarget()
            self.rule_target = temp_model.from_map(m['RuleTarget'])
        return self


class GetInterceptionTargetDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetInterceptionTargetDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetInterceptionTargetDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterceptionTargetDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLastOnceTaskInfoRequest(TeaModel):
    def __init__(self, source=None, task_name=None, task_type=None):
        self.source = source  # type: str
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLastOnceTaskInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetLastOnceTaskInfoResponseBodyTaskInfo(TeaModel):
    def __init__(self, progress=None, result=None, status=None):
        self.progress = progress  # type: int
        self.result = result  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLastOnceTaskInfoResponseBodyTaskInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetLastOnceTaskInfoResponseBody(TeaModel):
    def __init__(self, collect_time=None, finish_count=None, request_id=None, task_id=None, task_info=None,
                 total_count=None):
        self.collect_time = collect_time  # type: long
        self.finish_count = finish_count  # type: int
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: long
        self.task_info = task_info  # type: GetLastOnceTaskInfoResponseBodyTaskInfo
        self.total_count = total_count  # type: int

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super(GetLastOnceTaskInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = GetLastOnceTaskInfoResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetLastOnceTaskInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLastOnceTaskInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLastOnceTaskInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLastOnceTaskInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetModuleConfigRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None):
        self.current_page = current_page  # type: str
        self.page_size = page_size  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetModuleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class GetModuleConfigResponseBodyModuleConfigListItems(TeaModel):
    def __init__(self, group_id=None, instance_id=None, instance_name=None, ip=None, region=None, uuid=None):
        self.group_id = group_id  # type: int
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.ip = ip  # type: str
        self.region = region  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetModuleConfigResponseBodyModuleConfigListItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.region is not None:
            result['Region'] = self.region
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetModuleConfigResponseBodyModuleConfigList(TeaModel):
    def __init__(self, config_name=None, items=None, module_name=None):
        self.config_name = config_name  # type: str
        self.items = items  # type: list[GetModuleConfigResponseBodyModuleConfigListItems]
        self.module_name = module_name  # type: str

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetModuleConfigResponseBodyModuleConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = GetModuleConfigResponseBodyModuleConfigListItems()
                self.items.append(temp_model.from_map(k))
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class GetModuleConfigResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetModuleConfigResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetModuleConfigResponseBody(TeaModel):
    def __init__(self, http_status_code=None, module_config_list=None, page_info=None, request_id=None,
                 success=None):
        self.http_status_code = http_status_code  # type: int
        self.module_config_list = module_config_list  # type: list[GetModuleConfigResponseBodyModuleConfigList]
        self.page_info = page_info  # type: GetModuleConfigResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.module_config_list:
            for k in self.module_config_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(GetModuleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['ModuleConfigList'] = []
        if self.module_config_list is not None:
            for k in self.module_config_list:
                result['ModuleConfigList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.module_config_list = []
        if m.get('ModuleConfigList') is not None:
            for k in m.get('ModuleConfigList'):
                temp_model = GetModuleConfigResponseBodyModuleConfigList()
                self.module_config_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = GetModuleConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetModuleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetModuleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetModuleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetModuleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnceTaskResultInfoRequest(TeaModel):
    def __init__(self, task_id=None, task_name=None, task_type=None):
        self.task_id = task_id  # type: str
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOnceTaskResultInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetOnceTaskResultInfoResponseBodyTaskInfo(TeaModel):
    def __init__(self, status=None):
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOnceTaskResultInfoResponseBodyTaskInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetOnceTaskResultInfoResponseBody(TeaModel):
    def __init__(self, collect_time=None, finish_count=None, request_id=None, task_id=None, task_info=None,
                 total_count=None):
        self.collect_time = collect_time  # type: long
        self.finish_count = finish_count  # type: int
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: long
        self.task_info = task_info  # type: GetOnceTaskResultInfoResponseBodyTaskInfo
        self.total_count = total_count  # type: int

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super(GetOnceTaskResultInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = GetOnceTaskResultInfoResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOnceTaskResultInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOnceTaskResultInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOnceTaskResultInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnceTaskResultInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPropertyScheduleConfigRequest(TeaModel):
    def __init__(self, type=None, uuid=None):
        self.type = type  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPropertyScheduleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig(TeaModel):
    def __init__(self, next_schedule_time=None, schedule_time=None, type=None):
        self.next_schedule_time = next_schedule_time  # type: long
        self.schedule_time = schedule_time  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_schedule_time is not None:
            result['NextScheduleTime'] = self.next_schedule_time
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextScheduleTime') is not None:
            self.next_schedule_time = m.get('NextScheduleTime')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPropertyScheduleConfigResponseBody(TeaModel):
    def __init__(self, property_schedule_config=None, request_id=None):
        self.property_schedule_config = property_schedule_config  # type: GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig
        self.request_id = request_id  # type: str

    def validate(self):
        if self.property_schedule_config:
            self.property_schedule_config.validate()

    def to_map(self):
        _map = super(GetPropertyScheduleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.property_schedule_config is not None:
            result['PropertyScheduleConfig'] = self.property_schedule_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PropertyScheduleConfig') is not None:
            temp_model = GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig()
            self.property_schedule_config = temp_model.from_map(m['PropertyScheduleConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPropertyScheduleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPropertyScheduleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPropertyScheduleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRulesCountResponseBody(TeaModel):
    def __init__(self, request_id=None, total_system_client_rule_count=None, total_user_define_rule_count=None):
        self.request_id = request_id  # type: str
        self.total_system_client_rule_count = total_system_client_rule_count  # type: long
        self.total_user_define_rule_count = total_user_define_rule_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetRulesCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_system_client_rule_count is not None:
            result['TotalSystemClientRuleCount'] = self.total_system_client_rule_count
        if self.total_user_define_rule_count is not None:
            result['TotalUserDefineRuleCount'] = self.total_user_define_rule_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalSystemClientRuleCount') is not None:
            self.total_system_client_rule_count = m.get('TotalSystemClientRuleCount')
        if m.get('TotalUserDefineRuleCount') is not None:
            self.total_user_define_rule_count = m.get('TotalUserDefineRuleCount')
        return self


class GetRulesCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetRulesCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetRulesCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRulesCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSuspiciousStatisticsRequest(TeaModel):
    def __init__(self, group_id_list=None, source_ip=None):
        # The ID of the asset group. Separate multiple IDs with commas (,).
        # 
        # >  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.
        self.group_id_list = group_id_list  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSuspiciousStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class GetSuspiciousStatisticsResponseBody(TeaModel):
    def __init__(self, remind_count=None, request_id=None, serious_count=None, suspicious_count=None,
                 total_count=None):
        # The number of alerts whose Emergency level is Reminder.
        self.remind_count = remind_count  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The number of alerts whose Emergency level is Urgent.
        self.serious_count = serious_count  # type: int
        # The number of alerts whose Emergency level is Suspicious.
        self.suspicious_count = suspicious_count  # type: int
        # The total number of alerts.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSuspiciousStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind_count is not None:
            result['RemindCount'] = self.remind_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.serious_count is not None:
            result['SeriousCount'] = self.serious_count
        if self.suspicious_count is not None:
            result['SuspiciousCount'] = self.suspicious_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RemindCount') is not None:
            self.remind_count = m.get('RemindCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SeriousCount') is not None:
            self.serious_count = m.get('SeriousCount')
        if m.get('SuspiciousCount') is not None:
            self.suspicious_count = m.get('SuspiciousCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetSuspiciousStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSuspiciousStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSuspiciousStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSuspiciousStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVulStatisticsRequest(TeaModel):
    def __init__(self, group_id_list=None, source_ip=None, type_list=None):
        # The ID of the asset group. Separate multiple IDs with commas (,). 
        # > You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups
        self.group_id_list = group_id_list  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the vulnerability whose statistics you want to query. Separate multiple vulnerability types with commas (,). Valid values:
        # - **cve**:Linux software vulnerabilities
        # - **sys**:Windows system vulnerabilities
        # - **cms**: Web-CMS vulnerabilities
        # - **emg**: urgent vulnerabilities
        # - **app**: application vulnerabilities
        # - **sca**: vulnerabilities that are detected based on software component analysis
        self.type_list = type_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetVulStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id_list is not None:
            result['GroupIdList'] = self.group_id_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type_list is not None:
            result['TypeList'] = self.type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupIdList') is not None:
            self.group_id_list = m.get('GroupIdList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TypeList') is not None:
            self.type_list = m.get('TypeList')
        return self


class GetVulStatisticsResponseBody(TeaModel):
    def __init__(self, request_id=None, vul_asap_sum=None, vul_later_sum=None, vul_nntf_sum=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of vulnerabilities that have the high priority.
        self.vul_asap_sum = vul_asap_sum  # type: int
        # The number of vulnerabilities that have the medium priority.
        self.vul_later_sum = vul_later_sum  # type: int
        # The number of vulnerabilities that have the low priority.
        self.vul_nntf_sum = vul_nntf_sum  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetVulStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_asap_sum is not None:
            result['VulAsapSum'] = self.vul_asap_sum
        if self.vul_later_sum is not None:
            result['VulLaterSum'] = self.vul_later_sum
        if self.vul_nntf_sum is not None:
            result['VulNntfSum'] = self.vul_nntf_sum
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulAsapSum') is not None:
            self.vul_asap_sum = m.get('VulAsapSum')
        if m.get('VulLaterSum') is not None:
            self.vul_later_sum = m.get('VulLaterSum')
        if m.get('VulNntfSum') is not None:
            self.vul_nntf_sum = m.get('VulNntfSum')
        return self


class GetVulStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetVulStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetVulStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVulStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVulWhitelistRequest(TeaModel):
    def __init__(self, vul_whitelist_id=None):
        # The ID of the whitelist.
        self.vul_whitelist_id = vul_whitelist_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetVulWhitelistRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vul_whitelist_id is not None:
            result['VulWhitelistId'] = self.vul_whitelist_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VulWhitelistId') is not None:
            self.vul_whitelist_id = m.get('VulWhitelistId')
        return self


class GetVulWhitelistResponseBodyVulWhitelist(TeaModel):
    def __init__(self, alias_name=None, id=None, name=None, reason=None, target=None, type=None, whitelist=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The ID of the whitelist.
        self.id = id  # type: long
        # The name of the vulnerability.
        self.name = name  # type: str
        # The reason why the vulnerability is added to the whitelist.
        self.reason = reason  # type: str
        # The application scope of the rule. The value is a JSON string that contains the following fields:
        # 
        # *   **type**: the type of the assets to which the rule is applied. Valid values:
        # 
        #     *   **Uuid**: server
        #     *   **GroupId**: server group
        # 
        # *   **groupIds**: the IDs of server groups.
        # 
        # *   **uuids**: the UUIDs of servers.
        # 
        # >  If this parameter is empty, the rule is applied to all assets.
        self.target = target  # type: str
        # The type of the vulnerability.
        self.type = type  # type: str
        # The information about the vulnerability that is added to the whitelist. The value is a JSON string that contains the following fields:
        # 
        # *   **Name**: the name of the vulnerability.
        # 
        # *   **Type**: the type of the vulnerability. Valid values:
        # 
        #     *   **cve**: Linux software vulnerability
        #     *   **sys**: Windows system vulnerability
        #     *   **cms**: Web-CMS vulnerability
        #     *   **app**: application vulnerability
        #     *   **emg**: urgent vulnerability
        # 
        # *   **AliasName**: the alias of the vulnerability.
        self.whitelist = whitelist  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetVulWhitelistResponseBodyVulWhitelist, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class GetVulWhitelistResponseBody(TeaModel):
    def __init__(self, request_id=None, vul_whitelist=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The information about the whitelist.
        self.vul_whitelist = vul_whitelist  # type: GetVulWhitelistResponseBodyVulWhitelist

    def validate(self):
        if self.vul_whitelist:
            self.vul_whitelist.validate()

    def to_map(self):
        _map = super(GetVulWhitelistResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vul_whitelist is not None:
            result['VulWhitelist'] = self.vul_whitelist.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VulWhitelist') is not None:
            temp_model = GetVulWhitelistResponseBodyVulWhitelist()
            self.vul_whitelist = temp_model.from_map(m['VulWhitelist'])
        return self


class GetVulWhitelistResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetVulWhitelistResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetVulWhitelistResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HandleSecurityEventsRequest(TeaModel):
    def __init__(self, mark_batch=None, mark_miss_param=None, operation_code=None, operation_params=None,
                 security_event_ids=None, source_ip=None):
        # Specifies whether to add multiple alert events to the whitelist at a time. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.mark_batch = mark_batch  # type: str
        # The whitelist rule. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **field**: The field based on which alert events are added to the whitelist.
        # 
        # *   **operate**: The method that is used to added alert events to the whitelist. Valid values:
        # 
        #     *   **notContains**: does not contain
        #     *   **contains**: contains
        #     *   **regex**: matches by regular expression
        #     *   **strEqual**: equals
        #     *   **strNotEqual**: does not equal
        # 
        # *   **fieldValue**: The value of the field based on which alert events are added to the whitelist.
        # 
        # *   **uuid**: The application scope of the whitelist rule. Valid values:
        # 
        #     *   **part**: the current asset
        #     *   **ALL**: all assets
        # 
        # >  You can call the [DescribeSecurityEventOperations](~~DescribeSecurityEventOperations~~) operation to obtain the fields that you can specify for **field**.
        self.mark_miss_param = mark_miss_param  # type: str
        # The operation that you want to perform to handle the alert events. Valid values:
        # 
        # *   **block_ip**: blocks the source IP address.
        # *   **advance\_mark\_mis_info**: adds the alert events to the whitelist.
        # *   **ignore**: ignores the alert events.
        # *   **manual_handled**: marks the alert events as manually handled.
        # *   **kill_process**: terminates the malicious process.
        # *   **cleanup**: performs in-depth virus detection and removal.
        # *   **kill\_and_quara**: kills the malicious processes and quarantines the source file.
        # *   **disable\_malicious_defense**: stops the container on which the alerting files or processes exist.
        # *   **client\_problem_check**: performs troubleshooting.
        # *   **quara**: quarantines the source file of the malicious process.
        self.operation_code = operation_code  # type: str
        # The configuration of the operation that you want to perform to handle the alert events.
        # 
        # >  If you set OperationCode to `kill_and_quara` or `block_ip`, you must specify OperationParams. If you set OperationCode to other values, you can leave OperationParams empty.
        self.operation_params = operation_params  # type: str
        # The IDs of the alert events.
        self.security_event_ids = security_event_ids  # type: list[str]
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSecurityEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mark_batch is not None:
            result['MarkBatch'] = self.mark_batch
        if self.mark_miss_param is not None:
            result['MarkMissParam'] = self.mark_miss_param
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MarkBatch') is not None:
            self.mark_batch = m.get('MarkBatch')
        if m.get('MarkMissParam') is not None:
            self.mark_miss_param = m.get('MarkMissParam')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class HandleSecurityEventsResponseBodyHandleSecurityEventsResponse(TeaModel):
    def __init__(self, task_id=None):
        # The ID of the task to handle the alert events.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSecurityEventsResponseBodyHandleSecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class HandleSecurityEventsResponseBody(TeaModel):
    def __init__(self, handle_security_events_response=None, request_id=None):
        # The handling result of the alert events.
        self.handle_security_events_response = handle_security_events_response  # type: HandleSecurityEventsResponseBodyHandleSecurityEventsResponse
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.handle_security_events_response:
            self.handle_security_events_response.validate()

    def to_map(self):
        _map = super(HandleSecurityEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.handle_security_events_response is not None:
            result['HandleSecurityEventsResponse'] = self.handle_security_events_response.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HandleSecurityEventsResponse') is not None:
            temp_model = HandleSecurityEventsResponseBodyHandleSecurityEventsResponse()
            self.handle_security_events_response = temp_model.from_map(m['HandleSecurityEventsResponse'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HandleSecurityEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: HandleSecurityEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(HandleSecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HandleSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HandleSimilarSecurityEventsRequest(TeaModel):
    def __init__(self, mark_miss_param=None, operation_code=None, operation_params=None, resource_owner_id=None,
                 source_ip=None, task_id=None):
        self.mark_miss_param = mark_miss_param  # type: str
        self.operation_code = operation_code  # type: str
        self.operation_params = operation_params  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.source_ip = source_ip  # type: str
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSimilarSecurityEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mark_miss_param is not None:
            result['MarkMissParam'] = self.mark_miss_param
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MarkMissParam') is not None:
            self.mark_miss_param = m.get('MarkMissParam')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class HandleSimilarSecurityEventsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSimilarSecurityEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HandleSimilarSecurityEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: HandleSimilarSecurityEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(HandleSimilarSecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HandleSimilarSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class IgnoreCheckItemsRequestCheckAndRiskTypeList(TeaModel):
    def __init__(self, check_id=None, risk_type=None):
        self.check_id = check_id  # type: long
        self.risk_type = risk_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(IgnoreCheckItemsRequestCheckAndRiskTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        return self


class IgnoreCheckItemsRequest(TeaModel):
    def __init__(self, check_and_risk_type_list=None, lang=None, reason=None, type=None, uuid_list=None):
        self.check_and_risk_type_list = check_and_risk_type_list  # type: list[IgnoreCheckItemsRequestCheckAndRiskTypeList]
        self.lang = lang  # type: str
        self.reason = reason  # type: str
        self.type = type  # type: int
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        if self.check_and_risk_type_list:
            for k in self.check_and_risk_type_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(IgnoreCheckItemsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CheckAndRiskTypeList'] = []
        if self.check_and_risk_type_list is not None:
            for k in self.check_and_risk_type_list:
                result['CheckAndRiskTypeList'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.check_and_risk_type_list = []
        if m.get('CheckAndRiskTypeList') is not None:
            for k in m.get('CheckAndRiskTypeList'):
                temp_model = IgnoreCheckItemsRequestCheckAndRiskTypeList()
                self.check_and_risk_type_list.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class IgnoreCheckItemsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(IgnoreCheckItemsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class IgnoreCheckItemsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: IgnoreCheckItemsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(IgnoreCheckItemsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = IgnoreCheckItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class IgnoreHcCheckWarningsRequest(TeaModel):
    def __init__(self, check_ids=None, check_warning_ids=None, reason=None, risk_id=None, source_ip=None, type=None):
        # The ID of the check item.
        # 
        # >  You can call the [DescribeCheckWarnings](~~DescribeCheckWarnings~~) operation to query the IDs of check items.
        self.check_ids = check_ids  # type: str
        # The ID of the alert that is triggered by the check item. Separate multiple IDs with commas (,).
        # 
        # >  You can call the [DescribeCheckWarnings](~~DescribeCheckWarnings~~) operation to query the IDs of alerts that are triggered by check items.
        self.check_warning_ids = check_warning_ids  # type: str
        # The reason for the current operation.
        self.reason = reason  # type: str
        # The ID of the risk item that you want to ignore or cancel ignoring.
        # 
        # >  You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.
        self.risk_id = risk_id  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the operation that you want to perform. Valid values:
        # 
        # *   **1**: ignores a risk item
        # *   **2**: cancels ignoring a risk item
        self.type = type  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(IgnoreHcCheckWarningsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.check_warning_ids is not None:
            result['CheckWarningIds'] = self.check_warning_ids
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('CheckWarningIds') is not None:
            self.check_warning_ids = m.get('CheckWarningIds')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class IgnoreHcCheckWarningsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(IgnoreHcCheckWarningsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class IgnoreHcCheckWarningsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: IgnoreHcCheckWarningsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(IgnoreHcCheckWarningsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = IgnoreHcCheckWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallBackupClientRequest(TeaModel):
    def __init__(self, policy_version=None, uuid=None, uuid_list=None):
        # The version of the anti-ransomware policy. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies. Valid values:
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        self.policy_version = policy_version  # type: str
        # The UUID of the server on which you want to install the anti-ransomware agent.
        # 
        # >  You must specify at least one of the UuidList and Uuid parameters.
        self.uuid = uuid  # type: str
        # The UUIDs of servers on which you want to install the anti-ransomware agent.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallBackupClientRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class InstallBackupClientResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallBackupClientResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallBackupClientResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InstallBackupClientResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InstallBackupClientResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallBackupClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallCloudMonitorRequest(TeaModel):
    def __init__(self, agent_access_key=None, agent_secret_key=None, argus_version=None, instance_id_list=None,
                 uuid_list=None):
        # The AccessKey ID that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](~~114948~~) operation to query the AccessKey ID.
        # 
        # >  This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.
        self.agent_access_key = agent_access_key  # type: str
        # The AccessKey secret that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](~~114948~~) operation to query the AccessKey secret.
        # 
        # >  This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.
        self.agent_secret_key = agent_secret_key  # type: str
        # The version of the CloudMonitor agent that you want to install on the servers. For more information about the latest version of the CloudMonitor agent, see [Overview](~~183431~~).
        self.argus_version = argus_version  # type: str
        # The IDs of the servers on which you want to install the CloudMonitor agent. Separate multiple IDs with commas (,).
        self.instance_id_list = instance_id_list  # type: list[str]
        # The UUIDs of the servers on which you want to install the CloudMonitor agent. Separate multiple UUIDs with commas (,).
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallCloudMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_access_key is not None:
            result['AgentAccessKey'] = self.agent_access_key
        if self.agent_secret_key is not None:
            result['AgentSecretKey'] = self.agent_secret_key
        if self.argus_version is not None:
            result['ArgusVersion'] = self.argus_version
        if self.instance_id_list is not None:
            result['InstanceIdList'] = self.instance_id_list
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AgentAccessKey') is not None:
            self.agent_access_key = m.get('AgentAccessKey')
        if m.get('AgentSecretKey') is not None:
            self.agent_secret_key = m.get('AgentSecretKey')
        if m.get('ArgusVersion') is not None:
            self.argus_version = m.get('ArgusVersion')
        if m.get('InstanceIdList') is not None:
            self.instance_id_list = m.get('InstanceIdList')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class InstallCloudMonitorResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        # The error code returned if the request fails.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallCloudMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallCloudMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InstallCloudMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InstallCloudMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallCloudMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallUniBackupAgentRequest(TeaModel):
    def __init__(self, policy_id=None):
        self.policy_id = policy_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallUniBackupAgentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class InstallUniBackupAgentResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallUniBackupAgentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallUniBackupAgentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InstallUniBackupAgentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InstallUniBackupAgentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallUniBackupAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinWebLockProcessWhiteListRequest(TeaModel):
    def __init__(self, process_paths=None, uuids=None):
        self.process_paths = process_paths  # type: list[str]
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinWebLockProcessWhiteListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.process_paths is not None:
            result['ProcessPaths'] = self.process_paths
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProcessPaths') is not None:
            self.process_paths = m.get('ProcessPaths')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class JoinWebLockProcessWhiteListResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinWebLockProcessWhiteListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinWebLockProcessWhiteListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: JoinWebLockProcessWhiteListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(JoinWebLockProcessWhiteListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinWebLockProcessWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAvailableHoneypotRequest(TeaModel):
    def __init__(self, node_id=None):
        # The ID of the management node to which the honeypot is deployed.
        self.node_id = node_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAvailableHoneypotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ListAvailableHoneypotResponseBodyData(TeaModel):
    def __init__(self, honeypot_image_display_name=None, honeypot_image_id=None, honeypot_image_name=None,
                 honeypot_image_type=None, honeypot_image_version=None, multiports=None, proto=None, service_port=None, template=None):
        # The display name of the image that is used for the honeypot.
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        # The ID of the image that is used for the honeypot.
        self.honeypot_image_id = honeypot_image_id  # type: str
        # The name of the image that is used for the honeypot.
        self.honeypot_image_name = honeypot_image_name  # type: str
        # The type of the image that is used for the honeypot.
        self.honeypot_image_type = honeypot_image_type  # type: str
        # The version of the image that is used for the honeypot.
        self.honeypot_image_version = honeypot_image_version  # type: str
        # The port that is supported by the honeypot. The value is in the JSON format. The value contains the following fields:
        # 
        # *   **log_type**: the log type
        # *   **proto**: the supported protocol
        # *   **description**: the description
        # *   **ports**: the supported ports
        # *   **port_str**: the supported port number of the string type
        # *   **type**: the type
        self.multiports = multiports  # type: str
        # The protocol that is supported by the honeypot.
        self.proto = proto  # type: str
        # The service port of the honeypot.
        self.service_port = service_port  # type: str
        # The configuration template of the honeypot.
        self.template = template  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAvailableHoneypotResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_image_type is not None:
            result['HoneypotImageType'] = self.honeypot_image_type
        if self.honeypot_image_version is not None:
            result['HoneypotImageVersion'] = self.honeypot_image_version
        if self.multiports is not None:
            result['Multiports'] = self.multiports
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.service_port is not None:
            result['ServicePort'] = self.service_port
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotImageType') is not None:
            self.honeypot_image_type = m.get('HoneypotImageType')
        if m.get('HoneypotImageVersion') is not None:
            self.honeypot_image_version = m.get('HoneypotImageVersion')
        if m.get('Multiports') is not None:
            self.multiports = m.get('Multiports')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('ServicePort') is not None:
            self.service_port = m.get('ServicePort')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class ListAvailableHoneypotResponseBody(TeaModel):
    def __init__(self, code=None, count=None, data=None, http_status_code=None, message=None, request_id=None,
                 success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The number of images that are used for the honeypot.
        self.count = count  # type: int
        # An array consisting of the information about the images that are used for the honeypot.
        self.data = data  # type: list[ListAvailableHoneypotResponseBodyData]
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListAvailableHoneypotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAvailableHoneypotResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAvailableHoneypotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListAvailableHoneypotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListAvailableHoneypotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAvailableHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckInstanceResultRequest(TeaModel):
    def __init__(self, check_id=None, current_page=None, instance_id_key=None, instance_ids=None,
                 instance_name_key=None, lang=None, page_size=None, region_id_key=None, sort_types=None, statuses=None):
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The instance ID of the check item.
        self.instance_id_key = instance_id_key  # type: str
        # The instance IDs of cloud services.
        self.instance_ids = instance_ids  # type: list[str]
        # The instance name of the check item.
        self.instance_name_key = instance_name_key  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The region ID of the instance.
        self.region_id_key = region_id_key  # type: str
        # The type of the condition based on which the check items are sorted. Set the value to **STATUS**.
        self.sort_types = sort_types  # type: list[str]
        # The statuses of check items.
        self.statuses = statuses  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckInstanceResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id_key is not None:
            result['InstanceIdKey'] = self.instance_id_key
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_name_key is not None:
            result['InstanceNameKey'] = self.instance_name_key
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_key is not None:
            result['RegionIdKey'] = self.region_id_key
        if self.sort_types is not None:
            result['SortTypes'] = self.sort_types
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIdKey') is not None:
            self.instance_id_key = m.get('InstanceIdKey')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceNameKey') is not None:
            self.instance_name_key = m.get('InstanceNameKey')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdKey') is not None:
            self.region_id_key = m.get('RegionIdKey')
        if m.get('SortTypes') is not None:
            self.sort_types = m.get('SortTypes')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        return self


class ListCheckInstanceResultResponseBodyBasicData(TeaModel):
    def __init__(self, id=None, instance_id=None, instance_name=None, region_id=None, status=None):
        # The ID of the check result for the instance.
        self.id = id  # type: long
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The statuses of check items. Multiple statuses are separated by commas (,). Valid values:
        # 
        # *   **PASS**\
        # *   **NOT_PASS**\
        # *   **CHECKING**\
        # *   **NOT_CHECK**\
        # *   **WHITELIST**\
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckInstanceResultResponseBodyBasicData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCheckInstanceResultResponseBodyColumnsGrids(TeaModel):
    def __init__(self, key=None, show_name=None, type=None):
        # The search condition.
        self.key = key  # type: str
        # The display name of the search condition.
        self.show_name = show_name  # type: str
        # The format of the check results for the instances. Valid values:
        # 
        # *   **text**\
        # *   **link**\
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckInstanceResultResponseBodyColumnsGrids, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckInstanceResultResponseBodyColumns(TeaModel):
    def __init__(self, grids=None, key=None, search=None, search_key=None, show_name=None, type=None):
        # The metadata information about the details of the instances.
        self.grids = grids  # type: list[ListCheckInstanceResultResponseBodyColumnsGrids]
        # The search condition.
        self.key = key  # type: str
        # Indicates whether the search condition is used. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.search = search  # type: bool
        # The value of the search condition.
        self.search_key = search_key  # type: str
        # The display name of the search condition.
        self.show_name = show_name  # type: str
        # The format of the check results for the instances. Valid values:
        # 
        # *   **text**\
        # *   **link**\
        self.type = type  # type: str

    def validate(self):
        if self.grids:
            for k in self.grids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCheckInstanceResultResponseBodyColumns, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Grids'] = []
        if self.grids is not None:
            for k in self.grids:
                result['Grids'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.search is not None:
            result['Search'] = self.search
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.grids = []
        if m.get('Grids') is not None:
            for k in m.get('Grids'):
                temp_model = ListCheckInstanceResultResponseBodyColumnsGrids()
                self.grids.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Search') is not None:
            self.search = m.get('Search')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckInstanceResultResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: str
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckInstanceResultResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckInstanceResultResponseBody(TeaModel):
    def __init__(self, basic_data=None, checks=None, columns=None, page_info=None, request_id=None):
        # An array that consists of the basic information about the instances.
        self.basic_data = basic_data  # type: list[ListCheckInstanceResultResponseBodyBasicData]
        # The extended information about the instances.
        self.checks = checks  # type: list[dict[str, any]]
        # The metadata information about the search conditions that can be used to filter instances.
        self.columns = columns  # type: list[ListCheckInstanceResultResponseBodyColumns]
        # The pagination information.
        self.page_info = page_info  # type: ListCheckInstanceResultResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.basic_data:
            for k in self.basic_data:
                if k:
                    k.validate()
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListCheckInstanceResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BasicData'] = []
        if self.basic_data is not None:
            for k in self.basic_data:
                result['BasicData'].append(k.to_map() if k else None)
        if self.checks is not None:
            result['Checks'] = self.checks
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.basic_data = []
        if m.get('BasicData') is not None:
            for k in m.get('BasicData'):
                temp_model = ListCheckInstanceResultResponseBodyBasicData()
                self.basic_data.append(temp_model.from_map(k))
        if m.get('Checks') is not None:
            self.checks = m.get('Checks')
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = ListCheckInstanceResultResponseBodyColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckInstanceResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckInstanceResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCheckInstanceResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCheckInstanceResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckInstanceResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckItemWarningMachineRequest(TeaModel):
    def __init__(self, check_id=None, container_field_name=None, container_field_value=None, current_page=None,
                 group_id=None, lang=None, page_size=None, remark=None, risk_type=None, status=None):
        self.check_id = check_id  # type: long
        self.container_field_name = container_field_name  # type: str
        self.container_field_value = container_field_value  # type: str
        self.current_page = current_page  # type: int
        self.group_id = group_id  # type: long
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.remark = remark  # type: str
        self.risk_type = risk_type  # type: str
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningMachineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCheckItemWarningMachineResponseBodyListFixList(TeaModel):
    def __init__(self, risk_id=None, risk_name=None):
        self.risk_id = risk_id  # type: long
        self.risk_name = risk_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponseBodyListFixList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class ListCheckItemWarningMachineResponseBodyListWarningRiskList(TeaModel):
    def __init__(self, risk_id=None, risk_name=None):
        self.risk_id = risk_id  # type: long
        self.risk_name = risk_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponseBodyListWarningRiskList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_id is not None:
            result['RiskId'] = self.risk_id
        if self.risk_name is not None:
            result['RiskName'] = self.risk_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskId') is not None:
            self.risk_id = m.get('RiskId')
        if m.get('RiskName') is not None:
            self.risk_name = m.get('RiskName')
        return self


class ListCheckItemWarningMachineResponseBodyList(TeaModel):
    def __init__(self, auth_version=None, bind=None, fix_list=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, port_open=None, prompt=None, region_id=None, status=None, uuid=None,
                 warning_risk_list=None):
        self.auth_version = auth_version  # type: int
        self.bind = bind  # type: bool
        self.fix_list = fix_list  # type: list[ListCheckItemWarningMachineResponseBodyListFixList]
        self.instance_id = instance_id  # type: str
        self.instance_name = instance_name  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.port_open = port_open  # type: bool
        self.prompt = prompt  # type: str
        self.region_id = region_id  # type: str
        self.status = status  # type: int
        self.uuid = uuid  # type: str
        self.warning_risk_list = warning_risk_list  # type: list[ListCheckItemWarningMachineResponseBodyListWarningRiskList]

    def validate(self):
        if self.fix_list:
            for k in self.fix_list:
                if k:
                    k.validate()
        if self.warning_risk_list:
            for k in self.warning_risk_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_version is not None:
            result['AuthVersion'] = self.auth_version
        if self.bind is not None:
            result['Bind'] = self.bind
        result['FixList'] = []
        if self.fix_list is not None:
            for k in self.fix_list:
                result['FixList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.port_open is not None:
            result['PortOpen'] = self.port_open
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        result['WarningRiskList'] = []
        if self.warning_risk_list is not None:
            for k in self.warning_risk_list:
                result['WarningRiskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthVersion') is not None:
            self.auth_version = m.get('AuthVersion')
        if m.get('Bind') is not None:
            self.bind = m.get('Bind')
        self.fix_list = []
        if m.get('FixList') is not None:
            for k in m.get('FixList'):
                temp_model = ListCheckItemWarningMachineResponseBodyListFixList()
                self.fix_list.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('PortOpen') is not None:
            self.port_open = m.get('PortOpen')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        self.warning_risk_list = []
        if m.get('WarningRiskList') is not None:
            for k in m.get('WarningRiskList'):
                temp_model = ListCheckItemWarningMachineResponseBodyListWarningRiskList()
                self.warning_risk_list.append(temp_model.from_map(k))
        return self


class ListCheckItemWarningMachineResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckItemWarningMachineResponseBody(TeaModel):
    def __init__(self, list=None, page_info=None, request_id=None):
        self.list = list  # type: list[ListCheckItemWarningMachineResponseBodyList]
        self.page_info = page_info  # type: ListCheckItemWarningMachineResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCheckItemWarningMachineResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckItemWarningMachineResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckItemWarningMachineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCheckItemWarningMachineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCheckItemWarningMachineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckItemWarningMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckItemWarningSummaryRequest(TeaModel):
    def __init__(self, check_item_fuzzy=None, check_level=None, check_type=None, check_warning_status=None,
                 container_field_name=None, container_field_value=None, current_page=None, group_id=None, lang=None, page_size=None,
                 risk_type=None):
        self.check_item_fuzzy = check_item_fuzzy  # type: str
        self.check_level = check_level  # type: str
        self.check_type = check_type  # type: str
        self.check_warning_status = check_warning_status  # type: int
        self.container_field_name = container_field_name  # type: str
        self.container_field_value = container_field_value  # type: str
        self.current_page = current_page  # type: int
        self.group_id = group_id  # type: long
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.risk_type = risk_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_item_fuzzy is not None:
            result['CheckItemFuzzy'] = self.check_item_fuzzy
        if self.check_level is not None:
            result['CheckLevel'] = self.check_level
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.check_warning_status is not None:
            result['CheckWarningStatus'] = self.check_warning_status
        if self.container_field_name is not None:
            result['ContainerFieldName'] = self.container_field_name
        if self.container_field_value is not None:
            result['ContainerFieldValue'] = self.container_field_value
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckItemFuzzy') is not None:
            self.check_item_fuzzy = m.get('CheckItemFuzzy')
        if m.get('CheckLevel') is not None:
            self.check_level = m.get('CheckLevel')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('CheckWarningStatus') is not None:
            self.check_warning_status = m.get('CheckWarningStatus')
        if m.get('ContainerFieldName') is not None:
            self.container_field_name = m.get('ContainerFieldName')
        if m.get('ContainerFieldValue') is not None:
            self.container_field_value = m.get('ContainerFieldValue')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        return self


class ListCheckItemWarningSummaryResponseBodyList(TeaModel):
    def __init__(self, advice=None, alias=None, check_id=None, check_item=None, check_level=None, check_type=None,
                 description=None, risk_type=None, status=None, warning_machine_count=None):
        self.advice = advice  # type: str
        self.alias = alias  # type: str
        self.check_id = check_id  # type: long
        self.check_item = check_item  # type: str
        self.check_level = check_level  # type: str
        self.check_type = check_type  # type: str
        self.description = description  # type: str
        self.risk_type = risk_type  # type: str
        self.status = status  # type: int
        self.warning_machine_count = warning_machine_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningSummaryResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advice is not None:
            result['Advice'] = self.advice
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.check_item is not None:
            result['CheckItem'] = self.check_item
        if self.check_level is not None:
            result['CheckLevel'] = self.check_level
        if self.check_type is not None:
            result['CheckType'] = self.check_type
        if self.description is not None:
            result['Description'] = self.description
        if self.risk_type is not None:
            result['RiskType'] = self.risk_type
        if self.status is not None:
            result['Status'] = self.status
        if self.warning_machine_count is not None:
            result['WarningMachineCount'] = self.warning_machine_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Advice') is not None:
            self.advice = m.get('Advice')
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('CheckItem') is not None:
            self.check_item = m.get('CheckItem')
        if m.get('CheckLevel') is not None:
            self.check_level = m.get('CheckLevel')
        if m.get('CheckType') is not None:
            self.check_type = m.get('CheckType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RiskType') is not None:
            self.risk_type = m.get('RiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WarningMachineCount') is not None:
            self.warning_machine_count = m.get('WarningMachineCount')
        return self


class ListCheckItemWarningSummaryResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckItemWarningSummaryResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckItemWarningSummaryResponseBody(TeaModel):
    def __init__(self, list=None, page_info=None, request_id=None):
        self.list = list  # type: list[ListCheckItemWarningSummaryResponseBodyList]
        self.page_info = page_info  # type: ListCheckItemWarningSummaryResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListCheckItemWarningSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCheckItemWarningSummaryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckItemWarningSummaryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckItemWarningSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCheckItemWarningSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCheckItemWarningSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckItemWarningSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckResultRequest(TeaModel):
    def __init__(self, check_key=None, current_page=None, instance_ids=None, instance_types=None, lang=None,
                 page_size=None, requirement_ids=None, risk_levels=None, sort_types=None, standard_ids=None, statuses=None,
                 vendors=None):
        # The key that you want to use to search for check items in fuzzy match mode.
        self.check_key = check_key  # type: str
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The instance IDs of the cloud services that you want to query. Separate multiple IDs with commas (,).
        self.instance_ids = instance_ids  # type: list[str]
        # The asset types of cloud services. Valid values:
        # 
        # *   **ECS**: Elastic Compute Service (ECS)
        # *   **SLB**: Server Load Balancer (SLB)
        # *   **RDS**: ApsaraDB RDS
        # *   **MONGODB**: ApsaraDB for MongoDB (MongoDB)
        # *   **KVSTORE**: ApsaraDB for Redis (Redis)
        # *   **ACR**: Container Registry
        # *   **CSK**: Container Service for Kubernetes (ACK)
        # *   **VPC**: Virtual Private Cloud (VPC)
        # *   **ACTIONTRAIL**: ActionTrail
        # *   **CDN**: Alibaba Cloud CDN (CDN)
        # *   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **RDC**: Apsara Devops
        # *   **RAM**: Resource Access Management (RAM)
        # *   **DDOS**: Anti-DDoS
        # *   **WAF**: Web Application Firewall (WAF)
        # *   **OSS**: Object Storage Service (OSS)
        # *   **POLARDB**: PolarDB
        # *   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
        # *   **MSE**: Microservices Engine (MSE)
        # *   **NAS**: Apsara File Storage NAS (NAS)
        # *   **SDDP**: Sensitive Data Discovery and Protection (SDDP)
        # *   **EIP**: Elastic IP Address (EIP)
        self.instance_types = instance_types  # type: list[str]
        # The language of the content within the request and the response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The IDs of requirement items.
        self.requirement_ids = requirement_ids  # type: list[long]
        # The severities of check items. Separate multiple severities with commas (,). Valid values:
        # 
        # *   **HIGH**\
        # *   **MEDIUM**\
        # *   **LOW**\
        self.risk_levels = risk_levels  # type: list[str]
        # The types of the conditions based on which check items are sorted. Valid values:
        # 
        # *   **RISK_LEVEL**: risk level
        # *   **STATUS**: state
        self.sort_types = sort_types  # type: list[str]
        # The IDs of standards.
        self.standard_ids = standard_ids  # type: list[long]
        # The states of check items. Separate multiple states with commas (,). Valid values:
        # 
        # *   **PASS**\
        # *   **NOT_PASS**\
        # *   **CHECKING**\
        # *   **NOT_CHECK**\
        # *   **WHITELIST**\
        self.statuses = statuses  # type: list[str]
        # The cloud service providers. Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        self.vendors = vendors  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_key is not None:
            result['CheckKey'] = self.check_key
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.requirement_ids is not None:
            result['RequirementIds'] = self.requirement_ids
        if self.risk_levels is not None:
            result['RiskLevels'] = self.risk_levels
        if self.sort_types is not None:
            result['SortTypes'] = self.sort_types
        if self.standard_ids is not None:
            result['StandardIds'] = self.standard_ids
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckKey') is not None:
            self.check_key = m.get('CheckKey')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequirementIds') is not None:
            self.requirement_ids = m.get('RequirementIds')
        if m.get('RiskLevels') is not None:
            self.risk_levels = m.get('RiskLevels')
        if m.get('SortTypes') is not None:
            self.sort_types = m.get('SortTypes')
        if m.get('StandardIds') is not None:
            self.standard_ids = m.get('StandardIds')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class ListCheckResultResponseBodyChecksCheckPolicies(TeaModel):
    def __init__(self, requirement_id=None, requirement_show_name=None, section_id=None, section_show_name=None,
                 standard_id=None, standard_show_name=None):
        # The requirement item ID of the check item.
        self.requirement_id = requirement_id  # type: long
        # The item display name of the check item.
        self.requirement_show_name = requirement_show_name  # type: str
        # The section ID of the check item.
        self.section_id = section_id  # type: long
        # The section display name of the check item.
        self.section_show_name = section_show_name  # type: str
        # The standard ID of the check item.
        self.standard_id = standard_id  # type: long
        # The standard display name of the check item.
        self.standard_show_name = standard_show_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckResultResponseBodyChecksCheckPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requirement_id is not None:
            result['RequirementId'] = self.requirement_id
        if self.requirement_show_name is not None:
            result['RequirementShowName'] = self.requirement_show_name
        if self.section_id is not None:
            result['SectionId'] = self.section_id
        if self.section_show_name is not None:
            result['SectionShowName'] = self.section_show_name
        if self.standard_id is not None:
            result['StandardId'] = self.standard_id
        if self.standard_show_name is not None:
            result['StandardShowName'] = self.standard_show_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequirementId') is not None:
            self.requirement_id = m.get('RequirementId')
        if m.get('RequirementShowName') is not None:
            self.requirement_show_name = m.get('RequirementShowName')
        if m.get('SectionId') is not None:
            self.section_id = m.get('SectionId')
        if m.get('SectionShowName') is not None:
            self.section_show_name = m.get('SectionShowName')
        if m.get('StandardId') is not None:
            self.standard_id = m.get('StandardId')
        if m.get('StandardShowName') is not None:
            self.standard_show_name = m.get('StandardShowName')
        return self


class ListCheckResultResponseBodyChecks(TeaModel):
    def __init__(self, check_id=None, check_policies=None, check_show_name=None, instance_sub_type=None,
                 instance_type=None, last_check_time=None, risk_level=None, status=None, task_id=None, trial_permission=None,
                 vendor=None, vendor_show_name=None):
        # The ID of the check item.
        self.check_id = check_id  # type: long
        # The check policies.
        self.check_policies = check_policies  # type: list[ListCheckResultResponseBodyChecksCheckPolicies]
        # The name of the check item.
        self.check_show_name = check_show_name  # type: str
        # The asset subtype of the cloud service. Valid values:
        # 
        # *   If the **InstanceType** parameter is set to **ECS**, this parameter supports the following valid values:
        # 
        #     *   **INSTANCE**\
        #     *   **DISK**\
        #     *   **SECURITY_GROUP**\
        # 
        # *   If the **InstanceType** parameter is set to **ACR**, this parameter supports the following valid values:
        # 
        #     *   **REPOSITORY_ENTERPRISE**\
        #     *   **REPOSITORY_PERSON**\
        # 
        # *   If the **InstanceType** parameter is set to **RAM**, this parameter supports the following valid values:
        # 
        #     *   **ALIAS**\
        #     *   **USER**\
        #     *   **POLICY**\
        #     *   **GROUP**\
        # 
        # *   If the **InstanceType** parameter is set to **WAF**, this parameter supports the following valid values:
        # 
        #     *   **DOMAIN**\
        # 
        # *   If the **InstanceType** parameter is set to other values, this parameter supports the following valid values:
        # 
        #     *   **INSTANCE**\
        self.instance_sub_type = instance_sub_type  # type: str
        # The asset type of the cloud service. Valid values:
        # 
        # *   **ECS**: ECS
        # *   **SLB**: SLB
        # *   **RDS**: ApsaraDB RDS
        # *   **MONGODB**: MongoDB
        # *   **KVSTORE**: Redis
        # *   **ACR**: Container Registry
        # *   **CSK**: ACK
        # *   **VPC**: VPC
        # *   **ACTIONTRAIL**: ActionTrail
        # *   **CDN**: CDN
        # *   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **RDC**: Apsara Devops
        # *   **RAM**: RAM
        # *   **DDOS**: Anti-DDoS
        # *   **WAF**: WAF
        # *   **OSS**: OSS
        # *   **POLARDB**: PolarDB
        # *   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
        # *   **MSE**: MSE
        # *   **NAS**: NAS
        # *   **SDDP**: SDDP
        # *   **EIP**: EIP
        self.instance_type = instance_type  # type: str
        # The timestamp when the last check was performed. Unit: milliseconds.
        self.last_check_time = last_check_time  # type: long
        # The risk level of the check item. Valid values:
        # 
        # *   **HIGH**\
        # *   **MEDIUM**\
        # *   **LOW**\
        self.risk_level = risk_level  # type: str
        # The state of the check item. Valid values:
        # 
        # *   **PASS**\
        # *   **NOT_PASS**\
        # *   **CHECKING**\
        # *   **NOT_CHECK**\
        # *   **WHITELIST**\
        self.status = status  # type: str
        # The ID of the check task.
        self.task_id = task_id  # type: str
        # The flag that whether this check item needs trial permission.
        self.trial_permission = trial_permission  # type: bool
        # The value of the cloud service provider.
        self.vendor = vendor  # type: str
        # The name of the cloud service provider.
        self.vendor_show_name = vendor_show_name  # type: str

    def validate(self):
        if self.check_policies:
            for k in self.check_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCheckResultResponseBodyChecks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        result['CheckPolicies'] = []
        if self.check_policies is not None:
            for k in self.check_policies:
                result['CheckPolicies'].append(k.to_map() if k else None)
        if self.check_show_name is not None:
            result['CheckShowName'] = self.check_show_name
        if self.instance_sub_type is not None:
            result['InstanceSubType'] = self.instance_sub_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.last_check_time is not None:
            result['LastCheckTime'] = self.last_check_time
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trial_permission is not None:
            result['TrialPermission'] = self.trial_permission
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_show_name is not None:
            result['VendorShowName'] = self.vendor_show_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        self.check_policies = []
        if m.get('CheckPolicies') is not None:
            for k in m.get('CheckPolicies'):
                temp_model = ListCheckResultResponseBodyChecksCheckPolicies()
                self.check_policies.append(temp_model.from_map(k))
        if m.get('CheckShowName') is not None:
            self.check_show_name = m.get('CheckShowName')
        if m.get('InstanceSubType') is not None:
            self.instance_sub_type = m.get('InstanceSubType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('LastCheckTime') is not None:
            self.last_check_time = m.get('LastCheckTime')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TrialPermission') is not None:
            self.trial_permission = m.get('TrialPermission')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorShowName') is not None:
            self.vendor_show_name = m.get('VendorShowName')
        return self


class ListCheckResultResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckResultResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCheckResultResponseBody(TeaModel):
    def __init__(self, checks=None, page_info=None, request_id=None):
        # An array that consists of the check items.
        self.checks = checks  # type: list[ListCheckResultResponseBodyChecks]
        # The pagination information.
        self.page_info = page_info  # type: ListCheckResultResponseBodyPageInfo
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.checks:
            for k in self.checks:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListCheckResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Checks'] = []
        if self.checks is not None:
            for k in self.checks:
                result['Checks'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.checks = []
        if m.get('Checks') is not None:
            for k in m.get('Checks'):
                temp_model = ListCheckResultResponseBodyChecks()
                self.checks.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListCheckResultResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCheckResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCheckResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCheckResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckStandardRequest(TeaModel):
    def __init__(self, instance_ids=None, instance_sub_types=None, instance_types=None, lang=None, vendors=None):
        self.instance_ids = instance_ids  # type: list[str]
        self.instance_sub_types = instance_sub_types  # type: list[str]
        self.instance_types = instance_types  # type: list[str]
        self.lang = lang  # type: str
        self.vendors = vendors  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckStandardRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_sub_types is not None:
            result['InstanceSubTypes'] = self.instance_sub_types
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.vendors is not None:
            result['Vendors'] = self.vendors
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceSubTypes') is not None:
            self.instance_sub_types = m.get('InstanceSubTypes')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Vendors') is not None:
            self.vendors = m.get('Vendors')
        return self


class ListCheckStandardResponseBodyStandardsRequirements(TeaModel):
    def __init__(self, id=None, risk_check_count=None, show_name=None):
        self.id = id  # type: long
        self.risk_check_count = risk_check_count  # type: long
        self.show_name = show_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCheckStandardResponseBodyStandardsRequirements, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.risk_check_count is not None:
            result['RiskCheckCount'] = self.risk_check_count
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RiskCheckCount') is not None:
            self.risk_check_count = m.get('RiskCheckCount')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        return self


class ListCheckStandardResponseBodyStandards(TeaModel):
    def __init__(self, id=None, requirements=None, show_name=None, type=None):
        self.id = id  # type: long
        self.requirements = requirements  # type: list[ListCheckStandardResponseBodyStandardsRequirements]
        self.show_name = show_name  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.requirements:
            for k in self.requirements:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCheckStandardResponseBodyStandards, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        result['Requirements'] = []
        if self.requirements is not None:
            for k in self.requirements:
                result['Requirements'].append(k.to_map() if k else None)
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.requirements = []
        if m.get('Requirements') is not None:
            for k in m.get('Requirements'):
                temp_model = ListCheckStandardResponseBodyStandardsRequirements()
                self.requirements.append(temp_model.from_map(k))
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCheckStandardResponseBody(TeaModel):
    def __init__(self, request_id=None, standards=None):
        self.request_id = request_id  # type: str
        self.standards = standards  # type: list[ListCheckStandardResponseBodyStandards]

    def validate(self):
        if self.standards:
            for k in self.standards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCheckStandardResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Standards'] = []
        if self.standards is not None:
            for k in self.standards:
                result['Standards'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standards = []
        if m.get('Standards') is not None:
            for k in m.get('Standards'):
                temp_model = ListCheckStandardResponseBodyStandards()
                self.standards.append(temp_model.from_map(k))
        return self


class ListCheckStandardResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCheckStandardResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCheckStandardResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckStandardResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClientUserDefineRuleTypesResponseBody(TeaModel):
    def __init__(self, request_id=None, user_define_rule_types=None):
        self.request_id = request_id  # type: str
        self.user_define_rule_types = user_define_rule_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClientUserDefineRuleTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_define_rule_types is not None:
            result['UserDefineRuleTypes'] = self.user_define_rule_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDefineRuleTypes') is not None:
            self.user_define_rule_types = m.get('UserDefineRuleTypes')
        return self


class ListClientUserDefineRuleTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListClientUserDefineRuleTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListClientUserDefineRuleTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClientUserDefineRuleTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClientUserDefineRulesRequest(TeaModel):
    def __init__(self, current_page=None, name=None, page_size=None, type=None):
        self.current_page = current_page  # type: int
        self.name = name  # type: str
        self.page_size = page_size  # type: int
        self.type = type  # type: list[int]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClientUserDefineRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListClientUserDefineRulesResponseBodyPageInfo(TeaModel):
    def __init__(self, current_page=None, page_size=None, total_count=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClientUserDefineRulesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListClientUserDefineRulesResponseBodyUserDefineRuleList(TeaModel):
    def __init__(self, action_type=None, id=None, name=None, platform=None, switch_id=None, type=None):
        self.action_type = action_type  # type: int
        self.id = id  # type: long
        self.name = name  # type: str
        self.platform = platform  # type: str
        self.switch_id = switch_id  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClientUserDefineRulesResponseBodyUserDefineRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListClientUserDefineRulesResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, user_define_rule_list=None):
        self.page_info = page_info  # type: ListClientUserDefineRulesResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.user_define_rule_list = user_define_rule_list  # type: list[ListClientUserDefineRulesResponseBodyUserDefineRuleList]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.user_define_rule_list:
            for k in self.user_define_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListClientUserDefineRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UserDefineRuleList'] = []
        if self.user_define_rule_list is not None:
            for k in self.user_define_rule_list:
                result['UserDefineRuleList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListClientUserDefineRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.user_define_rule_list = []
        if m.get('UserDefineRuleList') is not None:
            for k in m.get('UserDefineRuleList'):
                temp_model = ListClientUserDefineRulesResponseBodyUserDefineRuleList()
                self.user_define_rule_list.append(temp_model.from_map(k))
        return self


class ListClientUserDefineRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListClientUserDefineRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListClientUserDefineRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClientUserDefineRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterCnnfStatusDetailRequest(TeaModel):
    def __init__(self, cluster_ids=None):
        self.cluster_ids = cluster_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClusterCnnfStatusDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        return self


class ListClusterCnnfStatusDetailResponseBodyData(TeaModel):
    def __init__(self, cluster_id=None, installed=None, instance_id=None, internet_ip=None, intranet_ip=None,
                 invalid_type=None, machine_name=None, machine_type=None, plugin_name=None, plugin_version=None, status=None,
                 uuid=None):
        self.cluster_id = cluster_id  # type: str
        self.installed = installed  # type: bool
        self.instance_id = instance_id  # type: str
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.invalid_type = invalid_type  # type: str
        self.machine_name = machine_name  # type: str
        self.machine_type = machine_type  # type: int
        self.plugin_name = plugin_name  # type: str
        self.plugin_version = plugin_version  # type: str
        self.status = status  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClusterCnnfStatusDetailResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.installed is not None:
            result['Installed'] = self.installed
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.invalid_type is not None:
            result['InvalidType'] = self.invalid_type
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.machine_type is not None:
            result['MachineType'] = self.machine_type
        if self.plugin_name is not None:
            result['PluginName'] = self.plugin_name
        if self.plugin_version is not None:
            result['PluginVersion'] = self.plugin_version
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Installed') is not None:
            self.installed = m.get('Installed')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('InvalidType') is not None:
            self.invalid_type = m.get('InvalidType')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('MachineType') is not None:
            self.machine_type = m.get('MachineType')
        if m.get('PluginName') is not None:
            self.plugin_name = m.get('PluginName')
        if m.get('PluginVersion') is not None:
            self.plugin_version = m.get('PluginVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListClusterCnnfStatusDetailResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[ListClusterCnnfStatusDetailResponseBodyData]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListClusterCnnfStatusDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListClusterCnnfStatusDetailResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterCnnfStatusDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListClusterCnnfStatusDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListClusterCnnfStatusDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterCnnfStatusDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterInterceptionConfigRequest(TeaModel):
    def __init__(self, cluster_cnnfstatus=None, cluster_id=None, cluster_name=None, current_page=None,
                 page_size=None):
        self.cluster_cnnfstatus = cluster_cnnfstatus  # type: int
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClusterInterceptionConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_cnnfstatus is not None:
            result['ClusterCNNFStatus'] = self.cluster_cnnfstatus
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterCNNFStatus') is not None:
            self.cluster_cnnfstatus = m.get('ClusterCNNFStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListClusterInterceptionConfigResponseBodyClusterConfigList(TeaModel):
    def __init__(self, cluster_cnnfstatus=None, cluster_id=None, cluster_name=None, cluster_type=None,
                 interception_switch=None, open_rule_count=None, support_cnnf=None, total_rule_count=None):
        self.cluster_cnnfstatus = cluster_cnnfstatus  # type: int
        self.cluster_id = cluster_id  # type: str
        self.cluster_name = cluster_name  # type: str
        self.cluster_type = cluster_type  # type: str
        self.interception_switch = interception_switch  # type: int
        self.open_rule_count = open_rule_count  # type: long
        self.support_cnnf = support_cnnf  # type: bool
        self.total_rule_count = total_rule_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClusterInterceptionConfigResponseBodyClusterConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_cnnfstatus is not None:
            result['ClusterCNNFStatus'] = self.cluster_cnnfstatus
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.interception_switch is not None:
            result['InterceptionSwitch'] = self.interception_switch
        if self.open_rule_count is not None:
            result['OpenRuleCount'] = self.open_rule_count
        if self.support_cnnf is not None:
            result['SupportCNNF'] = self.support_cnnf
        if self.total_rule_count is not None:
            result['TotalRuleCount'] = self.total_rule_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterCNNFStatus') is not None:
            self.cluster_cnnfstatus = m.get('ClusterCNNFStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('InterceptionSwitch') is not None:
            self.interception_switch = m.get('InterceptionSwitch')
        if m.get('OpenRuleCount') is not None:
            self.open_rule_count = m.get('OpenRuleCount')
        if m.get('SupportCNNF') is not None:
            self.support_cnnf = m.get('SupportCNNF')
        if m.get('TotalRuleCount') is not None:
            self.total_rule_count = m.get('TotalRuleCount')
        return self


class ListClusterInterceptionConfigResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, currrent_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.currrent_page = currrent_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListClusterInterceptionConfigResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.currrent_page is not None:
            result['CurrrentPage'] = self.currrent_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrrentPage') is not None:
            self.currrent_page = m.get('CurrrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListClusterInterceptionConfigResponseBody(TeaModel):
    def __init__(self, cluster_config_list=None, page_info=None, request_id=None):
        self.cluster_config_list = cluster_config_list  # type: list[ListClusterInterceptionConfigResponseBodyClusterConfigList]
        self.page_info = page_info  # type: ListClusterInterceptionConfigResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cluster_config_list:
            for k in self.cluster_config_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListClusterInterceptionConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterConfigList'] = []
        if self.cluster_config_list is not None:
            for k in self.cluster_config_list:
                result['ClusterConfigList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cluster_config_list = []
        if m.get('ClusterConfigList') is not None:
            for k in m.get('ClusterConfigList'):
                temp_model = ListClusterInterceptionConfigResponseBodyClusterConfigList()
                self.cluster_config_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListClusterInterceptionConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterInterceptionConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListClusterInterceptionConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListClusterInterceptionConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterInterceptionConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotRequest(TeaModel):
    def __init__(self, current_page=None, honeypot_ids=None, honeypot_name=None, node_id=None, node_name=None,
                 page_size=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The IDs of honeypots.
        self.honeypot_ids = honeypot_ids  # type: list[str]
        # The name of the honeypot.
        self.honeypot_name = honeypot_name  # type: str
        # The ID of the management node to which the honeypot belongs.
        self.node_id = node_id  # type: str
        # The name of the management node to which the honeypot belongs.
        self.node_name = node_name  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honeypot_ids is not None:
            result['HoneypotIds'] = self.honeypot_ids
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneypotIds') is not None:
            self.honeypot_ids = m.get('HoneypotIds')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListHoneypotResponseBodyList(TeaModel):
    def __init__(self, control_node_name=None, honeypot_id=None, honeypot_image_display_name=None,
                 honeypot_image_id=None, honeypot_image_name=None, honeypot_name=None, node_id=None, preset_id=None, state=None):
        # The name of the management node to which the honeypot is deployed.
        self.control_node_name = control_node_name  # type: str
        # The ID of the honeypot.
        self.honeypot_id = honeypot_id  # type: str
        # The display name of the image that is used for the honeypot.
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        # The ID of the image that is used for the honeypot.
        self.honeypot_image_id = honeypot_image_id  # type: str
        # The name of the image that is used for the honeypot.
        self.honeypot_image_name = honeypot_image_name  # type: str
        # The name of the honeypot.
        self.honeypot_name = honeypot_name  # type: str
        # The ID of the management node.
        self.node_id = node_id  # type: str
        # The ID of the custom configuration for the honeypot.
        self.preset_id = preset_id  # type: str
        # An array that consists of the status information of the honeypot.
        self.state = state  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_id is not None:
            result['HoneypotImageId'] = self.honeypot_image_id
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageId') is not None:
            self.honeypot_image_id = m.get('HoneypotImageId')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListHoneypotResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, list=None, message=None, page_info=None, request_id=None,
                 success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        self.list = list  # type: list[ListHoneypotResponseBodyList]
        # The error message returned.
        self.message = message  # type: str
        # The pagination information.
        self.page_info = page_info  # type: ListHoneypotResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListHoneypotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListHoneypotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListHoneypotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotAlarmEventsRequest(TeaModel):
    def __init__(self, current_page=None, dealed=None, dst_ip=None, page_size=None, request_id=None,
                 risk_level_list=None, src_ip=None):
        self.current_page = current_page  # type: int
        self.dealed = dealed  # type: str
        self.dst_ip = dst_ip  # type: str
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.risk_level_list = risk_level_list  # type: list[str]
        self.src_ip = src_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.dst_ip is not None:
            result['DstIp'] = self.dst_ip
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.risk_level_list is not None:
            result['RiskLevelList'] = self.risk_level_list
        if self.src_ip is not None:
            result['SrcIp'] = self.src_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('DstIp') is not None:
            self.dst_ip = m.get('DstIp')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RiskLevelList') is not None:
            self.risk_level_list = m.get('RiskLevelList')
        if m.get('SrcIp') is not None:
            self.src_ip = m.get('SrcIp')
        return self


class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList(TeaModel):
    def __init__(self, field_ext_info=None, field_key=None, field_type=None, field_value=None):
        self.field_ext_info = field_ext_info  # type: str
        self.field_key = field_key  # type: str
        self.field_type = field_type  # type: str
        self.field_value = field_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_ext_info is not None:
            result['FieldExtInfo'] = self.field_ext_info
        if self.field_key is not None:
            result['FieldKey'] = self.field_key
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FieldExtInfo') is not None:
            self.field_ext_info = m.get('FieldExtInfo')
        if m.get('FieldKey') is not None:
            self.field_key = m.get('FieldKey')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        return self


class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents(TeaModel):
    def __init__(self, alarm_event_id=None, alarm_event_name=None, alarm_event_type=None, alarm_unique_info=None,
                 event_count=None, first_time=None, last_time=None, merge_field_list=None, operate_status=None, risk_level=None):
        self.alarm_event_id = alarm_event_id  # type: long
        self.alarm_event_name = alarm_event_name  # type: str
        self.alarm_event_type = alarm_event_type  # type: str
        self.alarm_unique_info = alarm_unique_info  # type: str
        self.event_count = event_count  # type: int
        self.first_time = first_time  # type: long
        self.last_time = last_time  # type: long
        self.merge_field_list = merge_field_list  # type: list[ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList]
        self.operate_status = operate_status  # type: int
        self.risk_level = risk_level  # type: str

    def validate(self):
        if self.merge_field_list:
            for k in self.merge_field_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_id is not None:
            result['AlarmEventId'] = self.alarm_event_id
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.event_count is not None:
            result['EventCount'] = self.event_count
        if self.first_time is not None:
            result['FirstTime'] = self.first_time
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        result['MergeFieldList'] = []
        if self.merge_field_list is not None:
            for k in self.merge_field_list:
                result['MergeFieldList'].append(k.to_map() if k else None)
        if self.operate_status is not None:
            result['OperateStatus'] = self.operate_status
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmEventId') is not None:
            self.alarm_event_id = m.get('AlarmEventId')
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('EventCount') is not None:
            self.event_count = m.get('EventCount')
        if m.get('FirstTime') is not None:
            self.first_time = m.get('FirstTime')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        self.merge_field_list = []
        if m.get('MergeFieldList') is not None:
            for k in m.get('MergeFieldList'):
                temp_model = ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList()
                self.merge_field_list.append(temp_model.from_map(k))
        if m.get('OperateStatus') is not None:
            self.operate_status = m.get('OperateStatus')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        return self


class ListHoneypotAlarmEventsResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotAlarmEventsResponseBody(TeaModel):
    def __init__(self, honeypot_alarm_events=None, page_info=None, request_id=None):
        self.honeypot_alarm_events = honeypot_alarm_events  # type: list[ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents]
        self.page_info = page_info  # type: ListHoneypotAlarmEventsResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.honeypot_alarm_events:
            for k in self.honeypot_alarm_events:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HoneypotAlarmEvents'] = []
        if self.honeypot_alarm_events is not None:
            for k in self.honeypot_alarm_events:
                result['HoneypotAlarmEvents'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.honeypot_alarm_events = []
        if m.get('HoneypotAlarmEvents') is not None:
            for k in m.get('HoneypotAlarmEvents'):
                temp_model = ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents()
                self.honeypot_alarm_events.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotAlarmEventsResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHoneypotAlarmEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListHoneypotAlarmEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListHoneypotAlarmEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotAlarmEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotNodeRequest(TeaModel):
    def __init__(self, current_page=None, node_id=None, node_name=None, page_size=None):
        # The number of the page to return.
        self.current_page = current_page  # type: int
        # The ID of the management node.
        self.node_id = node_id  # type: str
        # The name of the management node.
        self.node_name = node_name  # type: str
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListHoneypotNodeResponseBodyHoneypotNodeList(TeaModel):
    def __init__(self, allow_honeypot_access_internet=None, create_time=None, default_node=None,
                 ecs_instance_id=None, honeypot_total_count=None, honeypot_used_count=None, node_id=None, node_ip=None,
                 node_name=None, probe_total_count=None, probe_used_count=None, security_group_probe_ip_list=None,
                 total_status=None, upgrade_available=None):
        # Indicates whether the honeypot is allowed to access the Internet.
        # 
        # *   **true**: The honeypot is allowed to access the Internet.
        # *   **false**: The honeypot is not allowed to access the Internet.
        self.allow_honeypot_access_internet = allow_honeypot_access_internet  # type: bool
        # The time when the management node was created.
        self.create_time = create_time  # type: str
        # The type of the management node. Default value: **false**. Valid values:
        # 
        # *   **false**: non-default type
        # *   **true**: default type
        self.default_node = default_node  # type: bool
        # The ID of the Elastic Compute Service (ECS) instance.
        self.ecs_instance_id = ecs_instance_id  # type: str
        # The maximum number of honeypots that can be deployed on the management node.
        self.honeypot_total_count = honeypot_total_count  # type: int
        # The number of honeypots that are deployed on the management node.
        self.honeypot_used_count = honeypot_used_count  # type: int
        # The ID of the management node.
        self.node_id = node_id  # type: str
        # The IP address of the management node.
        self.node_ip = node_ip  # type: str
        # The name of the management node.
        self.node_name = node_name  # type: str
        # The maximum number of probes that can be used.
        self.probe_total_count = probe_total_count  # type: int
        # The number of probes that are used.
        self.probe_used_count = probe_used_count  # type: int
        # An array that consists of the allowed CIDR blocks.
        self.security_group_probe_ip_list = security_group_probe_ip_list  # type: list[str]
        # The status of the management node. Valid values:
        # 
        # *   **1**: normal
        # *   **2**: abnormal
        self.total_status = total_status  # type: int
        self.upgrade_available = upgrade_available  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotNodeResponseBodyHoneypotNodeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_honeypot_access_internet is not None:
            result['AllowHoneypotAccessInternet'] = self.allow_honeypot_access_internet
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.default_node is not None:
            result['DefaultNode'] = self.default_node
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.honeypot_total_count is not None:
            result['HoneypotTotalCount'] = self.honeypot_total_count
        if self.honeypot_used_count is not None:
            result['HoneypotUsedCount'] = self.honeypot_used_count
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.probe_total_count is not None:
            result['ProbeTotalCount'] = self.probe_total_count
        if self.probe_used_count is not None:
            result['ProbeUsedCount'] = self.probe_used_count
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        if self.total_status is not None:
            result['TotalStatus'] = self.total_status
        if self.upgrade_available is not None:
            result['UpgradeAvailable'] = self.upgrade_available
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowHoneypotAccessInternet') is not None:
            self.allow_honeypot_access_internet = m.get('AllowHoneypotAccessInternet')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DefaultNode') is not None:
            self.default_node = m.get('DefaultNode')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('HoneypotTotalCount') is not None:
            self.honeypot_total_count = m.get('HoneypotTotalCount')
        if m.get('HoneypotUsedCount') is not None:
            self.honeypot_used_count = m.get('HoneypotUsedCount')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('ProbeTotalCount') is not None:
            self.probe_total_count = m.get('ProbeTotalCount')
        if m.get('ProbeUsedCount') is not None:
            self.probe_used_count = m.get('ProbeUsedCount')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        if m.get('TotalStatus') is not None:
            self.total_status = m.get('TotalStatus')
        if m.get('UpgradeAvailable') is not None:
            self.upgrade_available = m.get('UpgradeAvailable')
        return self


class ListHoneypotNodeResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotNodeResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotNodeResponseBody(TeaModel):
    def __init__(self, code=None, honeypot_node_list=None, http_status_code=None, message=None, page_info=None,
                 request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # An array that consists of the information about the management nodes.
        self.honeypot_node_list = honeypot_node_list  # type: list[ListHoneypotNodeResponseBodyHoneypotNodeList]
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The pagination information.
        self.page_info = page_info  # type: ListHoneypotNodeResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.honeypot_node_list:
            for k in self.honeypot_node_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListHoneypotNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['HoneypotNodeList'] = []
        if self.honeypot_node_list is not None:
            for k in self.honeypot_node_list:
                result['HoneypotNodeList'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.honeypot_node_list = []
        if m.get('HoneypotNodeList') is not None:
            for k in m.get('HoneypotNodeList'):
                temp_model = ListHoneypotNodeResponseBodyHoneypotNodeList()
                self.honeypot_node_list.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotNodeResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListHoneypotNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListHoneypotNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotPresetRequest(TeaModel):
    def __init__(self, current_page=None, honeypot_image_name=None, lang=None, node_id=None, node_name=None,
                 page_size=None, preset_name=None):
        self.current_page = current_page  # type: int
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.lang = lang  # type: str
        self.node_id = node_id  # type: str
        self.node_name = node_name  # type: str
        self.page_size = page_size  # type: int
        self.preset_name = preset_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotPresetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class ListHoneypotPresetResponseBodyList(TeaModel):
    def __init__(self, control_node_name=None, honeypot_image_display_name=None, honeypot_image_name=None,
                 honeypot_preset_id=None, node_id=None, preset_name=None, preset_type=None):
        self.control_node_name = control_node_name  # type: str
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.honeypot_preset_id = honeypot_preset_id  # type: str
        self.node_id = node_id  # type: str
        self.preset_name = preset_name  # type: str
        self.preset_type = preset_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotPresetResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node_name is not None:
            result['ControlNodeName'] = self.control_node_name
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        if self.preset_type is not None:
            result['PresetType'] = self.preset_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ControlNodeName') is not None:
            self.control_node_name = m.get('ControlNodeName')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        if m.get('PresetType') is not None:
            self.preset_type = m.get('PresetType')
        return self


class ListHoneypotPresetResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotPresetResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotPresetResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, list=None, message=None, page_info=None, request_id=None,
                 success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.list = list  # type: list[ListHoneypotPresetResponseBodyList]
        self.message = message  # type: str
        self.page_info = page_info  # type: ListHoneypotPresetResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListHoneypotPresetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotPresetResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotPresetResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotPresetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListHoneypotPresetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListHoneypotPresetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHoneypotProbeRequest(TeaModel):
    def __init__(self, current_page=None, display_name=None, lang=None, page_size=None, probe_status=None,
                 probe_type=None):
        self.current_page = current_page  # type: int
        self.display_name = display_name  # type: str
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.probe_status = probe_status  # type: str
        self.probe_type = probe_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotProbeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.probe_status is not None:
            result['ProbeStatus'] = self.probe_status
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProbeStatus') is not None:
            self.probe_status = m.get('ProbeStatus')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        return self


class ListHoneypotProbeResponseBodyListControlNode(TeaModel):
    def __init__(self, ecs_instance_id=None, node_id=None, node_name=None):
        self.ecs_instance_id = ecs_instance_id  # type: str
        self.node_id = node_id  # type: str
        self.node_name = node_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotProbeResponseBodyListControlNode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        return self


class ListHoneypotProbeResponseBodyList(TeaModel):
    def __init__(self, control_node=None, deploy_time=None, display_name=None, host_ip=None, os_type=None,
                 probe_id=None, probe_type=None, probe_version=None, status=None, uuid=None, vpc_id=None):
        self.control_node = control_node  # type: ListHoneypotProbeResponseBodyListControlNode
        self.deploy_time = deploy_time  # type: long
        self.display_name = display_name  # type: str
        self.host_ip = host_ip  # type: str
        self.os_type = os_type  # type: str
        self.probe_id = probe_id  # type: str
        self.probe_type = probe_type  # type: str
        self.probe_version = probe_version  # type: str
        self.status = status  # type: str
        self.uuid = uuid  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.control_node:
            self.control_node.validate()

    def to_map(self):
        _map = super(ListHoneypotProbeResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_node is not None:
            result['ControlNode'] = self.control_node.to_map()
        if self.deploy_time is not None:
            result['DeployTime'] = self.deploy_time
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.host_ip is not None:
            result['HostIp'] = self.host_ip
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.probe_type is not None:
            result['ProbeType'] = self.probe_type
        if self.probe_version is not None:
            result['ProbeVersion'] = self.probe_version
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ControlNode') is not None:
            temp_model = ListHoneypotProbeResponseBodyListControlNode()
            self.control_node = temp_model.from_map(m['ControlNode'])
        if m.get('DeployTime') is not None:
            self.deploy_time = m.get('DeployTime')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('HostIp') is not None:
            self.host_ip = m.get('HostIp')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ProbeType') is not None:
            self.probe_type = m.get('ProbeType')
        if m.get('ProbeVersion') is not None:
            self.probe_version = m.get('ProbeVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListHoneypotProbeResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListHoneypotProbeResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHoneypotProbeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, list=None, message=None, page_info=None, request_id=None,
                 success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.list = list  # type: list[ListHoneypotProbeResponseBodyList]
        self.message = message  # type: str
        self.page_info = page_info  # type: ListHoneypotProbeResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListHoneypotProbeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHoneypotProbeResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListHoneypotProbeResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHoneypotProbeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListHoneypotProbeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListHoneypotProbeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterceptionImageResponseBodyImageList(TeaModel):
    def __init__(self, image_name=None, image_uuid=None):
        self.image_name = image_name  # type: str
        self.image_uuid = image_uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInterceptionImageResponseBodyImageList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        return self


class ListInterceptionImageResponseBody(TeaModel):
    def __init__(self, image_list=None, request_id=None):
        self.image_list = image_list  # type: list[ListInterceptionImageResponseBodyImageList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_list:
            for k in self.image_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListInterceptionImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageList'] = []
        if self.image_list is not None:
            for k in self.image_list:
                result['ImageList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_list = []
        if m.get('ImageList') is not None:
            for k in m.get('ImageList'):
                temp_model = ListInterceptionImageResponseBodyImageList()
                self.image_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInterceptionImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListInterceptionImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListInterceptionImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterceptionImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterceptionRulePageRequest(TeaModel):
    def __init__(self, cluster_id=None, criteria=None, criteria_type=None, current_page=None, page_size=None):
        self.cluster_id = cluster_id  # type: str
        self.criteria = criteria  # type: str
        self.criteria_type = criteria_type  # type: str
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInterceptionRulePageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.criteria_type is not None:
            result['CriteriaType'] = self.criteria_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('CriteriaType') is not None:
            self.criteria_type = m.get('CriteriaType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget(TeaModel):
    def __init__(self, app_name=None, image_list=None, namespace=None, ports=None, rule_type=None, tag_list=None,
                 target_id=None, target_name=None, target_type=None):
        self.app_name = app_name  # type: str
        self.image_list = image_list  # type: list[str]
        self.namespace = namespace  # type: str
        self.ports = ports  # type: list[str]
        self.rule_type = rule_type  # type: str
        self.tag_list = tag_list  # type: list[str]
        self.target_id = target_id  # type: int
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.ports is not None:
            result['Ports'] = self.ports
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Ports') is not None:
            self.ports = m.get('Ports')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget(TeaModel):
    def __init__(self, app_name=None, image_list=None, namespace=None, rule_type=None, tag_list=None, target_id=None,
                 target_name=None, target_type=None):
        self.app_name = app_name  # type: str
        self.image_list = image_list  # type: list[str]
        self.namespace = namespace  # type: str
        self.rule_type = rule_type  # type: str
        self.tag_list = tag_list  # type: list[str]
        self.target_id = target_id  # type: int
        self.target_name = target_name  # type: str
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.image_list is not None:
            result['ImageList'] = self.image_list
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ImageList') is not None:
            self.image_list = m.get('ImageList')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ListInterceptionRulePageResponseBodyInterceptionRuleList(TeaModel):
    def __init__(self, dst_target=None, intercept_type=None, order_index=None, rule_id=None, rule_name=None,
                 rule_switch=None, rule_type=None, src_target=None):
        self.dst_target = dst_target  # type: ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget
        self.intercept_type = intercept_type  # type: long
        self.order_index = order_index  # type: long
        self.rule_id = rule_id  # type: long
        self.rule_name = rule_name  # type: str
        self.rule_switch = rule_switch  # type: int
        self.rule_type = rule_type  # type: str
        self.src_target = src_target  # type: ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget

    def validate(self):
        if self.dst_target:
            self.dst_target.validate()
        if self.src_target:
            self.src_target.validate()

    def to_map(self):
        _map = super(ListInterceptionRulePageResponseBodyInterceptionRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_target is not None:
            result['DstTarget'] = self.dst_target.to_map()
        if self.intercept_type is not None:
            result['InterceptType'] = self.intercept_type
        if self.order_index is not None:
            result['OrderIndex'] = self.order_index
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_switch is not None:
            result['RuleSwitch'] = self.rule_switch
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.src_target is not None:
            result['SrcTarget'] = self.src_target.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DstTarget') is not None:
            temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget()
            self.dst_target = temp_model.from_map(m['DstTarget'])
        if m.get('InterceptType') is not None:
            self.intercept_type = m.get('InterceptType')
        if m.get('OrderIndex') is not None:
            self.order_index = m.get('OrderIndex')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleSwitch') is not None:
            self.rule_switch = m.get('RuleSwitch')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('SrcTarget') is not None:
            temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget()
            self.src_target = temp_model.from_map(m['SrcTarget'])
        return self


class ListInterceptionRulePageResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListInterceptionRulePageResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInterceptionRulePageResponseBody(TeaModel):
    def __init__(self, interception_rule_list=None, page_info=None, request_id=None):
        self.interception_rule_list = interception_rule_list  # type: list[ListInterceptionRulePageResponseBodyInterceptionRuleList]
        self.page_info = page_info  # type: ListInterceptionRulePageResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.interception_rule_list:
            for k in self.interception_rule_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListInterceptionRulePageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InterceptionRuleList'] = []
        if self.interception_rule_list is not None:
            for k in self.interception_rule_list:
                result['InterceptionRuleList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.interception_rule_list = []
        if m.get('InterceptionRuleList') is not None:
            for k in m.get('InterceptionRuleList'):
                temp_model = ListInterceptionRulePageResponseBodyInterceptionRuleList()
                self.interception_rule_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListInterceptionRulePageResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInterceptionRulePageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListInterceptionRulePageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListInterceptionRulePageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterceptionRulePageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPluginForUuidRequest(TeaModel):
    def __init__(self, types=None, uuid=None):
        self.types = types  # type: list[str]
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPluginForUuidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types is not None:
            result['Types'] = self.types
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListPluginForUuidShrinkRequest(TeaModel):
    def __init__(self, types_shrink=None, uuid=None):
        self.types_shrink = types_shrink  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPluginForUuidShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList(TeaModel):
    def __init__(self, config=None, msg=None, overall_config=None, type=None):
        self.config = config  # type: bool
        self.msg = msg  # type: str
        self.overall_config = overall_config  # type: bool
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.overall_config is not None:
            result['OverallConfig'] = self.overall_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('OverallConfig') is not None:
            self.overall_config = m.get('OverallConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList(TeaModel):
    def __init__(self, aegis_suspicious_config_list=None, plugin_install_code=None, plugin_name=None,
                 plugin_online_installed=None, plugin_online_status=None, plugin_version=None):
        self.aegis_suspicious_config_list = aegis_suspicious_config_list  # type: list[ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList]
        self.plugin_install_code = plugin_install_code  # type: str
        self.plugin_name = plugin_name  # type: str
        self.plugin_online_installed = plugin_online_installed  # type: bool
        self.plugin_online_status = plugin_online_status  # type: bool
        self.plugin_version = plugin_version  # type: str

    def validate(self):
        if self.aegis_suspicious_config_list:
            for k in self.aegis_suspicious_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisSuspiciousConfigList'] = []
        if self.aegis_suspicious_config_list is not None:
            for k in self.aegis_suspicious_config_list:
                result['AegisSuspiciousConfigList'].append(k.to_map() if k else None)
        if self.plugin_install_code is not None:
            result['PluginInstallCode'] = self.plugin_install_code
        if self.plugin_name is not None:
            result['PluginName'] = self.plugin_name
        if self.plugin_online_installed is not None:
            result['PluginOnlineInstalled'] = self.plugin_online_installed
        if self.plugin_online_status is not None:
            result['PluginOnlineStatus'] = self.plugin_online_status
        if self.plugin_version is not None:
            result['PluginVersion'] = self.plugin_version
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aegis_suspicious_config_list = []
        if m.get('AegisSuspiciousConfigList') is not None:
            for k in m.get('AegisSuspiciousConfigList'):
                temp_model = ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList()
                self.aegis_suspicious_config_list.append(temp_model.from_map(k))
        if m.get('PluginInstallCode') is not None:
            self.plugin_install_code = m.get('PluginInstallCode')
        if m.get('PluginName') is not None:
            self.plugin_name = m.get('PluginName')
        if m.get('PluginOnlineInstalled') is not None:
            self.plugin_online_installed = m.get('PluginOnlineInstalled')
        if m.get('PluginOnlineStatus') is not None:
            self.plugin_online_status = m.get('PluginOnlineStatus')
        if m.get('PluginVersion') is not None:
            self.plugin_version = m.get('PluginVersion')
        return self


class ListPluginForUuidResponseBody(TeaModel):
    def __init__(self, aegis_uuid_target_plugin_config_list=None, code=None, message=None, request_id=None):
        self.aegis_uuid_target_plugin_config_list = aegis_uuid_target_plugin_config_list  # type: list[ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList]
        self.code = code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        if self.aegis_uuid_target_plugin_config_list:
            for k in self.aegis_uuid_target_plugin_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPluginForUuidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisUuidTargetPluginConfigList'] = []
        if self.aegis_uuid_target_plugin_config_list is not None:
            for k in self.aegis_uuid_target_plugin_config_list:
                result['AegisUuidTargetPluginConfigList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aegis_uuid_target_plugin_config_list = []
        if m.get('AegisUuidTargetPluginConfigList') is not None:
            for k in m.get('AegisUuidTargetPluginConfigList'):
                temp_model = ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList()
                self.aegis_uuid_target_plugin_config_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPluginForUuidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPluginForUuidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPluginForUuidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPluginForUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrivateRegistryListRequest(TeaModel):
    def __init__(self, registry_type=None):
        self.registry_type = registry_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPrivateRegistryListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        return self


class ListPrivateRegistryListResponseBodyImageRegistryInfos(TeaModel):
    def __init__(self, ali_uid=None, domain_name=None, id=None, jenkins_env=None, net_type=None, password=None,
                 persistence_day=None, protocol_type=None, region_id=None, registry_host_ip=None, registry_name=None,
                 registry_type=None, registry_version=None, token=None, trans_per_hour=None, user_name=None, vpc_id=None,
                 white_list=None):
        self.ali_uid = ali_uid  # type: long
        self.domain_name = domain_name  # type: str
        self.id = id  # type: long
        self.jenkins_env = jenkins_env  # type: str
        self.net_type = net_type  # type: long
        self.password = password  # type: str
        self.persistence_day = persistence_day  # type: long
        self.protocol_type = protocol_type  # type: long
        self.region_id = region_id  # type: str
        self.registry_host_ip = registry_host_ip  # type: str
        self.registry_name = registry_name  # type: str
        self.registry_type = registry_type  # type: str
        self.registry_version = registry_version  # type: str
        self.token = token  # type: str
        self.trans_per_hour = trans_per_hour  # type: int
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.white_list = white_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPrivateRegistryListResponseBodyImageRegistryInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.jenkins_env is not None:
            result['JenkinsEnv'] = self.jenkins_env
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.registry_version is not None:
            result['RegistryVersion'] = self.registry_version
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JenkinsEnv') is not None:
            self.jenkins_env = m.get('JenkinsEnv')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('RegistryVersion') is not None:
            self.registry_version = m.get('RegistryVersion')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class ListPrivateRegistryListResponseBody(TeaModel):
    def __init__(self, image_registry_infos=None, request_id=None):
        self.image_registry_infos = image_registry_infos  # type: list[ListPrivateRegistryListResponseBodyImageRegistryInfos]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image_registry_infos:
            for k in self.image_registry_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPrivateRegistryListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageRegistryInfos'] = []
        if self.image_registry_infos is not None:
            for k in self.image_registry_infos:
                result['ImageRegistryInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_registry_infos = []
        if m.get('ImageRegistryInfos') is not None:
            for k in m.get('ImageRegistryInfos'):
                temp_model = ListPrivateRegistryListResponseBodyImageRegistryInfos()
                self.image_registry_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrivateRegistryListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPrivateRegistryListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPrivateRegistryListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrivateRegistryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrivateRegistryTypeResponseBodyRegistryTypeInfos(TeaModel):
    def __init__(self, count=None, registry_type=None):
        self.count = count  # type: long
        self.registry_type = registry_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPrivateRegistryTypeResponseBodyRegistryTypeInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        return self


class ListPrivateRegistryTypeResponseBody(TeaModel):
    def __init__(self, registry_type_infos=None, request_id=None):
        self.registry_type_infos = registry_type_infos  # type: list[ListPrivateRegistryTypeResponseBodyRegistryTypeInfos]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.registry_type_infos:
            for k in self.registry_type_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPrivateRegistryTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RegistryTypeInfos'] = []
        if self.registry_type_infos is not None:
            for k in self.registry_type_infos:
                result['RegistryTypeInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.registry_type_infos = []
        if m.get('RegistryTypeInfos') is not None:
            for k in m.get('RegistryTypeInfos'):
                temp_model = ListPrivateRegistryTypeResponseBodyRegistryTypeInfos()
                self.registry_type_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrivateRegistryTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPrivateRegistryTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPrivateRegistryTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrivateRegistryTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemAggregationRulesRequest(TeaModel):
    def __init__(self, aggregation_ids=None, current_page=None, lang=None, page_size=None, rule_name=None,
                 rule_types=None, system_type=None):
        self.aggregation_ids = aggregation_ids  # type: list[int]
        self.current_page = current_page  # type: int
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.rule_name = rule_name  # type: str
        self.rule_types = rule_types  # type: list[int]
        self.system_type = system_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemAggregationRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_ids is not None:
            result['AggregationIds'] = self.aggregation_ids
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AggregationIds') is not None:
            self.aggregation_ids = m.get('AggregationIds')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        return self


class ListSystemAggregationRulesResponseBodyAggregationList(TeaModel):
    def __init__(self, id=None, name=None, rule_count=None):
        self.id = id  # type: int
        self.name = name  # type: str
        self.rule_count = rule_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemAggregationRulesResponseBodyAggregationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        return self


class ListSystemAggregationRulesResponseBodyPageInfo(TeaModel):
    def __init__(self, current_page=None, page_size=None, total_count=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemAggregationRulesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSystemAggregationRulesResponseBody(TeaModel):
    def __init__(self, aggregation_list=None, page_info=None, request_id=None):
        self.aggregation_list = aggregation_list  # type: list[ListSystemAggregationRulesResponseBodyAggregationList]
        self.page_info = page_info  # type: ListSystemAggregationRulesResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.aggregation_list:
            for k in self.aggregation_list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListSystemAggregationRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AggregationList'] = []
        if self.aggregation_list is not None:
            for k in self.aggregation_list:
                result['AggregationList'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aggregation_list = []
        if m.get('AggregationList') is not None:
            for k in m.get('AggregationList'):
                temp_model = ListSystemAggregationRulesResponseBodyAggregationList()
                self.aggregation_list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListSystemAggregationRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSystemAggregationRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSystemAggregationRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSystemAggregationRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemAggregationRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemClientRuleTypesResponseBody(TeaModel):
    def __init__(self, request_id=None, rule_types=None):
        self.request_id = request_id  # type: str
        self.rule_types = rule_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemClientRuleTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        return self


class ListSystemClientRuleTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSystemClientRuleTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSystemClientRuleTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemClientRuleTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemClientRulesRequest(TeaModel):
    def __init__(self, aggregation_ids=None, current_page=None, is_container=None, lang=None, page_size=None,
                 rule_name=None, rule_types=None, system_type=None):
        self.aggregation_ids = aggregation_ids  # type: list[int]
        self.current_page = current_page  # type: int
        self.is_container = is_container  # type: int
        self.lang = lang  # type: str
        self.page_size = page_size  # type: int
        self.rule_name = rule_name  # type: str
        self.rule_types = rule_types  # type: list[int]
        self.system_type = system_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemClientRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_ids is not None:
            result['AggregationIds'] = self.aggregation_ids
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_container is not None:
            result['IsContainer'] = self.is_container
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_types is not None:
            result['RuleTypes'] = self.rule_types
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AggregationIds') is not None:
            self.aggregation_ids = m.get('AggregationIds')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsContainer') is not None:
            self.is_container = m.get('IsContainer')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTypes') is not None:
            self.rule_types = m.get('RuleTypes')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        return self


class ListSystemClientRulesResponseBodyPageInfo(TeaModel):
    def __init__(self, current_page=None, page_size=None, total_count=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemClientRulesResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSystemClientRulesResponseBodyRuleListPolicies(TeaModel):
    def __init__(self, policy_key=None, policy_name=None):
        self.policy_key = policy_key  # type: str
        self.policy_name = policy_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemClientRulesResponseBodyRuleListPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_key is not None:
            result['PolicyKey'] = self.policy_key
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyKey') is not None:
            self.policy_key = m.get('PolicyKey')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        return self


class ListSystemClientRulesResponseBodyRuleList(TeaModel):
    def __init__(self, aggregation_name=None, description=None, platform=None, policies=None, rule_id=None,
                 rule_name=None, rule_type=None, status=None, switch_id=None):
        self.aggregation_name = aggregation_name  # type: str
        self.description = description  # type: str
        self.platform = platform  # type: str
        self.policies = policies  # type: list[ListSystemClientRulesResponseBodyRuleListPolicies]
        self.rule_id = rule_id  # type: long
        self.rule_name = rule_name  # type: str
        self.rule_type = rule_type  # type: int
        self.status = status  # type: int
        self.switch_id = switch_id  # type: str

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSystemClientRulesResponseBodyRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregation_name is not None:
            result['AggregationName'] = self.aggregation_name
        if self.description is not None:
            result['Description'] = self.description
        if self.platform is not None:
            result['Platform'] = self.platform
        result['Policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['Policies'].append(k.to_map() if k else None)
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.status is not None:
            result['Status'] = self.status
        if self.switch_id is not None:
            result['SwitchId'] = self.switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AggregationName') is not None:
            self.aggregation_name = m.get('AggregationName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        self.policies = []
        if m.get('Policies') is not None:
            for k in m.get('Policies'):
                temp_model = ListSystemClientRulesResponseBodyRuleListPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SwitchId') is not None:
            self.switch_id = m.get('SwitchId')
        return self


class ListSystemClientRulesResponseBody(TeaModel):
    def __init__(self, page_info=None, request_id=None, rule_list=None):
        self.page_info = page_info  # type: ListSystemClientRulesResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.rule_list = rule_list  # type: list[ListSystemClientRulesResponseBodyRuleList]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.rule_list:
            for k in self.rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSystemClientRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RuleList'] = []
        if self.rule_list is not None:
            for k in self.rule_list:
                result['RuleList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListSystemClientRulesResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rule_list = []
        if m.get('RuleList') is not None:
            for k in m.get('RuleList'):
                temp_model = ListSystemClientRulesResponseBodyRuleList()
                self.rule_list.append(temp_model.from_map(k))
        return self


class ListSystemClientRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSystemClientRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSystemClientRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemClientRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemRuleAggregationTypesRequest(TeaModel):
    def __init__(self, lang=None):
        self.lang = lang  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemRuleAggregationTypesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ListSystemRuleAggregationTypesResponseBodyAggregationTypeList(TeaModel):
    def __init__(self, id=None, name=None):
        self.id = id  # type: int
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemRuleAggregationTypesResponseBodyAggregationTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListSystemRuleAggregationTypesResponseBody(TeaModel):
    def __init__(self, aggregation_type_list=None, request_id=None):
        self.aggregation_type_list = aggregation_type_list  # type: list[ListSystemRuleAggregationTypesResponseBodyAggregationTypeList]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.aggregation_type_list:
            for k in self.aggregation_type_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSystemRuleAggregationTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AggregationTypeList'] = []
        if self.aggregation_type_list is not None:
            for k in self.aggregation_type_list:
                result['AggregationTypeList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aggregation_type_list = []
        if m.get('AggregationTypeList') is not None:
            for k in m.get('AggregationTypeList'):
                temp_model = ListSystemRuleAggregationTypesResponseBodyAggregationTypeList()
                self.aggregation_type_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSystemRuleAggregationTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSystemRuleAggregationTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSystemRuleAggregationTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemRuleAggregationTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUninstallAegisMachinesRequest(TeaModel):
    def __init__(self, current_page=None, os=None, page_size=None, region_id_str=None, region_no=None, remark=None,
                 source_ip=None, vendor=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The operating system of the server.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **osType**, the value of the **Values** parameter indicates an operating system.
        self.os = os  # type: str
        # The number of entries to return on each page. Default value: **5**.
        self.page_size = page_size  # type: int
        # The region in which the server resides.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.
        self.region_id_str = region_id_str  # type: str
        # The region in which the server resides.
        # 
        # >  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.
        self.region_no = region_no  # type: str
        # The information about the server that you want to query. The value can be the name or the public IP address of the server.
        self.remark = remark  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The source of the server. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud.
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUninstallAegisMachinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.os is not None:
            result['Os'] = self.os
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id_str is not None:
            result['RegionIdStr'] = self.region_id_str
        if self.region_no is not None:
            result['RegionNo'] = self.region_no
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIdStr') is not None:
            self.region_id_str = m.get('RegionIdStr')
        if m.get('RegionNo') is not None:
            self.region_no = m.get('RegionNo')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class ListUninstallAegisMachinesResponseBodyMachineList(TeaModel):
    def __init__(self, instance_id=None, instance_name=None, internet_ip=None, intranet_ip=None,
                 machine_region=None, os=None, region_id=None, uuid=None, vendor=None, vendor_name=None):
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The public IP address of the server.
        self.internet_ip = internet_ip  # type: str
        # The private IP address of the server.
        self.intranet_ip = intranet_ip  # type: str
        # The region in which the server resides.
        self.machine_region = machine_region  # type: str
        # The operating system of the server. Valid values:
        # 
        # *   **linux**\
        # *   **windows**\
        # *   **windows-2003**\
        self.os = os  # type: str
        # The ID of the region in which the server resides.
        self.region_id = region_id  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str
        # The source of the server. Valid values:
        # 
        # *   **0**: an asset provided by Alibaba Cloud
        # *   **1**: a third-party cloud server
        # *   **2**: a server in a data center
        # *   **3**, **4**, **5**, and **7**: other cloud asset
        # *   **8**: a lightweight asset
        self.vendor = vendor  # type: int
        # The name of the service provider (SP) for the server.
        # 
        # Valid values:
        # 
        # *   **ALIYUN**: Alibaba Cloud
        # *   **OUT**: a third-party service provider
        # *   **IDC**: a data center
        # *   **TENCENT**: Tencent Cloud
        # *   **HUAWEICLOUD**: Huawei Cloud
        # *   **Microsoft**: Microsoft
        # *   **AWS**: Amazon Web Services (AWS)
        # *   **TRIPARTITE**: a lightweight server
        self.vendor_name = vendor_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUninstallAegisMachinesResponseBodyMachineList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_region is not None:
            result['MachineRegion'] = self.machine_region
        if self.os is not None:
            result['Os'] = self.os
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.vendor_name is not None:
            result['VendorName'] = self.vendor_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineRegion') is not None:
            self.machine_region = m.get('MachineRegion')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('VendorName') is not None:
            self.vendor_name = m.get('VendorName')
        return self


class ListUninstallAegisMachinesResponseBody(TeaModel):
    def __init__(self, current_page=None, machine_list=None, page_size=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # An array that consists of the information about servers.
        self.machine_list = machine_list  # type: list[ListUninstallAegisMachinesResponseBodyMachineList]
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.machine_list:
            for k in self.machine_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUninstallAegisMachinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['MachineList'] = []
        if self.machine_list is not None:
            for k in self.machine_list:
                result['MachineList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.machine_list = []
        if m.get('MachineList') is not None:
            for k in m.get('MachineList'):
                temp_model = ListUninstallAegisMachinesResponseBodyMachineList()
                self.machine_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUninstallAegisMachinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUninstallAegisMachinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUninstallAegisMachinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUninstallAegisMachinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUuidsByWebPathRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, type=None, web_path=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.type = type  # type: str
        self.web_path = web_path  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUuidsByWebPathRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        if self.web_path is not None:
            result['WebPath'] = self.web_path
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WebPath') is not None:
            self.web_path = m.get('WebPath')
        return self


class ListUuidsByWebPathResponseBodyList(TeaModel):
    def __init__(self, internet_ip=None, intranet_ip=None, machine_name=None, uuid=None):
        self.internet_ip = internet_ip  # type: str
        self.intranet_ip = intranet_ip  # type: str
        self.machine_name = machine_name  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUuidsByWebPathResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.machine_name is not None:
            result['MachineName'] = self.machine_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('MachineName') is not None:
            self.machine_name = m.get('MachineName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListUuidsByWebPathResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUuidsByWebPathResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUuidsByWebPathResponseBody(TeaModel):
    def __init__(self, list=None, page_info=None, request_id=None):
        self.list = list  # type: list[ListUuidsByWebPathResponseBodyList]
        self.page_info = page_info  # type: ListUuidsByWebPathResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(ListUuidsByWebPathResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListUuidsByWebPathResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = ListUuidsByWebPathResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUuidsByWebPathResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUuidsByWebPathResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUuidsByWebPathResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUuidsByWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVulAutoRepairConfigRequest(TeaModel):
    def __init__(self, alias_name=None, current_page=None, page_size=None, type=None):
        self.alias_name = alias_name  # type: str
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListVulAutoRepairConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListVulAutoRepairConfigResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListVulAutoRepairConfigResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList(TeaModel):
    def __init__(self, alias_name=None, id=None, name=None, reason=None, type=None):
        self.alias_name = alias_name  # type: str
        self.id = id  # type: long
        self.name = name  # type: str
        self.reason = reason  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListVulAutoRepairConfigResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, page_info=None, request_id=None, success=None,
                 vul_auto_repair_config_list=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.page_info = page_info  # type: ListVulAutoRepairConfigResponseBodyPageInfo
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.vul_auto_repair_config_list = vul_auto_repair_config_list  # type: list[ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList]

    def validate(self):
        if self.page_info:
            self.page_info.validate()
        if self.vul_auto_repair_config_list:
            for k in self.vul_auto_repair_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListVulAutoRepairConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['VulAutoRepairConfigList'] = []
        if self.vul_auto_repair_config_list is not None:
            for k in self.vul_auto_repair_config_list:
                result['VulAutoRepairConfigList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = ListVulAutoRepairConfigResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.vul_auto_repair_config_list = []
        if m.get('VulAutoRepairConfigList') is not None:
            for k in m.get('VulAutoRepairConfigList'):
                temp_model = ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList()
                self.vul_auto_repair_config_list.append(temp_model.from_map(k))
        return self


class ListVulAutoRepairConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListVulAutoRepairConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListVulAutoRepairConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVulAutoRepairConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAccessKeyLeakDealRequest(TeaModel):
    def __init__(self, id=None, id_list=None, remark=None, type=None):
        self.id = id  # type: long
        self.id_list = id_list  # type: list[long]
        self.remark = remark  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAccessKeyLeakDealRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.id_list is not None:
            result['IdList'] = self.id_list
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IdList') is not None:
            self.id_list = m.get('IdList')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyAccessKeyLeakDealResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAccessKeyLeakDealResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAccessKeyLeakDealResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAccessKeyLeakDealResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAccessKeyLeakDealResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAccessKeyLeakDealResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAntiBruteForceRuleRequest(TeaModel):
    def __init__(self, default_rule=None, fail_count=None, forbidden_time=None, id=None, name=None,
                 resource_owner_id=None, source_ip=None, span=None, uuid_list=None):
        # Specifies whether to set the defense rule as the default rule. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.default_rule = default_rule  # type: bool
        # The threshold of logon failures that you specify. Valid values:
        # 
        # *   **2**\
        # *   **3**\
        # *   **4**\
        # *   **5**\
        # *   **10**\
        # *   **50**\
        # *   **80**\
        # *   **100**\
        self.fail_count = fail_count  # type: int
        # The period of time during which logons from an account are not allowed. Unit: minutes. Valid values:
        # 
        # *   **5**\
        # *   **15**\
        # *   **30**\
        # *   **60**\
        # *   **120**\
        # *   **360**\
        # *   **720**\
        # *   **1440**\
        # *   **10080**\
        # *   **52560000**: permanent
        self.forbidden_time = forbidden_time  # type: int
        # The ID of the defense rule.
        self.id = id  # type: long
        # The name of the defense rule.
        self.name = name  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The period of time during which logon failures from an account are measured. Unit: minutes. Valid values:
        # 
        # *   **1**\
        # *   **2**\
        # *   **5**\
        # *   **10**\
        # *   **15**\
        self.span = span  # type: int
        # An array consisting of the UUIDs of the servers to which the defense rule is applied.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAntiBruteForceRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.forbidden_time is not None:
            result['ForbiddenTime'] = self.forbidden_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.span is not None:
            result['Span'] = self.span
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ForbiddenTime') is not None:
            self.forbidden_time = m.get('ForbiddenTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAntiBruteForceRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAntiBruteForceRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAntiBruteForceRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAntiBruteForceRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppVulScanCycleRequest(TeaModel):
    def __init__(self, cycle=None):
        self.cycle = cycle  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAppVulScanCycleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle is not None:
            result['Cycle'] = self.cycle
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cycle') is not None:
            self.cycle = m.get('Cycle')
        return self


class ModifyAppVulScanCycleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAppVulScanCycleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppVulScanCycleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAppVulScanCycleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAppVulScanCycleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppVulScanCycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAssetGroupRequest(TeaModel):
    def __init__(self, group_id=None, source_ip=None, uuids=None):
        self.group_id = group_id  # type: long
        self.source_ip = source_ip  # type: str
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAssetGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyAssetGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAssetGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAssetGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAssetGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAssetGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAssetGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAssetImportantRequest(TeaModel):
    def __init__(self, important_code=None, uuid_list=None):
        self.important_code = important_code  # type: int
        self.uuid_list = uuid_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAssetImportantRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.important_code is not None:
            result['ImportantCode'] = self.important_code
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImportantCode') is not None:
            self.important_code = m.get('ImportantCode')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyAssetImportantResponseBody(TeaModel):
    def __init__(self, err_code=None, err_message=None, http_status_code=None, request_id=None, success=None):
        self.err_code = err_code  # type: str
        self.err_message = err_message  # type: str
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAssetImportantResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_code is not None:
            result['ErrCode'] = self.err_code
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrCode') is not None:
            self.err_code = m.get('ErrCode')
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyAssetImportantResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAssetImportantResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAssetImportantResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAssetImportantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoDelConfigRequest(TeaModel):
    def __init__(self, days=None):
        self.days = days  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoDelConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        return self


class ModifyAutoDelConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoDelConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoDelConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAutoDelConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAutoDelConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoDelConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBackupPolicyRequest(TeaModel):
    def __init__(self, id=None, name=None, policy=None, policy_region_id=None, policy_version=None, uuid_list=None):
        self.id = id  # type: long
        self.name = name  # type: str
        self.policy = policy  # type: dict[str, any]
        self.policy_region_id = policy_region_id  # type: str
        self.policy_version = policy_version  # type: str
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyBackupPolicyShrinkRequest(TeaModel):
    def __init__(self, id=None, name=None, policy_shrink=None, policy_region_id=None, policy_version=None,
                 uuid_list=None):
        self.id = id  # type: long
        self.name = name  # type: str
        self.policy_shrink = policy_shrink  # type: str
        self.policy_region_id = policy_region_id  # type: str
        self.policy_version = policy_version  # type: str
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBackupPolicyShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.policy_shrink is not None:
            result['Policy'] = self.policy_shrink
        if self.policy_region_id is not None:
            result['PolicyRegionId'] = self.policy_region_id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policy') is not None:
            self.policy_shrink = m.get('Policy')
        if m.get('PolicyRegionId') is not None:
            self.policy_region_id = m.get('PolicyRegionId')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyBackupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBackupPolicyStatusRequest(TeaModel):
    def __init__(self, id=None, policy_version=None, status=None):
        # The ID of the anti-ransomware policy.
        self.id = id  # type: long
        # The version of the anti-ransomware policy. Set the value to **2.0.0**.
        self.policy_version = policy_version  # type: str
        # Specifies whether to enable or disable the anti-ransomware policy. Valid values:
        # 
        # *   **enabled**: enables the anti-ransomware policy. After you enable the anti-ransomware policy, the anti-ransomware feature protects data on your servers. Data on your servers is backed up based on the policy.
        # *   **disabled**: disables the anti-ransomware policy. After you disable the anti-ransomware policy, the data backup task that is running based on the policy stops.
        # 
        # >  When the system runs data backup tasks, your network bandwidth is consumed. We recommend that you enable the anti-ransomware policy during peak-off hours to back up data.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBackupPolicyStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyBackupPolicyStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBackupPolicyStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBackupPolicyStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyBackupPolicyStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyBackupPolicyStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBackupPolicyStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClearLogstoreStorageRequest(TeaModel):
    def __init__(self, from_=None, lang=None, user_log_store=None, user_project=None):
        self.from_ = from_  # type: str
        self.lang = lang  # type: str
        self.user_log_store = user_log_store  # type: str
        self.user_project = user_project  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClearLogstoreStorageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.user_log_store is not None:
            result['UserLogStore'] = self.user_log_store
        if self.user_project is not None:
            result['UserProject'] = self.user_project
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('UserLogStore') is not None:
            self.user_log_store = m.get('UserLogStore')
        if m.get('UserProject') is not None:
            self.user_project = m.get('UserProject')
        return self


class ModifyClearLogstoreStorageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClearLogstoreStorageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClearLogstoreStorageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyClearLogstoreStorageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyClearLogstoreStorageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClearLogstoreStorageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientConfSetupRequest(TeaModel):
    def __init__(self, strategy_config=None, strategy_tag=None, strategy_tag_value=None):
        self.strategy_config = strategy_config  # type: str
        self.strategy_tag = strategy_tag  # type: str
        self.strategy_tag_value = strategy_tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientConfSetupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_config is not None:
            result['StrategyConfig'] = self.strategy_config
        if self.strategy_tag is not None:
            result['StrategyTag'] = self.strategy_tag
        if self.strategy_tag_value is not None:
            result['StrategyTagValue'] = self.strategy_tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('StrategyConfig') is not None:
            self.strategy_config = m.get('StrategyConfig')
        if m.get('StrategyTag') is not None:
            self.strategy_tag = m.get('StrategyTag')
        if m.get('StrategyTagValue') is not None:
            self.strategy_tag_value = m.get('StrategyTagValue')
        return self


class ModifyClientConfSetupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientConfSetupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientConfSetupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyClientConfSetupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyClientConfSetupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientConfSetupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientConfStrategyRequest(TeaModel):
    def __init__(self, tag=None, tag_ext=None, tag_value=None, uuid=None, uuids=None):
        self.tag = tag  # type: str
        self.tag_ext = tag_ext  # type: str
        self.tag_value = tag_value  # type: str
        self.uuid = uuid  # type: str
        self.uuids = uuids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientConfStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_ext is not None:
            result['TagExt'] = self.tag_ext
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagExt') is not None:
            self.tag_ext = m.get('TagExt')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyClientConfStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientConfStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientConfStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyClientConfStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyClientConfStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientConfStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyClientUserDefineRuleRequest(TeaModel):
    def __init__(self, action_type=None, cmdline=None, file_path=None, ip=None, id=None, md_5list=None, name=None,
                 new_file_path=None, parent_cmdline=None, parent_proc_path=None, platform=None, port=None, port_str=None,
                 proc_path=None, registry_content=None, registry_key=None, type=None):
        self.action_type = action_type  # type: int
        self.cmdline = cmdline  # type: str
        self.file_path = file_path  # type: str
        self.ip = ip  # type: str
        self.id = id  # type: long
        self.md_5list = md_5list  # type: str
        self.name = name  # type: str
        self.new_file_path = new_file_path  # type: str
        self.parent_cmdline = parent_cmdline  # type: str
        self.parent_proc_path = parent_proc_path  # type: str
        self.platform = platform  # type: str
        self.port = port  # type: int
        self.port_str = port_str  # type: str
        self.proc_path = proc_path  # type: str
        self.registry_content = registry_content  # type: str
        self.registry_key = registry_key  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientUserDefineRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.cmdline is not None:
            result['Cmdline'] = self.cmdline
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.ip is not None:
            result['IP'] = self.ip
        if self.id is not None:
            result['Id'] = self.id
        if self.md_5list is not None:
            result['Md5List'] = self.md_5list
        if self.name is not None:
            result['Name'] = self.name
        if self.new_file_path is not None:
            result['NewFilePath'] = self.new_file_path
        if self.parent_cmdline is not None:
            result['ParentCmdline'] = self.parent_cmdline
        if self.parent_proc_path is not None:
            result['ParentProcPath'] = self.parent_proc_path
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.port is not None:
            result['Port'] = self.port
        if self.port_str is not None:
            result['PortStr'] = self.port_str
        if self.proc_path is not None:
            result['ProcPath'] = self.proc_path
        if self.registry_content is not None:
            result['RegistryContent'] = self.registry_content
        if self.registry_key is not None:
            result['RegistryKey'] = self.registry_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Cmdline') is not None:
            self.cmdline = m.get('Cmdline')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Md5List') is not None:
            self.md_5list = m.get('Md5List')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NewFilePath') is not None:
            self.new_file_path = m.get('NewFilePath')
        if m.get('ParentCmdline') is not None:
            self.parent_cmdline = m.get('ParentCmdline')
        if m.get('ParentProcPath') is not None:
            self.parent_proc_path = m.get('ParentProcPath')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('PortStr') is not None:
            self.port_str = m.get('PortStr')
        if m.get('ProcPath') is not None:
            self.proc_path = m.get('ProcPath')
        if m.get('RegistryContent') is not None:
            self.registry_content = m.get('RegistryContent')
        if m.get('RegistryKey') is not None:
            self.registry_key = m.get('RegistryKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyClientUserDefineRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyClientUserDefineRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyClientUserDefineRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyClientUserDefineRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyClientUserDefineRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyClientUserDefineRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyConcernNecessityRequest(TeaModel):
    def __init__(self, concern_necessity=None):
        self.concern_necessity = concern_necessity  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyConcernNecessityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.concern_necessity is not None:
            result['ConcernNecessity'] = self.concern_necessity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConcernNecessity') is not None:
            self.concern_necessity = m.get('ConcernNecessity')
        return self


class ModifyConcernNecessityResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyConcernNecessityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyConcernNecessityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyConcernNecessityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyConcernNecessityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyConcernNecessityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCreateVulWhitelistRequest(TeaModel):
    def __init__(self, reason=None, target_info=None, whitelist=None):
        self.reason = reason  # type: str
        self.target_info = target_info  # type: str
        self.whitelist = whitelist  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCreateVulWhitelistRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        if self.whitelist is not None:
            result['Whitelist'] = self.whitelist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        if m.get('Whitelist') is not None:
            self.whitelist = m.get('Whitelist')
        return self


class ModifyCreateVulWhitelistResponseBodyVulWhitelistList(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCreateVulWhitelistResponseBodyVulWhitelistList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ModifyCreateVulWhitelistResponseBody(TeaModel):
    def __init__(self, request_id=None, vul_whitelist_list=None):
        self.request_id = request_id  # type: str
        self.vul_whitelist_list = vul_whitelist_list  # type: list[ModifyCreateVulWhitelistResponseBodyVulWhitelistList]

    def validate(self):
        if self.vul_whitelist_list:
            for k in self.vul_whitelist_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyCreateVulWhitelistResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VulWhitelistList'] = []
        if self.vul_whitelist_list is not None:
            for k in self.vul_whitelist_list:
                result['VulWhitelistList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.vul_whitelist_list = []
        if m.get('VulWhitelistList') is not None:
            for k in m.get('VulWhitelistList'):
                temp_model = ModifyCreateVulWhitelistResponseBodyVulWhitelistList()
                self.vul_whitelist_list.append(temp_model.from_map(k))
        return self


class ModifyCreateVulWhitelistResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCreateVulWhitelistResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCreateVulWhitelistResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCreateVulWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCustomBlockRecordRequest(TeaModel):
    def __init__(self, block_ip=None, bound=None, expire_time=None, resource_owner_id=None, uuids=None):
        self.block_ip = block_ip  # type: str
        self.bound = bound  # type: str
        self.expire_time = expire_time  # type: long
        self.resource_owner_id = resource_owner_id  # type: long
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCustomBlockRecordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_ip is not None:
            result['BlockIp'] = self.block_ip
        if self.bound is not None:
            result['Bound'] = self.bound
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlockIp') is not None:
            self.block_ip = m.get('BlockIp')
        if m.get('Bound') is not None:
            self.bound = m.get('Bound')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyCustomBlockRecordResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCustomBlockRecordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCustomBlockRecordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCustomBlockRecordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCustomBlockRecordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCustomBlockRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCycleTaskRequest(TeaModel):
    def __init__(self, config_id=None, enable=None, first_date_str=None, interval_period=None, param=None,
                 period_unit=None, target_end_time=None, target_start_time=None, task_name=None, task_type=None):
        self.config_id = config_id  # type: str
        self.enable = enable  # type: int
        self.first_date_str = first_date_str  # type: long
        self.interval_period = interval_period  # type: int
        self.param = param  # type: str
        self.period_unit = period_unit  # type: str
        self.target_end_time = target_end_time  # type: int
        self.target_start_time = target_start_time  # type: int
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCycleTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.first_date_str is not None:
            result['FirstDateStr'] = self.first_date_str
        if self.interval_period is not None:
            result['IntervalPeriod'] = self.interval_period
        if self.param is not None:
            result['Param'] = self.param
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.target_end_time is not None:
            result['TargetEndTime'] = self.target_end_time
        if self.target_start_time is not None:
            result['TargetStartTime'] = self.target_start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('FirstDateStr') is not None:
            self.first_date_str = m.get('FirstDateStr')
        if m.get('IntervalPeriod') is not None:
            self.interval_period = m.get('IntervalPeriod')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('TargetEndTime') is not None:
            self.target_end_time = m.get('TargetEndTime')
        if m.get('TargetStartTime') is not None:
            self.target_start_time = m.get('TargetStartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class ModifyCycleTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCycleTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCycleTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCycleTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCycleTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCycleTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEmgVulSubmitRequest(TeaModel):
    def __init__(self, lang=None, name=None, user_agreement=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # Specifies whether to scan for urgent vulnerabilities. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.user_agreement = user_agreement  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEmgVulSubmitRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.user_agreement is not None:
            result['UserAgreement'] = self.user_agreement
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UserAgreement') is not None:
            self.user_agreement = m.get('UserAgreement')
        return self


class ModifyEmgVulSubmitResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEmgVulSubmitResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEmgVulSubmitResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyEmgVulSubmitResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyEmgVulSubmitResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEmgVulSubmitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyGroupPropertyRequest(TeaModel):
    def __init__(self, data=None):
        self.data = data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyGroupPropertyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ModifyGroupPropertyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyGroupPropertyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyGroupPropertyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyGroupPropertyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyGroupPropertyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyGroupPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAntiBruteForceRuleRequest(TeaModel):
    def __init__(self, new_rule_id=None, resource_owner_id=None, source_ip=None, uuid=None):
        # The ID of the defense rule.
        self.new_rule_id = new_rule_id  # type: long
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the server for which you want to modify the defense rule. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAntiBruteForceRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_rule_id is not None:
            result['NewRuleId'] = self.new_rule_id
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NewRuleId') is not None:
            self.new_rule_id = m.get('NewRuleId')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyInstanceAntiBruteForceRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAntiBruteForceRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAntiBruteForceRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceAntiBruteForceRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceAntiBruteForceRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAntiBruteForceRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLogMetaStatusRequest(TeaModel):
    def __init__(self, from_=None, log_store=None, project=None, status=None):
        self.from_ = from_  # type: str
        self.log_store = log_store  # type: str
        self.project = project  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLogMetaStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyLogMetaStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLogMetaStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLogMetaStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyLogMetaStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyLogMetaStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLogMetaStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLoginBaseConfigRequest(TeaModel):
    def __init__(self, config=None, target=None, type=None):
        self.config = config  # type: str
        self.target = target  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLoginBaseConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyLoginBaseConfigResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLoginBaseConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyLoginBaseConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyLoginBaseConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyLoginBaseConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLoginBaseConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLoginSwitchConfigRequest(TeaModel):
    def __init__(self, item=None, status=None):
        # The type of the alert that you want to enable or disable. Valid values:
        # 
        # *   **login\_common_ip**: alerts for unapproved logon IP addresses
        # *   **login\_common_time**: alerts for unapproved logon time ranges
        # *   **login\_common_account**: alerts for unapproved logon accounts
        self.item = item  # type: str
        # Specifies whether to enable the logon security settings. Valid values:
        # 
        # *   **0**: disables the logon security settings
        # *   **1**: enables the logon security settings
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLoginSwitchConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyLoginSwitchConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLoginSwitchConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLoginSwitchConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyLoginSwitchConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyLoginSwitchConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLoginSwitchConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNoticeConfigRequest(TeaModel):
    def __init__(self, project=None, route=None, source_ip=None, time_limit=None):
        self.project = project  # type: str
        self.route = route  # type: int
        self.source_ip = source_ip  # type: str
        self.time_limit = time_limit  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNoticeConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project
        if self.route is not None:
            result['Route'] = self.route
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.time_limit is not None:
            result['TimeLimit'] = self.time_limit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Route') is not None:
            self.route = m.get('Route')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TimeLimit') is not None:
            self.time_limit = m.get('TimeLimit')
        return self


class ModifyNoticeConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNoticeConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNoticeConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyNoticeConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyNoticeConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNoticeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOpenLogShipperRequest(TeaModel):
    def __init__(self, from_=None):
        self.from_ = from_  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOpenLogShipperRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        return self


class ModifyOpenLogShipperResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOpenLogShipperResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOpenLogShipperResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOpenLogShipperResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOpenLogShipperResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOpenLogShipperResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOperateVulRequest(TeaModel):
    def __init__(self, info=None, operate_type=None, reason=None, type=None):
        # The details of the vulnerability. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **name**: the name of the vulnerability.
        # 
        # *   **uuid**: the UUID of the server on which the vulnerability is detected.
        # 
        # *   **tag**: the tag that is added to the vulnerability. Valid values:
        # 
        #     *   **oval**: Linux software vulnerability
        #     *   **system**: Windows system vulnerability
        #     *   **cms**: Web-CMS vulnerability
        # 
        # >  You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the tags that are added to vulnerabilities of other types.
        # 
        # *   **isFront**: specifies whether a pre-patch is required to fix the Windows system vulnerability. This field is required only for Windows system vulnerabilities. Valid values:
        # 
        #     *   **0**: no
        #     *   **1**: yes
        # 
        # >  You can fix multiple vulnerabilities at a time. Separate the details of multiple vulnerabilities with commas (,). You can call the [DescribeVulLIst](~~DescribeVulList~~) operation to query the details of vulnerabilities.
        self.info = info  # type: str
        # The operation that you want to perform on the vulnerability. Valid values:
        # 
        # *   **vul_fix**: fixes the vulnerability.
        # *   **vul_verify**: verifies the vulnerability.
        # *   **vul_ignore**: ignores the vulnerability.
        # *   **vul\_undo_ignore**: cancels ignoring the vulnerability.
        # *   **vul_delete**: deletes the vulnerability.
        self.operate_type = operate_type  # type: str
        # The reason why the vulnerability is **ignored**.
        # 
        # >  This parameter is required only when you set **OperateType** to **vul_ignore**.
        self.reason = reason  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **emg**: urgent vulnerability
        # *   **app**: application vulnerability
        # *   **sca**: vulnerability that is detected based on software component analysis
        # 
        # >  You cannot fix the urgent vulnerabilities, application vulnerabilities, or vulnerabilities that are detected based on software component analysis.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOperateVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyOperateVulResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOperateVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOperateVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOperateVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOperateVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOperateVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPropertyScheduleConfigRequest(TeaModel):
    def __init__(self, schedule_time=None, type=None):
        # The new collection frequency of asset fingerprints. Valid values:
        # 
        # *   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
        # *   **1**: collects asset fingerprints once an hour.
        # *   **3**: collects asset fingerprints once every 3 hours.
        # *   **12**: collects asset fingerprints once every 12 hours.
        # *   **24**: collects asset fingerprints once a day.
        # *   **168**: collects asset fingerprints once every 7 days.
        self.schedule_time = schedule_time  # type: str
        # The type of the asset fingerprints for which you want to modify the collection frequency. Valid values:
        # 
        # *   **scheduler\_port_period**: listening port
        # *   **scheduler\_process_period**: running process
        # *   **scheduler\_account_period**: account
        # *   **scheduler\_software_period**: software
        # *   **scheduler\_cron_period**: scheduled task
        # *   **scheduler\_sca_period**: middleware, database, or web service
        # *   **scheduler\_autorun_period**: startup item
        # *   **scheduler\_lkm_period**: kernel module
        # *   **scheduler\_sca\_proxy_period**: website
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPropertyScheduleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyPropertyScheduleConfigResponseBody(TeaModel):
    def __init__(self, modify_result=None, request_id=None):
        # Indicates whether the collection frequency of asset fingerprints is modified. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.modify_result = modify_result  # type: bool
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPropertyScheduleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.modify_result is not None:
            result['ModifyResult'] = self.modify_result
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ModifyResult') is not None:
            self.modify_result = m.get('ModifyResult')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPropertyScheduleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPropertyScheduleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPropertyScheduleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPropertyScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPushAllTaskRequest(TeaModel):
    def __init__(self, source_ip=None, tasks=None, uuids=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The check items. Separate multiple check items with commas (,). Valid values:
        # 
        # *   **OVAL_ENTITY**: Common Vulnerabilities and Exposures (CVE) vulnerabilities
        # *   **CMS**: Web-CMS vulnerabilities
        # *   **SYSVUL**: Windows system vulnerabilities
        # *   **SCA**: application vulnerabilities
        # *   **HEALTH_CHECK**: baselines
        # *   **WEBSHELL**: webshells
        # *   **PROC_SNAPSHOT**: processes
        # *   **PORT_SNAPSHOT**: ports
        # *   **ACCOUNT_SNAPSHOT**: accounts
        # *   **SOFTWARE_SNAPSHOT**: software assets
        # *   **SCA_SNAPSHOT**: middleware
        self.tasks = tasks  # type: str
        # The UUIDs of servers on which you want to perform security check tasks. Separate multiple UUIDs with commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPushAllTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tasks is not None:
            result['Tasks'] = self.tasks
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tasks') is not None:
            self.tasks = m.get('Tasks')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList(TeaModel):
    def __init__(self, group_id=None, instance_id=None, instance_name=None, ip=None, message=None, online=None,
                 os_version=None, region=None, success=None, uuid=None):
        # The ID of the server group to which the server belongs.
        self.group_id = group_id  # type: long
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The name of the server.
        self.instance_name = instance_name  # type: str
        # The IP address of the server.
        self.ip = ip  # type: str
        # The message that describes the security check failure.
        self.message = message  # type: str
        # Indicates whether the Security Center agent is online. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  If the Security Center agent of the server is offline, Security Center does not protect the server.
        self.online = online  # type: bool
        # The operating system version of the server.
        self.os_version = os_version  # type: str
        # The region in which the server resides.
        self.region = region  # type: str
        # Indicates whether the security check task is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.message is not None:
            result['Message'] = self.message
        if self.online is not None:
            result['Online'] = self.online
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.region is not None:
            result['Region'] = self.region
        if self.success is not None:
            result['Success'] = self.success
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyPushAllTaskResponseBodyPushTaskRsp(TeaModel):
    def __init__(self, push_task_result_list=None):
        # An array consisting of the servers on which security check tasks failed.
        self.push_task_result_list = push_task_result_list  # type: list[ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList]

    def validate(self):
        if self.push_task_result_list:
            for k in self.push_task_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyPushAllTaskResponseBodyPushTaskRsp, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PushTaskResultList'] = []
        if self.push_task_result_list is not None:
            for k in self.push_task_result_list:
                result['PushTaskResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.push_task_result_list = []
        if m.get('PushTaskResultList') is not None:
            for k in m.get('PushTaskResultList'):
                temp_model = ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList()
                self.push_task_result_list.append(temp_model.from_map(k))
        return self


class ModifyPushAllTaskResponseBody(TeaModel):
    def __init__(self, push_task_rsp=None, request_id=None):
        # The results of security check tasks.
        self.push_task_rsp = push_task_rsp  # type: ModifyPushAllTaskResponseBodyPushTaskRsp
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.push_task_rsp:
            self.push_task_rsp.validate()

    def to_map(self):
        _map = super(ModifyPushAllTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.push_task_rsp is not None:
            result['PushTaskRsp'] = self.push_task_rsp.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PushTaskRsp') is not None:
            temp_model = ModifyPushAllTaskResponseBodyPushTaskRsp()
            self.push_task_rsp = temp_model.from_map(m['PushTaskRsp'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPushAllTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPushAllTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPushAllTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPushAllTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRiskCheckStatusRequest(TeaModel):
    def __init__(self, item_id=None, lang=None, resource_owner_id=None, source_ip=None, status=None, task_id=None):
        # The ID of the check item.
        self.item_id = item_id  # type: long
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The method to handle the check item. Valid values:
        # 
        # *   **ignored**: ignores the check item.
        # *   **reset**: cancels ignoring the check item.
        self.status = status  # type: str
        # The ID of the check task to which the check item belongs.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRiskCheckStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ModifyRiskCheckStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRiskCheckStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRiskCheckStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyRiskCheckStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyRiskCheckStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRiskCheckStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRiskSingleResultStatusRequest(TeaModel):
    def __init__(self, ids=None, lang=None, resource_owner_id=None, source_ip=None, status=None, task_id=None):
        # The IDs of the affected assets.
        self.ids = ids  # type: list[str]
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The method to handle the risk item. Valid values:
        # 
        # *   **ignored**: ignores the risk item.
        # *   **failed**: cancels the ignore operation on the risk item.
        self.status = status  # type: str
        # The ID of the check task to which the affected asset belongs.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRiskSingleResultStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ModifyRiskSingleResultStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRiskSingleResultStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRiskSingleResultStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyRiskSingleResultStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyRiskSingleResultStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRiskSingleResultStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityCheckScheduleConfigRequest(TeaModel):
    def __init__(self, days_of_week=None, end_time=None, lang=None, resource_owner_id=None, source_ip=None,
                 start_time=None):
        # The days on which the automatic configuration check runs. You can specify multiple days. Separate multiple days with commas (,). Valid values:
        # 
        # *   **1**: Monday
        # *   **2**: Tuesday
        # *   **3**: Wednesday
        # *   **4**: Thursday
        # *   **5**: Friday
        # *   **6**: Saturday
        # *   **7**: Sunday
        self.days_of_week = days_of_week  # type: str
        # The time period during which the automatic configuration check ends. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.end_time = end_time  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The time period during which the automatic configuration check starts. Valid values:
        # 
        # *   **0**: 00:00 to 06:00
        # *   **6**: 06:00 to 12:00
        # *   **12**: 12:00 to 18:00
        # *   **18**: 18:00 to 24:00
        self.start_time = start_time  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityCheckScheduleConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days_of_week is not None:
            result['DaysOfWeek'] = self.days_of_week
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DaysOfWeek') is not None:
            self.days_of_week = m.get('DaysOfWeek')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifySecurityCheckScheduleConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityCheckScheduleConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityCheckScheduleConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityCheckScheduleConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityCheckScheduleConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityCheckScheduleConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityEventMarkMissIndividuallyRequest(TeaModel):
    def __init__(self, delete_mark_miss_param=None, from_=None, insert_mark_miss_param=None, lang=None,
                 source_ip=None):
        self.delete_mark_miss_param = delete_mark_miss_param  # type: str
        self.from_ = from_  # type: str
        self.insert_mark_miss_param = insert_mark_miss_param  # type: str
        self.lang = lang  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityEventMarkMissIndividuallyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_mark_miss_param is not None:
            result['DeleteMarkMissParam'] = self.delete_mark_miss_param
        if self.from_ is not None:
            result['From'] = self.from_
        if self.insert_mark_miss_param is not None:
            result['InsertMarkMissParam'] = self.insert_mark_miss_param
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeleteMarkMissParam') is not None:
            self.delete_mark_miss_param = m.get('DeleteMarkMissParam')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('InsertMarkMissParam') is not None:
            self.insert_mark_miss_param = m.get('InsertMarkMissParam')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class ModifySecurityEventMarkMissIndividuallyResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None, time_cost=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.time_cost = time_cost  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityEventMarkMissIndividuallyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class ModifySecurityEventMarkMissIndividuallyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityEventMarkMissIndividuallyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityEventMarkMissIndividuallyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityEventMarkMissIndividuallyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStartVulScanRequest(TeaModel):
    def __init__(self, types=None, uuids=None):
        # The types of vulnerabilities that can be detected. Valid values:
        # 
        # *   **cve**: Linux software vulnerabilities
        # *   **sys**: Windows system vulnerabilities
        # *   **cms**: Web-CMS vulnerabilities
        # *   **app**: application vulnerabilities
        # *   **emg**: urgent vulnerabilities
        # *   **image**: container image vulnerabilities
        # 
        # >  If you leave this parameter empty, all types of vulnerabilities can be detected.
        self.types = types  # type: str
        # The UUIDs of servers.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStartVulScanRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.types is not None:
            result['Types'] = self.types
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ModifyStartVulScanResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStartVulScanResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStartVulScanResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyStartVulScanResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyStartVulScanResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStartVulScanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStrategyRequest(TeaModel):
    def __init__(self, custom_type=None, cycle_days=None, cycle_start_time=None, end_time=None, id=None, name=None,
                 risk_custom_params=None, risk_sub_type_name=None, source_ip=None, start_time=None, target_type=None):
        # The type of the baseline check policy. Valid values:
        # 
        # *   **custom**: a custom baseline check policy
        # *   **common**: a standard baseline check policy
        self.custom_type = custom_type  # type: str
        # The new interval of the baseline check. Valid values:
        # 
        # *   **1**: every 2 days
        # *   **3**: every 4 days
        # *   **7**: every 8 days
        # *   **30**: every 31 days
        self.cycle_days = cycle_days  # type: str
        # The new time range during which the baseline check starts. Valid values:
        # 
        # *   **0**: The baseline check starts within the time range from 00:00 to 06:00.
        # *   **6**: The baseline check starts within the time range from 06:00 to 12:00.
        # *   **12**: The baseline check starts within the time range from 12:00 to 18:00.
        # *   **18**: The baseline check starts within the time range from 18:00 to 24:00.
        # 
        # >  This parameter is deprecated.
        self.cycle_start_time = cycle_start_time  # type: str
        # The time when the baseline check based on the baseline check policy ends.
        self.end_time = end_time  # type: str
        # The ID of the baseline check policy.
        self.id = id  # type: str
        # The new name of the baseline check policy.
        self.name = name  # type: str
        # The custom configurations of the baseline. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **typeName**: the name of the baseline.
        # 
        # *   **checkDetails**: the details of the baseline. The value is in the JSON format.
        # 
        #     *   **checkId**: the ID of the check item.
        # 
        #     *   **rules**: the rule configurations. The value is in the JSON format.
        # 
        #         *   **ruleId**: the ID of the rule.
        # 
        #         *   **paramList**: the list of parameters in the rule. The value is in the JSON format.
        # 
        #             *   **paramName**: the name of the parameter.
        #             *   **value**: the value of the parameter.
        self.risk_custom_params = risk_custom_params  # type: str
        # The subtype of the baselines. You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the subtypes of baselines.
        self.risk_sub_type_name = risk_sub_type_name  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The time when the baseline check based on the baseline check policy starts.
        self.start_time = start_time  # type: str
        # The method that is used to apply the baseline check policy. Valid values:
        # 
        # *   **groupId**: asset groups
        # *   **uuid**: assets
        self.target_type = target_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_type is not None:
            result['CustomType'] = self.custom_type
        if self.cycle_days is not None:
            result['CycleDays'] = self.cycle_days
        if self.cycle_start_time is not None:
            result['CycleStartTime'] = self.cycle_start_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.risk_custom_params is not None:
            result['RiskCustomParams'] = self.risk_custom_params
        if self.risk_sub_type_name is not None:
            result['RiskSubTypeName'] = self.risk_sub_type_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomType') is not None:
            self.custom_type = m.get('CustomType')
        if m.get('CycleDays') is not None:
            self.cycle_days = m.get('CycleDays')
        if m.get('CycleStartTime') is not None:
            self.cycle_start_time = m.get('CycleStartTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RiskCustomParams') is not None:
            self.risk_custom_params = m.get('RiskCustomParams')
        if m.get('RiskSubTypeName') is not None:
            self.risk_sub_type_name = m.get('RiskSubTypeName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class ModifyStrategyResponseBodyResult(TeaModel):
    def __init__(self, strategy_id=None):
        # The ID of the baseline check policy.
        self.strategy_id = strategy_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStrategyResponseBodyResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class ModifyStrategyResponseBody(TeaModel):
    def __init__(self, http_status_code=None, request_id=None, result=None, success=None):
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # The result returned.
        self.result = result  # type: ModifyStrategyResponseBodyResult
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super(ModifyStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ModifyStrategyResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStrategyTargetRequest(TeaModel):
    def __init__(self, config=None, source_ip=None, target=None, type=None):
        # The ID of the baseline check policy. The ID is returned after the policy is created. The value of this parameter is in the JSON format and contains the following field:
        # 
        # *   **strategyId**: the ID of the policy
        self.config = config  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The information about the asset group to which the policy is applied. The value of this parameter is in the JSON format and contains the following fields:
        # 
        # *   **TargetType**: the type of the asset to which the policy is applied. Set the value to **groupId**, which indicates that the policy is applied to an asset group.
        # 
        # *   **BindUuidCount**: the number of servers to which the policy is applied.
        # 
        # *   **Target**: the ID of the asset group.
        # 
        # *   **Flag**: the operation that you want to perform on the asset group. Valid values:
        # 
        #     *   **del**: removes the asset group from the policy.
        #     *   **add**: adds the asset group to the policy.
        self.target = target  # type: str
        # The configuration type. Set the value to **hc_strategy**.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStrategyTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyStrategyTargetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStrategyTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStrategyTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyStrategyTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyStrategyTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStrategyTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyTagWithUuidRequest(TeaModel):
    def __init__(self, machine_types=None, tag_id=None, tag_list=None, uuid_list=None):
        # The type of the assets whose tags you want to modify. Valid values:
        # 
        # *   **ecs**: Elastic Compute Service (ECS) instances or servers that are not deployed on Alibaba Cloud.
        # *   **cloud_product**: Alibaba Cloud service.
        # 
        # >  If you do not specify this parameter, the default value **ecs** is used.
        self.machine_types = machine_types  # type: str
        # The ID of the tag whose name you want to change.
        # 
        # >  You can call the [DescribeGroupedTags](~~DescribeGroupedTags~~) operation to query the IDs of the tags.
        self.tag_id = tag_id  # type: str
        # The tag names that you want to change. Separate multiple tag names with commas (,).
        # 
        # >  You can call the [DescribeGroupedTags](~~DescribeGroupedTags~~) operation to query the names of the tags that are added to assets.
        self.tag_list = tag_list  # type: str
        # The UUIDs of the assets whose tags you want to modify. Separate multiple UUIDs with commas (,).
        # 
        # > You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets to which the tags are added. If you do not specify this parameter, the tags that are specified in **TagList** parameter are removed from all assets.
        self.uuid_list = uuid_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTagWithUuidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.machine_types is not None:
            result['MachineTypes'] = self.machine_types
        if self.tag_id is not None:
            result['TagId'] = self.tag_id
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MachineTypes') is not None:
            self.machine_types = m.get('MachineTypes')
        if m.get('TagId') is not None:
            self.tag_id = m.get('TagId')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class ModifyTagWithUuidResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyTagWithUuidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyTagWithUuidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyTagWithUuidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyTagWithUuidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyTagWithUuidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUniBackupPolicyRequest(TeaModel):
    def __init__(self, account_name=None, account_password=None, full_plan=None, inc_plan=None, policy_id=None,
                 policy_name=None, policy_status=None, retention=None, speed_limiter=None):
        self.account_name = account_name  # type: str
        self.account_password = account_password  # type: str
        self.full_plan = full_plan  # type: dict[str, any]
        self.inc_plan = inc_plan  # type: dict[str, any]
        self.policy_id = policy_id  # type: long
        self.policy_name = policy_name  # type: str
        self.policy_status = policy_status  # type: str
        self.retention = retention  # type: int
        self.speed_limiter = speed_limiter  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUniBackupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.full_plan is not None:
            result['FullPlan'] = self.full_plan
        if self.inc_plan is not None:
            result['IncPlan'] = self.inc_plan
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('FullPlan') is not None:
            self.full_plan = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan = m.get('IncPlan')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class ModifyUniBackupPolicyShrinkRequest(TeaModel):
    def __init__(self, account_name=None, account_password=None, full_plan_shrink=None, inc_plan_shrink=None,
                 policy_id=None, policy_name=None, policy_status=None, retention=None, speed_limiter=None):
        self.account_name = account_name  # type: str
        self.account_password = account_password  # type: str
        self.full_plan_shrink = full_plan_shrink  # type: str
        self.inc_plan_shrink = inc_plan_shrink  # type: str
        self.policy_id = policy_id  # type: long
        self.policy_name = policy_name  # type: str
        self.policy_status = policy_status  # type: str
        self.retention = retention  # type: int
        self.speed_limiter = speed_limiter  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUniBackupPolicyShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_name is not None:
            result['AccountName'] = self.account_name
        if self.account_password is not None:
            result['AccountPassword'] = self.account_password
        if self.full_plan_shrink is not None:
            result['FullPlan'] = self.full_plan_shrink
        if self.inc_plan_shrink is not None:
            result['IncPlan'] = self.inc_plan_shrink
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.speed_limiter is not None:
            result['SpeedLimiter'] = self.speed_limiter
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountName') is not None:
            self.account_name = m.get('AccountName')
        if m.get('AccountPassword') is not None:
            self.account_password = m.get('AccountPassword')
        if m.get('FullPlan') is not None:
            self.full_plan_shrink = m.get('FullPlan')
        if m.get('IncPlan') is not None:
            self.inc_plan_shrink = m.get('IncPlan')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('SpeedLimiter') is not None:
            self.speed_limiter = m.get('SpeedLimiter')
        return self


class ModifyUniBackupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUniBackupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUniBackupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyUniBackupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyUniBackupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUniBackupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVpcHoneyPotRequest(TeaModel):
    def __init__(self, honey_pot_action=None, vpc_id=None):
        self.honey_pot_action = honey_pot_action  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVpcHoneyPotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honey_pot_action is not None:
            result['HoneyPotAction'] = self.honey_pot_action
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneyPotAction') is not None:
            self.honey_pot_action = m.get('HoneyPotAction')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ModifyVpcHoneyPotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVpcHoneyPotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVpcHoneyPotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVpcHoneyPotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVpcHoneyPotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVpcHoneyPotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulConfigRequest(TeaModel):
    def __init__(self, config=None, type=None):
        self.config = config  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyVulConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVulConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVulConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulTargetRequest(TeaModel):
    def __init__(self, config=None, target=None):
        self.config = config  # type: str
        self.target = target  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        return self


class ModifyVulTargetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVulTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVulTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulTargetConfigRequest(TeaModel):
    def __init__(self, config=None, source_ip=None, type=None, uuid=None):
        # Specifies whether to enable vulnerability detection. Valid values:
        # 
        # *   **on**: yes
        # *   **off**: no
        self.config = config  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   **cve**: Linux software vulnerability
        # *   **sys**: Windows system vulnerability
        # *   **cms**: Web-CMS vulnerability
        # *   **emg**: urgent vulnerability
        self.type = type  # type: str
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulTargetConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyVulTargetConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulTargetConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulTargetConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVulTargetConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVulTargetConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVulWhitelistTargetRequest(TeaModel):
    def __init__(self, id=None, reason=None, source_ip=None, target_info=None):
        self.id = id  # type: long
        self.reason = reason  # type: str
        self.source_ip = source_ip  # type: str
        self.target_info = target_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulWhitelistTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class ModifyVulWhitelistTargetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVulWhitelistTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVulWhitelistTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVulWhitelistTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVulWhitelistTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVulWhitelistTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockCreateConfigRequest(TeaModel):
    def __init__(self, defence_mode=None, dir=None, exclusive_dir=None, exclusive_file=None,
                 exclusive_file_type=None, inclusive_file=None, inclusive_file_type=None, lang=None, local_backup_dir=None, mode=None,
                 source_ip=None, uuid=None):
        self.defence_mode = defence_mode  # type: str
        self.dir = dir  # type: str
        self.exclusive_dir = exclusive_dir  # type: str
        self.exclusive_file = exclusive_file  # type: str
        self.exclusive_file_type = exclusive_file_type  # type: str
        self.inclusive_file = inclusive_file  # type: str
        self.inclusive_file_type = inclusive_file_type  # type: str
        self.lang = lang  # type: str
        self.local_backup_dir = local_backup_dir  # type: str
        self.mode = mode  # type: str
        self.source_ip = source_ip  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockCreateConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockCreateConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockCreateConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockCreateConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockCreateConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockCreateConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockCreateConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockDeleteConfigRequest(TeaModel):
    def __init__(self, id=None, lang=None, source_ip=None, uuid=None):
        # The ID of the protected directory that you want to delete. 
        # > You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the IDs of protected directories.
        self.id = id  # type: int
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUID of the server for which you want to delete the protected directory. 
        # > You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the UUID of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockDeleteConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockDeleteConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockDeleteConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockDeleteConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockDeleteConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockDeleteConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockDeleteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockProcessStatusRequest(TeaModel):
    def __init__(self, deal_all=None, operate_info=None, process_path=None, status=None, uuid=None):
        self.deal_all = deal_all  # type: int
        self.operate_info = operate_info  # type: str
        self.process_path = process_path  # type: list[str]
        self.status = status  # type: int
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockProcessStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deal_all is not None:
            result['DealAll'] = self.deal_all
        if self.operate_info is not None:
            result['OperateInfo'] = self.operate_info
        if self.process_path is not None:
            result['ProcessPath'] = self.process_path
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DealAll') is not None:
            self.deal_all = m.get('DealAll')
        if m.get('OperateInfo') is not None:
            self.operate_info = m.get('OperateInfo')
        if m.get('ProcessPath') is not None:
            self.process_path = m.get('ProcessPath')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockProcessStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockProcessStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockProcessStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockProcessStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockProcessStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockProcessStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockStartRequest(TeaModel):
    def __init__(self, defence_mode=None, dir=None, exclusive_dir=None, exclusive_file=None,
                 exclusive_file_type=None, inclusive_file_type=None, local_backup_dir=None, mode=None, uuid=None):
        self.defence_mode = defence_mode  # type: str
        self.dir = dir  # type: str
        self.exclusive_dir = exclusive_dir  # type: str
        self.exclusive_file = exclusive_file  # type: str
        self.exclusive_file_type = exclusive_file_type  # type: str
        self.inclusive_file_type = inclusive_file_type  # type: str
        self.local_backup_dir = local_backup_dir  # type: str
        self.mode = mode  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockStartRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockStartResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockStartResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockStartResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockStartResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockStartResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockStartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockStatusRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, status=None, uuid=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # Specifies whether to enable or disable web tamper proofing for the specified server. Valid values:
        # 
        # *   **on**: enables web tamper proofing
        # *   **off**: disables web tamper proofing
        # 
        # >  After you disable web tamper proofing for the specified server, one quota is released.
        self.status = status  # type: str
        # The UUID of the server for which you want to enable or disable web tamper proofing. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockUnbindRequest(TeaModel):
    def __init__(self, uuid=None):
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockUnbindRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockUnbindResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockUnbindResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockUnbindResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockUnbindResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockUnbindResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockUnbindResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebLockUpdateConfigRequest(TeaModel):
    def __init__(self, defence_mode=None, dir=None, exclusive_dir=None, exclusive_file=None,
                 exclusive_file_type=None, id=None, inclusive_file=None, inclusive_file_type=None, lang=None, local_backup_dir=None,
                 mode=None, source_ip=None, uuid=None):
        self.defence_mode = defence_mode  # type: str
        self.dir = dir  # type: str
        self.exclusive_dir = exclusive_dir  # type: str
        self.exclusive_file = exclusive_file  # type: str
        self.exclusive_file_type = exclusive_file_type  # type: str
        self.id = id  # type: int
        self.inclusive_file = inclusive_file  # type: str
        self.inclusive_file_type = inclusive_file_type  # type: str
        self.lang = lang  # type: str
        self.local_backup_dir = local_backup_dir  # type: str
        self.mode = mode  # type: str
        self.source_ip = source_ip  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockUpdateConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.defence_mode is not None:
            result['DefenceMode'] = self.defence_mode
        if self.dir is not None:
            result['Dir'] = self.dir
        if self.exclusive_dir is not None:
            result['ExclusiveDir'] = self.exclusive_dir
        if self.exclusive_file is not None:
            result['ExclusiveFile'] = self.exclusive_file
        if self.exclusive_file_type is not None:
            result['ExclusiveFileType'] = self.exclusive_file_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inclusive_file is not None:
            result['InclusiveFile'] = self.inclusive_file
        if self.inclusive_file_type is not None:
            result['InclusiveFileType'] = self.inclusive_file_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.local_backup_dir is not None:
            result['LocalBackupDir'] = self.local_backup_dir
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefenceMode') is not None:
            self.defence_mode = m.get('DefenceMode')
        if m.get('Dir') is not None:
            self.dir = m.get('Dir')
        if m.get('ExclusiveDir') is not None:
            self.exclusive_dir = m.get('ExclusiveDir')
        if m.get('ExclusiveFile') is not None:
            self.exclusive_file = m.get('ExclusiveFile')
        if m.get('ExclusiveFileType') is not None:
            self.exclusive_file_type = m.get('ExclusiveFileType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InclusiveFile') is not None:
            self.inclusive_file = m.get('InclusiveFile')
        if m.get('InclusiveFileType') is not None:
            self.inclusive_file_type = m.get('InclusiveFileType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LocalBackupDir') is not None:
            self.local_backup_dir = m.get('LocalBackupDir')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ModifyWebLockUpdateConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebLockUpdateConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyWebLockUpdateConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebLockUpdateConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebLockUpdateConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebLockUpdateConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyWebPathRequest(TeaModel):
    def __init__(self, config=None, target=None, type=None):
        self.config = config  # type: str
        self.target = target  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebPathRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyWebPathResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyWebPathResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyWebPathResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyWebPathResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyWebPathResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyWebPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenSensitiveFileScanRequest(TeaModel):
    def __init__(self, switch_on=None):
        # Specifies whether to enable or disable sensitive file scan. Valid values:
        # 
        # *   **on**: enables sensitive file scan
        # *   **off**: disables sensitive file scan
        self.switch_on = switch_on  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OpenSensitiveFileScanRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.switch_on is not None:
            result['SwitchOn'] = self.switch_on
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SwitchOn') is not None:
            self.switch_on = m.get('SwitchOn')
        return self


class OpenSensitiveFileScanResponseBodyData(TeaModel):
    def __init__(self, switch_on=None):
        # Indicates whether sensitive file scan is enabled or disabled. Valid values:
        # 
        # *   **on**: enabled
        # *   **off**: disabled
        self.switch_on = switch_on  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OpenSensitiveFileScanResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.switch_on is not None:
            result['SwitchOn'] = self.switch_on
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SwitchOn') is not None:
            self.switch_on = m.get('SwitchOn')
        return self


class OpenSensitiveFileScanResponseBody(TeaModel):
    def __init__(self, code=None, data=None, http_status_code=None, message=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # The data.
        self.data = data  # type: OpenSensitiveFileScanResponseBodyData
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(OpenSensitiveFileScanResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = OpenSensitiveFileScanResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OpenSensitiveFileScanResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OpenSensitiveFileScanResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OpenSensitiveFileScanResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenSensitiveFileScanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateAgentClientInstallRequest(TeaModel):
    def __init__(self, instance_ids=None, lang=None, uuids=None):
        # The IDs of the servers on which you want to install the Security Center agent. Separate multiple IDs with commas (,).
        # 
        # >  You must specify at least one of the **InstanceIds** and **Uuids** parameters before you can call this operation.
        self.instance_ids = instance_ids  # type: str
        self.lang = lang  # type: str
        # The UUIDs of the servers on which you want to install the Security Center agent. Separate multiple UUIDs with commas (,).
        # 
        # >  You must specify at least one of the **InstanceIds** and **Uuids** parameters before you can call this operation.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateAgentClientInstallRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList(TeaModel):
    def __init__(self, instance_id=None, record_id=None, uuid=None):
        # The ID of the server.
        self.instance_id = instance_id  # type: str
        # The ID of the installation task.
        self.record_id = record_id  # type: long
        # The UUID of the server.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class OperateAgentClientInstallResponseBody(TeaModel):
    def __init__(self, aegis_celint_install_respose_list=None, request_id=None):
        # An array that consists of the returned results.
        self.aegis_celint_install_respose_list = aegis_celint_install_respose_list  # type: list[OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList]
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.aegis_celint_install_respose_list:
            for k in self.aegis_celint_install_respose_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(OperateAgentClientInstallResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AegisCelintInstallResposeList'] = []
        if self.aegis_celint_install_respose_list is not None:
            for k in self.aegis_celint_install_respose_list:
                result['AegisCelintInstallResposeList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aegis_celint_install_respose_list = []
        if m.get('AegisCelintInstallResposeList') is not None:
            for k in m.get('AegisCelintInstallResposeList'):
                temp_model = OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList()
                self.aegis_celint_install_respose_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateAgentClientInstallResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateAgentClientInstallResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateAgentClientInstallResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateAgentClientInstallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateCommonOverallConfigRequest(TeaModel):
    def __init__(self, config=None, source_ip=None, type=None):
        # Specifies whether to enable or disable the feature. Valid values:
        # 
        # *   **on**: enable
        # *   **off**: disable
        self.config = config  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the feature. Valid values:
        # 
        # *   **kdump_switch**: Active defense experience optimization
        # *   **threat_detect**: Dynamic adaptive threat detection capability
        # *   **suspicious_aggregation**: Alert Association
        # *   **alidetect**: File Test
        # *   **USER-ENABLE-SWITCH-TYPE\_38857**: Entrance service execution high-risk operation (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50858**: Web service performs high-risk operations (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50859**: Entrance service execution suspicious operation (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50862**: Cloud Assistant Advanced Protection (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50867**: Create malicious files (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50868**: Create suspicious files (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_64025**: Ingress service execute command \[enhanced mode] (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51229**: Browser service execution a high-risk operation (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51230**: Entrance service execution suspicious operation (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51232**: System processes execution high-risk operations (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51233**: Java service execution high-risk operations (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51234**: Office components execution high-risk operations (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51235**: Web service performs high-risk operations (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52820**: Create malicious files (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52826**: Entrance service execution high-risk operation (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_55251**: Database services execution high-risk operations (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_63725**: Ingress service implants suspicious script/binary file (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_3277**: Suspicious process startup (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50983**: obfuscated command (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51200**: Command line download and run malicious files (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_71131**: Ingress service executes sequence of suspicious behavior (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51225**: Powershell executes high-risk commands (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_51226**: Powershell execute suspicious command (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52821**: Suspicious process startup (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_57242**: Malicious command execution (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_57340**: Command line download and run malicious files (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_39659**: Sensitive Registry Key Protection (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52816**: high-risk account manipulation behavior (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54365**: Create service autorun item (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54366**: Create high-risk autorun item (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54367**: Create scheduled task autorun item (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54368**: Create registry autorun item (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54369**: Create WMI autorun item (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_50869**: Unauthorized execution of high-risk orders (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_54395**: Unauthorized reading and writing of sensitive files (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_57897**: suspected privilege escalation (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_52825**: Unauthorized execution of high-risk orders (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_5507**: malicious drivers (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50876**: Against security software (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_53168**: process debugging (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_54699**: Hijack dynamic link library (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_62981**: Bypassing security monitoring (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_52815**: Load high-risk drivers (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52823**: Running high-risk ARK tools (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54373**: Against security software (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54374**: Intrusion trace cleanup (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54265**: Hijacking the PAM Module (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_54953**: Hashdump Attack (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_54383**: MimiKatz Credential Stealing (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54384**: Hashdump Attack (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_50861**: Information detection (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_52818**: Information detection (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_54034**: Intranet scan (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51228**: High-risk lateral penetration tools (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_50870**: Rebound Shell (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50873**: WebShell execute command
        # *   **USER-ENABLE-SWITCH-TYPE\_51236**: Rebound Shell (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_50877**: Malicious soft communication (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50884**: Suspicious worm script behavior (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_50885**: malicious script behavior (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51201**: ransomware (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_51202**: Suspected Extortion (Linux)
        # *   **USER-ENABLE-SWITCH-TYPE\_52827**: ransomware (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52828**: Suspected Extortion (Windows)
        # *   **USER-ENABLE-SWITCH-TYPE\_52829**: delete system backup behavior (Windows)
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateCommonOverallConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateCommonOverallConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateCommonOverallConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateCommonOverallConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateCommonOverallConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateCommonOverallConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateCommonOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateCommonTargetConfigRequest(TeaModel):
    def __init__(self, field_name=None, field_value=None, source_ip=None, target_operations=None, target_type=None,
                 type=None):
        self.field_name = field_name  # type: str
        self.field_value = field_value  # type: str
        self.source_ip = source_ip  # type: str
        self.target_operations = target_operations  # type: str
        self.target_type = target_type  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateCommonTargetConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_operations is not None:
            result['TargetOperations'] = self.target_operations
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetOperations') is not None:
            self.target_operations = m.get('TargetOperations')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateCommonTargetConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateCommonTargetConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateCommonTargetConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateCommonTargetConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateCommonTargetConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateCommonTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateImageBaselineWhitelistRequest(TeaModel):
    def __init__(self, baseline_item_key_list=None, image_uuid=None, lang=None, operation=None, scan_range=None):
        self.baseline_item_key_list = baseline_item_key_list  # type: str
        self.image_uuid = image_uuid  # type: str
        self.lang = lang  # type: str
        self.operation = operation  # type: str
        self.scan_range = scan_range  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateImageBaselineWhitelistRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_key_list is not None:
            result['BaselineItemKeyList'] = self.baseline_item_key_list
        if self.image_uuid is not None:
            result['ImageUuid'] = self.image_uuid
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.scan_range is not None:
            result['ScanRange'] = self.scan_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineItemKeyList') is not None:
            self.baseline_item_key_list = m.get('BaselineItemKeyList')
        if m.get('ImageUuid') is not None:
            self.image_uuid = m.get('ImageUuid')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ScanRange') is not None:
            self.scan_range = m.get('ScanRange')
        return self


class OperateImageBaselineWhitelistResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateImageBaselineWhitelistResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateImageBaselineWhitelistResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateImageBaselineWhitelistResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateImageBaselineWhitelistResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateImageBaselineWhitelistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateImageVulRequest(TeaModel):
    def __init__(self, info=None, operate_type=None, type=None):
        self.info = info  # type: str
        self.operate_type = operate_type  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateImageVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateImageVulResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateImageVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateImageVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateImageVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateImageVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateImageVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateSuspiciousOverallConfigRequest(TeaModel):
    def __init__(self, config=None, lang=None, no_target_as_on=None, source_ip=None, type=None):
        # Specifies whether to enable the feature. Valid values:
        # 
        # *   **on**: yes
        # *   **off**: no
        self.config = config  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # Specifies whether to configure assets for the feature. Default value: **false**. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  This parameter takes effect only when you set **Config** to **on**.
        self.no_target_as_on = no_target_as_on  # type: bool
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the feature. Valid values:
        # 
        # *   **auto_breaking**: Anti-Virus
        # *   **ransomware_breaking**: Anti-ransomware (Bait Capture)
        # *   **webshell\_cloud_breaking**: Webshell Protection
        # *   **alinet**: Behavior prevention
        # *   **k8s\_log_analysis**: K8s Threat Detection
        # *   **alisecguard**: Defense mode for Client Protection
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateSuspiciousOverallConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.no_target_as_on is not None:
            result['NoTargetAsOn'] = self.no_target_as_on
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NoTargetAsOn') is not None:
            self.no_target_as_on = m.get('NoTargetAsOn')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateSuspiciousOverallConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateSuspiciousOverallConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateSuspiciousOverallConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateSuspiciousOverallConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateSuspiciousOverallConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateSuspiciousOverallConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateSuspiciousTargetConfigRequest(TeaModel):
    def __init__(self, lang=None, source_ip=None, target_operations=None, target_type=None, type=None):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The configuration of proactive defense for your server. The value includes the following fields:
        # 
        # *   **targetType**: specifies the dimension from which you manage proactive defense. UUIDs are supported. Set the value to **uuid**.
        # *   **target**: specifies the UUID of the server for which you want to configure proactive defense.
        # *   **flag**: specifies whether to enable or disable proactive defense for your server. Valid values are **add** and **del**. The value add indicates that proactive defense will be enabled for your server. The value del indicates that proactive defense will be disabled for your server.
        self.target_operations = target_operations  # type: str
        # The dimension from which you manage proactive defense. Only the server UUID dimension is supported.
        # 
        # Set the value to **uuid**.
        self.target_type = target_type  # type: str
        # The type of proactive defense. Valid Values:
        # 
        # *   **auto_breaking**: automatic blocking
        # *   **webshell_cloud_breaking**: webshell defense
        # *   **alinet**: malicious behavior defense
        # *   **ransomware_breaking**: ransomware capture
        # *   **alisecguard**: client protection
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateSuspiciousTargetConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.target_operations is not None:
            result['TargetOperations'] = self.target_operations
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('TargetOperations') is not None:
            self.target_operations = m.get('TargetOperations')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateSuspiciousTargetConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateSuspiciousTargetConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateSuspiciousTargetConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateSuspiciousTargetConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateSuspiciousTargetConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateSuspiciousTargetConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateVirusEventsRequest(TeaModel):
    def __init__(self, operation_all=None, operation_code=None, operation_range=None):
        self.operation_all = operation_all  # type: int
        self.operation_code = operation_code  # type: str
        self.operation_range = operation_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVirusEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_all is not None:
            result['OperationAll'] = self.operation_all
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_range is not None:
            result['OperationRange'] = self.operation_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationAll') is not None:
            self.operation_all = m.get('OperationAll')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationRange') is not None:
            self.operation_range = m.get('OperationRange')
        return self


class OperateVirusEventsResponseBody(TeaModel):
    def __init__(self, request_id=None, task_id=None):
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVirusEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class OperateVirusEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateVirusEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateVirusEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateVirusEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateVulsRequest(TeaModel):
    def __init__(self, operate_type=None, type=None, uuids=None, vul_names=None):
        # The operation on the vulnerabilities. Set the value to **vul_fix**, which indicates vulnerability fixing.
        self.operate_type = operate_type  # type: str
        # The type of the vulnerabilities that you want to fix. Set the value to **cve**, which indicates Linux software vulnerabilities.
        self.type = type  # type: str
        # The UUIDs of servers for which you want to fix vulnerabilities.
        self.uuids = uuids  # type: list[str]
        # The names of the vulnerabilities that you want to fix.
        self.vul_names = vul_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVulsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.type is not None:
            result['Type'] = self.type
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.vul_names is not None:
            result['VulNames'] = self.vul_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('VulNames') is not None:
            self.vul_names = m.get('VulNames')
        return self


class OperateVulsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVulsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateVulsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateVulsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateVulsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateVulsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateWebLockFileEventsRequest(TeaModel):
    def __init__(self, deal_all=None, event_ids=None, operation_code=None):
        self.deal_all = deal_all  # type: int
        self.event_ids = event_ids  # type: list[long]
        self.operation_code = operation_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateWebLockFileEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deal_all is not None:
            result['DealAll'] = self.deal_all
        if self.event_ids is not None:
            result['EventIds'] = self.event_ids
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DealAll') is not None:
            self.deal_all = m.get('DealAll')
        if m.get('EventIds') is not None:
            self.event_ids = m.get('EventIds')
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        return self


class OperateWebLockFileEventsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateWebLockFileEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateWebLockFileEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateWebLockFileEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateWebLockFileEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateWebLockFileEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperationCancelIgnoreSuspEventRequest(TeaModel):
    def __init__(self, security_event_ids=None):
        self.security_event_ids = security_event_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperationCancelIgnoreSuspEventRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_event_ids is not None:
            result['SecurityEventIds'] = self.security_event_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityEventIds') is not None:
            self.security_event_ids = m.get('SecurityEventIds')
        return self


class OperationCancelIgnoreSuspEventResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None, time_cost=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool
        self.time_cost = time_cost  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperationCancelIgnoreSuspEventResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class OperationCancelIgnoreSuspEventResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperationCancelIgnoreSuspEventResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperationCancelIgnoreSuspEventResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperationCancelIgnoreSuspEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperationSuspEventsRequest(TeaModel):
    def __init__(self, from_=None, operation=None, source_ip=None, sub_operation=None, suspicious_event_ids=None,
                 warn_type=None):
        self.from_ = from_  # type: str
        self.operation = operation  # type: str
        self.source_ip = source_ip  # type: str
        self.sub_operation = sub_operation  # type: str
        self.suspicious_event_ids = suspicious_event_ids  # type: str
        self.warn_type = warn_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperationSuspEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.sub_operation is not None:
            result['SubOperation'] = self.sub_operation
        if self.suspicious_event_ids is not None:
            result['SuspiciousEventIds'] = self.suspicious_event_ids
        if self.warn_type is not None:
            result['WarnType'] = self.warn_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SubOperation') is not None:
            self.sub_operation = m.get('SubOperation')
        if m.get('SuspiciousEventIds') is not None:
            self.suspicious_event_ids = m.get('SuspiciousEventIds')
        if m.get('WarnType') is not None:
            self.warn_type = m.get('WarnType')
        return self


class OperationSuspEventsResponseBody(TeaModel):
    def __init__(self, access_code=None, request_id=None, success=None):
        self.access_code = access_code  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperationSuspEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_code is not None:
            result['AccessCode'] = self.access_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessCode') is not None:
            self.access_code = m.get('AccessCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OperationSuspEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperationSuspEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperationSuspEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperationSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PageImageRegistryRequest(TeaModel):
    def __init__(self, current_page=None, page_size=None, registry_name_like=None, registry_type_in_list=None,
                 registry_type_not_in_list=None, source_ip=None):
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.registry_name_like = registry_name_like  # type: str
        self.registry_type_in_list = registry_type_in_list  # type: list[str]
        self.registry_type_not_in_list = registry_type_not_in_list  # type: list[str]
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PageImageRegistryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.registry_name_like is not None:
            result['RegistryNameLike'] = self.registry_name_like
        if self.registry_type_in_list is not None:
            result['RegistryTypeInList'] = self.registry_type_in_list
        if self.registry_type_not_in_list is not None:
            result['RegistryTypeNotInList'] = self.registry_type_not_in_list
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegistryNameLike') is not None:
            self.registry_name_like = m.get('RegistryNameLike')
        if m.get('RegistryTypeInList') is not None:
            self.registry_type_in_list = m.get('RegistryTypeInList')
        if m.get('RegistryTypeNotInList') is not None:
            self.registry_type_not_in_list = m.get('RegistryTypeNotInList')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class PageImageRegistryResponseBodyList(TeaModel):
    def __init__(self, black_list=None, domain_name=None, gmt_create=None, gmt_modified=None, id=None,
                 image_count=None, jenkins_env=None, net_type=None, password=None, persistence_day=None, protocol_type=None,
                 region_id=None, registry_host_ip=None, registry_name=None, registry_type=None, token=None,
                 trans_per_hour=None, user_name=None, vpc_id=None, white_list=None):
        self.black_list = black_list  # type: str
        self.domain_name = domain_name  # type: str
        self.gmt_create = gmt_create  # type: str
        self.gmt_modified = gmt_modified  # type: str
        self.id = id  # type: long
        self.image_count = image_count  # type: int
        self.jenkins_env = jenkins_env  # type: str
        self.net_type = net_type  # type: int
        self.password = password  # type: str
        self.persistence_day = persistence_day  # type: int
        self.protocol_type = protocol_type  # type: int
        self.region_id = region_id  # type: str
        self.registry_host_ip = registry_host_ip  # type: str
        self.registry_name = registry_name  # type: str
        self.registry_type = registry_type  # type: str
        self.token = token  # type: str
        self.trans_per_hour = trans_per_hour  # type: int
        self.user_name = user_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.white_list = white_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PageImageRegistryResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_list is not None:
            result['BlackList'] = self.black_list
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.image_count is not None:
            result['ImageCount'] = self.image_count
        if self.jenkins_env is not None:
            result['JenkinsEnv'] = self.jenkins_env
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.password is not None:
            result['Password'] = self.password
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.registry_host_ip is not None:
            result['RegistryHostIp'] = self.registry_host_ip
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.token is not None:
            result['Token'] = self.token
        if self.trans_per_hour is not None:
            result['TransPerHour'] = self.trans_per_hour
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlackList') is not None:
            self.black_list = m.get('BlackList')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageCount') is not None:
            self.image_count = m.get('ImageCount')
        if m.get('JenkinsEnv') is not None:
            self.jenkins_env = m.get('JenkinsEnv')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegistryHostIp') is not None:
            self.registry_host_ip = m.get('RegistryHostIp')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('TransPerHour') is not None:
            self.trans_per_hour = m.get('TransPerHour')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class PageImageRegistryResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        self.count = count  # type: int
        self.current_page = current_page  # type: int
        self.page_size = page_size  # type: int
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PageImageRegistryResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PageImageRegistryResponseBody(TeaModel):
    def __init__(self, list=None, page_info=None, request_id=None):
        self.list = list  # type: list[PageImageRegistryResponseBodyList]
        self.page_info = page_info  # type: PageImageRegistryResponseBodyPageInfo
        self.request_id = request_id  # type: str

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(PageImageRegistryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = PageImageRegistryResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageInfo') is not None:
            temp_model = PageImageRegistryResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PageImageRegistryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PageImageRegistryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PageImageRegistryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PageImageRegistryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseClientRequest(TeaModel):
    def __init__(self, uuids=None, value=None):
        # The list of servers for which you want to enable or disable the Security Center agent.
        self.uuids = uuids  # type: str
        # The status of the Security Center agent. Valid values:
        # - **0**: disabled
        # - **1**: enabled
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PauseClientRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PauseClientResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PauseClientResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PauseClientResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PauseClientResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PauseClientResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicCreateImageScanTaskRequest(TeaModel):
    def __init__(self, digests=None, instance_ids=None, region_ids=None, registry_types=None, repo_ids=None,
                 repo_names=None, repo_namespaces=None, source_ip=None, tags=None):
        # The SHA-256 value of the image digest. Separate multiple SHA-256 values with commas (,).
        self.digests = digests  # type: str
        # The ID of the Container Registry instance in which the image repository is created. Separate multiple IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # The region ID of the image. Separate multiple IDs with commas (,).
        self.region_ids = region_ids  # type: str
        # The type of the image repository. Separate multiple types with commas (,). Valid values:
        # 
        # *   **acr**\
        # *   **harbor**\
        # *   **quay**\
        self.registry_types = registry_types  # type: str
        # The ID of the image repository. Separate multiple IDs with commas (,).
        self.repo_ids = repo_ids  # type: str
        # The name of the image repository. Separate multiple names with commas (,).
        self.repo_names = repo_names  # type: str
        # The namespace to which the image repository belongs. Separate multiple namespaces with commas (,).
        self.repo_namespaces = repo_namespaces  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The tag that is added to the image. Separate multiple tags with commas (,).
        self.tags = tags  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicCreateImageScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digests is not None:
            result['Digests'] = self.digests
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.registry_types is not None:
            result['RegistryTypes'] = self.registry_types
        if self.repo_ids is not None:
            result['RepoIds'] = self.repo_ids
        if self.repo_names is not None:
            result['RepoNames'] = self.repo_names
        if self.repo_namespaces is not None:
            result['RepoNamespaces'] = self.repo_namespaces
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digests') is not None:
            self.digests = m.get('Digests')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('RegistryTypes') is not None:
            self.registry_types = m.get('RegistryTypes')
        if m.get('RepoIds') is not None:
            self.repo_ids = m.get('RepoIds')
        if m.get('RepoNames') is not None:
            self.repo_names = m.get('RepoNames')
        if m.get('RepoNamespaces') is not None:
            self.repo_namespaces = m.get('RepoNamespaces')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class PublicCreateImageScanTaskResponseBodyData(TeaModel):
    def __init__(self, can_create=None, collect_time=None, exec_time=None, finish_count=None, progress=None,
                 result=None, status=None, task_id=None, total_count=None):
        # Indicates whether you can create more image scan tasks. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        # 
        # >  By default, a maximum of 10 image scan tasks can be running at the same time. If 10 image scan tasks are running, you cannot create an image scan task by calling this operation. You must wait for at least one of the 10 existing image scan tasks to complete before you can create an image scan task.
        self.can_create = can_create  # type: bool
        # The timestamp when the information about the images was collected. Unit: milliseconds.
        self.collect_time = collect_time  # type: long
        # The timestamp when the image scan task started to run. Unit: milliseconds.
        self.exec_time = exec_time  # type: long
        # The number of images that have been scanned.
        self.finish_count = finish_count  # type: int
        # The progress of the image scan task. Unit: percent.
        self.progress = progress  # type: int
        # The result of the image scan task. Valid values:
        # 
        # *   **SUCCESS**: The task is successful.
        # *   **TASK_NOT_SUPPORT_REGION**: The images are deployed in a region that is not supported by container image scan.
        # 
        # >  For more information about the regions supported by container image scan, see the "Regions supported by container image scan" section in this topic.
        self.result = result  # type: str
        # The status of the image scan task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **PRE_ANALYZER**: The task is being pre-processed.
        # *   **SUCCESS**: The task is successful.
        # *   **FAIL**: The task failed.
        self.status = status  # type: str
        # The ID of the image scan task.
        self.task_id = task_id  # type: str
        # The total number of images that need to be scanned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicCreateImageScanTaskResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PublicCreateImageScanTaskResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The data returned if the call is successful.
        self.data = data  # type: PublicCreateImageScanTaskResponseBodyData
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(PublicCreateImageScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicCreateImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicCreateImageScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PublicCreateImageScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PublicCreateImageScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicCreateImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicPreCheckImageScanTaskRequest(TeaModel):
    def __init__(self, digests=None, instance_ids=None, region_ids=None, registry_types=None, repo_ids=None,
                 repo_names=None, repo_namespaces=None, source_ip=None, tags=None):
        # The SHA-256 value of the image digest. Separate multiple SHA-256 values with commas (,).
        self.digests = digests  # type: str
        # The ID of the Container Registry instance in which the image repository is created. Separate multiple IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # The region ID of the image. Separate multiple IDs with commas (,).
        self.region_ids = region_ids  # type: str
        # The type of the image repository. Separate multiple types with commas (,). Valid values:
        # 
        # *   **acr**\
        # *   **harbor**\
        # *   **quay**\
        self.registry_types = registry_types  # type: str
        # The ID of the image repository. Separate multiple IDs with commas (,).
        self.repo_ids = repo_ids  # type: str
        # The name of the image repository. Separate multiple names with commas (,).
        self.repo_names = repo_names  # type: str
        # The namespace to which the image repository belongs. Separate multiple namespaces with commas (,).
        self.repo_namespaces = repo_namespaces  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The tag that is added to the image. Separate multiple tags with commas (,).
        self.tags = tags  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicPreCheckImageScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.digests is not None:
            result['Digests'] = self.digests
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.registry_types is not None:
            result['RegistryTypes'] = self.registry_types
        if self.repo_ids is not None:
            result['RepoIds'] = self.repo_ids
        if self.repo_names is not None:
            result['RepoNames'] = self.repo_names
        if self.repo_namespaces is not None:
            result['RepoNamespaces'] = self.repo_namespaces
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Digests') is not None:
            self.digests = m.get('Digests')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('RegistryTypes') is not None:
            self.registry_types = m.get('RegistryTypes')
        if m.get('RepoIds') is not None:
            self.repo_ids = m.get('RepoIds')
        if m.get('RepoNames') is not None:
            self.repo_names = m.get('RepoNames')
        if m.get('RepoNamespaces') is not None:
            self.repo_namespaces = m.get('RepoNamespaces')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class PublicPreCheckImageScanTaskResponseBodyData(TeaModel):
    def __init__(self, need_auth_count=None, scan_image_count=None):
        # The number of images to scan in the task.
        self.need_auth_count = need_auth_count  # type: int
        # The quota for container image scan to be consumed by the task.
        self.scan_image_count = scan_image_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicPreCheckImageScanTaskResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.need_auth_count is not None:
            result['NeedAuthCount'] = self.need_auth_count
        if self.scan_image_count is not None:
            result['ScanImageCount'] = self.scan_image_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NeedAuthCount') is not None:
            self.need_auth_count = m.get('NeedAuthCount')
        if m.get('ScanImageCount') is not None:
            self.scan_image_count = m.get('ScanImageCount')
        return self


class PublicPreCheckImageScanTaskResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The data returned if the call is successful.
        self.data = data  # type: PublicPreCheckImageScanTaskResponseBodyData
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(PublicPreCheckImageScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicPreCheckImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicPreCheckImageScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PublicPreCheckImageScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PublicPreCheckImageScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicPreCheckImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublicSyncAndCreateImageScanTaskRequest(TeaModel):
    def __init__(self, images=None, source_ip=None):
        self.images = images  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicSyncAndCreateImageScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Images') is not None:
            self.images = m.get('Images')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class PublicSyncAndCreateImageScanTaskResponseBodyData(TeaModel):
    def __init__(self, can_create=None, collect_time=None, exec_time=None, finish_count=None, progress=None,
                 result=None, status=None, task_id=None, total_count=None):
        self.can_create = can_create  # type: bool
        self.collect_time = collect_time  # type: long
        self.exec_time = exec_time  # type: long
        self.finish_count = finish_count  # type: int
        self.progress = progress  # type: int
        self.result = result  # type: str
        self.status = status  # type: str
        self.task_id = task_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PublicSyncAndCreateImageScanTaskResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_create is not None:
            result['CanCreate'] = self.can_create
        if self.collect_time is not None:
            result['CollectTime'] = self.collect_time
        if self.exec_time is not None:
            result['ExecTime'] = self.exec_time
        if self.finish_count is not None:
            result['FinishCount'] = self.finish_count
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanCreate') is not None:
            self.can_create = m.get('CanCreate')
        if m.get('CollectTime') is not None:
            self.collect_time = m.get('CollectTime')
        if m.get('ExecTime') is not None:
            self.exec_time = m.get('ExecTime')
        if m.get('FinishCount') is not None:
            self.finish_count = m.get('FinishCount')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class PublicSyncAndCreateImageScanTaskResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: PublicSyncAndCreateImageScanTaskResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(PublicSyncAndCreateImageScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PublicSyncAndCreateImageScanTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublicSyncAndCreateImageScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PublicSyncAndCreateImageScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PublicSyncAndCreateImageScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublicSyncAndCreateImageScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDiscoverDatabaseRequest(TeaModel):
    def __init__(self, create_mark=None):
        self.create_mark = create_mark  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryDiscoverDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        return self


class QueryDiscoverDatabaseResponseBody(TeaModel):
    def __init__(self, request_id=None, task_progress=None):
        self.request_id = request_id  # type: str
        self.task_progress = task_progress  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryDiscoverDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_progress is not None:
            result['TaskProgress'] = self.task_progress
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskProgress') is not None:
            self.task_progress = m.get('TaskProgress')
        return self


class QueryDiscoverDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryDiscoverDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryDiscoverDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDiscoverDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryGroupIdByGroupNameRequest(TeaModel):
    def __init__(self, group_name=None, source_ip=None):
        # The name of the asset group.
        self.group_name = group_name  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryGroupIdByGroupNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryGroupIdByGroupNameResponseBody(TeaModel):
    def __init__(self, group_id=None, request_id=None):
        # The ID of the asset group.
        self.group_id = group_id  # type: long
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryGroupIdByGroupNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryGroupIdByGroupNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryGroupIdByGroupNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryGroupIdByGroupNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryGroupIdByGroupNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryGroupedSecurityEventMarkMissListRequest(TeaModel):
    def __init__(self, current_page=None, disposal_way=None, event_name=None, from_=None, lang=None, page_size=None,
                 remark=None, source_ip=None):
        # The number of the page to return. Default value: **1**.
        self.current_page = current_page  # type: int
        # The handling method. Valid values:
        # 
        # *   **1**: Automatically Added to Whitelist
        # *   **2**: Defense Without Notification
        self.disposal_way = disposal_way  # type: str
        # The name of the alert event. The value indicates a subtype.
        self.event_name = event_name  # type: str
        # The ID of the request source. Set the value to sas.
        self.from_ = from_  # type: str
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        # The number of entries to return on each page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The condition that is used to query alert events by asset. You can specify a value of the following types:
        # 
        # *   The IP address of the asset.
        # *   The public IP address of the asset.
        # *   The private IP address of the asset.
        # *   The name of the asset.
        self.remark = remark  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryGroupedSecurityEventMarkMissListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.disposal_way is not None:
            result['DisposalWay'] = self.disposal_way
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.from_ is not None:
            result['From'] = self.from_
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DisposalWay') is not None:
            self.disposal_way = m.get('DisposalWay')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBodyList(TeaModel):
    def __init__(self, ali_uid=None, disposal_way=None, event_name=None, event_name_original=None, event_type=None,
                 event_type_original=None, field=None, field_value=None, filed_alias_name=None, operate=None, uuids=None):
        # The ID of the user.
        self.ali_uid = ali_uid  # type: long
        # The handling method. Valid values:
        # 
        # *   **auto\_add_white**: Automatically Added to Whitelist
        # *   **defense\_not_notification**: Defense Without Notification
        self.disposal_way = disposal_way  # type: str
        # The name of the alert event. The value indicates a subtype.
        self.event_name = event_name  # type: str
        # The name of the alert event. The value indicates a type.
        self.event_name_original = event_name_original  # type: str
        # The subtype of the alert event.
        self.event_type = event_type  # type: str
        # The type of the alert event.
        self.event_type_original = event_type_original  # type: str
        # The field that is used in the whitelist rule.
        self.field = field  # type: str
        # The value of the field.
        self.field_value = field_value  # type: str
        # The alias of the field.
        self.filed_alias_name = filed_alias_name  # type: str
        # The operator. Valid values:
        # 
        # *   **contains**: contains
        # *   **notContains**: does not contain
        # *   **strEqual**: equals
        # *   **strNotEqual**: does not equal
        # *   **regex**: regular expression
        self.operate = operate  # type: str
        # The UUIDs of assets. Multiple UUIDs are separated by commas (,).
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryGroupedSecurityEventMarkMissListResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.disposal_way is not None:
            result['DisposalWay'] = self.disposal_way
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_name_original is not None:
            result['EventNameOriginal'] = self.event_name_original
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.event_type_original is not None:
            result['EventTypeOriginal'] = self.event_type_original
        if self.field is not None:
            result['Field'] = self.field
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.filed_alias_name is not None:
            result['FiledAliasName'] = self.filed_alias_name
        if self.operate is not None:
            result['Operate'] = self.operate
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('DisposalWay') is not None:
            self.disposal_way = m.get('DisposalWay')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventNameOriginal') is not None:
            self.event_name_original = m.get('EventNameOriginal')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('EventTypeOriginal') is not None:
            self.event_type_original = m.get('EventTypeOriginal')
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('FiledAliasName') is not None:
            self.filed_alias_name = m.get('FiledAliasName')
        if m.get('Operate') is not None:
            self.operate = m.get('Operate')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo(TeaModel):
    def __init__(self, count=None, current_page=None, page_size=None, total_count=None):
        # The number of entries returned on the current page.
        self.count = count  # type: int
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page. Default value: **20**.
        self.page_size = page_size  # type: int
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryGroupedSecurityEventMarkMissListResponseBody(TeaModel):
    def __init__(self, code=None, list=None, message=None, page_info=None, request_id=None, success=None):
        # The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.
        self.code = code  # type: str
        # An array that consists of the whitelist rules.
        self.list = list  # type: list[QueryGroupedSecurityEventMarkMissListResponseBodyList]
        # The error message returned.
        self.message = message  # type: str
        # The pagination information.
        self.page_info = page_info  # type: QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: yes
        # *   **false**: no
        self.success = success  # type: bool

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super(QueryGroupedSecurityEventMarkMissListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = QueryGroupedSecurityEventMarkMissListResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageInfo') is not None:
            temp_model = QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryGroupedSecurityEventMarkMissListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryGroupedSecurityEventMarkMissListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryGroupedSecurityEventMarkMissListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryGroupedSecurityEventMarkMissListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJenkinsImageRegistryPersistenceDayRequest(TeaModel):
    def __init__(self, source_ip=None):
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryJenkinsImageRegistryPersistenceDayRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class QueryJenkinsImageRegistryPersistenceDayResponseBody(TeaModel):
    def __init__(self, data=None, http_status_code=None, request_id=None, time_cost=None):
        self.data = data  # type: int
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str
        self.time_cost = time_cost  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryJenkinsImageRegistryPersistenceDayResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class QueryJenkinsImageRegistryPersistenceDayResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryJenkinsImageRegistryPersistenceDayResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryJenkinsImageRegistryPersistenceDayResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJenkinsImageRegistryPersistenceDayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPreCheckDatabaseRequest(TeaModel):
    def __init__(self, instance_uuid=None, task_id=None, uni_region_id=None):
        self.instance_uuid = instance_uuid  # type: str
        self.task_id = task_id  # type: str
        self.uni_region_id = uni_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryPreCheckDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class QueryPreCheckDatabaseResponseBody(TeaModel):
    def __init__(self, completed_time=None, created_time=None, description=None, progress=None, request_id=None,
                 result=None, updated_time=None):
        self.completed_time = completed_time  # type: long
        self.created_time = created_time  # type: long
        self.description = description  # type: str
        self.progress = progress  # type: int
        self.request_id = request_id  # type: str
        self.result = result  # type: str
        self.updated_time = updated_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryPreCheckDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed_time is not None:
            result['CompletedTime'] = self.completed_time
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CompletedTime') is not None:
            self.completed_time = m.get('CompletedTime')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class QueryPreCheckDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryPreCheckDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryPreCheckDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPreCheckDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootMachineRequest(TeaModel):
    def __init__(self, uuid=None):
        # The UUID of the server that you want to restart.
        # 
        # >  You can call the [DescribeCloudCenterInstances](~~describecloudcenterinstances~~) operation to query the UUIDs of servers.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootMachineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class RebootMachineResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootMachineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootMachineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RebootMachineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RebootMachineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshAssetsRequest(TeaModel):
    def __init__(self, asset_type=None, cloud_asset_sub_type=None, cloud_asset_type=None):
        # The type of the asset that you want to synchronize.default **ecs**, Valid values:
        # 
        # *   **cloud_product**: Alibaba Cloud service
        # *   **ecs**: Elastic Compute Service (ECS) instance
        # *   **container_image**: container image
        self.asset_type = asset_type  # type: str
        # The subtype of the cloud service.
        # 
        # >  The following list describes the subtypes of cloud services.
        self.cloud_asset_sub_type = cloud_asset_sub_type  # type: int
        # The type of the cloud service. Valid values:
        # 
        # *   **0**: ECS
        # *   **1**: Server Load Balancer (SLB)
        # *   **3**: ApsaraDB RDS
        # *   **4**: ApsaraDB for MongoDB (MongoDB)
        # *   **5**: ApsaraDB for Redis (Redis)
        # *   **6**: Container Registry
        # *   **8**: Container Service for Kubernetes (ACK)
        # *   **9**: Virtual Private Cloud (VPC)
        # *   **11**: ActionTrail
        # *   **12**: Alibaba Cloud CDN (CDN)
        # *   **13**: Certificate Management Service (formerly SSL Certificates Service)
        # *   **14**: Apsara Devops
        # *   **15**: Resource Access Management (RAM)
        # *   **16**: Anti-DDoS
        # *   **17**: Web Application Firewall (WAF)
        # *   **18**: Object Storage Service (OSS)
        # *   **19**: PolarDB
        # *   **20**: ApsaraDB RDS for PostgreSQL
        # *   **21**: Microservices Engine (MSE)
        # *   **22**: Apsara File Storage NAS (NAS)
        # *   **23**: Data Security Center (DSC)
        # *   **24**: Elastic IP Address (EIP)
        self.cloud_asset_type = cloud_asset_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshAssetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        if self.cloud_asset_sub_type is not None:
            result['CloudAssetSubType'] = self.cloud_asset_sub_type
        if self.cloud_asset_type is not None:
            result['CloudAssetType'] = self.cloud_asset_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        if m.get('CloudAssetSubType') is not None:
            self.cloud_asset_sub_type = m.get('CloudAssetSubType')
        if m.get('CloudAssetType') is not None:
            self.cloud_asset_type = m.get('CloudAssetType')
        return self


class RefreshAssetsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshAssetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RefreshAssetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RefreshAssetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RefreshAssetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshContainerAssetsRequest(TeaModel):
    def __init__(self, asset_type=None):
        # The type of the container asset whose statistics you want to refresh. Valid values:
        # 
        # *   **IMAGE**\
        # *   **CONTAINER**\
        self.asset_type = asset_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshContainerAssetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_type is not None:
            result['AssetType'] = self.asset_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssetType') is not None:
            self.asset_type = m.get('AssetType')
        return self


class RefreshContainerAssetsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshContainerAssetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RefreshContainerAssetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RefreshContainerAssetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RefreshContainerAssetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshContainerAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveCheckInstanceResultWhiteListRequest(TeaModel):
    def __init__(self, check_id=None, instance_ids=None):
        self.check_id = check_id  # type: long
        self.instance_ids = instance_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveCheckInstanceResultWhiteListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RemoveCheckInstanceResultWhiteListResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveCheckInstanceResultWhiteListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveCheckInstanceResultWhiteListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveCheckInstanceResultWhiteListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveCheckInstanceResultWhiteListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveCheckInstanceResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveCheckResultWhiteListRequest(TeaModel):
    def __init__(self, check_group_id=None, check_ids=None, type=None):
        self.check_group_id = check_group_id  # type: str
        self.check_ids = check_ids  # type: list[long]
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveCheckResultWhiteListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_group_id is not None:
            result['CheckGroupId'] = self.check_group_id
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckGroupId') is not None:
            self.check_group_id = m.get('CheckGroupId')
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RemoveCheckResultWhiteListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveCheckResultWhiteListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveCheckResultWhiteListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveCheckResultWhiteListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveCheckResultWhiteListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveCheckResultWhiteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackSuspEventQuaraFileRequest(TeaModel):
    def __init__(self, from_=None, quara_file_id=None, source_ip=None):
        # The ID of the request source. Set the value to sas.
        self.from_ = from_  # type: str
        # The ID of the quarantined file.   
        # > If you do not configure this parameter, you cannot call the RollbackSuspEventQuaraFile operation to restore a quarantined file. You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.
        self.quara_file_id = quara_file_id  # type: int
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.quara_file_id is not None:
            result['QuaraFileId'] = self.quara_file_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('QuaraFileId') is not None:
            self.quara_file_id = m.get('QuaraFileId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class RollbackSuspEventQuaraFileResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackSuspEventQuaraFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RollbackSuspEventQuaraFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackSuspEventQuaraFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SasInstallCodeRequest(TeaModel):
    def __init__(self, source_ip=None):
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SasInstallCodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class SasInstallCodeResponseBody(TeaModel):
    def __init__(self, request_id=None, data=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The installation verification code that is used to run the installation command when you manually install the Security Center agent.
        self.data = data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SasInstallCodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class SasInstallCodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SasInstallCodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SasInstallCodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SasInstallCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveImageBaselineStrategyRequest(TeaModel):
    def __init__(self, baseline_item_list=None, lang=None, strategy_id=None, strategy_name=None):
        self.baseline_item_list = baseline_item_list  # type: str
        self.lang = lang  # type: str
        self.strategy_id = strategy_id  # type: long
        self.strategy_name = strategy_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SaveImageBaselineStrategyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_item_list is not None:
            result['BaselineItemList'] = self.baseline_item_list
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineItemList') is not None:
            self.baseline_item_list = m.get('BaselineItemList')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class SaveImageBaselineStrategyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SaveImageBaselineStrategyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SaveImageBaselineStrategyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SaveImageBaselineStrategyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SaveImageBaselineStrategyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveImageBaselineStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveSuspEventUserSettingRequest(TeaModel):
    def __init__(self, from_=None, levels_on=None):
        self.from_ = from_  # type: str
        self.levels_on = levels_on  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SaveSuspEventUserSettingRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.levels_on is not None:
            result['LevelsOn'] = self.levels_on
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('LevelsOn') is not None:
            self.levels_on = m.get('LevelsOn')
        return self


class SaveSuspEventUserSettingResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SaveSuspEventUserSettingResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveSuspEventUserSettingResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SaveSuspEventUserSettingResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SaveSuspEventUserSettingResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveSuspEventUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetRegistryScanDayNumRequest(TeaModel):
    def __init__(self, scan_day_num=None):
        self.scan_day_num = scan_day_num  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetRegistryScanDayNumRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scan_day_num is not None:
            result['ScanDayNum'] = self.scan_day_num
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ScanDayNum') is not None:
            self.scan_day_num = m.get('ScanDayNum')
        return self


class SetRegistryScanDayNumResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetRegistryScanDayNumResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetRegistryScanDayNumResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetRegistryScanDayNumResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetRegistryScanDayNumResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetRegistryScanDayNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartBaselineSecurityCheckRequest(TeaModel):
    def __init__(self, item_ids=None, lang=None, resource_owner_id=None, source_ip=None, type=None):
        # The IDs of the check items.
        # 
        # >  To perform a check task on cloud service configurations, you must specify the IDs of the check items. You can call the  [DescribeRiskItemType ](~~DescribeRiskItemType~~)  operation to query the IDs of check items.
        self.item_ids = item_ids  # type: list[long]
        # The language of the content within the request and the response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The type of the check task. Valid values:
        # 
        # *   **check**\
        # *   **verify**\
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartBaselineSecurityCheckRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ItemIds') is not None:
            self.item_ids = m.get('ItemIds')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartBaselineSecurityCheckResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartBaselineSecurityCheckResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartBaselineSecurityCheckResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartBaselineSecurityCheckResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartBaselineSecurityCheckResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartBaselineSecurityCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartDiscoverDatabaseTaskResponseBody(TeaModel):
    def __init__(self, create_mark=None, request_id=None):
        self.create_mark = create_mark  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartDiscoverDatabaseTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartDiscoverDatabaseTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartDiscoverDatabaseTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartDiscoverDatabaseTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartDiscoverDatabaseTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPreCheckDatabaseRequest(TeaModel):
    def __init__(self, database_type=None, instance_uuid=None, uni_region_id=None):
        self.database_type = database_type  # type: str
        self.instance_uuid = instance_uuid  # type: str
        self.uni_region_id = uni_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartPreCheckDatabaseRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.instance_uuid is not None:
            result['InstanceUuid'] = self.instance_uuid
        if self.uni_region_id is not None:
            result['UniRegionId'] = self.uni_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('InstanceUuid') is not None:
            self.instance_uuid = m.get('InstanceUuid')
        if m.get('UniRegionId') is not None:
            self.uni_region_id = m.get('UniRegionId')
        return self


class StartPreCheckDatabaseResponseBody(TeaModel):
    def __init__(self, create_mark=None, request_id=None):
        self.create_mark = create_mark  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartPreCheckDatabaseResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_mark is not None:
            result['CreateMark'] = self.create_mark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateMark') is not None:
            self.create_mark = m.get('CreateMark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartPreCheckDatabaseResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartPreCheckDatabaseResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartPreCheckDatabaseResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPreCheckDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartVirusScanTaskRequest(TeaModel):
    def __init__(self, target_info=None):
        self.target_info = target_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartVirusScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_info is not None:
            result['TargetInfo'] = self.target_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetInfo') is not None:
            self.target_info = m.get('TargetInfo')
        return self


class StartVirusScanTaskResponseBody(TeaModel):
    def __init__(self, request_id=None, scan_task_id=None):
        self.request_id = request_id  # type: str
        self.scan_task_id = scan_task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartVirusScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scan_task_id is not None:
            result['ScanTaskId'] = self.scan_task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScanTaskId') is not None:
            self.scan_task_id = m.get('ScanTaskId')
        return self


class StartVirusScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartVirusScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartVirusScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartVirusScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCheckResponseBodyData(TeaModel):
    def __init__(self, operate_code=None):
        self.operate_code = operate_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitCheckResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class SubmitCheckResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None, task_id=None):
        self.data = data  # type: SubmitCheckResponseBodyData
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(SubmitCheckResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCheckResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitCheckResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitCheckResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitCheckResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindAegisRequest(TeaModel):
    def __init__(self, uuids=None):
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnbindAegisRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class UnbindAegisResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnbindAegisResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindAegisResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnbindAegisResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnbindAegisResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindAegisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallBackupClientRequest(TeaModel):
    def __init__(self, policy_version=None, uuid=None, uuid_list=None):
        # The version of the anti-ransomware policy. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies. Valid values:
        # 
        # *   **1.0.0**\
        # *   **2.0.0**\
        self.policy_version = policy_version  # type: str
        # The UUID of the server from which you want to uninstall the anti-ransomware agent.
        # 
        # >  You must specify at least one of the UuidList and Uuid parameters.
        self.uuid = uuid  # type: str
        # The UUIDs of the servers from which you want to uninstall the anti-ransomware agent.
        # 
        # >  You must specify at least one of the UuidList and Uuid parameters.
        self.uuid_list = uuid_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallBackupClientRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_version is not None:
            result['PolicyVersion'] = self.policy_version
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.uuid_list is not None:
            result['UuidList'] = self.uuid_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyVersion') is not None:
            self.policy_version = m.get('PolicyVersion')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('UuidList') is not None:
            self.uuid_list = m.get('UuidList')
        return self


class UninstallBackupClientResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallBackupClientResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UninstallBackupClientResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UninstallBackupClientResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UninstallBackupClientResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallBackupClientResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallUniBackupAgentRequest(TeaModel):
    def __init__(self, policy_id=None):
        self.policy_id = policy_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallUniBackupAgentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        return self


class UninstallUniBackupAgentResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallUniBackupAgentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UninstallUniBackupAgentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UninstallUniBackupAgentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UninstallUniBackupAgentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallUniBackupAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotRequest(TeaModel):
    def __init__(self, honeypot_id=None, honeypot_name=None, meta=None):
        self.honeypot_id = honeypot_id  # type: str
        self.honeypot_name = honeypot_name  # type: str
        self.meta = meta  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.meta is not None:
            result['Meta'] = self.meta
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        return self


class UpdateHoneypotResponseBodyData(TeaModel):
    def __init__(self, honeypot_id=None, honeypot_image_display_name=None, honeypot_image_name=None,
                 honeypot_name=None, node_id=None, preset_id=None, state=None):
        self.honeypot_id = honeypot_id  # type: str
        self.honeypot_image_display_name = honeypot_image_display_name  # type: str
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.honeypot_name = honeypot_name  # type: str
        self.node_id = node_id  # type: str
        self.preset_id = preset_id  # type: str
        self.state = state  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_id is not None:
            result['HoneypotId'] = self.honeypot_id
        if self.honeypot_image_display_name is not None:
            result['HoneypotImageDisplayName'] = self.honeypot_image_display_name
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_name is not None:
            result['HoneypotName'] = self.honeypot_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.preset_id is not None:
            result['PresetId'] = self.preset_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotId') is not None:
            self.honeypot_id = m.get('HoneypotId')
        if m.get('HoneypotImageDisplayName') is not None:
            self.honeypot_image_display_name = m.get('HoneypotImageDisplayName')
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotName') is not None:
            self.honeypot_name = m.get('HoneypotName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('PresetId') is not None:
            self.preset_id = m.get('PresetId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdateHoneypotResponseBody(TeaModel):
    def __init__(self, code=None, data=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: UpdateHoneypotResponseBodyData
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(UpdateHoneypotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateHoneypotResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateHoneypotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateHoneypotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotNodeRequest(TeaModel):
    def __init__(self, available_probe_num=None, node_id=None, node_name=None, security_group_probe_ip_list=None):
        self.available_probe_num = available_probe_num  # type: int
        self.node_id = node_id  # type: str
        self.node_name = node_name  # type: str
        self.security_group_probe_ip_list = security_group_probe_ip_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotNodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_probe_num is not None:
            result['AvailableProbeNum'] = self.available_probe_num
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.security_group_probe_ip_list is not None:
            result['SecurityGroupProbeIpList'] = self.security_group_probe_ip_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableProbeNum') is not None:
            self.available_probe_num = m.get('AvailableProbeNum')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('SecurityGroupProbeIpList') is not None:
            self.security_group_probe_ip_list = m.get('SecurityGroupProbeIpList')
        return self


class UpdateHoneypotNodeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotNodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotNodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateHoneypotNodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateHoneypotNodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotPresetRequest(TeaModel):
    def __init__(self, honeypot_image_name=None, honeypot_preset_id=None, meta=None, preset_name=None):
        self.honeypot_image_name = honeypot_image_name  # type: str
        self.honeypot_preset_id = honeypot_preset_id  # type: str
        self.meta = meta  # type: str
        self.preset_name = preset_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotPresetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.honeypot_image_name is not None:
            result['HoneypotImageName'] = self.honeypot_image_name
        if self.honeypot_preset_id is not None:
            result['HoneypotPresetId'] = self.honeypot_preset_id
        if self.meta is not None:
            result['Meta'] = self.meta
        if self.preset_name is not None:
            result['PresetName'] = self.preset_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HoneypotImageName') is not None:
            self.honeypot_image_name = m.get('HoneypotImageName')
        if m.get('HoneypotPresetId') is not None:
            self.honeypot_preset_id = m.get('HoneypotPresetId')
        if m.get('Meta') is not None:
            self.meta = m.get('Meta')
        if m.get('PresetName') is not None:
            self.preset_name = m.get('PresetName')
        return self


class UpdateHoneypotPresetResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotPresetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotPresetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateHoneypotPresetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateHoneypotPresetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotPresetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHoneypotProbeRequest(TeaModel):
    def __init__(self, arp=None, display_name=None, ping=None, probe_id=None, service_ip_list=None):
        self.arp = arp  # type: bool
        self.display_name = display_name  # type: str
        self.ping = ping  # type: bool
        self.probe_id = probe_id  # type: str
        self.service_ip_list = service_ip_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotProbeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arp is not None:
            result['Arp'] = self.arp
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.ping is not None:
            result['Ping'] = self.ping
        if self.probe_id is not None:
            result['ProbeId'] = self.probe_id
        if self.service_ip_list is not None:
            result['ServiceIpList'] = self.service_ip_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arp') is not None:
            self.arp = m.get('Arp')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Ping') is not None:
            self.ping = m.get('Ping')
        if m.get('ProbeId') is not None:
            self.probe_id = m.get('ProbeId')
        if m.get('ServiceIpList') is not None:
            self.service_ip_list = m.get('ServiceIpList')
        return self


class UpdateHoneypotProbeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.http_status_code = http_status_code  # type: int
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateHoneypotProbeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateHoneypotProbeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateHoneypotProbeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateHoneypotProbeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHoneypotProbeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJenkinsImageRegistryNameRequest(TeaModel):
    def __init__(self, registry_id=None, registry_name=None, source_ip=None):
        self.registry_id = registry_id  # type: long
        self.registry_name = registry_name  # type: str
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_id is not None:
            result['RegistryId'] = self.registry_id
        if self.registry_name is not None:
            result['RegistryName'] = self.registry_name
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegistryId') is not None:
            self.registry_id = m.get('RegistryId')
        if m.get('RegistryName') is not None:
            self.registry_name = m.get('RegistryName')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class UpdateJenkinsImageRegistryNameResponseBody(TeaModel):
    def __init__(self, data=None, http_status_code=None, request_id=None, time_cost=None):
        self.data = data  # type: bool
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str
        self.time_cost = time_cost  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class UpdateJenkinsImageRegistryNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateJenkinsImageRegistryNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJenkinsImageRegistryNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJenkinsImageRegistryPersistenceDayRequest(TeaModel):
    def __init__(self, persistence_day=None, registry_id=None, source_ip=None):
        self.persistence_day = persistence_day  # type: int
        self.registry_id = registry_id  # type: long
        self.source_ip = source_ip  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryPersistenceDayRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.persistence_day is not None:
            result['PersistenceDay'] = self.persistence_day
        if self.registry_id is not None:
            result['RegistryId'] = self.registry_id
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PersistenceDay') is not None:
            self.persistence_day = m.get('PersistenceDay')
        if m.get('RegistryId') is not None:
            self.registry_id = m.get('RegistryId')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        return self


class UpdateJenkinsImageRegistryPersistenceDayResponseBody(TeaModel):
    def __init__(self, data=None, http_status_code=None, request_id=None, time_cost=None):
        self.data = data  # type: bool
        self.http_status_code = http_status_code  # type: int
        self.request_id = request_id  # type: str
        self.time_cost = time_cost  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryPersistenceDayResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class UpdateJenkinsImageRegistryPersistenceDayResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateJenkinsImageRegistryPersistenceDayResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateJenkinsImageRegistryPersistenceDayResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJenkinsImageRegistryPersistenceDayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeBackupPolicyVersionRequest(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpgradeBackupPolicyVersionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpgradeBackupPolicyVersionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpgradeBackupPolicyVersionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpgradeBackupPolicyVersionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpgradeBackupPolicyVersionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpgradeBackupPolicyVersionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeBackupPolicyVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ValidateHcWarningsRequest(TeaModel):
    def __init__(self, risk_ids=None, source_ip=None, uuids=None):
        # The IDs of risk items that you want to verify. Separate multiple IDs with commas (,).
        self.risk_ids = risk_ids  # type: str
        # The source IP address of the request.
        self.source_ip = source_ip  # type: str
        # The UUIDs of servers on which you want to verify risk items.
        self.uuids = uuids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ValidateHcWarningsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.risk_ids is not None:
            result['RiskIds'] = self.risk_ids
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.uuids is not None:
            result['Uuids'] = self.uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RiskIds') is not None:
            self.risk_ids = m.get('RiskIds')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Uuids') is not None:
            self.uuids = m.get('Uuids')
        return self


class ValidateHcWarningsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ValidateHcWarningsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ValidateHcWarningsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ValidateHcWarningsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ValidateHcWarningsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ValidateHcWarningsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCheckInstanceResultRequest(TeaModel):
    def __init__(self, check_id=None, instance_ids=None):
        self.check_id = check_id  # type: long
        self.instance_ids = instance_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCheckInstanceResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class VerifyCheckInstanceResultResponseBodyData(TeaModel):
    def __init__(self, fail_instances=None, operate_code=None):
        self.fail_instances = fail_instances  # type: list[str]
        self.operate_code = operate_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCheckInstanceResultResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_instances is not None:
            result['FailInstances'] = self.fail_instances
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailInstances') is not None:
            self.fail_instances = m.get('FailInstances')
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class VerifyCheckInstanceResultResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: VerifyCheckInstanceResultResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(VerifyCheckInstanceResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = VerifyCheckInstanceResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class VerifyCheckInstanceResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: VerifyCheckInstanceResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(VerifyCheckInstanceResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyCheckInstanceResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCheckResultRequest(TeaModel):
    def __init__(self, check_ids=None):
        self.check_ids = check_ids  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCheckResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_ids is not None:
            result['CheckIds'] = self.check_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CheckIds') is not None:
            self.check_ids = m.get('CheckIds')
        return self


class VerifyCheckResultResponseBodyData(TeaModel):
    def __init__(self, operate_code=None):
        self.operate_code = operate_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCheckResultResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_code is not None:
            result['OperateCode'] = self.operate_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperateCode') is not None:
            self.operate_code = m.get('OperateCode')
        return self


class VerifyCheckResultResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: VerifyCheckResultResponseBodyData
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(VerifyCheckResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = VerifyCheckResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class VerifyCheckResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: VerifyCheckResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(VerifyCheckResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyCheckResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


